/**
 * @fileoverview UID generator, from Blockly.
 */
/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 */
declare const genUID: () => string;

type SideEffectDisposer = () => any;
declare class SideEffectManager {
    /**
     * Add a disposer directly.
     * @param disposer a disposer or a list of disposers
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    addDisposer(disposer: SideEffectDisposer | SideEffectDisposer[], disposerID?: string): string;
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer or a list of disposers
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    push: (disposer: SideEffectDisposer | SideEffectDisposer[], disposerID?: string) => string;
    /**
     * Add a side effect.
     * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    add(executor: () => SideEffectDisposer | SideEffectDisposer[] | null | false, disposerID?: string): string;
    /**
     * Sugar for addEventListener.
     * @param el
     * @param type
     * @param listener
     * @param options
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    addEventListener<K extends keyof WindowEventMap>(el: Window, type: K, listener: (this: Window, ev: WindowEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions, disposerID?: string): string;
    addEventListener<K extends keyof DocumentEventMap>(el: Document, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions, disposerID?: string): string;
    addEventListener<K extends keyof HTMLElementEventMap>(el: HTMLElement, type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions, disposerID?: string): string;
    addEventListener<K extends keyof MediaQueryListEventMap>(el: MediaQueryList, type: K, listener: (this: HTMLElement, ev: MediaQueryListEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions, disposerID?: string): string;
    /**
     * Sugar for setTimeout.
     * @param handler
     * @param timeout
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    setTimeout(handler: () => void, timeout: number, disposerID?: string): string;
    /**
     * Sugar for setInterval.
     * @param handler
     * @param timeout
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    setInterval(handler: () => void, timeout: number, disposerID?: string): string;
    /**
     * Remove but not run the disposer. Do nothing if not found.
     * @param disposerID
     */
    remove(disposerID: string): SideEffectDisposer | undefined;
    /**
     * Remove and run the disposer. Do nothing if not found.
     * @param disposerID
     */
    flush(disposerID: string): void;
    /**
     * Remove and run all of the disposers.
     */
    flushAll(): void;
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    readonly disposers: Map<string, SideEffectDisposer>;
    genUID(): string;
}
/**
 * Join multiple disposers into on disposer
 */
declare function joinDisposers(disposers: SideEffectDisposer[]): SideEffectDisposer;

type AsyncSideEffectDisposer = () => Promise<any> | any;
type AsyncSideEffectExecutor = () => Promise<AsyncSideEffectDisposer | AsyncSideEffectDisposer[] | null | false> | AsyncSideEffectDisposer | AsyncSideEffectDisposer[] | null | false;
declare class AsyncSideEffectManager {
    /**
     * Add a side effect.
     * @param executor Execute side effect. Return a disposer or a disposer array. Return null or false to ignore.
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    add(executor: AsyncSideEffectExecutor, disposerID?: string): string;
    private _add_;
    /**
     * Add a disposer directly.
     * @param disposer a disposer
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    addDisposer(disposer: AsyncSideEffectDisposer | AsyncSideEffectDisposer[], disposerID?: string): string;
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    push: (disposer: AsyncSideEffectDisposer | AsyncSideEffectDisposer[], disposerID?: string) => string;
    /**
     * Remove but not run the disposer. Do nothing if not found.
     * @param disposerID
     */
    remove(disposerID: string): AsyncSideEffectDisposer | undefined;
    /**
     * Remove and run the disposer. Do nothing if not found.
     * @param disposerID
     */
    flush(disposerID: string): void;
    private _flush_;
    /**
     * Remove and run all of the disposers.
     */
    flushAll(): void;
    /**
     * @returns a Promise resolved when current tasks are finished.
     */
    finished: Promise<void>;
    private _resolveFinished_?;
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    readonly disposers: Map<string, AsyncSideEffectDisposer>;
    genUID(): string;
    private readonly _nextTask_;
    private readonly _isRunning_;
    private _startTask_;
    private _endTask_;
}
/**
 * Join multiple disposers into on disposer and wait until all disposers are resolved.
 */
declare function joinAsyncDisposers(disposers: AsyncSideEffectDisposer[]): AsyncSideEffectDisposer;

type DisposableDisposer = () => any;
declare class Disposable {
    /**
     * Add a disposer directly.
     * @param disposers a disposer or a list of disposers
     */
    addDisposer(disposers: DisposableDisposer | DisposableDisposer[]): void;
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer or a list of disposers
     */
    push: (disposers: DisposableDisposer | DisposableDisposer[]) => void;
    /**
     * Add a side effect.
     * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.
     */
    add(executor: () => DisposableDisposer | DisposableDisposer[] | null | false): void;
    /**
     * Sugar for addEventListener.
     * @param el
     * @param type
     * @param listener
     * @param options
     */
    addEventListener<K extends keyof WindowEventMap>(el: Window, type: K, listener: (this: Window, ev: WindowEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions): DisposableDisposer;
    addEventListener<K extends keyof DocumentEventMap>(el: Document, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions): DisposableDisposer;
    addEventListener<K extends keyof HTMLElementEventMap>(el: HTMLElement, type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions): DisposableDisposer;
    addEventListener<K extends keyof MediaQueryListEventMap>(el: MediaQueryList, type: K, listener: (this: HTMLElement, ev: MediaQueryListEventMap[K]) => unknown, options?: boolean | AddEventListenerOptions): DisposableDisposer;
    /**
     * Sugar for setTimeout.
     * @param handler
     * @param timeout
     * @returns ticket
     */
    setTimeout(handler: () => void, timeout: number): DisposableDisposer;
    /**
     * Sugar for setInterval.
     * @param handler
     * @param timeout
     * @returns ticket
     */
    setInterval(handler: () => void, timeout: number): DisposableDisposer;
    /**
     * Remove but not run the disposer. Do nothing if not found.
     * @param disposer
     */
    remove(disposer: DisposableDisposer): void;
    /**
     * Remove and run the disposer. Do nothing if not found.
     * @param disposer
     */
    flush(disposer: DisposableDisposer): void;
    /**
     * Remove and run all of the disposers.
     */
    flushAll(): void;
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    readonly disposers: Set<SideEffectDisposer>;
}

export { AsyncSideEffectDisposer, AsyncSideEffectExecutor, AsyncSideEffectManager, Disposable, DisposableDisposer, SideEffectDisposer, SideEffectManager, genUID, joinAsyncDisposers, joinDisposers };
