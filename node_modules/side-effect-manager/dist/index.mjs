// src/gen-uid.ts
var SOUP = "!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var SOUP_LEN = 87;
var ID_LEN = 20;
var reusedIdCarrier = [];
var genUID = () => {
  for (let i = 0; i < ID_LEN; i++) {
    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);
  }
  return reusedIdCarrier.join("");
};

// src/utils.ts
function invoke(fn) {
  try {
    return fn();
  } catch (e) {
    console.error(e);
  }
}

// src/side-effect-manager.ts
var SideEffectManager = class {
  constructor() {
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer or a list of disposers
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    this.push = this.addDisposer;
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    this.disposers = /* @__PURE__ */ new Map();
  }
  /**
   * Add a disposer directly.
   * @param disposer a disposer or a list of disposers
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  addDisposer(disposer, disposerID = this.genUID()) {
    this.flush(disposerID);
    this.disposers.set(
      disposerID,
      Array.isArray(disposer) ? joinDisposers(disposer) : disposer
    );
    return disposerID;
  }
  /**
   * Add a side effect.
   * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  add(executor, disposerID = this.genUID()) {
    const disposers = executor();
    return disposers ? this.addDisposer(disposers, disposerID) : disposerID;
  }
  addEventListener(el, type, listener, options, disposerID = this.genUID()) {
    el.addEventListener(type, listener, options);
    this.addDisposer(
      () => el.removeEventListener(type, listener, options),
      disposerID
    );
    return disposerID;
  }
  /**
   * Sugar for setTimeout.
   * @param handler
   * @param timeout
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  setTimeout(handler, timeout, disposerID = this.genUID()) {
    const ticket = window.setTimeout(() => {
      this.remove(disposerID);
      handler();
    }, timeout);
    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);
  }
  /**
   * Sugar for setInterval.
   * @param handler
   * @param timeout
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  setInterval(handler, timeout, disposerID = this.genUID()) {
    const ticket = window.setInterval(handler, timeout);
    return this.addDisposer(() => window.clearInterval(ticket), disposerID);
  }
  /**
   * Remove but not run the disposer. Do nothing if not found.
   * @param disposerID
   */
  remove(disposerID) {
    const disposer = this.disposers.get(disposerID);
    this.disposers.delete(disposerID);
    return disposer;
  }
  /**
   * Remove and run the disposer. Do nothing if not found.
   * @param disposerID
   */
  flush(disposerID) {
    const disposer = this.remove(disposerID);
    if (disposer) {
      disposer();
    }
  }
  /**
   * Remove and run all of the disposers.
   */
  flushAll() {
    this.disposers.forEach(invoke);
    this.disposers.clear();
  }
  genUID() {
    let uid;
    do {
      uid = genUID();
    } while (this.disposers.has(uid));
    return uid;
  }
};
function joinDisposers(disposers) {
  return () => disposers.forEach(invoke);
}

// src/async-side-effect-manager.ts
var AsyncSideEffectManager = class {
  constructor() {
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer
     * @param disposerID Optional id for the disposer
     * @returns disposerID
     */
    this.push = this.addDisposer;
    /**
     * @returns a Promise resolved when current tasks are finished.
     */
    this.finished = Promise.resolve();
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    this.disposers = /* @__PURE__ */ new Map();
    this._n = /* @__PURE__ */ new Map();
    this._i = /* @__PURE__ */ new Set();
  }
  /**
   * Add a side effect.
   * @param executor Execute side effect. Return a disposer or a disposer array. Return null or false to ignore.
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  add(executor, disposerID = this.genUID()) {
    if (this._i.has(disposerID)) {
      this._n.set(disposerID, () => this._a(executor, disposerID));
    } else {
      this._a(executor, disposerID);
    }
    return disposerID;
  }
  async _a(executor, disposerID) {
    this._s(disposerID);
    const disposer = this.remove(disposerID);
    if (disposer) {
      try {
        await disposer();
      } catch (e) {
        console.error(e);
      }
    }
    try {
      const disposers = await executor();
      if (disposers) {
        this.disposers.set(
          disposerID,
          Array.isArray(disposers) ? joinAsyncDisposers(disposers) : disposers
        );
      }
    } catch (e) {
      console.error(e);
    }
    this._e(disposerID);
    const task = this._n.get(disposerID);
    if (task) {
      this._n.delete(disposerID);
      task();
    }
  }
  /**
   * Add a disposer directly.
   * @param disposer a disposer
   * @param disposerID Optional id for the disposer
   * @returns disposerID
   */
  addDisposer(disposer, disposerID = this.genUID()) {
    return this.add(() => disposer, disposerID);
  }
  /**
   * Remove but not run the disposer. Do nothing if not found.
   * @param disposerID
   */
  remove(disposerID) {
    const disposer = this.disposers.get(disposerID);
    this.disposers.delete(disposerID);
    return disposer;
  }
  /**
   * Remove and run the disposer. Do nothing if not found.
   * @param disposerID
   */
  flush(disposerID) {
    if (this._i.has(disposerID)) {
      this._n.set(disposerID, () => this._f(disposerID));
    } else {
      this._f(disposerID);
    }
  }
  async _f(disposerID) {
    const disposer = this.remove(disposerID);
    if (disposer) {
      this._s(disposerID);
      try {
        await disposer();
      } catch (e) {
        console.error(e);
      }
      this._e(disposerID);
    }
    const task = this._n.get(disposerID);
    if (task) {
      this._n.delete(disposerID);
      task();
    }
  }
  /**
   * Remove and run all of the disposers.
   */
  flushAll() {
    this.disposers.forEach((_, disposerID) => this.flush(disposerID));
  }
  genUID() {
    let uid;
    do {
      uid = genUID();
    } while (this.disposers.has(uid));
    return uid;
  }
  _s(disposerID) {
    this._i.add(disposerID);
    if (!this._r) {
      this.finished = new Promise((resolve) => {
        this._r = resolve;
      });
    }
  }
  _e(disposerID) {
    this._i.delete(disposerID);
    if (this._r && this._i.size <= 0 && this._n.size <= 0) {
      this._r();
      this._r = void 0;
    }
  }
};
function joinAsyncDisposers(disposers) {
  return () => Promise.all(disposers.map(invoke));
}

// src/disposable.ts
var Disposable = class {
  constructor() {
    /**
     * @alias addDisposer
     * Add a disposer directly.
     * @param disposer a disposer or a list of disposers
     */
    this.push = this.addDisposer;
    /**
     * All disposers. Use this only when you know what you are doing.
     */
    this.disposers = /* @__PURE__ */ new Set();
  }
  /**
   * Add a disposer directly.
   * @param disposers a disposer or a list of disposers
   */
  addDisposer(disposers) {
    if (Array.isArray(disposers)) {
      disposers.forEach((disposer) => {
        this.disposers.add(disposer);
      });
    } else {
      this.disposers.add(disposers);
    }
  }
  /**
   * Add a side effect.
   * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.
   */
  add(executor) {
    const disposers = executor();
    if (disposers) {
      this.push(disposers);
    }
  }
  addEventListener(el, type, listener, options) {
    el.addEventListener(type, listener, options);
    const disposer = () => el.removeEventListener(type, listener, options);
    this.push(disposer);
    return disposer;
  }
  /**
   * Sugar for setTimeout.
   * @param handler
   * @param timeout
   * @returns ticket
   */
  setTimeout(handler, timeout) {
    const ticket = window.setTimeout(() => {
      this.remove(disposer);
      handler();
    }, timeout);
    const disposer = () => window.clearTimeout(ticket);
    this.push(disposer);
    return disposer;
  }
  /**
   * Sugar for setInterval.
   * @param handler
   * @param timeout
   * @returns ticket
   */
  setInterval(handler, timeout) {
    const ticket = setInterval(handler, timeout);
    const disposer = () => clearInterval(ticket);
    this.push(disposer);
    return disposer;
  }
  /**
   * Remove but not run the disposer. Do nothing if not found.
   * @param disposer
   */
  remove(disposer) {
    this.disposers.delete(disposer);
  }
  /**
   * Remove and run the disposer. Do nothing if not found.
   * @param disposer
   */
  flush(disposer) {
    this.remove(disposer);
    disposer();
  }
  /**
   * Remove and run all of the disposers.
   */
  flushAll() {
    this.disposers.forEach(invoke);
    this.disposers.clear();
  }
};

export { AsyncSideEffectManager, Disposable, SideEffectManager, genUID, joinAsyncDisposers, joinDisposers };
