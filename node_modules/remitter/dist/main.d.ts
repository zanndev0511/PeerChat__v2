/**
 * A event name that can be used to listen to all events.
 */
declare const ANY_EVENT: unique symbol;
type ANY_EVENT = typeof ANY_EVENT;

type Fn = (...args: any[]) => any;
type AnyEventData<TConfig, TEventName extends keyof TConfig = keyof TConfig> = {
    event: TEventName;
    data: TConfig[TEventName];
};
type AnyRemitterListener<TConfig> = (data: AnyEventData<TConfig>) => void;
type RemitterConfig<TConfig> = TConfig & {
    [name in ANY_EVENT]: AnyEventData<TConfig>;
};
type RemitterDatalessEventName<TConfig> = {
    [EventName in keyof RemitterConfig<TConfig>]: RemitterConfig<TConfig>[EventName] extends undefined | void | never ? EventName : never;
}[keyof RemitterConfig<TConfig>];
type RemitterEventNames<TConfig> = keyof TConfig;
type AllRemitterEventNames<TConfig> = keyof TConfig | ANY_EVENT;
type RemitterListener<TConfig, TEventName extends RemitterEventNames<RemitterConfig<TConfig>> = RemitterEventNames<RemitterConfig<TConfig>>> = RemitterConfig<TConfig>[TEventName] extends undefined | void | never ? () => void : (eventData: RemitterConfig<TConfig>[TEventName]) => void;
type RemitterDisposer = () => void;

declare class ReadonlyRemitter<TConfig = any> {
    readonly ANY_EVENT: ANY_EVENT;
    private readonly listeners_;
    private relayListeners_?;
    private onceListeners_?;
    /**
     * Emit an event to `eventName` listeners.
     */
    protected emit<TEventName extends RemitterDatalessEventName<TConfig>>(eventName: TEventName): void;
    /**
     * Emit an event with payload to `eventName` listeners.
     */
    protected emit<TEventName extends RemitterEventNames<TConfig>>(eventName: TEventName, eventData: TConfig[TEventName]): void;
    /**
     * Add an `ANY_EVENT_NAME` listener to receive all events.
     */
    on(eventName: typeof ANY_EVENT, listener: AnyRemitterListener<TConfig>): RemitterDisposer;
    /**
     * Add a listener to the eventName.
     */
    on<TEventName extends RemitterEventNames<TConfig>>(eventName: TEventName, listener: RemitterListener<TConfig, TEventName>): RemitterDisposer;
    /**
     * Add a one-time listener to `ANY_EVENT_NAME` to receive all events..
     */
    once(eventName: typeof ANY_EVENT, listener: AnyRemitterListener<TConfig>): RemitterDisposer;
    /**
     * Add a one-time listener to the eventName.
     */
    once<TEventName extends RemitterEventNames<TConfig>>(eventName: TEventName, listener: RemitterListener<TConfig, TEventName>): RemitterDisposer;
    /**
     * Remove a listener from the eventName.
     */
    off<TEventName extends AllRemitterEventNames<TConfig>>(eventName: TEventName, listener: Fn): boolean;
    clear<TEventName extends AllRemitterEventNames<TConfig>>(eventName?: TEventName): void;
    /**
     * Returns the number of listeners for the eventName.
     * @param eventName If empty returns the number of listeners for all events.
     * @returns
     */
    count<TEventName extends AllRemitterEventNames<TConfig>>(eventName?: TEventName): number;
    /**
     * Start a side effect when the eventName has a first listener.
     * Dispose the side effect when the eventName has no listeners.
     * For example tap into other events.
     *
     * remit `ANY_EVENT` will be started when any event is listened.
     *
     * @param eventName
     * @param start A function that is called when listener count if `eventName` grows from 0 to 1. Returns a disposer when listener count if `eventName` drops from 1 to 0.
     */
    protected remit<TEventName extends AllRemitterEventNames<TConfig>>(eventName: TEventName, start: (remitter: Remitter<TConfig>) => RemitterDisposer): RemitterDisposer;
    /**
     * Dispose all listeners.
     */
    dispose(): void;
}
declare class Remitter<TConfig = any> extends ReadonlyRemitter<TConfig> {
    constructor();
    emit: {
        <TEventName extends RemitterDatalessEventName<TConfig>>(eventName: TEventName): void;
        <TEventName_1 extends keyof TConfig>(eventName: TEventName_1, eventData: TConfig[TEventName_1]): void;
    };
    remit: <TEventName extends AllRemitterEventNames<TConfig>>(eventName: TEventName, start: (remitter: Remitter<TConfig>) => RemitterDisposer) => RemitterDisposer;
}

export { ANY_EVENT, AllRemitterEventNames, AnyEventData, AnyRemitterListener, ReadonlyRemitter, Remitter, RemitterConfig, RemitterDatalessEventName, RemitterDisposer, RemitterEventNames, RemitterListener };
