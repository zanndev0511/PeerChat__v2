// src/constants.ts
var ANY_EVENT = Symbol.for("$\u2009ANY_EVENT\u2009$");

// src/utils.ts
var tryCall = (fn, arg) => {
  try {
    return fn(arg);
  } catch (e) {
    console.error(e);
  }
};
var noop = () => {
};

// src/relay.ts
var startRelay = (listener, remitter) => {
  listener.a = tryCall(listener.c, remitter) || noop;
};
var tryStartAllRelay = (listeners, remitter) => {
  for (const listener of listeners) {
    if (!listener.a) {
      if (
        /*
          Sugar for
          ```
          listener.eventName_ === ANY_EVENT
            ? remitter.count() > 0
            : remitter.count(listener.eventName_) > 0 ||
              remitter.count(ANY_EVENT) > 0
          ```
          `tryStartAll_` will always be called when remitter.count() > 0
        */
        listener.b === ANY_EVENT || remitter.count(listener.b) > 0 || remitter.count(ANY_EVENT) > 0
      ) {
        startRelay(listener, remitter);
      }
    }
  }
};
var stopRelay = (listener) => {
  if (listener.a) {
    tryCall(listener.a);
    listener.a = null;
  }
};
var tryStopAllRelay = (listeners, remitter) => {
  for (const listener of listeners) {
    if (listener.a) {
      if (listener.b === ANY_EVENT ? remitter.count() <= 0 : remitter.count(ANY_EVENT) <= 0 && remitter.count(listener.b) <= 0) {
        stopRelay(listener);
      }
    }
  }
};

// node_modules/.pnpm/@wopjs+disposable@0.0.9/node_modules/@wopjs/disposable/dist/index.mjs
var invoke = (fn) => {
  try {
    fn();
  } catch (e) {
    console.error(e);
  }
};
var abortable = (disposer) => {
  const abortable2 = () => {
    if (disposer) {
      invoke(disposer);
      disposer = null;
    }
    abortable2.abortable();
  };
  abortable2.dispose = abortable2;
  abortable2.abortable = abortable$abortable;
  return abortable2;
};
function abortable$abortable(onDispose) {
  if (this._o) {
    invoke(this._o);
  }
  this._o = onDispose;
}

// src/remitter.ts
var ReadonlyRemitter = class {
  ANY_EVENT = ANY_EVENT;
  _l = /* @__PURE__ */ new Map();
  _r;
  _o;
  emit(event, data) {
    const listeners = this._l.get(event);
    if (listeners) {
      for (const listener of listeners) {
        tryCall(listener, data);
      }
    }
    if (event !== ANY_EVENT && this.count(ANY_EVENT)) {
      this.emit(ANY_EVENT, {
        event,
        data
      });
    }
  }
  on(eventName, listener) {
    let listeners = this._l.get(eventName);
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set();
      this._l.set(eventName, listeners);
    }
    listeners.add(listener);
    if (this._r && listeners.size === 1) {
      tryStartAllRelay(
        this._r,
        this
      );
    }
    return () => {
      this.off(eventName, listener);
    };
  }
  once(eventName, listener) {
    const off = abortable(() => this.off(eventName, onceListener));
    const onceListener = (eventData) => (off(), listener(eventData));
    (this._o || (this._o = /* @__PURE__ */ new WeakMap())).set(
      listener,
      onceListener
    );
    this.on(eventName, onceListener);
    return off;
  }
  /**
   * Remove a listener from the eventName.
   */
  off(eventName, listener) {
    const listeners = this._l.get(eventName);
    if (listeners) {
      let result = listeners.delete(listener);
      const onceListener = this._o?.get(listener);
      if (onceListener) {
        result = listeners.delete(onceListener) || result;
      }
      if (listeners.size <= 0) {
        this._l.delete(eventName);
        if (this._r) {
          tryStopAllRelay(this._r, this);
        }
      }
      return result;
    }
    return false;
  }
  clear(eventName) {
    if (eventName) {
      this._l.get(eventName)?.clear();
    } else {
      this._l.clear();
    }
    if (this._r) {
      tryStopAllRelay(this._r, this);
    }
  }
  /**
   * Returns the number of listeners for the eventName.
   * @param eventName If empty returns the number of listeners for all events.
   * @returns
   */
  count(eventName) {
    if (eventName) {
      return this._l.get(eventName)?.size || 0;
    } else {
      let count = 0;
      for (const listeners of this._l.values()) {
        count += listeners.size;
      }
      return count;
    }
  }
  /**
   * Start a side effect when the eventName has a first listener.
   * Dispose the side effect when the eventName has no listeners.
   * For example tap into other events.
   *
   * remit `ANY_EVENT` will be started when any event is listened.
   *
   * @param eventName
   * @param start A function that is called when listener count if `eventName` grows from 0 to 1. Returns a disposer when listener count if `eventName` drops from 1 to 0.
   */
  remit(eventName, start) {
    const relayListener = {
      c: start,
      b: eventName
    };
    (this._r || (this._r = /* @__PURE__ */ new Set())).add(
      relayListener
    );
    if (this.count(eventName) > 0 || this.count(ANY_EVENT) > 0) {
      startRelay(relayListener, this);
    }
    return () => {
      this._r?.delete(relayListener);
      stopRelay(relayListener);
    };
  }
  /**
   * Dispose all listeners.
   */
  dispose() {
    this.clear();
    this._r?.clear();
  }
};
var Remitter = class extends ReadonlyRemitter {
  constructor() {
    super();
  }
  emit = super.emit;
  remit = super.remit;
};

export { ANY_EVENT, ReadonlyRemitter, Remitter };
