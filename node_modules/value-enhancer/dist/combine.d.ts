import { ReadonlyVal } from "./readonly-val";
import type { ValConfig } from "./typings";
export declare type TValInputsValueTuple<TValInputs extends readonly ReadonlyVal[]> = Readonly<{
    [K in keyof TValInputs]: ExtractValValue<TValInputs[K]>;
}>;
export declare type ExtractValValue<TVal> = TVal extends ReadonlyVal<infer TValue, any> ? TValue : never;
export declare type ExtractValMeta<TVal> = TVal extends ReadonlyVal<any, infer TMeta> ? TMeta : never;
export declare type CombineValTransform<TDerivedValue = any, TValues extends readonly any[] = any[], TMeta = any> = (newValues: TValues, oldValues?: TValues, meta?: TMeta) => TDerivedValue;
export declare class CombinedVal<TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[], TValue = any, TMeta = ExtractValMeta<TValInputs[number]>> extends ReadonlyVal<TValue, TMeta> {
    constructor(valInputs: TValInputs, transform: CombineValTransform<TValue, [
        ...TValInputsValueTuple<TValInputs>
    ], TMeta>, config?: ValConfig<TValue, TMeta>);
    get value(): TValue;
    private _srcValue;
}
export declare function combine<TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[]>(valInputs: readonly [...TValInputs]): ReadonlyVal<[
    ...TValInputsValueTuple<TValInputs>
], ExtractValMeta<TValInputs[number]>>;
export declare function combine<TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[], TValue = any, TMeta = ExtractValMeta<TValInputs[number]>>(valInputs: readonly [...TValInputs], transform: CombineValTransform<TValue, [
    ...TValInputsValueTuple<TValInputs>
], TMeta>, config?: ValConfig<TValue, TMeta>): ReadonlyVal<TValue, TMeta>;
