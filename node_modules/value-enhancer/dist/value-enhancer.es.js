var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Subscribers {
  constructor(beforeSubscribe) {
    __publicField(this, "_subscribers");
    __publicField(this, "_bSub");
    __publicField(this, "_bSubDisposer");
    this._bSub = beforeSubscribe;
  }
  get size() {
    return this._subscribers ? this._subscribers.size : 0;
  }
  invoke(newValue, meta) {
    if (this._subscribers) {
      this._subscribers.forEach((subscriber) => subscriber(newValue, meta));
    }
  }
  add(subscribe) {
    if (this._bSub && (!this._subscribers || this._subscribers.size <= 0)) {
      this._bSubDisposer = this._bSub();
    }
    if (!this._subscribers) {
      this._subscribers = /* @__PURE__ */ new Set();
    }
    this._subscribers.add(subscribe);
  }
  remove(subscriber) {
    if (this._subscribers) {
      this._subscribers.delete(subscriber);
    }
    if (this._subscribers && this._subscribers.size <= 0) {
      if (this._bSubDisposer) {
        const _bSubDisposer = this._bSubDisposer;
        this._bSubDisposer = null;
        _bSubDisposer();
      }
    }
  }
  clear() {
    if (this._subscribers) {
      this._subscribers.clear();
    }
    if (this._bSubDisposer) {
      const _bSubDisposer = this._bSubDisposer;
      this._bSubDisposer = null;
      _bSubDisposer();
    }
  }
  destroy() {
    this.clear();
  }
}
class ReadonlyVal {
  constructor(value, config) {
    __publicField(this, "_subscribers");
    __publicField(this, "_value");
    this._value = value;
    let beforeSubscribe;
    if (config) {
      if (config.compare) {
        this.compare = config.compare;
      }
      if (config.beforeSubscribe) {
        const _beforeSubscribe = config.beforeSubscribe;
        const _setValue = this._setValue.bind(this);
        beforeSubscribe = () => _beforeSubscribe(_setValue);
      }
    }
    this._subscribers = new Subscribers(beforeSubscribe);
  }
  _setValue(value, meta) {
    if (!this.compare(value, this._value)) {
      this._value = value;
      this._subscribers.invoke(value, meta);
    }
  }
  get value() {
    return this._value;
  }
  reaction(subscriber) {
    this._subscribers.add(subscriber);
    return () => {
      this._subscribers.remove(subscriber);
    };
  }
  subscribe(subscriber, meta) {
    const disposer = this.reaction(subscriber);
    subscriber(this._value, meta);
    return disposer;
  }
  destroy() {
    this._subscribers.destroy();
  }
  unsubscribe(subscriber) {
    this._subscribers.remove(subscriber);
  }
  get size() {
    return this._subscribers.size;
  }
  compare(newValue, oldValue) {
    return newValue === oldValue;
  }
}
class Val extends ReadonlyVal {
  constructor() {
    super(...arguments);
    __publicField(this, "setValue", this._setValue);
  }
}
class DerivedVal extends ReadonlyVal {
  constructor(val, transform, config = {}) {
    super(transform(val.value), __spreadProps(__spreadValues({}, config), {
      beforeSubscribe: (setValue) => {
        const disposer = val.subscribe((newValue, meta) => setValue(transform(newValue), meta));
        if (config.beforeSubscribe) {
          const beforeSubscribeDisposer = config.beforeSubscribe(setValue);
          if (beforeSubscribeDisposer) {
            return () => {
              disposer();
              beforeSubscribeDisposer();
            };
          }
        }
        return disposer;
      }
    }));
    __publicField(this, "_srcValue");
    this._srcValue = () => transform(val.value);
  }
  get value() {
    if (this.size <= 0) {
      const value = this._srcValue();
      return this.compare(value, this._value) ? this._value : value;
    }
    return this._value;
  }
}
function derive(val, transform = (value) => value, config = {}) {
  return new DerivedVal(val, transform, config);
}
class CombinedVal extends ReadonlyVal {
  constructor(valInputs, transform, config = {}) {
    super(transform(getValues(valInputs)), __spreadProps(__spreadValues({}, config), {
      beforeSubscribe: (setValue) => {
        let lastValueInputs = getValues(valInputs);
        setValue(transform(lastValueInputs));
        const disposers = valInputs.map((val, i) => val.reaction((value, meta) => {
          lastValueInputs = lastValueInputs.slice();
          lastValueInputs[i] = value;
          setValue(transform(lastValueInputs), meta);
        }));
        const disposer = () => disposers.forEach((disposer2) => disposer2());
        if (config.beforeSubscribe) {
          const beforeSubscribeDisposer = config.beforeSubscribe(setValue);
          if (beforeSubscribeDisposer) {
            return () => {
              disposer();
              beforeSubscribeDisposer();
            };
          }
        }
        return disposer;
      }
    }));
    __publicField(this, "_srcValue");
    this._srcValue = () => transform(getValues(valInputs));
  }
  get value() {
    if (this.size <= 0) {
      const value = this._srcValue();
      return this.compare(value, this._value) ? this._value : value;
    }
    return this._value;
  }
}
function getValues(valInputs) {
  return valInputs.map(getValue);
}
function getValue(val) {
  return val.value;
}
function combine(valInputs, transform = (value) => value, config = {}) {
  return new CombinedVal(valInputs, transform, config);
}
function withOnValChanged(instance) {
  if (!instance.onValChanged) {
    instance.onValChanged = onValChanged;
  }
}
function onValChanged(key, listener) {
  const val = this[`_${key}$`] || this[key];
  if (!(val == null ? void 0 : val.reaction)) {
    throw new TypeError(`"${key}" is not related to a Val in this instance`);
  }
  return val.reaction(listener);
}
function withReadonlyValueEnhancer(instance, config, valManager) {
  Object.keys(config).forEach((key) => {
    bindInstance$1(instance, key, config[key]);
    if (valManager) {
      valManager.attach(config[key]);
    }
  });
  withOnValChanged(instance);
}
function bindInstance$1(instance, key, val) {
  Object.defineProperties(instance, {
    [key]: {
      get() {
        return val.value;
      }
    },
    [`_${key}$`]: {
      value: val
    }
  });
  return instance;
}
function withValueEnhancer(instance, config, valManager) {
  Object.keys(config).forEach((key) => {
    bindInstance(instance, key, config[key]);
    if (valManager) {
      valManager.attach(config[key]);
    }
  });
  withOnValChanged(instance);
}
function bindInstance(instance, key, val) {
  Object.defineProperties(instance, {
    [key]: {
      get() {
        return val.value;
      },
      set(value) {
        val.setValue(value);
      }
    },
    [`_${key}$`]: {
      value: val
    },
    [`set${capitalize(key)}`]: {
      value: (value, meta) => val.setValue(value, meta)
    }
  });
  return instance;
}
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
class ValManager {
  constructor() {
    __publicField(this, "vals", /* @__PURE__ */ new Set());
  }
  attach(val) {
    this.vals.add(val);
    return val;
  }
  detach(val) {
    this.vals.delete(val);
    return val;
  }
  destroy() {
    this.vals.forEach(destroyVal);
    this.vals.clear();
  }
}
function destroyVal(val) {
  val.destroy();
}
export { CombinedVal, DerivedVal, ReadonlyVal, Val, ValManager, bindInstance, combine, derive, withReadonlyValueEnhancer, withValueEnhancer };
//# sourceMappingURL=value-enhancer.es.js.map
