{"version":3,"file":"value-enhancer.cjs.js","sources":["../src/subscribers.ts","../src/readonly-val.ts","../src/val.ts","../src/derived-val.ts","../src/combine.ts","../src/with-on-val-changed.ts","../src/with-readonly-value-enhancer.ts","../src/with-value-enhancer.ts","../src/val-manager.ts"],"sourcesContent":["import type { ValDisposer, ValSubscriber } from \"./typings\";\n\nexport class Subscribers<TValue = any, TMeta = any> {\n  public get size(): number {\n    return this._subscribers ? this._subscribers.size : 0;\n  }\n\n  public constructor(beforeSubscribe?: () => void | ValDisposer | undefined) {\n    this._bSub = beforeSubscribe;\n  }\n\n  public invoke(newValue: TValue, meta?: TMeta): void {\n    if (this._subscribers) {\n      this._subscribers.forEach(subscriber => subscriber(newValue, meta));\n    }\n  }\n\n  public add(subscribe: ValSubscriber): void {\n    if (this._bSub && (!this._subscribers || this._subscribers.size <= 0)) {\n      this._bSubDisposer = this._bSub();\n    }\n\n    if (!this._subscribers) {\n      this._subscribers = new Set();\n    }\n\n    this._subscribers.add(subscribe);\n  }\n\n  public remove(subscriber: ValSubscriber): void {\n    if (this._subscribers) {\n      this._subscribers.delete(subscriber);\n    }\n    if (this._subscribers && this._subscribers.size <= 0) {\n      if (this._bSubDisposer) {\n        const _bSubDisposer = this._bSubDisposer;\n        this._bSubDisposer = null;\n        _bSubDisposer();\n      }\n    }\n  }\n\n  public clear(): void {\n    if (this._subscribers) {\n      this._subscribers.clear();\n    }\n    if (this._bSubDisposer) {\n      const _bSubDisposer = this._bSubDisposer;\n      this._bSubDisposer = null;\n      _bSubDisposer();\n    }\n  }\n\n  public destroy(): void {\n    this.clear();\n  }\n\n  private _subscribers?: Set<ValSubscriber<TValue, TMeta>>;\n\n  private _bSub?: () => void | ValDisposer | undefined;\n  private _bSubDisposer?: ValDisposer | void | null;\n}\n","import { Subscribers } from \"./subscribers\";\nimport type { ValDisposer, ValSubscriber, ValConfig } from \"./typings\";\n\nexport class ReadonlyVal<TValue = any, TMeta = any> {\n  private _subscribers: Subscribers<TValue, TMeta>;\n\n  protected _value: TValue;\n\n  protected _setValue(value: TValue, meta?: TMeta): void {\n    if (!this.compare(value, this._value)) {\n      this._value = value;\n      this._subscribers.invoke(value, meta);\n    }\n  }\n\n  public constructor(value: TValue, config?: ValConfig<TValue, TMeta>) {\n    this._value = value;\n\n    let beforeSubscribe: undefined | (() => void | ValDisposer | undefined);\n\n    if (config) {\n      if (config.compare) {\n        this.compare = config.compare;\n      }\n      if (config.beforeSubscribe) {\n        const _beforeSubscribe = config.beforeSubscribe;\n        const _setValue = this._setValue.bind(this);\n        beforeSubscribe = () => _beforeSubscribe(_setValue);\n      }\n    }\n\n    this._subscribers = new Subscribers<TValue, TMeta>(beforeSubscribe);\n  }\n\n  public get value(): TValue {\n    return this._value;\n  }\n\n  /**\n   * Subscribe to value changes without immediate emission.\n   */\n  public reaction(subscriber: ValSubscriber<TValue, TMeta>): ValDisposer {\n    this._subscribers.add(subscriber);\n\n    return (): void => {\n      this._subscribers.remove(subscriber);\n    };\n  }\n\n  /**\n   * Subscribe to value changes with immediate emission.\n   * @param subscriber\n   * @param meta Meta for the immediate emission\n   */\n  public subscribe(\n    subscriber: ValSubscriber<TValue, TMeta>,\n    meta?: TMeta\n  ): ValDisposer {\n    const disposer = this.reaction(subscriber);\n    subscriber(this._value, meta);\n    return disposer;\n  }\n\n  public destroy(): void {\n    this._subscribers.destroy();\n  }\n\n  public unsubscribe<T extends (...args: any[]) => any>(subscriber: T): void {\n    this._subscribers.remove(subscriber);\n  }\n\n  public get size(): number {\n    return this._subscribers.size;\n  }\n\n  /**\n   * Compare two values. Default `===`.\n   */\n  public compare(newValue: TValue, oldValue: TValue): boolean {\n    return newValue === oldValue;\n  }\n}\n","import { ReadonlyVal } from \"./readonly-val\";\n\nexport class Val<TValue = any, TMeta = any> extends ReadonlyVal<TValue, TMeta> {\n  public setValue: (value: TValue, meta?: TMeta) => void = this._setValue;\n}\n","import { ReadonlyVal } from \"./readonly-val\";\nimport type { ValConfig, ValTransform } from \"./typings\";\n\nexport class DerivedVal<\n  TSrcValue = any,\n  TValue = any,\n  TMeta = any\n> extends ReadonlyVal<TValue, TMeta> {\n  public constructor(\n    val: ReadonlyVal<TSrcValue>,\n    transform: ValTransform<TSrcValue, TValue>,\n    config: ValConfig<TValue, TMeta> = {}\n  ) {\n    super(transform(val.value), {\n      ...config,\n      beforeSubscribe: setValue => {\n        const disposer = val.subscribe((newValue, meta) =>\n          setValue(transform(newValue), meta)\n        );\n        if (config.beforeSubscribe) {\n          const beforeSubscribeDisposer = config.beforeSubscribe(setValue);\n          if (beforeSubscribeDisposer) {\n            return () => {\n              disposer();\n              beforeSubscribeDisposer();\n            };\n          }\n        }\n        return disposer;\n      },\n    });\n\n    this._srcValue = () => transform(val.value);\n  }\n\n  public override get value(): TValue {\n    if (this.size <= 0) {\n      const value = this._srcValue();\n      return this.compare(value, this._value) ? this._value : value;\n    }\n    return this._value;\n  }\n\n  private _srcValue: () => TValue;\n}\n\nexport function derive<TSrcValue = any, TValue = any, TMeta = any>(\n  val: ReadonlyVal<TSrcValue>\n): ReadonlyVal<TValue, TMeta>;\nexport function derive<TSrcValue = any, TValue = any, TMeta = any>(\n  val: ReadonlyVal<TSrcValue>,\n  transform: ValTransform<TSrcValue, TValue>,\n  config?: ValConfig<TValue, TMeta>\n): ReadonlyVal<TValue, TMeta>;\nexport function derive<TSrcValue = any, TValue = any, TMeta = any>(\n  val: ReadonlyVal<TSrcValue>,\n  transform: ValTransform<TSrcValue, TValue> = value =>\n    value as unknown as TValue,\n  config: ValConfig<TValue, TMeta> = {}\n): ReadonlyVal<TValue, TMeta> {\n  return new DerivedVal(val, transform, config);\n}\n","import { ReadonlyVal } from \"./readonly-val\";\nimport type { ValConfig } from \"./typings\";\n\nexport type TValInputsValueTuple<TValInputs extends readonly ReadonlyVal[]> =\n  Readonly<{\n    [K in keyof TValInputs]: ExtractValValue<TValInputs[K]>;\n  }>;\n\nexport type ExtractValValue<TVal> = TVal extends ReadonlyVal<infer TValue, any>\n  ? TValue\n  : never;\n\nexport type ExtractValMeta<TVal> = TVal extends ReadonlyVal<any, infer TMeta>\n  ? TMeta\n  : never;\n\nexport type CombineValTransform<\n  TDerivedValue = any,\n  TValues extends readonly any[] = any[],\n  TMeta = any\n> = (newValues: TValues, oldValues?: TValues, meta?: TMeta) => TDerivedValue;\n\nexport class CombinedVal<\n  TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[],\n  TValue = any,\n  TMeta = ExtractValMeta<TValInputs[number]>\n> extends ReadonlyVal<TValue, TMeta> {\n  public constructor(\n    valInputs: TValInputs,\n    transform: CombineValTransform<\n      TValue,\n      [...TValInputsValueTuple<TValInputs>],\n      TMeta\n    >,\n    config: ValConfig<TValue, TMeta> = {}\n  ) {\n    super(transform(getValues(valInputs)), {\n      ...config,\n      beforeSubscribe: setValue => {\n        let lastValueInputs = getValues(valInputs);\n        setValue(transform(lastValueInputs));\n        const disposers = valInputs.map((val, i) =>\n          val.reaction((value, meta) => {\n            lastValueInputs = lastValueInputs.slice() as [\n              ...TValInputsValueTuple<TValInputs>\n            ];\n            lastValueInputs[i] = value;\n            setValue(transform(lastValueInputs), meta);\n          })\n        );\n        const disposer = () => disposers.forEach(disposer => disposer());\n\n        if (config.beforeSubscribe) {\n          const beforeSubscribeDisposer = config.beforeSubscribe(setValue);\n          if (beforeSubscribeDisposer) {\n            return () => {\n              disposer();\n              beforeSubscribeDisposer();\n            };\n          }\n        }\n\n        return disposer;\n      },\n    });\n\n    this._srcValue = () => transform(getValues(valInputs));\n  }\n\n  public override get value(): TValue {\n    if (this.size <= 0) {\n      const value = this._srcValue();\n      return this.compare(value, this._value) ? this._value : value;\n    }\n    return this._value;\n  }\n\n  private _srcValue: () => TValue;\n}\n\nfunction getValues<TValInputs extends readonly ReadonlyVal[]>(\n  valInputs: TValInputs\n): [...TValInputsValueTuple<TValInputs>] {\n  return valInputs.map(getValue) as [...TValInputsValueTuple<TValInputs>];\n}\n\nfunction getValue<TValue>(val: ReadonlyVal<TValue>): TValue {\n  return val.value;\n}\n\nexport function combine<\n  TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[]\n>(\n  valInputs: readonly [...TValInputs]\n): ReadonlyVal<\n  [...TValInputsValueTuple<TValInputs>],\n  ExtractValMeta<TValInputs[number]>\n>;\nexport function combine<\n  TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[],\n  TValue = any,\n  TMeta = ExtractValMeta<TValInputs[number]>\n>(\n  valInputs: readonly [...TValInputs],\n  transform: CombineValTransform<\n    TValue,\n    [...TValInputsValueTuple<TValInputs>],\n    TMeta\n  >,\n  config?: ValConfig<TValue, TMeta>\n): ReadonlyVal<TValue, TMeta>;\nexport function combine<\n  TValInputs extends readonly ReadonlyVal[] = ReadonlyVal[],\n  TValue = any,\n  TMeta = ExtractValMeta<TValInputs[number]>\n>(\n  valInputs: readonly [...TValInputs],\n  transform: CombineValTransform<\n    TValue,\n    [...TValInputsValueTuple<TValInputs>],\n    TMeta\n  > = value => value as TValue,\n  config: ValConfig<TValue, TMeta> = {}\n): ReadonlyVal<TValue, TMeta> {\n  return new CombinedVal(valInputs, transform, config);\n}\n","import type { ReadonlyVal } from \"./readonly-val\";\nimport type { ValDisposer, ValSubscriber } from \"./typings\";\n\ntype ValueFromVal<V> = V extends ReadonlyVal<infer TValue> ? TValue : never;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype MetaFromVal<V> = V extends ReadonlyVal<infer _TValue, infer TMeta>\n  ? TMeta\n  : never;\n\nexport type WithOnValChanged<TConfig, TEnhancedResult> = TEnhancedResult & {\n  onValChanged: <\n    K extends Extract<keyof TConfig, string> = Extract<keyof TConfig, string>\n  >(\n    key: K,\n    listener: ValSubscriber<\n      ValueFromVal<TEnhancedResult[Extract<`_${K}$`, keyof TEnhancedResult>]>,\n      MetaFromVal<TEnhancedResult[Extract<`_${K}$`, keyof TEnhancedResult>]>\n    >\n  ) => ValDisposer;\n};\n\nexport function withOnValChanged<TInstance>(instance: TInstance): void {\n  if (!(instance as any).onValChanged) {\n    (instance as any).onValChanged = onValChanged;\n  }\n}\n\nfunction onValChanged<TConfig, K extends Extract<keyof TConfig, string>, O>(\n  this: O,\n  key: K,\n  listener: ValSubscriber<\n    ValueFromVal<O[Extract<`_${K}$`, keyof O>]>,\n    MetaFromVal<O[Extract<`_${K}$`, keyof O>]>\n  >\n): ValDisposer {\n  const val = (this as any)[`_${key}$`] || (this as any)[key];\n  if (!val?.reaction) {\n    throw new TypeError(`\"${key}\" is not related to a Val in this instance`);\n  }\n  return val.reaction(listener);\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport type { ExtractValValue } from \"./combine\";\nimport type { ReadonlyVal } from \"./readonly-val\";\nimport type { ValManager } from \"./val-manager\";\nimport type { WithOnValChanged } from \"./with-on-val-changed\";\nimport { withOnValChanged } from \"./with-on-val-changed\";\n\ntype IntersectionFromUnion<TUnion> = (\n  TUnion extends any ? (arg: TUnion) => void : never\n) extends (arg: infer TArg) => void\n  ? TArg\n  : never;\n\ntype ExtractReadonlyValKeys<\n  TInstance,\n  TKey = keyof TInstance\n> = TKey extends Extract<keyof TInstance, string>\n  ? TInstance[TKey] extends ReadonlyVal\n    ? TKey\n    : never\n  : never;\n\nexport type ReadonlyValEnhancedProps<TVal, TKey extends string> = Readonly<\n  Record<TKey, ExtractValValue<TVal>> & Record<`_${TKey}$`, TVal>\n>;\n\nexport type ReadonlyValEnhancerConfig = Record<string, ReadonlyVal>;\n\ntype ToReadonlyValUnion<\n  TConfig,\n  TKey = ExtractReadonlyValKeys<TConfig>\n> = TKey extends ExtractReadonlyValKeys<TConfig>\n  ? ReadonlyValEnhancedProps<TConfig[TKey], TKey>\n  : never;\n\nexport type ReadonlyValEnhancedResult<TConfig> = WithOnValChanged<\n  TConfig,\n  IntersectionFromUnion<ToReadonlyValUnion<TConfig>>\n>;\n\n/**\n * Bind ReadonlyVals/Vals `value` and itself to properties of an instance.\n *\n * @example\n * ```ts\n * import type { ReadonlyValEnhancedResult } from \"value-enhancer\";\n * import { Val, withReadonlyValueEnhancer } from \"value-enhancer\";\n *\n * type ReadonlyValConfig = {\n *   apple: Val<string>\n *   isApple: ReadonlyVal<boolean>\n * };\n *\n * interface Obj extends ReadonlyValEnhancedResult<ReadonlyValConfig> {}\n *\n * class Obj {\n *   constructor() {\n *     const apple$ = new Val(\"apple\");\n *     const isApple$ = derive(apple$, (apple) => apple === \"apple\");\n *\n *     withReadonlyValueEnhancer(this, {\n *       apple: apple$,\n *       isApple: isApple$,\n *     })\n *   }\n * }\n * ```\n *\n * `const obj = new Obj()` results in:\n * - `obj.apple`, a getter that returns `apple$.value`\n * - `obj._apple$`, the `apple$`\n * - `obj.isApple`, a getter that returns `isApple$.value`\n * - `obj._isApple$`, the `isApple$`\n * - `obj.onValChanged(key: \"apple\" | \"isApple\", listener)`, equals to calling <code>obj[\\`_${key}$\\`].reaction</code>\n */\nexport function withReadonlyValueEnhancer<\n  TInstance extends ReadonlyValEnhancedResult<TConfig>,\n  TConfig extends ReadonlyValEnhancerConfig\n>(instance: TInstance, config: TConfig, valManager?: ValManager): void {\n  Object.keys(config).forEach(key => {\n    bindInstance(instance, key, config[key]);\n    if (valManager) {\n      valManager.attach(config[key]);\n    }\n  });\n  withOnValChanged(instance);\n}\n\n/**\n * Bind a ReadonlyVal/Val to a property of an instance.\n *\n * @example\n * `bindInstance(Obj, \"aKey\", val)` results in:\n * - `Obj.aKey`, value of `val.value`\n * - `Obj._aKey$`, the `val`\n * @returns Same instance with bound properties\n */\nfunction bindInstance<TInstance, TKey extends string, TValue, TMeta>(\n  instance: TInstance,\n  key: TKey,\n  val: ReadonlyVal<TValue, TMeta>\n): ReadonlyValEnhancedProps<TValue, TKey> & TInstance {\n  Object.defineProperties(instance, {\n    [key]: {\n      get() {\n        return val.value;\n      },\n    },\n    [`_${key}$`]: {\n      value: val,\n    },\n  });\n  return instance as ReadonlyValEnhancedProps<TValue, TKey> & TInstance;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport type { ExtractValMeta, ExtractValValue } from \"./combine\";\nimport type { Val } from \"./val\";\nimport type { ValManager } from \"./val-manager\";\nimport type { WithOnValChanged } from \"./with-on-val-changed\";\nimport { withOnValChanged } from \"./with-on-val-changed\";\n\ntype IntersectionFromUnion<TUnion> = (\n  TUnion extends any ? (arg: TUnion) => void : never\n) extends (arg: infer TArg) => void\n  ? TArg\n  : never;\n\ntype ExtractValKeys<TInstance, TKey = keyof TInstance> = TKey extends Extract<\n  keyof TInstance,\n  string\n>\n  ? TInstance[TKey] extends Val\n    ? TKey\n    : never\n  : never;\n\ntype ValEnhancedProps<TVal, TKey extends string> = Readonly<\n  Record<`_${TKey}$`, TVal> &\n    Record<\n      `set${Capitalize<TKey>}`,\n      (value: ExtractValValue<TVal>, meta?: ExtractValMeta<TVal>) => void\n    >\n> &\n  Record<TKey, ExtractValValue<TVal>>;\n\nexport type ValEnhancerConfig = Record<string, Val>;\n\ntype ToValUnion<\n  TConfig,\n  TKey = ExtractValKeys<TConfig>\n> = TKey extends ExtractValKeys<TConfig>\n  ? ValEnhancedProps<TConfig[TKey], TKey>\n  : never;\n\nexport type ValEnhancedResult<TConfig> = WithOnValChanged<\n  TConfig,\n  IntersectionFromUnion<ToValUnion<TConfig>>\n>;\n\n/**\n * Bind Vals `value`, `setValue` and itself to properties of an instance.\n *\n * @example\n * ```ts\n * import type { ValEnhancedResult } from \"value-enhancer\";\n * import { Val, withValueEnhancer } from \"value-enhancer\";\n *\n * type ValConfig = {\n *   apple: Val<string>\n *   banana: Val<string>\n * };\n *\n * interface Obj extends ValEnhancedResult<ValConfig> {}\n *\n * class Obj {\n *   constructor() {\n *     const apple$ = new Val(\"apple\");\n *     const banana$ = new Val(\"banana\");\n *\n *     withValueEnhancer(this, {\n *       apple: apple$,\n *       banana: banana$,\n *     })\n *   }\n * }\n * ```\n *\n * `const obj = new Obj()` results in:\n * - `obj.apple`, a getter that returns `apple$.value`, setter same as `apple$.setValue(value)`\n * - `obj._apple$`, the `apple$`\n * - `obj.setApple(value)`, same as `apple$.setValue(value)`\n * - `obj.banana`, a getter that returns `banana$.value`, setter same as `banana$.setValue(value)`\n * - `obj.setBanana(value)`, same as `banana$.setValue(value)`\n * - `obj._banana$`, the `banana$`\n * - `obj.onValChanged(key: \"apple\" | \"isApple\", listener)`, equals to calling <code>obj[\\`_${key}$\\`].reaction</code>\n */\nexport function withValueEnhancer<\n  TInstance extends ValEnhancedResult<TConfig>,\n  TConfig extends ValEnhancerConfig\n>(instance: TInstance, config: TConfig, valManager?: ValManager): void {\n  Object.keys(config).forEach(key => {\n    bindInstance(instance, key, config[key]);\n    if (valManager) {\n      valManager.attach(config[key]);\n    }\n  });\n  withOnValChanged(instance);\n}\n\nexport type BindVal = <TKey extends string, TValue, TMeta>(\n  key: TKey,\n  val: Val<TValue, TMeta>\n) => Val<TValue, TMeta>;\n\n/**\n * Bind a Val to a property of an instance.\n *\n * @example\n * `bindInstance(obj, \"aKey\", val)` results in:\n * - `obj.aKey`, getter that returns `val.value`, setter same as `val.setValue(value)`\n * - `obj.setAKey(value)`, same as `val.setValue(value)`\n * - `obj._aKey$`, the `val`\n * @returns Same instance with bound properties\n */\nexport function bindInstance<TInstance, TKey extends string, TValue, TMeta>(\n  instance: TInstance,\n  key: TKey,\n  val: Val<TValue, TMeta>\n): ValEnhancedProps<TValue, TKey> & TInstance {\n  Object.defineProperties(instance, {\n    [key]: {\n      get() {\n        return val.value;\n      },\n      set(value) {\n        val.setValue(value);\n      },\n    },\n    [`_${key}$`]: {\n      value: val,\n    },\n    [`set${capitalize(key)}`]: {\n      value: (value: TValue, meta?: TMeta): void => val.setValue(value, meta),\n    },\n  });\n  return instance as ValEnhancedProps<TValue, TKey> & TInstance;\n}\n\nfunction capitalize<TStr extends string>(str: TStr): Capitalize<TStr> {\n  return (str[0].toUpperCase() + str.slice(1)) as Capitalize<TStr>;\n}\n","import type { ReadonlyVal } from \"./readonly-val\";\n\n/**\n * Manage life-cycles of a list of Vals (e.g. auto cleanup).\n *\n * @example\n * ```ts\n * const valManager = new ValManager();\n * const val1 = valManager.attach(new Val(\"12345\"));\n * const val2 = valManager.attach(new Val(\"\"));\n *\n * valManager.destroy(); // val1.destroy() and val2.destroy() are called\n * ```\n */\nexport class ValManager {\n  public readonly vals = new Set<ReadonlyVal>();\n\n  /** Attach a val to manager */\n  public attach<V extends ReadonlyVal>(val: V): V {\n    this.vals.add(val);\n    return val;\n  }\n\n  /** Detach a val from manager */\n  public detach<V extends ReadonlyVal>(val: V): V {\n    this.vals.delete(val);\n    return val;\n  }\n\n  public destroy(): void {\n    this.vals.forEach(destroyVal);\n    this.vals.clear();\n  }\n}\n\nfunction destroyVal(val: ReadonlyVal): void {\n  val.destroy();\n}\n"],"names":["bindInstance"],"mappings":"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"}