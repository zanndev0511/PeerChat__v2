import Tippy from 'tippy.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// inline-sass-helper:inline-sass-style-helper.js
function injectStyle(text2) {
  if (typeof document !== "undefined") {
    var style = document.createElement("style");
    var node = document.createTextNode(text2);
    style.appendChild(node);
    document.head.appendChild(style);
  }
}

// inline-sass-content:./src/style.scss
var style_default = '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}.tippy-box[data-theme~=light]{color:#26323d;box-shadow:0 0 20px 4px #9aa1b126,0 4px 80px -8px #24282f40,0 4px 4px -2px #5b5e6926;background-color:#fff}.tippy-box[data-theme~=light][data-placement^=top]>.tippy-arrow:before{border-top-color:#fff}.tippy-box[data-theme~=light][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#fff}.tippy-box[data-theme~=light][data-placement^=left]>.tippy-arrow:before{border-left-color:#fff}.tippy-box[data-theme~=light][data-placement^=right]>.tippy-arrow:before{border-right-color:#fff}.tippy-box[data-theme~=light]>.tippy-backdrop{background-color:#fff}.tippy-box[data-theme~=light]>.tippy-svg-arrow{fill:#fff}.fastboard-icon.light .fastboard-icon-stroke-color{stroke:var(--fastboard-color, #5d6066)}.fastboard-icon.light .fastboard-icon-fill-color{fill:var(--fastboard-color, #5d6066)}.fastboard-icon.light.is-active .fastboard-icon-stroke-color{stroke:var(--fastboard-active-color, #3381ff)}.fastboard-icon.light.is-active .fastboard-icon-fill-color{fill:var(--fastboard-active-color, #3381ff)}.fastboard-icon.dark .fastboard-icon-stroke-color{stroke:var(--fastboard-color, #7b7e84)}.fastboard-icon.dark .fastboard-icon-fill-color{fill:var(--fastboard-color, #7b7e84)}.fastboard-icon.dark.is-active .fastboard-icon-stroke-color{stroke:var(--fastboard-active-color, #2867cc)}.fastboard-icon.dark.is-active .fastboard-icon-fill-color{fill:var(--fastboard-active-color, #2867cc)}.fastboard-redo-undo{box-sizing:border-box;display:inline-flex;align-items:center;gap:4px;padding:4px;border:1px solid;border-radius:4px;font-size:14px;font-family:system-ui;pointer-events:auto;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px)}.fastboard-redo-undo *{box-sizing:inherit}.fastboard-redo-undo.light{color:var(--fastboard-color, #5d6066);background-color:var(--fastboard-bg-color, rgba(255, 255, 255, .9));border-color:var(--fastboard-border-color, #e5e8f0)}.fastboard-redo-undo.dark{color:var(--fastboard-color, #7b7e84);background-color:var(--fastboard-bg-color, rgba(20, 24, 30, .9));border-color:var(--fastboard-border-color, #383b42)}.fastboard-redo-undo-btn{appearance:none;cursor:pointer;margin:0;border:0;padding:0;width:24px;height:24px;background-color:#0000;border-radius:4px;font-size:0;line-height:1;flex-shrink:0}.fastboard-redo-undo-btn svg,.fastboard-redo-undo-btn img{width:100%;height:100%;pointer-events:none}.fastboard-redo-undo-btn:disabled{opacity:.5;cursor:not-allowed}.fastboard-redo-undo-btn.light:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-redo-undo-btn.dark:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-zoom-control{box-sizing:border-box;display:inline-flex;align-items:center;gap:4px;padding:4px;border:1px solid;border-radius:4px;font-size:14px;font-family:system-ui;pointer-events:auto;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px)}.fastboard-zoom-control *{box-sizing:inherit}.fastboard-zoom-control.light{color:var(--fastboard-color, #5d6066);background-color:var(--fastboard-bg-color, rgba(255, 255, 255, .9));border-color:var(--fastboard-border-color, #e5e8f0)}.fastboard-zoom-control.dark{color:var(--fastboard-color, #7b7e84);background-color:var(--fastboard-bg-color, rgba(20, 24, 30, .9));border-color:var(--fastboard-border-color, #383b42)}.fastboard-zoom-control-btn{appearance:none;cursor:pointer;margin:0;border:0;padding:0;width:24px;height:24px;background-color:#0000;border-radius:4px;font-size:0;line-height:1;flex-shrink:0}.fastboard-zoom-control-btn svg,.fastboard-zoom-control-btn img{width:100%;height:100%;pointer-events:none}.fastboard-zoom-control-btn:disabled{opacity:.5;cursor:not-allowed}.fastboard-zoom-control-btn.light:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-zoom-control-btn.dark:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-zoom-control-text{font-variant-numeric:tabular-nums}.fastboard-page-control{box-sizing:border-box;display:inline-flex;align-items:center;gap:4px;padding:4px;border:1px solid;border-radius:4px;font-size:14px;font-family:system-ui;pointer-events:auto;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px)}.fastboard-page-control *{box-sizing:inherit}.fastboard-page-control.light{color:var(--fastboard-color, #5d6066);background-color:var(--fastboard-bg-color, rgba(255, 255, 255, .9));border-color:var(--fastboard-border-color, #e5e8f0)}.fastboard-page-control.dark{color:var(--fastboard-color, #7b7e84);background-color:var(--fastboard-bg-color, rgba(20, 24, 30, .9));border-color:var(--fastboard-border-color, #383b42)}.fastboard-page-control-btn{appearance:none;cursor:pointer;margin:0;border:0;padding:0;width:24px;height:24px;background-color:#0000;border-radius:4px;font-size:0;line-height:1;flex-shrink:0}.fastboard-page-control-btn svg,.fastboard-page-control-btn img{width:100%;height:100%;pointer-events:none}.fastboard-page-control-btn:disabled{opacity:.5;cursor:not-allowed}.fastboard-page-control-btn.light:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-page-control-btn.dark:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-page-control-text{font-variant-numeric:tabular-nums}.fastboard-player-control{box-sizing:border-box;display:inline-flex;align-items:center;gap:4px;padding:4px;border:1px solid;border-radius:4px;font-size:14px;font-family:system-ui;pointer-events:auto;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);width:100%}.fastboard-player-control *{box-sizing:inherit}.fastboard-player-control.light{color:var(--fastboard-color, #5d6066);background-color:var(--fastboard-bg-color, rgba(255, 255, 255, .9));border-color:var(--fastboard-border-color, #e5e8f0)}.fastboard-player-control.dark{color:var(--fastboard-color, #7b7e84);background-color:var(--fastboard-bg-color, rgba(20, 24, 30, .9));border-color:var(--fastboard-border-color, #383b42)}.fastboard-player-control-btn{appearance:none;cursor:pointer;margin:0;border:0;padding:0;width:24px;height:24px;background-color:#0000;border-radius:4px;font-size:0;line-height:1;flex-shrink:0;display:inline}.fastboard-player-control-btn svg,.fastboard-player-control-btn img{width:100%;height:100%;pointer-events:none}.fastboard-player-control-btn:disabled{opacity:.5;cursor:not-allowed}.fastboard-player-control-btn.light:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-player-control-btn.dark:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-player-control-btn.loading svg,.fastboard-player-control-btn.loading img{animation:fastboard-player-control-rotate .5s linear infinite}@keyframes fastboard-player-control-rotate{to{transform:rotate(360deg)}}.fastboard-player-control-btn.speed{width:auto;padding:4px;text-align:right;font-size:14px;font-variant-numeric:tabular-nums}.fastboard-player-control-btn.is-active.light{color:var(--fastboard-active-color, #3381ff)}.fastboard-player-control-btn.is-active.dark{color:var(--fastboard-active-color, #2867cc)}.fastboard-player-control-speed-text,.fastboard-player-control-progress{font-size:14px;font-variant-numeric:tabular-nums;line-height:16px}.fastboard-player-control-progress{display:inline-flex;align-items:center}.fastboard-player-control-panel.speed{display:flex;flex-direction:column}.fastboard-toolbar{height:100%;display:flex;align-items:center;position:relative;transform:translate(0);transition:transform .5s cubic-bezier(.34,1.56,.64,1);pointer-events:none}.fastboard-toolbar.collapsed{transform:translate(-100%)}.fastboard-toolbar-handler{position:absolute;left:100%;width:17px;font-size:0;border-radius:3px;cursor:pointer;pointer-events:auto}.fastboard-toolbar-handler:focus-visible{outline:2px solid -webkit-focus-ring-color}.fastboard-toolbar-handler input[type=checkbox]{position:absolute;top:0;left:0;appearance:none;margin:0;width:100%;height:100%;cursor:pointer;opacity:0;z-index:-1}.fastboard-toolbar-handler svg{opacity:0;transition:opacity .5s 1s;pointer-events:none}.fastboard-toolbar-handler.light .fastboard-toolbar-handler-bg-color{fill:var(--fastboard-bg-color, rgba(255, 255, 255, .9))}.fastboard-toolbar-handler.light .fastboard-toolbar-handler-border-color{stroke:var(--fastboard-border-color, #e5e8f0)}.fastboard-toolbar-handler.light .fastboard-toolbar-handler-image-stroke-color{stroke:var(--fastboard-color, #5d6066)}.fastboard-toolbar-handler.light .fastboard-toolbar-handler-image-fill-color{fill:var(--fastboard-color, #5d6066)}.fastboard-toolbar-handler.dark .fastboard-toolbar-handler-bg-color{fill:var(--fastboard-bg-color, rgba(20, 24, 30, .9))}.fastboard-toolbar-handler.dark .fastboard-toolbar-handler-border-color{stroke:var(--fastboard-border-color, #383b42)}.fastboard-toolbar-handler.dark .fastboard-toolbar-handler-image-stroke-color{stroke:var(--fastboard-color, #7b7e84)}.fastboard-toolbar-handler.dark .fastboard-toolbar-handler-image-fill-color{fill:var(--fastboard-color, #7b7e84)}.fastboard-toolbar:hover .fastboard-toolbar-handler svg,.fastboard-toolbar.collapsed .fastboard-toolbar-handler svg{opacity:1;transition:opacity .2s}.fastboard-toolbar-btn{appearance:none;cursor:pointer;margin:0;border:0;padding:4px;width:32px;height:32px;background-color:#0000;border-radius:4px;font-size:0;line-height:1;flex-shrink:0}.fastboard-toolbar-btn svg,.fastboard-toolbar-btn img{width:100%;height:100%;pointer-events:none}.fastboard-toolbar-btn:disabled{opacity:.5;cursor:not-allowed}.fastboard-toolbar-btn.light:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-toolbar-btn.dark:not(:disabled):hover{background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-slider{box-sizing:border-box;position:relative;width:100%;height:100%;display:flex;align-items:center}.fastboard-slider *{box-sizing:inherit}.fastboard-slider-track{appearance:none;background:rgba(0,0,0,0);border:0;border-radius:26px;flex:1;display:block;height:19px;margin:0;width:0;min-width:0;padding:0;transition:box-shadow .3s ease;cursor:pointer;touch-action:manipulation}.fastboard-slider-track::-webkit-slider-runnable-track{border:0;border-radius:2.5px;height:5px;transition:box-shadow .3s ease;user-select:none;background-color:#80808040;-webkit-user-select:none;background-image:linear-gradient(to right,currentColor var(--value, 0%),transparent var(--value, 0%))}.fastboard-slider-track::-webkit-slider-thumb{background:#fff;border:0;border-radius:100%;box-shadow:0 1px 1px #23292f26,0 0 0 1px #23292f33;width:13px;height:13px;position:relative;transition:all .2s ease;cursor:grab;appearance:none;margin-top:-4px}.fastboard-slider-track::-moz-range-track{border:0;border-radius:2.5px;height:5px;transition:box-shadow .3s ease;user-select:none;background-color:#80808040;-webkit-user-select:none}.fastboard-slider-track::-moz-range-thumb{appearance:none;background:#fff;border:0;border-radius:100%;box-shadow:0 1px 1px #23292f26,0 0 0 1px #23292f33;width:13px;height:13px;position:relative;transition:all .2s ease;cursor:grab}.fastboard-slider-track::-moz-range-progress{background:currentColor;border-radius:2.5px;height:5px}.fastboard-slider-track::-ms-track{border:0;border-radius:2.5px;height:5px;transition:box-shadow .3s ease;user-select:none;background-color:#80808040;-webkit-user-select:none;color:#0000}.fastboard-slider-track::-ms-thumb{appearance:none;background:#fff;border:0;border-radius:100%;box-shadow:0 1px 1px #23292f26,0 0 0 1px #23292f33;width:13px;height:13px;position:relative;transition:all .2s ease;cursor:grab;margin-top:0}.fastboard-slider-track::-ms-tooltip{display:none}.fastboard-slider-track::-moz-focus-outer{border:0}.fastboard-slider-track.grabbing::-webkit-slider-thumb{cursor:grabbing}.fastboard-slider-track.light{color:var(--fastboard-active-color, #3381ff)}.fastboard-slider-track.dark{color:var(--fastboard-active-color, #2867cc)}.fastboard-toolbar-contents{box-sizing:border-box;display:inline-flex;align-items:center;gap:4px;border:1px solid;border-radius:4px;font-size:14px;font-family:system-ui;pointer-events:auto;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);padding:2px 0;gap:0;flex-direction:column}.fastboard-toolbar-contents *{box-sizing:inherit}.fastboard-toolbar-contents.light{color:var(--fastboard-color, #5d6066);background-color:var(--fastboard-bg-color, rgba(255, 255, 255, .9));border-color:var(--fastboard-border-color, #e5e8f0)}.fastboard-toolbar-contents.dark{color:var(--fastboard-color, #7b7e84);background-color:var(--fastboard-bg-color, rgba(20, 24, 30, .9));border-color:var(--fastboard-border-color, #383b42)}.fastboard-toolbar-contents>.fastboard-toolbar-btn{margin:2px 4px}.fastboard-toolbar-btn-interactive{position:relative}.fastboard-toolbar-triangle{width:0px;height:0px;border-bottom:4px solid;border-left:4px solid rgba(0,0,0,0);position:absolute;bottom:0;right:0}.fastboard-toolbar-btn:focus+.fastboard-toolbar-triangle{opacity:0}.fastboard-toolbar-scrollable{padding:2px 4px;overflow:hidden;display:flex;flex-direction:column;gap:4px}.fastboard-toolbar-tooltip{display:inline-flex;align-items:center;gap:4px}.fastboard-toolbar-hotkey{display:inline-flex;margin-right:-4px;width:24px;height:24px;align-items:center;justify-content:center;background-color:#ffffff1a;border-radius:4px}.fastboard-toolbar-panel-wrapper{display:none}.fastboard-toolbar-panel{display:flex;flex-direction:column}.fastboard-toolbar-panel-divider{height:.5px;width:100%;margin:4px 0;background-color:#ffffff26}.fastboard-toolbar-colors,.fastboard-toolbar-shapes{display:grid;align-self:center;grid-template:repeat(2,1fr)/repeat(4,1fr);align-items:center;justify-items:center;gap:4px}.fastboard-toolbar-shape-btn,.fastboard-toolbar-color-btn{width:24px;height:24px;padding:0;display:inline-flex;align-items:center;justify-content:center}.fastboard-toolbar-color-btn{border:1px solid rgba(0,0,0,0)}.fastboard-toolbar-color-btn.light.is-active{border-color:var(--fastboard-active-color, #3381ff)}.fastboard-toolbar-color-btn.dark.is-active{border-color:var(--fastboard-active-color, #2867cc)}.fastboard-toolbar-color-item{display:inline-block;width:16px;height:16px;border-radius:4px;pointer-events:none}.fastboard-toolbar-panel.apps{display:grid;grid-template-columns:repeat(min(var(--n, 3),3),minmax(max-content,1fr));gap:4px}.fastboard-toolbar-app-btn{margin:0;border:0;border-radius:2px;padding:4px 6px;background-color:#0000;display:inline-flex;flex-direction:column;align-items:center;gap:4px;font-size:0}.fastboard-toolbar-app-btn:disabled{opacity:.8}.fastboard-toolbar-app-btn-icon{width:32px;height:32px;pointer-events:none}.fastboard-toolbar-app-btn-text{font-size:14px;line-height:1;max-width:100%;overflow:hidden;text-overflow:ellipsis}.fastboard-toolbar-app-btn.is-loading{cursor:progress}.fastboard-toolbar-app-btn.is-failed{cursor:not-allowed;opacity:.5}.fastboard-toolbar-app-btn:not(:disabled,.is-loading,.is-failed):hover.light{cursor:pointer;background-color:var(--fastboard-hover-bg-color, #ebf2ff)}.fastboard-toolbar-app-btn-text.light{color:var(--fastboard-color, #5d6066)}.fastboard-toolbar-app-btn:not(:disabled,.is-loading,.is-failed):hover.dark{cursor:pointer;background-color:var(--fastboard-hover-bg-color, #383b42)}.fastboard-toolbar-app-btn-text.dark{color:var(--fastboard-color, #7b7e84)}.fastboard-root{position:relative;width:100%;height:100%;overflow:hidden}.fastboard-view{position:absolute;top:0;left:0;width:100%;height:100%}.fastboard-left{display:flex;align-items:center;position:absolute;bottom:62px;top:8px;left:0;z-index:200;pointer-events:none}.fastboard-left .fastboard-toolbar{padding-left:16px}.fastboard-bottom-left,.fastboard-bottom,.fastboard-bottom-right{display:flex;gap:10px;position:absolute;bottom:8px;left:8px;padding:8px;z-index:200;pointer-events:none}.fastboard-bottom-right{left:auto;right:8px}.fastboard-bottom{right:8px}.fastboard-left.hidden *,.fastboard-bottom.hidden *,.fastboard-bottom-left.hidden *,.fastboard-bottom-right.hidden *{opacity:0;pointer-events:none}.fastboard-tip{font-family:inherit;color:#d5d9e0;background-color:#03060d}.fastboard-tip[data-placement^=right]>.tippy-arrow:before{top:4px;border-width:4px;border-right-color:#03060d}.fastboard-tip[data-placement^=top]>.tippy-arrow:before{left:4px;border-width:4px;border-top-color:#03060d}.fastboard-panel .tippy-content{padding:8px}.netless-whiteboard:focus-visible{outline:none}';

// inline-sass-stub:./src/style.scss
injectStyle(style_default);

// ../../node_modules/.pnpm/svelte@3.59.2/node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function not_equal(a, b) {
  return a != a ? b == b : a !== b;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name10) {
  return document.createElement(name10);
}
function svg_element(name10) {
  return document.createElementNS("http://www.w3.org/2000/svg", name10);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name10, toggle) {
  element2.classList[toggle ? "add" : "remove"](name10);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function construct_svelte_component(component, props) {
  return new component(props);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block6, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block6(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance59, create_fragment59, not_equal2, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal: not_equal2,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance59 ? instance59(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal2($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment59 ? create_fragment59($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};
var SvelteComponentDev = class extends SvelteComponent {
  constructor(options) {
    if (!options || !options.target && !options.$$inline) {
      throw new Error("'target' is a required option");
    }
    super();
  }
  $destroy() {
    super.$destroy();
    this.$destroy = () => {
      console.warn("Component was already destroyed");
    };
  }
  $capture_state() {
  }
  $inject_state() {
  }
};
var SvelteComponentTyped = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
  }
};

// src/components/Icon/Icon.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block(ctx) {
  let img;
  let img_src_value;
  let img_title_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[1]
      );
      attr(img, "title", img_title_value = /*title*/
      ctx[2] || /*alt*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*src*/
      1 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      2) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[1]
        );
      }
      if (dirty & /*title, alt*/
      6 && img_title_value !== (img_title_value = /*title*/
      ctx2[2] || /*alt*/
      ctx2[1])) {
        attr(img, "title", img_title_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { src = "" } = $$props;
  let { alt = "" } = $$props;
  let { title = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [src, alt, title, $$scope, slots];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { src: 0, alt: 1, title: 2 });
  }
};
var Icon_default = Icon;

// src/components/Icons/Apps.svelte
function create_fragment2(ctx) {
  let svg;
  let rect0;
  let rect1;
  let rect2;
  let rect3;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      rect2 = svg_element("rect");
      rect3 = svg_element("rect");
      attr(rect0, "x", "5");
      attr(rect0, "y", "5");
      attr(rect0, "width", "6");
      attr(rect0, "height", "6");
      attr(rect0, "stroke", "#5D6066");
      attr(rect0, "stroke-width", "1.25");
      attr(rect0, "stroke-linejoin", "round");
      attr(rect0, "class", "fastboard-icon-stroke-color");
      attr(rect1, "x", "13");
      attr(rect1, "y", "5");
      attr(rect1, "width", "6");
      attr(rect1, "height", "6");
      attr(rect1, "stroke", "#5D6066");
      attr(rect1, "stroke-width", "1.25");
      attr(rect1, "stroke-linejoin", "round");
      attr(rect1, "class", "fastboard-icon-stroke-color");
      attr(rect2, "x", "5");
      attr(rect2, "y", "13");
      attr(rect2, "width", "6");
      attr(rect2, "height", "6");
      attr(rect2, "stroke", "#5D6066");
      attr(rect2, "stroke-width", "1.25");
      attr(rect2, "stroke-linejoin", "round");
      attr(rect2, "class", "fastboard-icon-stroke-color");
      attr(rect3, "x", "13");
      attr(rect3, "y", "13");
      attr(rect3, "width", "6");
      attr(rect3, "height", "6");
      attr(rect3, "stroke", "#5D6066");
      attr(rect3, "stroke-width", "1.25");
      attr(rect3, "stroke-linejoin", "round");
      attr(rect3, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect0);
      append(svg, rect1);
      append(svg, rect2);
      append(svg, rect3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Apps = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Apps_default = Apps;

// src/components/Icons/Arrow.svelte
function create_fragment3(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M5 19 15.5 8.5M17 12l2-7-7 2 3.5 1.5L17 12Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Arrow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Arrow_default = Arrow;

// src/components/Icons/ArrowBolded.svelte
function create_fragment4(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "stroke-width", "1.75");
      attr(path0, "d", "M5 19 15.5 8.5");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "fill", "#5D6066");
      attr(path1, "d", "m17 12 2-7-7 2 3.5 1.5L17 12Z");
      attr(path1, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var ArrowBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { theme: 0, active: 1 });
  }
};
var ArrowBolded_default = ArrowBolded;

// src/components/Icons/Balloon.svelte
function create_fragment5(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M19 7a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h2v3l2.414-2.414A2 2 0 0 1 12.828 16H17a2 2 0 0 0 2-2V7Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Balloon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Balloon_default = Balloon;

// src/components/Icons/BalloonBolded.svelte
function create_fragment6(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "M19 7a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h2v3l2.414-2.414A2 2 0 0 1 12.828 16H17a2 2 0 0 0 2-2V7Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var BalloonBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { theme: 0, active: 1 });
  }
};
var BalloonBolded_default = BalloonBolded;

// src/components/Icons/Circle.svelte
function create_fragment7(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      attr(rect, "width", "16");
      attr(rect, "height", "16");
      attr(rect, "x", "4");
      attr(rect, "y", "4");
      attr(rect, "stroke", "#5D6066");
      attr(rect, "stroke-linejoin", "round");
      attr(rect, "stroke-width", "1.25");
      attr(rect, "rx", "8");
      attr(rect, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Circle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Circle_default = Circle;

// src/components/Icons/CircleBolded.svelte
function create_fragment8(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      attr(rect, "width", "16");
      attr(rect, "height", "16");
      attr(rect, "x", "4");
      attr(rect, "y", "4");
      attr(rect, "stroke", "#5D6066");
      attr(rect, "stroke-linejoin", "round");
      attr(rect, "stroke-width", "1.75");
      attr(rect, "rx", "8");
      attr(rect, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var CircleBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { theme: 0, active: 1 });
  }
};
var CircleBolded_default = CircleBolded;

// src/components/Icons/Clear.svelte
function create_fragment9(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      attr(path0, "d", "M19.6567 4.34323L13.9999 10.0001");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-width", "1.25");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "d", "M8.34296 10.0001C9.90506 8.43799 12.4377 8.43799 13.9998 10.0001V10.0001C15.5619 11.5622 15.5619 14.0948 13.9998 15.6569V15.6569L8.34296 10.0001V10.0001Z");
      attr(path1, "stroke", "#5D6066");
      attr(path1, "stroke-width", "1.25");
      attr(path1, "stroke-linejoin", "round");
      attr(path1, "class", "fastboard-icon-stroke-color");
      attr(path2, "d", "M8.34292 10.0001L13.9998 15.6569L11.5856 19.8996L4.10028 11.4143L8.34292 10.0001Z");
      attr(path2, "stroke", "#5D6066");
      attr(path2, "stroke-width", "1.25");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
      append(svg, path2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Clear = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Clear_default = Clear;

// src/components/Icons/Click.svelte
function create_fragment10(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M10 18 6 6l12 4-6 2-2 6Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Click = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Click_default = Click;

// src/components/Icons/ClickFilled.svelte
function create_fragment11(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "d", "M10 18 6 6l12 4-6 2-2 6Z");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var ClickFilled = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { theme: 0, active: 1 });
  }
};
var ClickFilled_default = ClickFilled;

// src/components/Icons/Diamond.svelte
function create_fragment12(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(path, "d", "M4.222 12 12 4.222 19.778 12 12 19.778z");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Diamond = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Diamond_default = Diamond;

// src/components/Icons/Down.svelte
function create_fragment13(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(path, "d", "m16 10-2 2-2 2-2-2-2-2");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Down_default = Down;

// src/components/Icons/Eraser.svelte
function create_fragment14(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M13.414 4.929a2 2 0 0 1 2.829 0l2.828 2.828a2 2 0 0 1 0 2.829L12 17.656a4 4 0 0 1-5.657 0L4.93 16.244a2 2 0 0 1 0-2.829l8.485-8.485ZM12 6.343 17.657 12m-1.414-7.071-2.829 2.828m4.243-1.414-2.829 2.829m4.243-1.415-2.828 2.829");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Eraser = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Eraser_default = Eraser;

// src/components/Icons/EraserFilled.svelte
function create_fragment15(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M16.242 4.929a2 2 0 0 0-2.828 0L4.93 13.414a2 2 0 0 0 0 2.829l1.414 1.414a4 4 0 0 0 5.657 0l5.215-5.215-5.657-5.657.884-.884 5.657 5.657.972-.972a2 2 0 0 0 0-2.829l-2.83-2.827Z");
      attr(path, "clip-rule", "evenodd");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var EraserFilled = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { theme: 0, active: 1 });
  }
};
var EraserFilled_default = EraserFilled;

// src/components/Icons/Left.svelte
function create_fragment16(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "m14 8-2 2-2 2 2 2 2 2");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Left_default = Left;

// src/components/Icons/Line.svelte
function create_fragment17(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M5 19 19 5");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Line = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Line_default = Line;

// src/components/Icons/LineBolded.svelte
function create_fragment18(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "M5 19 19 5");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var LineBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { theme: 0, active: 1 });
  }
};
var LineBolded_default = LineBolded;

// src/components/Icons/Minus.svelte
function create_fragment19(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M5 12h14");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Minus_default = Minus;

// src/components/Icons/Pencil.svelte
function create_fragment20(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "stroke-width", "1.25");
      attr(path0, "d", "M15.536 4.222a2 2 0 0 1 2.828 0l1.414 1.414a2 2 0 0 1 0 2.828l-9.9 9.9-4.95.707.708-4.95 9.9-9.9Z");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "stroke", "#5D6066");
      attr(path1, "stroke-width", "1.25");
      attr(path1, "d", "m14.121 5.636 4.243 4.243");
      attr(path1, "class", "fastboard-icon-stroke-color");
      attr(path2, "stroke", "#5D6066");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "stroke-width", "1.25");
      attr(path2, "d", "m16.243 7.757-5.657 5.657m-3.536.707v1.415h1.415v1.414h1.414");
      attr(path2, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
      append(svg, path2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Pencil = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Pencil_default = Pencil;

// src/components/Icons/PencilFilled.svelte
function create_fragment21(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M18.364 4.222a2 2 0 0 0-2.828 0l-9.9 9.9-.707 4.95 4.95-.708 8.132-8.132-.008-.007-.008-.008-.007-.008-.008-.007-.008-.008-.008-.008-.007-.008-.008-.008-.008-.007-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.009-.009-.008-.008-.008-.008-.008-.008-.008-.009-.009-.008-.008-.008-.009-.009-.008-.008-.008-.009-.009-.008-.008-.008-.009-.009-.008-.008-.009-.009-.008-.009-.009-.008-.009-.009-.008-.008-.009-.01-.009-.008-.008-.009-.01-.008-.008-.01-.009-.008-.008-.009-.01-.009-.008-.008-.01-.01-.008-.008-.009-.01-.009-.008-.009-.01-.009-.008-.009-.01-.009-.008-.009-.01-.01-.008-.008-.01-.01-.009-.009-.009-.009-.009-.009-.01-.01-.008-.008-.01-.01-.009-.009-.01-.01-.009-.009-.009-.009-.01-.01-.009-.009-.009-.01-.01-.008-.009-.01-.01-.01-.009-.009-.01-.01-.009-.009-.01-.01-.009-.009-.01-.01-.009-.01-.01-.009-.009-.01-.01-.009-.01-.01-.009-.01-.01-.01-.01-.009-.009-.01-.01-.01-.01-.009-.01-.01-.009-.01-.01-.01-.01-.01-.01-.009-.01-.01-.01-.01-.009-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.011-.01-.01-.011-.01-.01-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.01-.01-.01-.01-.011-.011-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.011-.01-.01-.011-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.01-.009-.01-.01-.009-.01-.01-.01-.01-.009-.01-.01-.009-.01-.01-.01-.01-.009-.009-.01-.01-.01-.01-.009-.009-.01-.01-.009-.01-.01-.009-.009-.01-.01-.009-.009-.01-.01-.009-.009-.01-.01-.009-.009-.01-.01-.009-.009-.009-.009-.01-.01-.009-.009-.009-.009-.01-.01-.009-.009-.009-.009-.01-.01-.008-.008-.01-.01-.009-.009-.009-.009-.01-.009-.008-.01-.01-.008-.008-.01-.01-.008-.009-.01-.009-.008-.009-.01-.009-.008-.008-.01-.01-.008-.008-.009-.01-.009-.008-.009-.009-.008-.009-.01-.008-.008-.01L14.777 7l-.008-.009-.01-.008-.008-.01-.008-.008-.01-.008-.008-.009-.008-.008-.009-.009-.008-.009-.009-.008-.008-.008-.009-.009-.008-.008-.008-.009-.009-.008-.008-.008-.008-.009-.009-.008-.008-.008-.008-.008-.008-.009-.008-.008-.009-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.008-.007-.008-.008-.007-.008-.008-.008-.008-.007-.008-.008-.007-.008-.008-.007-.008-.008-.007-.008-.008-.007-.007-.008-.008-.007-.007-.008-.008-.007-.007-.007-.008-.008-.007-.007-.007-.007-.007-.008-.008-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.007-.006-.007-.007-.007-.007-.006-.007-.007-.006-.007-.007-.006-.007-.007-.006-.006-.007-.007-.006-.006-.007-.007-.006-.006-.006-.007-.007-.006-.006-.006-.006-.006-.006-.007-.007-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.006-.005-.006-.006-.005-.006-.006-.006-.006-.005-.006-.006-.005-.005-.006-.006-.005-.006-.006-.005-.005-.005-.006-.006-.005-.005-.005-.005-.006-.006-.005-.005-.005-.005-.005-.005-.005-.005-.005-.005-.006-.005-.005-.005-.004-.005-.005-.005-.005-.005-.005-.005-.005-.004-.005-.005-.004-.005-.005-.004-.005-.005-.004-.004-.005-.005-.004-.004-.004-.005-.005-.004-.004-.004-.004-.005-.005-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.004-.003-.004-.004-.003-.004-.004-.003-.004-.004-.003-.004-.004-.003-.003-.003-.004-.004-.003-.003-.003-.003-.004-.004-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.003-.002-.003-.003-.002-.003-.003-.002-.002-.003-.003-.002-.003-.003-.002-.002-.002-.002-.003-.003-.002-.002-.002-.002-.002-.002-.002-.002-.002L13.779 6l-.002-.002-.002-.002-.002-.002-.002-.002-.002-.002-.001-.001.707-.708.002.002.001.002.002.002.002.002.002.001.002.002.002.002.002.002.002.003.002.002.002.002.003.002.002.003.002.002.003.002.002.003.003.002.002.003.003.003.003.002.002.003.003.003.003.003.003.003.003.003.003.002.003.004.003.003.003.003.003.003.004.003.003.003.003.004.004.003.003.004.004.003.003.004.004.003.003.004.004.004.004.003.004.004.003.004.004.004.004.004.004.004.004.004.004.004.004.004.004.004.005.004.004.004.004.005.005.004.004.004.004.005.005.004.004.005.005.004.004.005.005.005.005.004.005.005.004.005.005.005.005.005.005.004.005.005.005.005.005.005.005.005.005.006.005.005.005.005.006.005.005.006.005.005.006.005.005.006.006.005.005.006.006.005.005.006.006.005.006.006.005.006.006.005.006.006.006.006.005.006.006.006.006.006.006.006.006.006.006.006.006.006.007.006.006.006.006.006.006.007.007.006.006.006.006.007.007.006.006.007.007.006.006.007.007.006.006.007.007.006.006.007.007.007.007.006.007.007.006.007.007.007.007.007.007.007.007.006.007.007.007.007.007.007.007.008.007.007.007.007.007.007.008.007.007.007.007.008.007.007.008.007.007.008.008.007.007.008.008.007.007.008.008.007.007.008.008.007.007.008.008.008.008.007.007.008.008.008.008.007.008.008.008.008.008.008.007.008.008.008.008.008.008.008.008.008.008.008.008.008.008.008.009.008.008.008.008.008.008.009.008.008.009.008.008.009.008.008.009.008.008.009.009.008.008.008.008.009.009.008.008.009.009.008.008.009.01.009.008.008.008.009.009.009.009.008.008.009.01.009.008.008.009.01.009.008.008.009.01.009.008.009.009.008.009.01.009.008.009.01.009.008.009.01.009.008.009.01.009.009.01.009.008.009.01.009.009.01.009.008.009.01.01.009.008.009.01.01.01.009.008.009.01.01.01.009.008.009.01.01.01.009.009.01.01.009.009.01.01.009.009.01.01.009.009.01.01.009.009.01.01.009.01.01.009.01.01.009.009.01.01.01.01.009.01.01.009.01.01.01.01.009.01.01.009.01.01.01.01.01.01.009.01.01.01.01.009.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.011.01.01.01.01.011.01.01.01.01.011.01.01.01.01.011.01.01.011.01.01.011.01.01.011.01.01.01.01.011.01.01.011.01.01.011.011.01.01.01.01.011.011.01.01.01.01.011.011.01.01.011.011.01.01.01.01.011.011.01.01.011.011.01.01.011.01.01.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.011.01.01.011.01.01.011.01.01.011.011.01.01.011.011.01.01.011.01.01.011.01.01.011.011.01.01.01.01.011.011.01.01.011.01.01.011.01.01.011.01.01.011.01.01.011.01.01.011.01.01.01.01.011.01.01.011.01.01.01.01.011.01.01.011.01.01.01.01.01.01.011.01.01.01.01.011.01.01.01.01.01.01.011.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.01.009.01.01.009.01.01.01.01.009.009.01.01.01.01.009.01.01.009.01.01.009.009.01.01.01.01.009.009.01.01.009.009.01.01.009.009.01.01.009.009.01.009.009.01.009.009.01.01.009.008.009.01.01.01.009.008.009.01.01.009.008.01.01.008.009.01.01.009.008.009.01.009.008.01.01.008.009.01.009.008.009.01.009.008.009.01.009.008.009.009.009.009.008.009.01.009.008.008.009.01.009.008.009.009.008.008.01.01.008.008.008.008.01.01.008.008.008.008.009.009.008.008.009.009.008.008.009.009.008.008.009.009.008.008.009.008.008.009.008.008.008.008.009.008.008.009.008.008.008.008.008.008.009.008.008.008.008.008.008.008.008.008.008.008.008.008.008.008.008.008.007.008.008.008.008.007.008.008.007.008.008.007.008.008.008.008.007 1.06-1.06a2 2 0 0 0 0-2.829l-1.414-1.414Zm-9.9 10.689c.346 0 .626.28.626.625v.789h.789v1.25H8.465a.625.625 0 0 1-.625-.625v-.79h-.79a.625.625 0 0 1-.625-.624V14.12h1.25v.79h.79Z");
      attr(path, "clip-rule", "evenodd");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var PencilFilled = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, { theme: 0, active: 1 });
  }
};
var PencilFilled_default = PencilFilled;

// src/components/Icons/Plus.svelte
function create_fragment22(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M5 12h14m-7-7v14");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Plus_default = Plus;

// src/components/Icons/Rectangle.svelte
function create_fragment23(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M5 5h14v14H5z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Rectangle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Rectangle_default = Rectangle;

// src/components/Icons/RectangleBolded.svelte
function create_fragment24(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "M5 5h14v14H5z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var RectangleBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, { theme: 0, active: 1 });
  }
};
var RectangleBolded_default = RectangleBolded;

// src/components/Icons/Redo.svelte
function create_fragment25(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "#5D6066");
      attr(path0, "d", "m14 5 6 4-6 4 2-4-2-4Z");
      attr(path0, "class", "fastboard-icon-fill-color");
      attr(path1, "fill", "#5D6066");
      attr(path1, "d", "M8 8.375h8v1.25H8v-1.25Zm0 8h12v1.25H8v-1.25ZM3.375 13A4.625 4.625 0 0 1 8 8.375v1.25A3.375 3.375 0 0 0 4.625 13h-1.25Zm1.25 0A3.375 3.375 0 0 0 8 16.375v1.25A4.625 4.625 0 0 1 3.375 13h1.25Z");
      attr(path1, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Redo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Redo_default = Redo;

// src/components/Icons/Reset.svelte
function create_fragment26(ctx) {
  let svg;
  let circle0;
  let path;
  let circle1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      path = svg_element("path");
      circle1 = svg_element("circle");
      attr(circle0, "cx", "12");
      attr(circle0, "cy", "12");
      attr(circle0, "fill", "#5D6066");
      attr(circle0, "r", "2");
      attr(circle0, "class", "fastboard-icon-fill-color");
      attr(path, "d", "M12 3v4m0 10v4m9-9h-4M7 12H3");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(circle1, "cx", "12");
      attr(circle1, "cy", "12");
      attr(circle1, "r", "7");
      attr(circle1, "stroke", "#5D6066");
      attr(circle1, "stroke-linejoin", "round");
      attr(circle1, "stroke-width", "1.25");
      attr(circle1, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle0);
      append(svg, path);
      append(svg, circle1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Reset = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Reset_default = Reset;

// src/components/Icons/Rhombus.svelte
function create_fragment27(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M3.515 12 12 3.514 20.485 12 12 20.485z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Rhombus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Rhombus_default = Rhombus;

// src/components/Icons/RhombusBolded.svelte
function create_fragment28(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "M3.515 12 12 3.514 20.485 12 12 20.485z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var RhombusBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, { theme: 0, active: 1 });
  }
};
var RhombusBolded_default = RhombusBolded;

// src/components/Icons/Right.svelte
function create_fragment29(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "m10 8 2 2 2 2-2 2-2 2");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Right_default = Right;

// src/components/Icons/Selector.svelte
function create_fragment30(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-dasharray", "1.25 1.25");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "stroke-width", "1.25");
      attr(path0, "d", "M18 11V4H4v14h7");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "stroke", "#5D6066");
      attr(path1, "stroke-linejoin", "round");
      attr(path1, "stroke-width", "1.25");
      attr(path1, "d", "m15 20-2-7 7 2-3.5 1.5L15 20Z");
      attr(path1, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Selector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Selector_default = Selector;

// src/components/Icons/SelectorFilled.svelte
function create_fragment31(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-dasharray", "1.25 1.25");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "stroke-width", "1.25");
      attr(path0, "d", "M18 11V4H4v14h7");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "fill", "#5D6066");
      attr(path1, "d", "m15 20-2-7 7 2-3.5 1.5L15 20Z");
      attr(path1, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var SelectorFilled = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, { theme: 0, active: 1 });
  }
};
var SelectorFilled_default = SelectorFilled;

// src/components/Icons/SpeechBalloon.svelte
function create_fragment32(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M17 4.5c.414 0 .79.168 1.06.44.272.27.44.646.44 1.06v9c0 .414-.168.79-.44 1.06a1.49 1.49 0 0 1-1.06.44h-4.207l-2.715 2.715-1.81-2.715H7a1.49 1.49 0 0 1-1.06-.44A1.495 1.495 0 0 1 5.5 15V6c0-.414.168-.79.44-1.06A1.49 1.49 0 0 1 7 4.5Z");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var SpeechBalloon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, { theme: 0, active: 1 });
  }
};
var SpeechBalloon_default = SpeechBalloon;

// src/components/Icons/Star.svelte
function create_fragment33(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "m12 4 1.88 5.411 5.728.117-4.565 3.46 1.66 5.484L12 15.2l-4.702 3.272 1.659-5.483-4.565-3.461 5.727-.117L12 4Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Star = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Star_default = Star;

// src/components/Icons/StarBolded.svelte
function create_fragment34(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "m12 4 1.88 5.411 5.728.117-4.565 3.46 1.66 5.484L12 15.2l-4.702 3.272 1.659-5.483-4.565-3.461 5.727-.117L12 4Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var StarBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, { theme: 0, active: 1 });
  }
};
var StarBolded_default = StarBolded;

// src/components/Icons/Text.svelte
function create_fragment35(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "M6 7V5h5m7 2V5h-5M8 19h3m5 0h-3m-2 0V5m0 14h2M11 5h2m0 0v14");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Text = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Text_default = Text;

// src/components/Icons/TextFilled.svelte
function create_fragment36(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "#3381FF");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "d", "M11.5 5.5h1v13h-1z");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(path1, "stroke", "#5D6066");
      attr(path1, "stroke-linejoin", "round");
      attr(path1, "stroke-width", "1.25");
      attr(path1, "d", "M6 7V5h5m7 2V5h-5M8 19h3m5 0h-3m-2 0V5m0 14h2M11 5h2m0 0v14");
      attr(path1, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var TextFilled = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, { theme: 0, active: 1 });
  }
};
var TextFilled_default = TextFilled;

// src/components/Icons/Triangle.svelte
function create_fragment37(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "d", "m12 5 8 14H4l8-14Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Triangle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Triangle_default = Triangle;

// src/components/Icons/TriangleBolded.svelte
function create_fragment38(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.75");
      attr(path, "d", "m12 5 8 14H4l8-14Z");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var TriangleBolded = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, { theme: 0, active: 1 });
  }
};
var TriangleBolded_default = TriangleBolded;

// src/components/Icons/Undo.svelte
function create_fragment39(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "#5D6066");
      attr(path0, "d", "M10 5 4 9l6 4-2-4 2-4Z");
      attr(path0, "class", "fastboard-icon-fill-color");
      attr(path1, "fill", "#5D6066");
      attr(path1, "d", "M16 8.375H8v1.25h8v-1.25Zm0 8H4v1.25h12v-1.25ZM20.625 13A4.625 4.625 0 0 0 16 8.375v1.25A3.375 3.375 0 0 1 19.375 13h1.25Zm-1.25 0A3.375 3.375 0 0 1 16 16.375v1.25A4.625 4.625 0 0 0 20.625 13h-1.25Z");
      attr(path1, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Undo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Undo_default = Undo;

// src/components/Icons/Up.svelte
function create_fragment40(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "m16 14-2-2-2-2-2 2-2 2");
      attr(path, "stroke", "#5D6066");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "1.25");
      attr(path, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Up_default = Up;

// src/components/Icons/WhiteboardAdd.svelte
function create_fragment41(ctx) {
  let svg;
  let path0;
  let rect;
  let path1;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      rect = svg_element("rect");
      path1 = svg_element("path");
      attr(path0, "d", "M4 20h16M4 6h16");
      attr(path0, "stroke", "#5D6066");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "stroke-width", "1.25");
      attr(path0, "class", "fastboard-icon-stroke-color");
      attr(rect, "height", "10");
      attr(rect, "rx", "1");
      attr(rect, "stroke", "#5D6066");
      attr(rect, "stroke-linejoin", "round");
      attr(rect, "stroke-width", "1.25");
      attr(rect, "width", "14");
      attr(rect, "x", "5");
      attr(rect, "y", "8");
      attr(rect, "class", "fastboard-icon-stroke-color");
      attr(path1, "d", "M12 4v2m-3 7h6m-3-3v6");
      attr(path1, "stroke", "#5D6066");
      attr(path1, "stroke-linejoin", "round");
      attr(path1, "stroke-width", "1.25");
      attr(path1, "class", "fastboard-icon-stroke-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, rect);
      append(svg, path1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var WhiteboardAdd = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, { theme: 0, active: 1 });
  }
};
var WhiteboardAdd_default = WhiteboardAdd;

// src/components/Icons/Play.svelte
function create_fragment42(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "d", "M8 5.14v14l11-7l-11-7z");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Play = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Play_default = Play;

// src/components/Icons/Pause.svelte
function create_fragment43(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "d", "M14 19h4V5h-4M6 19h4V5H6v14z");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Pause = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Pause_default = Pause;

// src/components/Icons/Loading.svelte
function create_fragment44(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#5D6066");
      attr(path, "d", "M12 4V2A10 10 0 0 0 2 12h2a8 8 0 0 1 8-8z");
      attr(path, "class", "fastboard-icon-fill-color");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", svg_class_value = "fastboard-icon " + /*theme*/
      ctx[0]);
      toggle_class(
        svg,
        "is-active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      1 && svg_class_value !== (svg_class_value = "fastboard-icon " + /*theme*/
      ctx2[0])) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*theme, active*/
      3) {
        toggle_class(
          svg,
          "is-active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { theme = "light" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [theme, active];
}
var Loading = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, { theme: 0, active: 1 });
  }
};
var Loading_default = Loading;

// src/components/Icons/index.ts
var Icons = {
  Apps: Apps_default,
  Arrow: Arrow_default,
  ArrowBolded: ArrowBolded_default,
  Balloon: Balloon_default,
  BalloonBolded: BalloonBolded_default,
  Circle: Circle_default,
  CircleBolded: CircleBolded_default,
  Clear: Clear_default,
  Click: Click_default,
  ClickFilled: ClickFilled_default,
  Diamond: Diamond_default,
  Down: Down_default,
  Eraser: Eraser_default,
  EraserFilled: EraserFilled_default,
  Left: Left_default,
  Line: Line_default,
  LineBolded: LineBolded_default,
  Minus: Minus_default,
  Pencil: Pencil_default,
  PencilFilled: PencilFilled_default,
  Plus: Plus_default,
  Rectangle: Rectangle_default,
  RectangleBolded: RectangleBolded_default,
  Redo: Redo_default,
  Reset: Reset_default,
  Rhombus: Rhombus_default,
  RhombusBolded: RhombusBolded_default,
  Right: Right_default,
  Selector: Selector_default,
  SelectorFilled: SelectorFilled_default,
  SpeechBalloon: SpeechBalloon_default,
  Star: Star_default,
  StarBolded: StarBolded_default,
  Text: Text_default,
  TextFilled: TextFilled_default,
  Triangle: Triangle_default,
  TriangleBolded: TriangleBolded_default,
  Undo: Undo_default,
  Up: Up_default,
  WhiteboardAdd: WhiteboardAdd_default,
  Play: Play_default,
  Pause: Pause_default,
  Loading: Loading_default
};
var Icons_default = Icons;
if (typeof window !== "undefined") {
  Tippy.setDefaultProps({
    delay: [1e3, 400],
    duration: 300,
    offset: [0, 11],
    theme: "dark",
    plugins: [
      {
        name: "className",
        defaultValue: "",
        fn(instance59) {
          function add() {
            const el = instance59.popper.firstElementChild;
            if (el) {
              el.classList.add("fastboard-tip");
              const extra = (instance59.props.className || "").trim();
              if (extra) {
                el.classList.add(extra);
              }
            }
          }
          function remove() {
            var _a;
            (_a = instance59.popper.firstElementChild) == null ? void 0 : _a.classList.remove("fastboard-tip");
          }
          return {
            onCreate: add,
            onBeforeUpdate: remove,
            onAfterUpdate: add
          };
        }
      }
    ]
  });
}
var tippy = function(node, props) {
  const instance59 = Tippy(node, props);
  return {
    update(props2) {
      instance59.setProps(props2);
    },
    destroy() {
      instance59.destroy();
    }
  };
};
function tippy_hide_all() {
  document.querySelectorAll("[data-tippy-root]").forEach((el) => {
    const instance59 = el._tippy;
    if (instance59)
      instance59.hide();
  });
}
var tippy_menu = {
  delay: 0,
  duration: [50, 300],
  placement: "right-start",
  interactive: true,
  trigger: "click"
};

// src/components/Button/Button.svelte
function create_else_block_1(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "class", button_class_value = /*name*/
      ctx[1] + "-btn " + /*className*/
      ctx[0] + " " + /*theme*/
      ctx[2]);
      button.disabled = /*disabled*/
      ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name, className, theme*/
      7 && button_class_value !== (button_class_value = /*name*/
      ctx2[1] + "-btn " + /*className*/
      ctx2[0] + " " + /*theme*/
      ctx2[2])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        button.disabled = /*disabled*/
        ctx2[3];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*menu*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block2(ctx) {
  let button;
  let button_class_value;
  let tippy_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "class", button_class_value = /*name*/
      ctx[1] + "-btn " + /*className*/
      ctx[0] + " " + /*theme*/
      ctx[2]);
      button.disabled = /*disabled*/
      ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler_1*/
            ctx[11]
          ),
          action_destroyer(tippy_action = tippy.call(null, button, {
            content: (
              /*content*/
              ctx[4]
            ),
            placement: (
              /*placement*/
              ctx[5]
            ),
            className: (
              /*className*/
              ctx[0]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name, className, theme*/
      7 && button_class_value !== (button_class_value = /*name*/
      ctx2[1] + "-btn " + /*className*/
      ctx2[0] + " " + /*theme*/
      ctx2[2])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        button.disabled = /*disabled*/
        ctx2[3];
      }
      if (tippy_action && is_function(tippy_action.update) && dirty & /*content, placement, className*/
      49)
        tippy_action.update.call(null, {
          content: (
            /*content*/
            ctx2[4]
          ),
          placement: (
            /*placement*/
            ctx2[5]
          ),
          className: (
            /*className*/
            ctx2[0]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let span1;
  let button;
  let button_class_value;
  let tippy_action;
  let t;
  let span0;
  let span0_class_value;
  let span1_class_value;
  let tippy_action_1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      span1 = element("span");
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      span0 = element("span");
      attr(button, "class", button_class_value = /*name*/
      ctx[1] + "-btn " + /*className*/
      ctx[0] + " " + /*theme*/
      ctx[2]);
      button.disabled = /*disabled*/
      ctx[3];
      attr(span0, "class", span0_class_value = /*name*/
      ctx[1] + "-triangle");
      attr(span1, "class", span1_class_value = /*name*/
      ctx[1] + "-btn-interactive " + /*theme*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append(span1, t);
      append(span1, span0);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          action_destroyer(tippy_action = tippy.call(null, button, __spreadProps(__spreadValues({
            content: (
              /*menu*/
              ctx[6]
            )
          }, tippy_menu), {
            placement: (
              /*menu_placement*/
              ctx[7]
            ),
            appendTo: document.body,
            theme: (
              /*theme*/
              ctx[2]
            ),
            className: "fastboard-panel"
          }))),
          action_destroyer(tippy_action_1 = tippy.call(null, span1, {
            content: (
              /*content*/
              ctx[4]
            ),
            placement: (
              /*placement*/
              ctx[5]
            ),
            className: (
              /*className*/
              ctx[0]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name, className, theme*/
      7 && button_class_value !== (button_class_value = /*name*/
      ctx2[1] + "-btn " + /*className*/
      ctx2[0] + " " + /*theme*/
      ctx2[2])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        button.disabled = /*disabled*/
        ctx2[3];
      }
      if (tippy_action && is_function(tippy_action.update) && dirty & /*menu, menu_placement, theme*/
      196)
        tippy_action.update.call(null, __spreadProps(__spreadValues({
          content: (
            /*menu*/
            ctx2[6]
          )
        }, tippy_menu), {
          placement: (
            /*menu_placement*/
            ctx2[7]
          ),
          appendTo: document.body,
          theme: (
            /*theme*/
            ctx2[2]
          ),
          className: "fastboard-panel"
        }));
      if (!current || dirty & /*name*/
      2 && span0_class_value !== (span0_class_value = /*name*/
      ctx2[1] + "-triangle")) {
        attr(span0, "class", span0_class_value);
      }
      if (!current || dirty & /*name, theme*/
      6 && span1_class_value !== (span1_class_value = /*name*/
      ctx2[1] + "-btn-interactive " + /*theme*/
      ctx2[2])) {
        attr(span1, "class", span1_class_value);
      }
      if (tippy_action_1 && is_function(tippy_action_1.update) && dirty & /*content, placement, className*/
      49)
        tippy_action_1.update.call(null, {
          content: (
            /*content*/
            ctx2[4]
          ),
          placement: (
            /*placement*/
            ctx2[5]
          ),
          className: (
            /*className*/
            ctx2[0]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment45(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*content*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = "" } = $$props;
  let { name: name10 = "fastboard-ui" } = $$props;
  let { theme = "light" } = $$props;
  let { disabled = false } = $$props;
  let { content = "" } = $$props;
  let { placement = "top" } = $$props;
  let { menu = "" } = $$props;
  let { menu_placement = "right-start" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("name" in $$props2)
      $$invalidate(1, name10 = $$props2.name);
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("content" in $$props2)
      $$invalidate(4, content = $$props2.content);
    if ("placement" in $$props2)
      $$invalidate(5, placement = $$props2.placement);
    if ("menu" in $$props2)
      $$invalidate(6, menu = $$props2.menu);
    if ("menu_placement" in $$props2)
      $$invalidate(7, menu_placement = $$props2.menu_placement);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    className,
    name10,
    theme,
    disabled,
    content,
    placement,
    menu,
    menu_placement,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      class: 0,
      name: 1,
      theme: 2,
      disabled: 3,
      content: 4,
      placement: 5,
      menu: 6,
      menu_placement: 7
    });
  }
};
var Button_default = Button;

// src/components/RedoUndo/RedoUndo.svelte
function create_default_slot_3(ctx) {
  let icons_undo;
  let current;
  icons_undo = new Icons_default.Undo({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_undo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_undo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_undo_changes = {};
      if (dirty & /*theme*/
      1)
        icons_undo_changes.theme = /*theme*/
        ctx2[0];
      icons_undo.$set(icons_undo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_undo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_undo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_undo, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.undo[
          /*type*/
          ctx[2]
        ]
      ),
      alt: "[undo]",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      6)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.undo[
          /*type*/
          ctx2[2]
        ];
      if (dirty & /*$$scope, theme*/
      131073) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let icons_redo;
  let current;
  icons_redo = new Icons_default.Redo({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_redo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_redo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_redo_changes = {};
      if (dirty & /*theme*/
      1)
        icons_redo_changes.theme = /*theme*/
        ctx2[0];
      icons_redo.$set(icons_redo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_redo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_redo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_redo, detaching);
    }
  };
}
function create_default_slot(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.redo[
          /*type*/
          ctx[2]
        ]
      ),
      alt: "[redo]",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      6)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.redo[
          /*type*/
          ctx2[2]
        ];
      if (dirty & /*$$scope, theme*/
      131073) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment46(ctx) {
  let div;
  let button0;
  let t_1;
  let button1;
  let div_class_value;
  let current;
  button0 = new Button_default({
    props: {
      class: "undo",
      name,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*undo_disabled*/
        ctx[4]
      ),
      content: (
        /*t*/
        ctx[7].undo
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*undo*/
    ctx[9]
  );
  button1 = new Button_default({
    props: {
      class: "redo",
      name,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*redo_disabled*/
        ctx[3]
      ),
      content: (
        /*t*/
        ctx[7].redo
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*redo*/
    ctx[10]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t_1 = space();
      create_component(button1.$$.fragment);
      attr(div, "class", div_class_value = name + " " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t_1);
      mount_component(button1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*theme*/
      1)
        button0_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*undo_disabled*/
      16)
        button0_changes.disabled = /*undo_disabled*/
        ctx2[4];
      if (dirty & /*t*/
      128)
        button0_changes.content = /*t*/
        ctx2[7].undo;
      if (dirty & /*$$scope, icons, type, theme*/
      131079) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*theme*/
      1)
        button1_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*redo_disabled*/
      8)
        button1_changes.disabled = /*redo_disabled*/
        ctx2[3];
      if (dirty & /*t*/
      128)
        button1_changes.content = /*t*/
        ctx2[7].redo;
      if (dirty & /*$$scope, icons, type, theme*/
      131079) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      if (!current || dirty & /*theme*/
      1 && div_class_value !== (div_class_value = name + " " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
var i18n = {
  en: { redo: "Redo", undo: "Undo" },
  "zh-CN": {
    redo: "\u91CD\u505A",
    undo: "\u64A4\u9500"
  }
};
var name = "fastboard-redo-undo";
function instance46($$self, $$props, $$invalidate) {
  let writable2;
  let disabled;
  let t;
  let undoSteps;
  let redoSteps;
  let undo_disabled;
  let redo_disabled;
  let $redoSteps, $$unsubscribe_redoSteps = noop, $$subscribe_redoSteps = () => ($$unsubscribe_redoSteps(), $$unsubscribe_redoSteps = subscribe(redoSteps, ($$value) => $$invalidate(14, $redoSteps = $$value)), redoSteps);
  let $undoSteps, $$unsubscribe_undoSteps = noop, $$subscribe_undoSteps = () => ($$unsubscribe_undoSteps(), $$unsubscribe_undoSteps = subscribe(undoSteps, ($$value) => $$invalidate(15, $undoSteps = $$value)), undoSteps);
  let $writable, $$unsubscribe_writable = noop, $$subscribe_writable = () => ($$unsubscribe_writable(), $$unsubscribe_writable = subscribe(writable2, ($$value) => $$invalidate(16, $writable = $$value)), writable2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_redoSteps());
  $$self.$$.on_destroy.push(() => $$unsubscribe_undoSteps());
  $$self.$$.on_destroy.push(() => $$unsubscribe_writable());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { icons = void 0 } = $$props;
  let type;
  function undo() {
    app == null ? void 0 : app.undo();
  }
  function redo() {
    app == null ? void 0 : app.redo();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(11, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(12, language = $$props2.language);
    if ("icons" in $$props2)
      $$invalidate(1, icons = $$props2.icons);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    2048) {
      $$subscribe_writable($$invalidate(8, writable2 = app == null ? void 0 : app.writable));
    }
    if ($$self.$$.dirty & /*$writable*/
    65536) {
      $$invalidate(13, disabled = !$writable);
    }
    if ($$self.$$.dirty & /*language*/
    4096) {
      $$invalidate(7, t = i18n[language]);
    }
    if ($$self.$$.dirty & /*disabled*/
    8192) {
      $$invalidate(2, type = disabled ? "disable" : "normal");
    }
    if ($$self.$$.dirty & /*app*/
    2048) {
      $$subscribe_undoSteps($$invalidate(6, undoSteps = app == null ? void 0 : app.canUndoSteps));
    }
    if ($$self.$$.dirty & /*app*/
    2048) {
      $$subscribe_redoSteps($$invalidate(5, redoSteps = app == null ? void 0 : app.canRedoSteps));
    }
    if ($$self.$$.dirty & /*disabled, $undoSteps*/
    40960) {
      $$invalidate(4, undo_disabled = disabled || !$undoSteps);
    }
    if ($$self.$$.dirty & /*disabled, $redoSteps*/
    24576) {
      $$invalidate(3, redo_disabled = disabled || !$redoSteps);
    }
  };
  return [
    theme,
    icons,
    type,
    redo_disabled,
    undo_disabled,
    redoSteps,
    undoSteps,
    t,
    writable2,
    undo,
    redo,
    app,
    language,
    disabled,
    $redoSteps,
    $undoSteps,
    $writable
  ];
}
var RedoUndo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      app: 11,
      theme: 0,
      language: 12,
      icons: 1
    });
  }
};
var RedoUndo_default = RedoUndo;

// src/components/PageControl/PageControl.svelte
function create_default_slot_5(ctx) {
  let icons_left;
  let current;
  icons_left = new Icons_default.Left({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_left.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_left, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_left_changes = {};
      if (dirty & /*theme*/
      1)
        icons_left_changes.theme = /*theme*/
        ctx2[0];
      icons_left.$set(icons_left_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_left.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_left.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_left, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.prev[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[prev]",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.prev[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      262145) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_else_block3(ctx) {
  let t0_value = (
    /*$index*/
    ctx[4] + 1 + ""
  );
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("/");
      t2 = text(
        /*$length*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$index*/
      16 && t0_value !== (t0_value = /*$index*/
      ctx2[4] + 1 + ""))
        set_data(t0, t0_value);
      if (dirty & /*$length*/
      8)
        set_data(
          t2,
          /*$length*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
    }
  };
}
function create_if_block3(ctx) {
  let t_1;
  return {
    c() {
      t_1 = text("\u2026");
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_default_slot_32(ctx) {
  let icons_right;
  let current;
  icons_right = new Icons_default.Right({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_right.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_right, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_right_changes = {};
      if (dirty & /*theme*/
      1)
        icons_right_changes.theme = /*theme*/
        ctx2[0];
      icons_right.$set(icons_right_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_right.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_right.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_right, detaching);
    }
  };
}
function create_default_slot_22(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.next[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[next]",
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.next[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      262145) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let icons_whiteboardadd;
  let current;
  icons_whiteboardadd = new Icons_default.WhiteboardAdd({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_whiteboardadd.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_whiteboardadd, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_whiteboardadd_changes = {};
      if (dirty & /*theme*/
      1)
        icons_whiteboardadd_changes.theme = /*theme*/
        ctx2[0];
      icons_whiteboardadd.$set(icons_whiteboardadd_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_whiteboardadd.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_whiteboardadd.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_whiteboardadd, detaching);
    }
  };
}
function create_default_slot2(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.add[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[add]",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.add[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      262145) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let div;
  let button0;
  let t0;
  let span;
  let span_class_value;
  let t1;
  let button1;
  let t2;
  let button2;
  let div_class_value;
  let current;
  button0 = new Button_default({
    props: {
      class: "prev",
      name: name2,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*prev_disabled*/
        ctx[7]
      ),
      content: (
        /*t*/
        ctx[10].prev
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*prevPage*/
    ctx[12]
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*$index*/
      ctx2[4] == null || /*$length*/
      ctx2[3] == null
    )
      return create_if_block3;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  button1 = new Button_default({
    props: {
      class: "next",
      name: name2,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*next_disabled*/
        ctx[6]
      ),
      content: (
        /*t*/
        ctx[10].next
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*nextPage*/
    ctx[13]
  );
  button2 = new Button_default({
    props: {
      class: "add",
      name: name2,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[2]
      ),
      content: (
        /*t*/
        ctx[10].add
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*addPage*/
    ctx[14]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      span = element("span");
      if_block.c();
      t1 = space();
      create_component(button1.$$.fragment);
      t2 = space();
      create_component(button2.$$.fragment);
      attr(span, "class", span_class_value = name2 + "-text " + /*theme*/
      ctx[0]);
      attr(div, "class", div_class_value = name2 + " " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t0);
      append(div, span);
      if_block.m(span, null);
      append(div, t1);
      mount_component(button1, div, null);
      append(div, t2);
      mount_component(button2, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*theme*/
      1)
        button0_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*prev_disabled*/
      128)
        button0_changes.disabled = /*prev_disabled*/
        ctx2[7];
      if (dirty & /*t*/
      1024)
        button0_changes.content = /*t*/
        ctx2[10].prev;
      if (dirty & /*$$scope, icons, type, theme*/
      262179) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
      if (!current || dirty & /*theme*/
      1 && span_class_value !== (span_class_value = name2 + "-text " + /*theme*/
      ctx2[0])) {
        attr(span, "class", span_class_value);
      }
      const button1_changes = {};
      if (dirty & /*theme*/
      1)
        button1_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*next_disabled*/
      64)
        button1_changes.disabled = /*next_disabled*/
        ctx2[6];
      if (dirty & /*t*/
      1024)
        button1_changes.content = /*t*/
        ctx2[10].next;
      if (dirty & /*$$scope, icons, type, theme*/
      262179) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*theme*/
      1)
        button2_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*disabled*/
      4)
        button2_changes.disabled = /*disabled*/
        ctx2[2];
      if (dirty & /*t*/
      1024)
        button2_changes.content = /*t*/
        ctx2[10].add;
      if (dirty & /*$$scope, icons, type, theme*/
      262179) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      if (!current || dirty & /*theme*/
      1 && div_class_value !== (div_class_value = name2 + " " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button0);
      if_block.d();
      destroy_component(button1);
      destroy_component(button2);
    }
  };
}
var i18n2 = {
  en: {
    prev: "Prev Page",
    next: "Next Page",
    add: "Add Page"
  },
  "zh-CN": {
    prev: "\u4E0A\u4E00\u9875",
    next: "\u4E0B\u4E00\u9875",
    add: "\u6DFB\u52A0\u9875\u9762"
  }
};
var name2 = "fastboard-page-control";
function instance47($$self, $$props, $$invalidate) {
  let writable2;
  let disabled;
  let t;
  let index;
  let length;
  let prev_disabled;
  let next_disabled;
  let $length, $$unsubscribe_length = noop, $$subscribe_length = () => ($$unsubscribe_length(), $$unsubscribe_length = subscribe(length, ($$value) => $$invalidate(3, $length = $$value)), length);
  let $index, $$unsubscribe_index = noop, $$subscribe_index = () => ($$unsubscribe_index(), $$unsubscribe_index = subscribe(index, ($$value) => $$invalidate(4, $index = $$value)), index);
  let $writable, $$unsubscribe_writable = noop, $$subscribe_writable = () => ($$unsubscribe_writable(), $$unsubscribe_writable = subscribe(writable2, ($$value) => $$invalidate(17, $writable = $$value)), writable2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_length());
  $$self.$$.on_destroy.push(() => $$unsubscribe_index());
  $$self.$$.on_destroy.push(() => $$unsubscribe_writable());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { icons = void 0 } = $$props;
  let type;
  function prevPage() {
    app == null ? void 0 : app.prevPage();
  }
  function nextPage() {
    app == null ? void 0 : app.nextPage();
  }
  function addPage() {
    app == null ? void 0 : app.addPage({ after: true });
    app == null ? void 0 : app.nextPage();
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(15, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(16, language = $$props2.language);
    if ("icons" in $$props2)
      $$invalidate(1, icons = $$props2.icons);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    32768) {
      $$subscribe_writable($$invalidate(11, writable2 = app == null ? void 0 : app.writable));
    }
    if ($$self.$$.dirty & /*$writable*/
    131072) {
      $$invalidate(2, disabled = !$writable);
    }
    if ($$self.$$.dirty & /*language*/
    65536) {
      $$invalidate(10, t = i18n2[language]);
    }
    if ($$self.$$.dirty & /*disabled*/
    4) {
      $$invalidate(5, type = disabled ? "disable" : "normal");
    }
    if ($$self.$$.dirty & /*app*/
    32768) {
      $$subscribe_index($$invalidate(9, index = app == null ? void 0 : app.sceneIndex));
    }
    if ($$self.$$.dirty & /*app*/
    32768) {
      $$subscribe_length($$invalidate(8, length = app == null ? void 0 : app.sceneLength));
    }
    if ($$self.$$.dirty & /*disabled, $index*/
    20) {
      $$invalidate(7, prev_disabled = disabled || !$index);
    }
    if ($$self.$$.dirty & /*disabled, $length, $index*/
    28) {
      $$invalidate(6, next_disabled = disabled || $length == null || $index === $length - 1);
    }
  };
  return [
    theme,
    icons,
    disabled,
    $length,
    $index,
    type,
    next_disabled,
    prev_disabled,
    length,
    index,
    t,
    writable2,
    prevPage,
    nextPage,
    addPage,
    app,
    language,
    $writable
  ];
}
var PageControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      app: 15,
      theme: 0,
      language: 16,
      icons: 1
    });
  }
};
var PageControl_default = PageControl;

// src/components/helpers.ts
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}

// src/components/ZoomControl/ZoomControl.svelte
function create_default_slot_52(ctx) {
  let icons_plus;
  let current;
  icons_plus = new Icons_default.Plus({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_plus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_plus, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_plus_changes = {};
      if (dirty & /*theme*/
      1)
        icons_plus_changes.theme = /*theme*/
        ctx2[0];
      icons_plus.$set(icons_plus_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_plus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_plus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_plus, detaching);
    }
  };
}
function create_default_slot_42(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.plus[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[plus]",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.plus[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      131073) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_else_block4(ctx) {
  let t0_value = Math.ceil(
    /*scale*/
    ctx[2] * 100
  ) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("%");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*scale*/
      4 && t0_value !== (t0_value = Math.ceil(
        /*scale*/
        ctx2[2] * 100
      ) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_if_block4(ctx) {
  let t_1;
  return {
    c() {
      t_1 = text("\u2026");
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_default_slot_33(ctx) {
  let icons_minus;
  let current;
  icons_minus = new Icons_default.Minus({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_minus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_minus, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_minus_changes = {};
      if (dirty & /*theme*/
      1)
        icons_minus_changes.theme = /*theme*/
        ctx2[0];
      icons_minus.$set(icons_minus_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_minus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_minus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_minus, detaching);
    }
  };
}
function create_default_slot_23(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.minus[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[minus]",
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.minus[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      131073) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_default_slot_13(ctx) {
  let icons_reset;
  let current;
  icons_reset = new Icons_default.Reset({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_reset.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_reset, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_reset_changes = {};
      if (dirty & /*theme*/
      1)
        icons_reset_changes.theme = /*theme*/
        ctx2[0];
      icons_reset.$set(icons_reset_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_reset.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_reset.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_reset, detaching);
    }
  };
}
function create_default_slot3(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.reset[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[reset]",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.reset[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      131073) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment48(ctx) {
  let div;
  let button0;
  let t0;
  let span;
  let span_class_value;
  let t1;
  let button1;
  let t2;
  let button2;
  let div_class_value;
  let current;
  button0 = new Button_default({
    props: {
      class: "plus",
      name: name3,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*plus_disabled*/
        ctx[7]
      ),
      content: (
        /*t*/
        ctx[9].plus
      ),
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*plus*/
    ctx[11]
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*$camera*/
      ctx2[4] == null
    )
      return create_if_block4;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  button1 = new Button_default({
    props: {
      class: "minus",
      name: name3,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*minus_disabled*/
        ctx[6]
      ),
      content: (
        /*t*/
        ctx[9].minus
      ),
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*minus*/
    ctx[12]
  );
  button2 = new Button_default({
    props: {
      class: "reset",
      name: name3,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      ),
      content: (
        /*t*/
        ctx[9].reset
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*reset*/
    ctx[13]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      span = element("span");
      if_block.c();
      t1 = space();
      create_component(button1.$$.fragment);
      t2 = space();
      create_component(button2.$$.fragment);
      attr(span, "class", span_class_value = name3 + "-text " + /*theme*/
      ctx[0]);
      attr(div, "class", div_class_value = name3 + " " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t0);
      append(div, span);
      if_block.m(span, null);
      append(div, t1);
      mount_component(button1, div, null);
      append(div, t2);
      mount_component(button2, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*theme*/
      1)
        button0_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*plus_disabled*/
      128)
        button0_changes.disabled = /*plus_disabled*/
        ctx2[7];
      if (dirty & /*t*/
      512)
        button0_changes.content = /*t*/
        ctx2[9].plus;
      if (dirty & /*$$scope, icons, type, theme*/
      131107) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
      if (!current || dirty & /*theme*/
      1 && span_class_value !== (span_class_value = name3 + "-text " + /*theme*/
      ctx2[0])) {
        attr(span, "class", span_class_value);
      }
      const button1_changes = {};
      if (dirty & /*theme*/
      1)
        button1_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*minus_disabled*/
      64)
        button1_changes.disabled = /*minus_disabled*/
        ctx2[6];
      if (dirty & /*t*/
      512)
        button1_changes.content = /*t*/
        ctx2[9].minus;
      if (dirty & /*$$scope, icons, type, theme*/
      131107) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*theme*/
      1)
        button2_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*disabled*/
      8)
        button2_changes.disabled = /*disabled*/
        ctx2[3];
      if (dirty & /*t*/
      512)
        button2_changes.content = /*t*/
        ctx2[9].reset;
      if (dirty & /*$$scope, icons, type, theme*/
      131107) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      if (!current || dirty & /*theme*/
      1 && div_class_value !== (div_class_value = name3 + " " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button0);
      if_block.d();
      destroy_component(button1);
      destroy_component(button2);
    }
  };
}
var i18n3 = {
  en: {
    plus: "Zoom In",
    minus: "Zoom Out",
    reset: "Reset"
  },
  "zh-CN": {
    plus: "\u653E\u5927",
    minus: "\u7F29\u5C0F",
    reset: "\u91CD\u7F6E"
  }
};
var scales = [
  0.3,
  0.4096000000000002,
  0.5120000000000001,
  0.6400000000000001,
  0.8,
  1,
  1.26,
  1.5876000000000001,
  2.000376,
  2.5204737600000002,
  3
];
function next_scale(scale, delta) {
  const { length } = scales;
  const last = length - 1;
  if (scale < scales[0])
    return scales[0];
  if (scale > scales[last])
    return scales[last];
  for (let i = 0; i < length; ++i) {
    const cur = scales[i];
    const prev = i === 0 ? -Infinity : (scales[i - 1] + cur) / 2;
    const next = i === last ? Infinity : (scales[i + 1] + cur) / 2;
    if (prev <= scale && scale <= next)
      return scales[clamp(i + delta, 0, last)];
  }
  return 1;
}
var name3 = "fastboard-zoom-control";
function instance48($$self, $$props, $$invalidate) {
  let writable2;
  let disabled;
  let t;
  let camera;
  let scale;
  let plus_disabled;
  let minus_disabled;
  let $camera, $$unsubscribe_camera = noop, $$subscribe_camera = () => ($$unsubscribe_camera(), $$unsubscribe_camera = subscribe(camera, ($$value) => $$invalidate(4, $camera = $$value)), camera);
  let $writable, $$unsubscribe_writable = noop, $$subscribe_writable = () => ($$unsubscribe_writable(), $$unsubscribe_writable = subscribe(writable2, ($$value) => $$invalidate(16, $writable = $$value)), writable2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_camera());
  $$self.$$.on_destroy.push(() => $$unsubscribe_writable());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { icons = void 0 } = $$props;
  let type;
  function plus() {
    app == null ? void 0 : app.moveCamera({
      scale: next_scale(scale, 1),
      centerX: 0,
      centerY: 0
    });
  }
  function minus() {
    app == null ? void 0 : app.moveCamera({
      scale: next_scale(scale, -1),
      centerX: 0,
      centerY: 0
    });
  }
  function reset() {
    app == null ? void 0 : app.moveCamera({ scale: 1, centerX: 0, centerY: 0 });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(14, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(15, language = $$props2.language);
    if ("icons" in $$props2)
      $$invalidate(1, icons = $$props2.icons);
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*app*/
    16384) {
      $$subscribe_writable($$invalidate(10, writable2 = app == null ? void 0 : app.writable));
    }
    if ($$self.$$.dirty & /*$writable*/
    65536) {
      $$invalidate(3, disabled = !$writable);
    }
    if ($$self.$$.dirty & /*language*/
    32768) {
      $$invalidate(9, t = i18n3[language]);
    }
    if ($$self.$$.dirty & /*disabled*/
    8) {
      $$invalidate(5, type = disabled ? "disable" : "normal");
    }
    if ($$self.$$.dirty & /*app*/
    16384) {
      $$subscribe_camera($$invalidate(8, camera = app == null ? void 0 : app.camera));
    }
    if ($$self.$$.dirty & /*$camera*/
    16) {
      $$invalidate(2, scale = (_a = $camera == null ? void 0 : $camera.scale) != null ? _a : 1);
    }
    if ($$self.$$.dirty & /*disabled, scale*/
    12) {
      $$invalidate(7, plus_disabled = disabled || next_scale(scale, 1) === scale);
    }
    if ($$self.$$.dirty & /*disabled, scale*/
    12) {
      $$invalidate(6, minus_disabled = disabled || next_scale(scale, -1) === scale);
    }
  };
  return [
    theme,
    icons,
    scale,
    disabled,
    $camera,
    type,
    minus_disabled,
    plus_disabled,
    camera,
    t,
    writable2,
    plus,
    minus,
    reset,
    app,
    language,
    $writable
  ];
}
var ZoomControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      app: 14,
      theme: 0,
      language: 15,
      icons: 1
    });
  }
};
var ZoomControl_default = ZoomControl;

// ../../node_modules/.pnpm/svelte@3.59.2/node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/actions/height.ts
var height = function(node, height2) {
  const styles = getComputedStyle(node);
  const paddings = (parseInt(styles.paddingTop) || 0) + (parseInt(styles.paddingBottom) || 0) + (parseInt(styles.borderTopWidth) || 0) + (parseInt(styles.borderBottomWidth) || 0);
  const observer = new ResizeObserver(() => {
    height2.set(node.getBoundingClientRect().height - paddings);
  });
  observer.observe(node);
  return {
    update(new_height) {
      height2 = new_height;
    },
    destroy() {
      observer.disconnect();
    }
  };
};
var scrollHeight = function(node, height2) {
  const observer = new ResizeObserver(() => {
    height2.set(node.scrollHeight);
  });
  observer.observe(node);
  return {
    update(new_height) {
      height2 = new_height;
    },
    destroy() {
      observer.disconnect();
    }
  };
};

// src/components/Toolbar/components/constants.ts
var colors = {
  "#E02020": [224, 32, 32],
  "#F7B500": [247, 181, 0],
  "#6DD400": [109, 212, 0],
  "#32C5FF": [50, 197, 255],
  "#0091FF": [0, 145, 255],
  "#6236FF": [98, 54, 255],
  "#B620E0": [182, 32, 224],
  "#6D7278": [109, 114, 120]
};
var shapes = [
  "rectangle",
  "ellipse",
  "straight",
  "arrow",
  "pentagram",
  "rhombus",
  "triangle",
  "speechBalloon"
];
var applianceShapes = shapes.slice(0, 4);
var shapesIcon = {
  rectangle: Icons_default.Rectangle,
  ellipse: Icons_default.Circle,
  straight: Icons_default.Line,
  arrow: Icons_default.Arrow,
  pentagram: Icons_default.Star,
  rhombus: Icons_default.Rhombus,
  triangle: Icons_default.Triangle,
  speechBalloon: Icons_default.Balloon
};
var shapesIconActive = {
  rectangle: Icons_default.RectangleBolded,
  ellipse: Icons_default.CircleBolded,
  straight: Icons_default.LineBolded,
  arrow: Icons_default.ArrowBolded,
  pentagram: Icons_default.StarBolded,
  rhombus: Icons_default.RhombusBolded,
  triangle: Icons_default.TriangleBolded,
  speechBalloon: Icons_default.BalloonBolded
};
var i18n4 = {
  en: {
    clicker: "clicker",
    selector: "selector",
    pencil: "pencil",
    eraser: "eraser",
    text: "text",
    shapes: "shapes",
    clear: "clear",
    apps: "apps"
  },
  "zh-CN": {
    clicker: "\u70B9\u51FB",
    selector: "\u9009\u62E9",
    pencil: "\u94C5\u7B14",
    eraser: "\u6A61\u76AE",
    text: "\u6587\u5B57",
    shapes: "\u5F62\u72B6",
    clear: "\u6E05\u5C4F",
    apps: "Apps"
  }
};
var colorKeys = Object.keys(colors);

// src/actions/scroll.ts
var scrollTop = function(node, value) {
  const listener = (top) => {
    node.scrollTo({ top, behavior: "smooth" });
  };
  let timer = 0;
  function on_scroll() {
    clearTimeout(timer);
    timer = window.setTimeout(() => value.set(node.scrollTop), 200);
  }
  node.addEventListener("scroll", on_scroll);
  let unsubscribe = value.subscribe(listener);
  return {
    update(new_value) {
      unsubscribe();
      unsubscribe = (value = new_value).subscribe(listener);
    },
    destroy() {
      clearTimeout(timer);
      node.removeEventListener("scroll", on_scroll);
      unsubscribe();
    }
  };
};

// src/behaviors/icons/visual-studio-code.svg
var visual_studio_code_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.01em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 254" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);"><defs><linearGradient id="IconifyId-17f872155be-cc766e-5439" x1="50%" x2="50%" y1="0%" y2="100%"><stop offset="0%" stop-color="%23FFF"/><stop offset="100%" stop-color="%23FFF" stop-opacity="0"/></linearGradient><path id="IconifyId-17f872155be-cc766e-5440" d="M180.828 252.605a15.872 15.872 0 0 0 12.65-.486l52.501-25.262a15.94 15.94 0 0 0 9.025-14.364V41.197a15.939 15.939 0 0 0-9.025-14.363l-52.5-25.263a15.877 15.877 0 0 0-18.115 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.507 91.695a15.853 15.853 0 0 0 5.464 3.571Zm10.464-183.649l-76.262 57.889l76.262 57.888V68.956Z"/></defs><mask id="IconifyId-17f872155be-cc766e-5441" fill="%23fff"><use href="%23IconifyId-17f872155be-cc766e-5440"/></mask><path fill="%230065A9" d="M246.135 26.873L193.593 1.575a15.885 15.885 0 0 0-18.123 3.08L3.466 161.482c-4.626 4.219-4.62 11.502.012 15.714l14.05 12.772a10.625 10.625 0 0 0 13.569.604L238.229 33.436c6.949-5.271 16.93-.315 16.93 8.407v-.61a15.938 15.938 0 0 0-9.024-14.36Z" mask="url(%23IconifyId-17f872155be-cc766e-5441)"/><path fill="%23007ACC" d="m246.135 226.816l-52.542 25.298a15.887 15.887 0 0 1-18.123-3.08L3.466 92.207c-4.626-4.218-4.62-11.502.012-15.713l14.05-12.773a10.625 10.625 0 0 1 13.569-.603l207.132 157.135c6.949 5.271 16.93.315 16.93-8.408v.611a15.939 15.939 0 0 1-9.024 14.36Z" mask="url(%23IconifyId-17f872155be-cc766e-5441)"/><path fill="%231F9CF0" d="M193.428 252.134a15.892 15.892 0 0 1-18.125-3.083c5.881 5.88 15.938 1.715 15.938-6.603V11.273c0-8.318-10.057-12.483-15.938-6.602a15.892 15.892 0 0 1 18.125-3.084l52.533 25.263a15.937 15.937 0 0 1 9.03 14.363V212.51c0 6.125-3.51 11.709-9.03 14.363l-52.533 25.262Z" mask="url(%23IconifyId-17f872155be-cc766e-5441)"/><path fill="url(%23IconifyId-17f872155be-cc766e-5439)" fill-opacity=".25" d="M180.828 252.605a15.874 15.874 0 0 0 12.65-.486l52.5-25.263a15.938 15.938 0 0 0 9.026-14.363V41.197a15.939 15.939 0 0 0-9.025-14.363L193.477 1.57a15.877 15.877 0 0 0-18.114 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.506 91.695a15.857 15.857 0 0 0 5.465 3.571Zm10.464-183.65l-76.262 57.89l76.262 57.888V68.956Z" mask="url(%23IconifyId-17f872155be-cc766e-5441)"/></svg>';

// src/behaviors/icons/geogebra.svg
var geogebra_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--arcticons" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 48 48"><path fill="none" stroke="%236557d2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M24 3a4.77 4.77 0 1 0 4.77 4.77A4.78 4.78 0 0 0 24 3ZM7.69 14.86a4.77 4.77 0 1 0 4.76 4.77a4.76 4.76 0 0 0-4.76-4.77Zm32.64 0a4.77 4.77 0 1 0 4.77 4.77a4.77 4.77 0 0 0-4.77-4.77ZM13.92 34.05a4.77 4.77 0 1 0 4.77 4.77a4.76 4.76 0 0 0-4.77-4.77Zm20.18 0a4.77 4.77 0 1 0 4.76 4.77a4.76 4.76 0 0 0-4.76-4.77Z"></path><path fill="none" stroke="%236557d2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M19.27 8.35a17.24 17.24 0 0 0-9.73 6.87m28.51.22a17.28 17.28 0 0 0-9.34-6.94m8.7 26.89A17.09 17.09 0 0 0 40.93 25v-.61M18 41.22a17.23 17.23 0 0 0 5.68 1a17 17 0 0 0 6.2-1.22M6.53 24.25v.72a17.16 17.16 0 0 0 3.77 10.76"></path></svg>';

// src/behaviors/icons/countdown.svg
var countdown_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--radix-icons" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 15 15"><path fill="grey" fill-rule="evenodd" d="M13.15 7.5c0-2.835-2.21-5.65-5.65-5.65c-2.778 0-4.151 2.056-4.737 3.15H4.5a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 1 0v1.813C2.705 3.071 4.334.85 7.5.85c4.063 0 6.65 3.335 6.65 6.65c0 3.315-2.587 6.65-6.65 6.65c-1.944 0-3.562-.77-4.715-1.942a6.772 6.772 0 0 1-1.427-2.167a.5.5 0 1 1 .925-.38c.28.681.692 1.314 1.216 1.846c.972.99 2.336 1.643 4.001 1.643c3.44 0 5.65-2.815 5.65-5.65ZM7 10V5h1v5H7Z" clip-rule="evenodd"></path></svg>';

// src/behaviors/apps.ts
var AppsInToolbar = class {
  constructor(_data) {
    this._data = _data;
    __publicField(this, "_listeners", []);
  }
  get data() {
    return this._data;
  }
  get length() {
    return this._data.length;
  }
  subscribe(fn) {
    this._listeners.push(fn);
    fn(this._data);
    return () => {
      this._listeners = this._listeners.filter((item) => item !== fn);
    };
  }
  push(...data) {
    this._data.push(...data);
    this._listeners.forEach((fn) => fn(this._data));
  }
  insert(data, index) {
    this._data.splice(index, 0, data);
    this._listeners.forEach((fn) => fn(this._data));
  }
  delete(filter) {
    this._data = this._data.filter((item) => !filter(item));
    this._listeners.forEach((fn) => fn(this._data));
  }
  clear() {
    this._data.length = 0;
    this._listeners.forEach((fn) => fn(this._data));
  }
};
var apps = new AppsInToolbar([
  {
    kind: "Monaco",
    icon: visual_studio_code_default,
    label: "Code Editor",
    onClick(app) {
      app.manager.addApp({
        kind: "Monaco",
        options: { title: "Code Editor" }
      });
    }
  },
  {
    kind: "GeoGebra",
    icon: geogebra_default,
    label: "GeoGebra",
    onClick(app) {
      app.manager.addApp({
        kind: "GeoGebra",
        options: { title: "GeoGebra" }
      });
    }
  },
  {
    kind: "Countdown",
    icon: countdown_default,
    label: "Countdown",
    onClick(app) {
      app.manager.addApp({
        kind: "Countdown",
        options: { title: "Countdown" }
      });
    }
  }
]);

// src/components/Toolbar/components/helper.ts
function tooltip(text2, hotkey) {
  if (!hotkey || typeof hotkey !== "string")
    return text2;
  const outer = element("span");
  const inner = element("span");
  inner.textContent = text2;
  const hotkey_span = element("span");
  hotkey_span.textContent = hotkey.toUpperCase();
  attr(outer, "class", "fastboard-toolbar-tooltip");
  attr(hotkey_span, "class", "fastboard-toolbar-hotkey");
  append(outer, inner);
  append(outer, hotkey_span);
  return outer;
}

// src/components/Toolbar/components/Slider.svelte
function create_fragment49(ctx) {
  let div;
  let input;
  let input_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "class", input_class_value = name4 + "-track " + /*theme*/
      ctx[2]);
      attr(input, "type", "range");
      input.disabled = /*disabled*/
      ctx[6];
      attr(
        input,
        "min",
        /*min*/
        ctx[3]
      );
      attr(
        input,
        "max",
        /*max*/
        ctx[4]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[5]
      );
      attr(
        input,
        "aria-valuemin",
        /*min*/
        ctx[3]
      );
      attr(
        input,
        "aria-valuemax",
        /*max*/
        ctx[4]
      );
      attr(
        input,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      toggle_class(
        input,
        "grabbing",
        /*grabbing*/
        ctx[8]
      );
      attr(div, "class", div_class_value = name4 + " " + /*className*/
      ctx[1] + " " + /*theme*/
      ctx[2]);
      set_style(
        div,
        "--value",
        /*percent*/
        ctx[9] + "%"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*real_value*/
        ctx[7]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "pointerdown",
            /*on_down*/
            ctx[10]
          ),
          listen(
            input,
            "change",
            /*on_change*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme*/
      4 && input_class_value !== (input_class_value = name4 + "-track " + /*theme*/
      ctx2[2])) {
        attr(input, "class", input_class_value);
      }
      if (dirty & /*disabled*/
      64) {
        input.disabled = /*disabled*/
        ctx2[6];
      }
      if (dirty & /*min*/
      8) {
        attr(
          input,
          "min",
          /*min*/
          ctx2[3]
        );
      }
      if (dirty & /*max*/
      16) {
        attr(
          input,
          "max",
          /*max*/
          ctx2[4]
        );
      }
      if (dirty & /*step*/
      32) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[5]
        );
      }
      if (dirty & /*min*/
      8) {
        attr(
          input,
          "aria-valuemin",
          /*min*/
          ctx2[3]
        );
      }
      if (dirty & /*max*/
      16) {
        attr(
          input,
          "aria-valuemax",
          /*max*/
          ctx2[4]
        );
      }
      if (dirty & /*value*/
      1) {
        attr(
          input,
          "aria-valuenow",
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*real_value*/
      128) {
        set_input_value(
          input,
          /*real_value*/
          ctx2[7]
        );
      }
      if (dirty & /*theme, grabbing*/
      260) {
        toggle_class(
          input,
          "grabbing",
          /*grabbing*/
          ctx2[8]
        );
      }
      if (dirty & /*className, theme*/
      6 && div_class_value !== (div_class_value = name4 + " " + /*className*/
      ctx2[1] + " " + /*theme*/
      ctx2[2])) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*percent*/
      512) {
        set_style(
          div,
          "--value",
          /*percent*/
          ctx2[9] + "%"
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
var name4 = "fastboard-slider";
function instance49($$self, $$props, $$invalidate) {
  let percent;
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { theme = "light" } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 0.01 } = $$props;
  let { value = 30 } = $$props;
  let { disabled = false } = $$props;
  let real_value = value;
  let grabbing = false;
  function on_down() {
    $$invalidate(8, grabbing = true);
  }
  function on_change() {
    $$invalidate(8, grabbing = false);
    $$invalidate(0, value = real_value);
    dispatch("change", value);
  }
  function input_change_input_handler() {
    real_value = to_number(this.value);
    $$invalidate(7, real_value), $$invalidate(0, value), $$invalidate(8, grabbing);
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(6, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, real_value, grabbing*/
    385) {
      if (value !== real_value && !grabbing) {
          $$invalidate(7, real_value = value);
        }
    }
    if ($$self.$$.dirty & /*real_value, min, max*/
    152) {
      $$invalidate(9, percent = 100 * (real_value - min) / (max - min));
    }
  };
  return [
    value,
    className,
    theme,
    min,
    max,
    step,
    disabled,
    real_value,
    grabbing,
    percent,
    on_down,
    on_change,
    input_change_input_handler
  ];
}
var Slider = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      class: 1,
      theme: 2,
      min: 3,
      max: 4,
      step: 5,
      value: 0,
      disabled: 6
    });
  }
};
var Slider_default = Slider;

// src/components/Toolbar/components/StrokeWidth.svelte
function create_fragment50(ctx) {
  let slider;
  let current;
  const slider_spread_levels = [
    { class: "fastboard-toolbar-slider" },
    /*props*/
    ctx[0],
    { min: 1 },
    { max: 32 }
  ];
  let slider_props = {};
  for (let i = 0; i < slider_spread_levels.length; i += 1) {
    slider_props = assign(slider_props, slider_spread_levels[i]);
  }
  slider = new Slider_default({ props: slider_props });
  slider.$on(
    "change",
    /*set_stroke_width*/
    ctx[2]
  );
  return {
    c() {
      create_component(slider.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slider, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const slider_changes = dirty & /*props*/
      1 ? get_spread_update(slider_spread_levels, [
        slider_spread_levels[0],
        get_spread_object(
          /*props*/
          ctx2[0]
        ),
        slider_spread_levels[2],
        slider_spread_levels[3]
      ]) : {};
      slider.$set(slider_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slider, detaching);
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let memberState;
  let value;
  let props;
  let $memberState, $$unsubscribe_memberState = noop, $$subscribe_memberState = () => ($$unsubscribe_memberState(), $$unsubscribe_memberState = subscribe(memberState, ($$value) => $$invalidate(7, $memberState = $$value)), memberState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_memberState());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { disabled = false } = $$props;
  function set_stroke_width({ detail: value2 }) {
    app == null ? void 0 : app.setStrokeWidth(value2);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*app*/
    8) {
      $$subscribe_memberState($$invalidate(1, memberState = app == null ? void 0 : app.memberState));
    }
    if ($$self.$$.dirty & /*$memberState*/
    128) {
      $$invalidate(6, value = (_a = $memberState == null ? void 0 : $memberState.strokeWidth) != null ? _a : 1);
    }
    if ($$self.$$.dirty & /*value, theme, disabled*/
    112) {
      $$invalidate(0, props = { value, theme, disabled });
    }
  };
  return [
    props,
    memberState,
    set_stroke_width,
    app,
    theme,
    disabled,
    value,
    $memberState
  ];
}
var StrokeWidth = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, { app: 3, theme: 4, disabled: 5 });
  }
};
var StrokeWidth_default = StrokeWidth;

// src/components/Toolbar/components/StrokeColor.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let button;
  let span;
  let t;
  let button_class_value;
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      span = element("span");
      t = space();
      attr(span, "class", "fastboard-toolbar-color-item");
      set_style(
        span,
        "background-color",
        /*key*/
        ctx[7]
      );
      attr(button, "class", button_class_value = "fastboard-toolbar-btn fastboard-toolbar-color-btn " + /*theme*/
      ctx[0]);
      attr(button, "data-color-key", /*key*/
      ctx[7]);
      button.disabled = /*disabled*/
      ctx[1];
      toggle_class(button, "is-active", is_equal_color(
        /*strokeColor*/
        ctx[2],
        colors[
          /*key*/
          ctx[7]
        ]
      ));
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(button, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*theme*/
      1 && button_class_value !== (button_class_value = "fastboard-toolbar-btn fastboard-toolbar-color-btn " + /*theme*/
      ctx[0])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx[1];
      }
      if (dirty & /*theme, is_equal_color, strokeColor, colors, colorKeys*/
      5) {
        toggle_class(button, "is-active", is_equal_color(
          /*strokeColor*/
          ctx[2],
          colors[
            /*key*/
            ctx[7]
          ]
        ));
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_fragment51(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = colorKeys;
  const get_key = (ctx2) => (
    /*key*/
    ctx2[7]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = "fastboard-toolbar-colors " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*set_stroke_color*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme, colorKeys, disabled, is_equal_color, strokeColor, colors*/
      7) {
        each_value = colorKeys;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block, null, get_each_context);
      }
      if (dirty & /*theme*/
      1 && div_class_value !== (div_class_value = "fastboard-toolbar-colors " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function is_equal_color(a, b) {
  return a && b && a.every((v, i) => v === b[i]);
}
function instance51($$self, $$props, $$invalidate) {
  let memberState;
  let strokeColor;
  let $memberState, $$unsubscribe_memberState = noop, $$subscribe_memberState = () => ($$unsubscribe_memberState(), $$unsubscribe_memberState = subscribe(memberState, ($$value) => $$invalidate(6, $memberState = $$value)), memberState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_memberState());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { disabled = false } = $$props;
  function set_stroke_color(ev) {
    let button = ev.target;
    if (button && button.dataset.colorKey) {
      let color = colors[button.dataset.colorKey];
      if (color && app) {
        app.setStrokeColor(color);
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    32) {
      $$subscribe_memberState($$invalidate(3, memberState = app == null ? void 0 : app.memberState));
    }
    if ($$self.$$.dirty & /*$memberState*/
    64) {
      $$invalidate(2, strokeColor = $memberState == null ? void 0 : $memberState.strokeColor);
    }
  };
  return [theme, disabled, strokeColor, memberState, set_stroke_color, app, $memberState];
}
var StrokeColor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, { app: 5, theme: 0, disabled: 1 });
  }
};
var StrokeColor_default = StrokeColor;

// src/components/Toolbar/components/TextColor.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let button;
  let span;
  let t;
  let button_class_value;
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      span = element("span");
      t = space();
      attr(span, "class", "fastboard-toolbar-color-item");
      set_style(
        span,
        "background-color",
        /*key*/
        ctx[7]
      );
      attr(button, "class", button_class_value = "fastboard-toolbar-btn fastboard-toolbar-color-btn " + /*theme*/
      ctx[0]);
      attr(button, "data-color-key", /*key*/
      ctx[7]);
      button.disabled = /*disabled*/
      ctx[1];
      toggle_class(button, "is-active", is_equal_color2(
        /*textColor*/
        ctx[2],
        colors[
          /*key*/
          ctx[7]
        ]
      ));
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(button, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*theme*/
      1 && button_class_value !== (button_class_value = "fastboard-toolbar-btn fastboard-toolbar-color-btn " + /*theme*/
      ctx[0])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx[1];
      }
      if (dirty & /*theme, is_equal_color, textColor, colors, colorKeys*/
      5) {
        toggle_class(button, "is-active", is_equal_color2(
          /*textColor*/
          ctx[2],
          colors[
            /*key*/
            ctx[7]
          ]
        ));
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_fragment52(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = colorKeys;
  const get_key = (ctx2) => (
    /*key*/
    ctx2[7]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = "fastboard-toolbar-colors " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*set_stroke_color*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme, colorKeys, disabled, is_equal_color, textColor, colors*/
      7) {
        each_value = colorKeys;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block2, null, get_each_context2);
      }
      if (dirty & /*theme*/
      1 && div_class_value !== (div_class_value = "fastboard-toolbar-colors " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function is_equal_color2(a, b) {
  return a && b && a.every((v, i) => v === b[i]);
}
function instance52($$self, $$props, $$invalidate) {
  let memberState;
  let textColor;
  let $memberState, $$unsubscribe_memberState = noop, $$subscribe_memberState = () => ($$unsubscribe_memberState(), $$unsubscribe_memberState = subscribe(memberState, ($$value) => $$invalidate(6, $memberState = $$value)), memberState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_memberState());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { disabled = false } = $$props;
  function set_stroke_color(ev) {
    let button = ev.target;
    if (button && button.dataset.colorKey) {
      let color = colors[button.dataset.colorKey];
      if (color && app) {
        app.setTextColor(color);
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    32) {
      $$subscribe_memberState($$invalidate(3, memberState = app == null ? void 0 : app.memberState));
    }
    if ($$self.$$.dirty & /*$memberState*/
    64) {
      $$invalidate(2, textColor = $memberState == null ? void 0 : $memberState.textColor);
    }
  };
  return [theme, disabled, textColor, memberState, set_stroke_color, app, $memberState];
}
var TextColor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, { app: 5, theme: 0, disabled: 1 });
  }
};
var TextColor_default = TextColor;

// src/components/Toolbar/components/Shapes.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  const constants_0 = (
    /*appliance*/
    child_ctx[4] === "shape" ? (
      /*shape*/
      child_ctx[3] === /*key*/
      child_ctx[12]
    ) : (
      /*appliance*/
      child_ctx[4] === /*key*/
      child_ctx[12]
    )
  );
  child_ctx[13] = constants_0;
  return child_ctx;
}
function create_else_block5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = shapesIcon[
    /*key*/
    ctx[12]
  ];
  function switch_props(ctx2) {
    return { props: { theme: (
      /*theme*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*theme*/
      1)
        switch_instance_changes.theme = /*theme*/
        ctx2[0];
      if (switch_value !== (switch_value = shapesIcon[
        /*key*/
        ctx2[12]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = shapesIconActive[
    /*key*/
    ctx[12]
  ];
  function switch_props(ctx2) {
    return {
      props: { theme: (
        /*theme*/
        ctx2[0]
      ), active: true }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*theme*/
      1)
        switch_instance_changes.theme = /*theme*/
        ctx2[0];
      if (switch_value !== (switch_value = shapesIconActive[
        /*key*/
        ctx2[12]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block3(key_1, ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let t_1;
  let button_class_value;
  let tippy_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block5, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*is_selected*/
      ctx2[13]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      if_block.c();
      t_1 = space();
      attr(button, "class", button_class_value = "fastboard-toolbar-btn fastboard-toolbar-shape-btn " + /*theme*/
      ctx[0] + " " + /*key*/
      ctx[12]);
      attr(button, "data-shape-key", /*key*/
      ctx[12]);
      button.disabled = /*disabled*/
      ctx[1];
      toggle_class(
        button,
        "is-active",
        /*is_selected*/
        ctx[13]
      );
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append(button, t_1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(tippy_action = tippy.call(null, button, {
          content: tooltip(
            /*t*/
            ctx[6][
              /*key*/
              ctx[12]
            ],
            /*c*/
            ctx[2][
              /*key*/
              ctx[12]
            ]
          ),
          placement: "top"
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, t_1);
      }
      if (!current || dirty & /*theme*/
      1 && button_class_value !== (button_class_value = "fastboard-toolbar-btn fastboard-toolbar-shape-btn " + /*theme*/
      ctx[0] + " " + /*key*/
      ctx[12])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx[1];
      }
      if (tippy_action && is_function(tippy_action.update) && dirty & /*t, c*/
      68)
        tippy_action.update.call(null, {
          content: tooltip(
            /*t*/
            ctx[6][
              /*key*/
              ctx[12]
            ],
            /*c*/
            ctx[2][
              /*key*/
              ctx[12]
            ]
          ),
          placement: "top"
        });
      if (!current || dirty & /*theme, appliance, shape, shapes*/
      25) {
        toggle_class(
          button,
          "is-active",
          /*is_selected*/
          ctx[13]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment53(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = shapes;
  const get_key = (ctx2) => (
    /*key*/
    ctx2[12]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = "fastboard-toolbar-shapes " + /*theme*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*set_appliance_or_shape*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*theme, shapes, disabled, tooltip, t, c, appliance, shape, shapesIconActive, shapesIcon*/
      95) {
        each_value = shapes;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block3, null, get_each_context3);
        check_outros();
      }
      if (!current || dirty & /*theme*/
      1 && div_class_value !== (div_class_value = "fastboard-toolbar-shapes " + /*theme*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
var i18n5 = {
  en: {
    rectangle: "Rectangle",
    ellipse: "Ellipse",
    straight: "Line",
    arrow: "Arrow",
    pentagram: "Star",
    rhombus: "Diamond",
    triangle: "Triangle",
    speechBalloon: "Balloon"
  },
  "zh-CN": {
    rectangle: "\u77E9\u5F62",
    ellipse: "\u692D\u5706",
    straight: "\u76F4\u7EBF",
    arrow: "\u7BAD\u5934",
    pentagram: "\u4E94\u89D2\u661F",
    rhombus: "\u83F1\u5F62",
    triangle: "\u4E09\u89D2\u5F62",
    speechBalloon: "\u6C14\u6CE1"
  }
};
function instance53($$self, $$props, $$invalidate) {
  let t;
  let memberState;
  let appliance;
  let shape;
  let hotkeys;
  let $memberState, $$unsubscribe_memberState = noop, $$subscribe_memberState = () => ($$unsubscribe_memberState(), $$unsubscribe_memberState = subscribe(memberState, ($$value) => $$invalidate(11, $memberState = $$value)), memberState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_memberState());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { disabled = false } = $$props;
  let c;
  function set_appliance_or_shape(ev) {
    let button = ev.target;
    if (button && button.dataset.shapeKey) {
      let shape2 = button.dataset.shapeKey;
      if (shape2 && app) {
        if (applianceShapes.includes(shape2)) {
          app.setAppliance(shape2);
        } else {
          app.setAppliance("shape", shape2);
        }
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(8, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(9, language = $$props2.language);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*language*/
    512) {
      $$invalidate(6, t = i18n5[language]);
    }
    if ($$self.$$.dirty & /*app*/
    256) {
      $$subscribe_memberState($$invalidate(5, memberState = app == null ? void 0 : app.memberState));
    }
    if ($$self.$$.dirty & /*$memberState*/
    2048) {
      $$invalidate(4, appliance = $memberState == null ? void 0 : $memberState.currentApplianceName);
    }
    if ($$self.$$.dirty & /*$memberState*/
    2048) {
      $$invalidate(3, shape = $memberState == null ? void 0 : $memberState.shapeType);
    }
    if ($$self.$$.dirty & /*app*/
    256) {
      $$invalidate(10, hotkeys = app == null ? void 0 : app.hotKeys);
    }
    if ($$self.$$.dirty & /*hotkeys*/
    1024) {
      $$invalidate(2, c = {
          rectangle: hotkeys == null ? void 0 : hotkeys.changeToRectangle,
          ellipse: hotkeys == null ? void 0 : hotkeys.changeToEllipse,
          straight: hotkeys == null ? void 0 : hotkeys.changeToStraight,
          arrow: hotkeys == null ? void 0 : hotkeys.changeToArrow
        });
    }
  };
  return [
    theme,
    disabled,
    c,
    shape,
    appliance,
    memberState,
    t,
    set_appliance_or_shape,
    app,
    language,
    hotkeys,
    $memberState
  ];
}
var Shapes = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      app: 8,
      theme: 0,
      language: 9,
      disabled: 1
    });
  }
};
var Shapes_default = Shapes;

// src/components/Toolbar/components/Contents.svelte
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  const constants_0 = (
    /*netless_app*/
    child_ctx[42]
  );
  child_ctx[43] = constants_0.icon;
  child_ctx[44] = constants_0.label;
  child_ctx[45] = constants_0.kind;
  child_ctx[46] = constants_0.onClick;
  const constants_1 = (
    /*$status*/
    child_ctx[20] && /*$status*/
    child_ctx[20][
      /*kind*/
      child_ctx[45]
    ]
  );
  child_ctx[47] = constants_1;
  const constants_2 = function func() {
    return (
      /*func*/
      ctx[38](
        /*onClick*/
        child_ctx[46]
      )
    );
  };
  child_ctx[48] = constants_2;
  return child_ctx;
}
function create_if_block_8(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { class: "scroll-up" },
    /*btn_props*/
    ctx[15]
  ];
  let button_props = {
    $$slots: { default: [create_default_slot_9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props });
  button.$on(
    "click",
    /*scroll_up*/
    ctx[22]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = dirty[0] & /*btn_props*/
      32768 ? get_spread_update(button_spread_levels, [button_spread_levels[0], get_spread_object(
        /*btn_props*/
        ctx2[15]
      )]) : {};
      if (dirty[0] & /*theme*/
      2 | dirty[1] & /*$$scope*/
      1048576) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let icons_up;
  let current;
  icons_up = new Icons_default.Up({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_up.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_up, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_up_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_up_changes.theme = /*theme*/
        ctx2[1];
      icons_up.$set(icons_up_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_up.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_up.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_up, detaching);
    }
  };
}
function create_else_block_5(ctx) {
  let icons_click;
  let current;
  icons_click = new Icons_default.Click({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_click.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_click, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_click_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_click_changes.theme = /*theme*/
        ctx2[1];
      icons_click.$set(icons_click_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_click.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_click.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_click, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let icons_clickfilled;
  let current;
  icons_clickfilled = new Icons_default.ClickFilled({
    props: { theme: (
      /*theme*/
      ctx[1]
    ), active: true }
  });
  return {
    c() {
      create_component(icons_clickfilled.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_clickfilled, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_clickfilled_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_clickfilled_changes.theme = /*theme*/
        ctx2[1];
      icons_clickfilled.$set(icons_clickfilled_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_clickfilled.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_clickfilled.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_clickfilled, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_7, create_else_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === "clicker"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_4(ctx) {
  let icons_selector;
  let current;
  icons_selector = new Icons_default.Selector({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_selector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_selector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_selector_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_selector_changes.theme = /*theme*/
        ctx2[1];
      icons_selector.$set(icons_selector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_selector, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let icons_selectorfilled;
  let current;
  icons_selectorfilled = new Icons_default.SelectorFilled({
    props: { theme: (
      /*theme*/
      ctx[1]
    ), active: true }
  });
  return {
    c() {
      create_component(icons_selectorfilled.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_selectorfilled, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_selectorfilled_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_selectorfilled_changes.theme = /*theme*/
        ctx2[1];
      icons_selectorfilled.$set(icons_selectorfilled_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_selectorfilled.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_selectorfilled.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_selectorfilled, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_6, create_else_block_4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === "selector"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_3(ctx) {
  let icons_pencil;
  let current;
  icons_pencil = new Icons_default.Pencil({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_pencil.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_pencil, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_pencil_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_pencil_changes.theme = /*theme*/
        ctx2[1];
      icons_pencil.$set(icons_pencil_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_pencil.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_pencil.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_pencil, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let icons_pencilfilled;
  let current;
  icons_pencilfilled = new Icons_default.PencilFilled({
    props: { theme: (
      /*theme*/
      ctx[1]
    ), active: true }
  });
  return {
    c() {
      create_component(icons_pencilfilled.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_pencilfilled, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_pencilfilled_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_pencilfilled_changes.theme = /*theme*/
        ctx2[1];
      icons_pencilfilled.$set(icons_pencilfilled_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_pencilfilled.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_pencilfilled.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_pencilfilled, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block_3];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === "pencil"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_2(ctx) {
  let icons_text;
  let current;
  icons_text = new Icons_default.Text({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_text.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_text, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_text_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_text_changes.theme = /*theme*/
        ctx2[1];
      icons_text.$set(icons_text_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_text.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_text.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_text, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let icons_textfilled;
  let current;
  icons_textfilled = new Icons_default.TextFilled({
    props: { theme: (
      /*theme*/
      ctx[1]
    ), active: true }
  });
  return {
    c() {
      create_component(icons_textfilled.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_textfilled, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_textfilled_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_textfilled_changes.theme = /*theme*/
        ctx2[1];
      icons_textfilled.$set(icons_textfilled_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_textfilled.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_textfilled.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_textfilled, detaching);
    }
  };
}
function create_default_slot_53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === "text"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = shapesIcon[
    /*last_shape*/
    ctx[10]
  ];
  function switch_props(ctx2) {
    return { props: { theme: (
      /*theme*/
      ctx2[1]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & /*theme*/
      2)
        switch_instance_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*last_shape*/
      1024 && switch_value !== (switch_value = shapesIcon[
        /*last_shape*/
        ctx2[10]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = shapesIconActive[
    /*last_shape*/
    ctx[10]
  ];
  function switch_props(ctx2) {
    return {
      props: { theme: (
        /*theme*/
        ctx2[1]
      ), active: true }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & /*theme*/
      2)
        switch_instance_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*last_shape*/
      1024 && switch_value !== (switch_value = shapesIconActive[
        /*last_shape*/
        ctx2[10]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_43(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3, create_else_block_12];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === /*last_shape*/
      ctx2[10] || /*appliance*/
      ctx2[8] === "shape" && /*shape*/
      ctx2[7] === /*last_shape*/
      ctx2[10]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block6(ctx) {
  let icons_eraser;
  let current;
  icons_eraser = new Icons_default.Eraser({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_eraser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_eraser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_eraser_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_eraser_changes.theme = /*theme*/
        ctx2[1];
      icons_eraser.$set(icons_eraser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_eraser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_eraser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_eraser, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let icons_eraserfilled;
  let current;
  icons_eraserfilled = new Icons_default.EraserFilled({
    props: { theme: (
      /*theme*/
      ctx[1]
    ), active: true }
  });
  return {
    c() {
      create_component(icons_eraserfilled.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_eraserfilled, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_eraserfilled_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_eraserfilled_changes.theme = /*theme*/
        ctx2[1];
      icons_eraserfilled.$set(icons_eraserfilled_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_eraserfilled.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_eraserfilled.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_eraserfilled, detaching);
    }
  };
}
function create_default_slot_34(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block6];
  const if_blocks = [];
  function select_block_type_5(ctx2, dirty) {
    if (
      /*appliance*/
      ctx2[8] === "eraser"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_5(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_5(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_24(ctx) {
  let icons_clear;
  let current;
  icons_clear = new Icons_default.Clear({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_clear.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_clear, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_clear_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_clear_changes.theme = /*theme*/
        ctx2[1];
      icons_clear.$set(icons_clear_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_clear.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_clear.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_clear, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { class: "apps" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*t*/
      ctx[9].apps
    ) },
    { menu: (
      /*apps_panel*/
      ctx[14]
    ) },
    { menu_placement: "right-end" }
  ];
  let button_props = {
    $$slots: { default: [create_default_slot_14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = dirty[0] & /*btn_props, t, apps_panel*/
      49664 ? get_spread_update(button_spread_levels, [
        button_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*t*/
        512 && { content: (
          /*t*/
          ctx2[9].apps
        ) },
        dirty[0] & /*apps_panel*/
        16384 && { menu: (
          /*apps_panel*/
          ctx2[14]
        ) },
        button_spread_levels[4]
      ]) : {};
      if (dirty[0] & /*theme*/
      2 | dirty[1] & /*$$scope*/
      1048576) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_14(ctx) {
  let icons_apps;
  let current;
  icons_apps = new Icons_default.Apps({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_apps.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_apps, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_apps_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_apps_changes.theme = /*theme*/
        ctx2[1];
      icons_apps.$set(icons_apps_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_apps.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_apps.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_apps, detaching);
    }
  };
}
function create_if_block6(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      class: "scroll-down",
      name: name5,
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*scroll_down*/
    ctx[23]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*theme*/
      2)
        button_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        button_changes.disabled = /*disabled*/
        ctx2[3];
      if (dirty[0] & /*theme*/
      2 | dirty[1] & /*$$scope*/
      1048576) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let icons_down;
  let current;
  icons_down = new Icons_default.Down({ props: { theme: (
    /*theme*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(icons_down.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_down, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_down_changes = {};
      if (dirty[0] & /*theme*/
      2)
        icons_down_changes.theme = /*theme*/
        ctx2[1];
      icons_down.$set(icons_down_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_down.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_down.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_down, detaching);
    }
  };
}
function create_each_block4(ctx) {
  let button;
  let img;
  let img_class_value;
  let img_src_value;
  let img_alt_value;
  let img_title_value;
  let t0;
  let span;
  let t1_value = (
    /*label*/
    ctx[44] + ""
  );
  let t1;
  let span_class_value;
  let t2;
  let button_class_value;
  let button_title_value;
  let button_data_app_kind_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(img, "class", img_class_value = name5 + "-app-btn-icon " + /*theme*/
      ctx[1]);
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[43]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*kind*/
      ctx[45]);
      attr(img, "title", img_title_value = /*label*/
      ctx[44]);
      attr(span, "class", span_class_value = name5 + "-app-btn-text " + /*theme*/
      ctx[1]);
      attr(button, "class", button_class_value = name5 + "-app-btn " + /*kind*/
      ctx[45] + " " + /*theme*/
      ctx[1]);
      attr(button, "title", button_title_value = /*label*/
      ctx[44] + /*state*/
      (ctx[47] && /*state*/
      ctx[47].reason ? ": " + /*state*/
      ctx[47].reason : ""));
      attr(button, "data-app-kind", button_data_app_kind_value = /*netless_app*/
      ctx[42].kind);
      button.disabled = button_disabled_value = /*state*/
      ctx[47] && /*state*/
      ctx[47].status !== "idle";
      toggle_class(
        button,
        "is-loading",
        /*state*/
        ctx[47] && /*state*/
        ctx[47].status === "loading"
      );
      toggle_class(
        button,
        "is-failed",
        /*state*/
        ctx[47] && /*state*/
        ctx[47].status === "failed"
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, img);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*on_click*/
            ctx[48]
          ))
            ctx[48].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*theme*/
      2 && img_class_value !== (img_class_value = name5 + "-app-btn-icon " + /*theme*/
      ctx[1])) {
        attr(img, "class", img_class_value);
      }
      if (dirty[0] & /*$apps*/
      524288 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx[43])) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & /*$apps*/
      524288 && img_alt_value !== (img_alt_value = /*kind*/
      ctx[45])) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty[0] & /*$apps*/
      524288 && img_title_value !== (img_title_value = /*label*/
      ctx[44])) {
        attr(img, "title", img_title_value);
      }
      if (dirty[0] & /*$apps*/
      524288 && t1_value !== (t1_value = /*label*/
      ctx[44] + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*theme*/
      2 && span_class_value !== (span_class_value = name5 + "-app-btn-text " + /*theme*/
      ctx[1])) {
        attr(span, "class", span_class_value);
      }
      if (dirty[0] & /*$apps, theme*/
      524290 && button_class_value !== (button_class_value = name5 + "-app-btn " + /*kind*/
      ctx[45] + " " + /*theme*/
      ctx[1])) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*$apps, $status*/
      1572864 && button_title_value !== (button_title_value = /*label*/
      ctx[44] + /*state*/
      (ctx[47] && /*state*/
      ctx[47].reason ? ": " + /*state*/
      ctx[47].reason : ""))) {
        attr(button, "title", button_title_value);
      }
      if (dirty[0] & /*$apps*/
      524288 && button_data_app_kind_value !== (button_data_app_kind_value = /*netless_app*/
      ctx[42].kind)) {
        attr(button, "data-app-kind", button_data_app_kind_value);
      }
      if (dirty[0] & /*$status, $apps*/
      1572864 && button_disabled_value !== (button_disabled_value = /*state*/
      ctx[47] && /*state*/
      ctx[47].status !== "idle")) {
        button.disabled = button_disabled_value;
      }
      if (dirty[0] & /*$apps, theme, $status, $apps*/
      1572866) {
        toggle_class(
          button,
          "is-loading",
          /*state*/
          ctx[47] && /*state*/
          ctx[47].status === "loading"
        );
      }
      if (dirty[0] & /*$apps, theme, $status, $apps*/
      1572866) {
        toggle_class(
          button,
          "is-failed",
          /*state*/
          ctx[47] && /*state*/
          ctx[47].status === "failed"
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment54(ctx) {
  let t0;
  let div0;
  let button0;
  let t1;
  let button1;
  let t2;
  let button2;
  let t3;
  let button3;
  let t4;
  let button4;
  let t5;
  let button5;
  let t6;
  let button6;
  let t7;
  let scrollHeight_action;
  let t8;
  let t9;
  let div8;
  let div2;
  let strokewidth0;
  let t10;
  let div1;
  let t11;
  let strokecolor0;
  let t12;
  let div3;
  let textcolor;
  let t13;
  let div6;
  let shapes2;
  let t14;
  let div4;
  let t15;
  let strokewidth1;
  let t16;
  let div5;
  let t17;
  let strokecolor1;
  let t18;
  let div7;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*scrollable*/
    ctx[5] && create_if_block_8(ctx)
  );
  const button0_spread_levels = [
    { class: "clicker" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*c*/
      ctx[18].clicker
    ) }
  ];
  let button0_props = {
    $$slots: { default: [create_default_slot_8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button0_spread_levels.length; i += 1) {
    button0_props = assign(button0_props, button0_spread_levels[i]);
  }
  button0 = new Button_default({ props: button0_props });
  button0.$on(
    "click",
    /*clicker*/
    ctx[24]
  );
  const button1_spread_levels = [
    { class: "selector" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*c*/
      ctx[18].selector
    ) }
  ];
  let button1_props = {
    $$slots: { default: [create_default_slot_7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button1_spread_levels.length; i += 1) {
    button1_props = assign(button1_props, button1_spread_levels[i]);
  }
  button1 = new Button_default({ props: button1_props });
  button1.$on(
    "click",
    /*selector*/
    ctx[25]
  );
  const button2_spread_levels = [
    { class: "pencil" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*c*/
      ctx[18].pencil
    ) },
    { menu: (
      /*pencil_panel*/
      ctx[11]
    ) }
  ];
  let button2_props = {
    $$slots: { default: [create_default_slot_6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button2_spread_levels.length; i += 1) {
    button2_props = assign(button2_props, button2_spread_levels[i]);
  }
  button2 = new Button_default({ props: button2_props });
  button2.$on(
    "click",
    /*pencil*/
    ctx[26]
  );
  const button3_spread_levels = [
    { class: "text" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*c*/
      ctx[18].text
    ) },
    { menu: (
      /*text_panel*/
      ctx[12]
    ) }
  ];
  let button3_props = {
    $$slots: { default: [create_default_slot_53] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button3_spread_levels.length; i += 1) {
    button3_props = assign(button3_props, button3_spread_levels[i]);
  }
  button3 = new Button_default({ props: button3_props });
  button3.$on(
    "click",
    /*text*/
    ctx[27]
  );
  const button4_spread_levels = [
    { class: "shapes" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*t*/
      ctx[9].shapes
    ) },
    { menu: (
      /*shapes_panel*/
      ctx[13]
    ) }
  ];
  let button4_props = {
    $$slots: { default: [create_default_slot_43] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button4_spread_levels.length; i += 1) {
    button4_props = assign(button4_props, button4_spread_levels[i]);
  }
  button4 = new Button_default({ props: button4_props });
  button4.$on(
    "click",
    /*select_last_shape*/
    ctx[28]
  );
  const button5_spread_levels = [
    { class: "eraser" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*c*/
      ctx[18].eraser
    ) }
  ];
  let button5_props = {
    $$slots: { default: [create_default_slot_34] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button5_spread_levels.length; i += 1) {
    button5_props = assign(button5_props, button5_spread_levels[i]);
  }
  button5 = new Button_default({ props: button5_props });
  button5.$on(
    "click",
    /*eraser*/
    ctx[29]
  );
  const button6_spread_levels = [
    { class: "clear" },
    /*btn_props*/
    ctx[15],
    { content: (
      /*t*/
      ctx[9].clear
    ) }
  ];
  let button6_props = {
    $$slots: { default: [create_default_slot_24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button6_spread_levels.length; i += 1) {
    button6_props = assign(button6_props, button6_spread_levels[i]);
  }
  button6 = new Button_default({ props: button6_props });
  button6.$on(
    "click",
    /*clear*/
    ctx[30]
  );
  let if_block1 = !/*hide_apps*/
  ctx[6] && create_if_block_12(ctx);
  let if_block2 = (
    /*scrollable*/
    ctx[5] && create_if_block6(ctx)
  );
  strokewidth0 = new StrokeWidth_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  strokecolor0 = new StrokeColor_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  textcolor = new TextColor_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  shapes2 = new Shapes_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  strokewidth1 = new StrokeWidth_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  strokecolor1 = new StrokeColor_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      )
    }
  });
  let each_value = (
    /*$apps*/
    ctx[19]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      create_component(button0.$$.fragment);
      t1 = space();
      create_component(button1.$$.fragment);
      t2 = space();
      create_component(button2.$$.fragment);
      t3 = space();
      create_component(button3.$$.fragment);
      t4 = space();
      create_component(button4.$$.fragment);
      t5 = space();
      create_component(button5.$$.fragment);
      t6 = space();
      create_component(button6.$$.fragment);
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      if (if_block2)
        if_block2.c();
      t9 = space();
      div8 = element("div");
      div2 = element("div");
      create_component(strokewidth0.$$.fragment);
      t10 = space();
      div1 = element("div");
      t11 = space();
      create_component(strokecolor0.$$.fragment);
      t12 = space();
      div3 = element("div");
      create_component(textcolor.$$.fragment);
      t13 = space();
      div6 = element("div");
      create_component(shapes2.$$.fragment);
      t14 = space();
      div4 = element("div");
      t15 = space();
      create_component(strokewidth1.$$.fragment);
      t16 = space();
      div5 = element("div");
      t17 = space();
      create_component(strokecolor1.$$.fragment);
      t18 = space();
      div7 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", name5 + "-scrollable");
      toggle_class(
        div0,
        "scrollable",
        /*scrollable*/
        ctx[5]
      );
      attr(div1, "class", name5 + "-panel-divider");
      attr(div2, "class", name5 + "-panel pencil");
      attr(div3, "class", name5 + "-panel text");
      attr(div4, "class", name5 + "-panel-divider");
      attr(div5, "class", name5 + "-panel-divider");
      attr(div6, "class", name5 + "-panel shapes");
      attr(div7, "class", name5 + "-panel apps");
      set_style(
        div7,
        "--n",
        /*$apps*/
        ctx[19].length
      );
      attr(div8, "class", name5 + "-panel-wrapper");
      set_style(div8, "display", "none");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div0, anchor);
      mount_component(button0, div0, null);
      append(div0, t1);
      mount_component(button1, div0, null);
      append(div0, t2);
      mount_component(button2, div0, null);
      append(div0, t3);
      mount_component(button3, div0, null);
      append(div0, t4);
      mount_component(button4, div0, null);
      append(div0, t5);
      mount_component(button5, div0, null);
      append(div0, t6);
      mount_component(button6, div0, null);
      append(div0, t7);
      if (if_block1)
        if_block1.m(div0, null);
      insert(target, t8, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t9, anchor);
      insert(target, div8, anchor);
      append(div8, div2);
      mount_component(strokewidth0, div2, null);
      append(div2, t10);
      append(div2, div1);
      append(div2, t11);
      mount_component(strokecolor0, div2, null);
      ctx[35](div2);
      append(div8, t12);
      append(div8, div3);
      mount_component(textcolor, div3, null);
      ctx[36](div3);
      append(div8, t13);
      append(div8, div6);
      mount_component(shapes2, div6, null);
      append(div6, t14);
      append(div6, div4);
      append(div6, t15);
      mount_component(strokewidth1, div6, null);
      append(div6, t16);
      append(div6, div5);
      append(div6, t17);
      mount_component(strokecolor1, div6, null);
      ctx[37](div6);
      append(div8, t18);
      append(div8, div7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div7, null);
        }
      }
      ctx[39](div7);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(scrollHeight_action = scrollHeight.call(
            null,
            div0,
            /*scroll_height*/
            ctx[4]
          )),
          action_destroyer(scrollTop.call(
            null,
            div0,
            /*top*/
            ctx[21]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*scrollable*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*scrollable*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const button0_changes = dirty[0] & /*btn_props, c*/
      294912 ? get_spread_update(button0_spread_levels, [
        button0_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*c*/
        262144 && { content: (
          /*c*/
          ctx2[18].clicker
        ) }
      ]) : {};
      if (dirty[0] & /*theme, appliance*/
      258 | dirty[1] & /*$$scope*/
      1048576) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = dirty[0] & /*btn_props, c*/
      294912 ? get_spread_update(button1_spread_levels, [
        button1_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*c*/
        262144 && { content: (
          /*c*/
          ctx2[18].selector
        ) }
      ]) : {};
      if (dirty[0] & /*theme, appliance*/
      258 | dirty[1] & /*$$scope*/
      1048576) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = dirty[0] & /*btn_props, c, pencil_panel*/
      296960 ? get_spread_update(button2_spread_levels, [
        button2_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*c*/
        262144 && { content: (
          /*c*/
          ctx2[18].pencil
        ) },
        dirty[0] & /*pencil_panel*/
        2048 && { menu: (
          /*pencil_panel*/
          ctx2[11]
        ) }
      ]) : {};
      if (dirty[0] & /*theme, appliance*/
      258 | dirty[1] & /*$$scope*/
      1048576) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = dirty[0] & /*btn_props, c, text_panel*/
      299008 ? get_spread_update(button3_spread_levels, [
        button3_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*c*/
        262144 && { content: (
          /*c*/
          ctx2[18].text
        ) },
        dirty[0] & /*text_panel*/
        4096 && { menu: (
          /*text_panel*/
          ctx2[12]
        ) }
      ]) : {};
      if (dirty[0] & /*theme, appliance*/
      258 | dirty[1] & /*$$scope*/
      1048576) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = dirty[0] & /*btn_props, t, shapes_panel*/
      41472 ? get_spread_update(button4_spread_levels, [
        button4_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*t*/
        512 && { content: (
          /*t*/
          ctx2[9].shapes
        ) },
        dirty[0] & /*shapes_panel*/
        8192 && { menu: (
          /*shapes_panel*/
          ctx2[13]
        ) }
      ]) : {};
      if (dirty[0] & /*last_shape, theme, appliance, shape*/
      1410 | dirty[1] & /*$$scope*/
      1048576) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
      const button5_changes = dirty[0] & /*btn_props, c*/
      294912 ? get_spread_update(button5_spread_levels, [
        button5_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*c*/
        262144 && { content: (
          /*c*/
          ctx2[18].eraser
        ) }
      ]) : {};
      if (dirty[0] & /*theme, appliance*/
      258 | dirty[1] & /*$$scope*/
      1048576) {
        button5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button5.$set(button5_changes);
      const button6_changes = dirty[0] & /*btn_props, t*/
      33280 ? get_spread_update(button6_spread_levels, [
        button6_spread_levels[0],
        dirty[0] & /*btn_props*/
        32768 && get_spread_object(
          /*btn_props*/
          ctx2[15]
        ),
        dirty[0] & /*t*/
        512 && { content: (
          /*t*/
          ctx2[9].clear
        ) }
      ]) : {};
      if (dirty[0] & /*theme*/
      2 | dirty[1] & /*$$scope*/
      1048576) {
        button6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button6.$set(button6_changes);
      if (!/*hide_apps*/
      ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hide_apps*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (scrollHeight_action && is_function(scrollHeight_action.update) && dirty[0] & /*scroll_height*/
      16)
        scrollHeight_action.update.call(
          null,
          /*scroll_height*/
          ctx2[4]
        );
      if (!current || dirty[0] & /*scrollable*/
      32) {
        toggle_class(
          div0,
          "scrollable",
          /*scrollable*/
          ctx2[5]
        );
      }
      if (
        /*scrollable*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*scrollable*/
          32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t9.parentNode, t9);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const strokewidth0_changes = {};
      if (dirty[0] & /*app*/
      1)
        strokewidth0_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        strokewidth0_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        strokewidth0_changes.disabled = /*disabled*/
        ctx2[3];
      strokewidth0.$set(strokewidth0_changes);
      const strokecolor0_changes = {};
      if (dirty[0] & /*app*/
      1)
        strokecolor0_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        strokecolor0_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        strokecolor0_changes.disabled = /*disabled*/
        ctx2[3];
      strokecolor0.$set(strokecolor0_changes);
      const textcolor_changes = {};
      if (dirty[0] & /*app*/
      1)
        textcolor_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        textcolor_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        textcolor_changes.disabled = /*disabled*/
        ctx2[3];
      textcolor.$set(textcolor_changes);
      const shapes_changes = {};
      if (dirty[0] & /*app*/
      1)
        shapes_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        shapes_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*language*/
      4)
        shapes_changes.language = /*language*/
        ctx2[2];
      if (dirty[0] & /*disabled*/
      8)
        shapes_changes.disabled = /*disabled*/
        ctx2[3];
      shapes2.$set(shapes_changes);
      const strokewidth1_changes = {};
      if (dirty[0] & /*app*/
      1)
        strokewidth1_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        strokewidth1_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        strokewidth1_changes.disabled = /*disabled*/
        ctx2[3];
      strokewidth1.$set(strokewidth1_changes);
      const strokecolor1_changes = {};
      if (dirty[0] & /*app*/
      1)
        strokecolor1_changes.app = /*app*/
        ctx2[0];
      if (dirty[0] & /*theme*/
      2)
        strokecolor1_changes.theme = /*theme*/
        ctx2[1];
      if (dirty[0] & /*disabled*/
      8)
        strokecolor1_changes.disabled = /*disabled*/
        ctx2[3];
      strokecolor1.$set(strokecolor1_changes);
      if (dirty[0] & /*$apps, theme, $status, app*/
      1572867) {
        each_value = /*$apps*/
        ctx2[19];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div7, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*$apps*/
      524288) {
        set_style(
          div7,
          "--n",
          /*$apps*/
          ctx2[19].length
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(button6.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(strokewidth0.$$.fragment, local);
      transition_in(strokecolor0.$$.fragment, local);
      transition_in(textcolor.$$.fragment, local);
      transition_in(shapes2.$$.fragment, local);
      transition_in(strokewidth1.$$.fragment, local);
      transition_in(strokecolor1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(button6.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(strokewidth0.$$.fragment, local);
      transition_out(strokecolor0.$$.fragment, local);
      transition_out(textcolor.$$.fragment, local);
      transition_out(shapes2.$$.fragment, local);
      transition_out(strokewidth1.$$.fragment, local);
      transition_out(strokecolor1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
      destroy_component(button5);
      destroy_component(button6);
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t8);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(div8);
      destroy_component(strokewidth0);
      destroy_component(strokecolor0);
      ctx[35](null);
      destroy_component(textcolor);
      ctx[36](null);
      destroy_component(shapes2);
      destroy_component(strokewidth1);
      destroy_component(strokecolor1);
      ctx[37](null);
      destroy_each(each_blocks, detaching);
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var name5 = "fastboard-toolbar";
function instance54($$self, $$props, $$invalidate) {
  let t;
  let hotkeys;
  let c;
  let memberState;
  let appliance;
  let shape;
  let status;
  let max_scroll;
  let $top;
  let $scroll_height, $$unsubscribe_scroll_height = noop, $$subscribe_scroll_height = () => ($$unsubscribe_scroll_height(), $$unsubscribe_scroll_height = subscribe(scroll_height, ($$value) => $$invalidate(33, $scroll_height = $$value)), scroll_height);
  let $memberState, $$unsubscribe_memberState = noop, $$subscribe_memberState = () => ($$unsubscribe_memberState(), $$unsubscribe_memberState = subscribe(memberState, ($$value) => $$invalidate(34, $memberState = $$value)), memberState);
  let $apps;
  let $status, $$unsubscribe_status = noop, $$subscribe_status = () => ($$unsubscribe_status(), $$unsubscribe_status = subscribe(status, ($$value) => $$invalidate(20, $status = $$value)), status);
  component_subscribe($$self, apps, ($$value) => $$invalidate(19, $apps = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_scroll_height());
  $$self.$$.on_destroy.push(() => $$unsubscribe_memberState());
  $$self.$$.on_destroy.push(() => $$unsubscribe_status());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { disabled = false } = $$props;
  let { scroll_height } = $$props;
  $$subscribe_scroll_height();
  let { computed_height = 0 } = $$props;
  let { scrollable = false } = $$props;
  let { hide_apps = false } = $$props;
  let last_shape = "rectangle";
  let pencil_panel;
  let text_panel;
  let shapes_panel;
  let apps_panel;
  let btn_props;
  let top = writable(0);
  component_subscribe($$self, top, (value) => $$invalidate(41, $top = value));
  function scroll_up() {
    set_store_value(top, $top = clamp($top - 32 - 4, 0, max_scroll), $top);
  }
  function scroll_down() {
    set_store_value(top, $top = clamp($top + 32 + 4, 0, max_scroll), $top);
  }
  function clicker() {
    app == null ? void 0 : app.setAppliance("clicker");
  }
  function selector() {
    app == null ? void 0 : app.setAppliance("selector");
  }
  function pencil() {
    app == null ? void 0 : app.setAppliance("pencil");
  }
  function text2() {
    app == null ? void 0 : app.setAppliance("text");
  }
  function select_last_shape() {
    if (applianceShapes.includes(last_shape)) {
      app == null ? void 0 : app.setAppliance(last_shape);
    } else {
      app == null ? void 0 : app.setAppliance("shape", last_shape);
    }
  }
  function eraser() {
    app == null ? void 0 : app.setAppliance("eraser");
  }
  function clear() {
    app == null ? void 0 : app.cleanCurrentScene();
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pencil_panel = $$value;
      $$invalidate(11, pencil_panel);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      text_panel = $$value;
      $$invalidate(12, text_panel);
    });
  }
  function div6_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      shapes_panel = $$value;
      $$invalidate(13, shapes_panel);
    });
  }
  const func = (onClick) => {
    app && onClick(app);
    tippy_hide_all();
  };
  function div7_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      apps_panel = $$value;
      $$invalidate(14, apps_panel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(2, language = $$props2.language);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("scroll_height" in $$props2)
      $$subscribe_scroll_height($$invalidate(4, scroll_height = $$props2.scroll_height));
    if ("computed_height" in $$props2)
      $$invalidate(31, computed_height = $$props2.computed_height);
    if ("scrollable" in $$props2)
      $$invalidate(5, scrollable = $$props2.scrollable);
    if ("hide_apps" in $$props2)
      $$invalidate(6, hide_apps = $$props2.hide_apps);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*theme, disabled*/
    10) {
      $$invalidate(15, btn_props = {
          name: name5,
          theme,
          disabled,
          placement: "right"
        });
    }
    if ($$self.$$.dirty[0] & /*language*/
    4) {
      $$invalidate(9, t = i18n4[language]);
    }
    if ($$self.$$.dirty[0] & /*app*/
    1) {
      $$invalidate(32, hotkeys = app == null ? void 0 : app.hotKeys);
    }
    if ($$self.$$.dirty[0] & /*t*/
    512 | $$self.$$.dirty[1] & /*hotkeys*/
    2) {
      $$invalidate(18, c = {
          clicker: tooltip(t.clicker, hotkeys == null ? void 0 : hotkeys.changeToClick),
          selector: tooltip(t.selector, hotkeys == null ? void 0 : hotkeys.changeToSelector),
          pencil: tooltip(t.pencil, hotkeys == null ? void 0 : hotkeys.changeToPencil),
          eraser: tooltip(t.eraser, hotkeys == null ? void 0 : hotkeys.changeToEraser),
          text: tooltip(t.text, hotkeys == null ? void 0 : hotkeys.changeToText)
        });
    }
    if ($$self.$$.dirty[0] & /*app*/
    1) {
      $$subscribe_memberState($$invalidate(17, memberState = app == null ? void 0 : app.memberState));
    }
    if ($$self.$$.dirty[1] & /*$memberState*/
    8) {
      $$invalidate(8, appliance = $memberState == null ? void 0 : $memberState.currentApplianceName);
    }
    if ($$self.$$.dirty[1] & /*$memberState*/
    8) {
      $$invalidate(7, shape = $memberState == null ? void 0 : $memberState.shapeType);
    }
    if ($$self.$$.dirty[0] & /*app*/
    1) {
      $$subscribe_status($$invalidate(16, status = app == null ? void 0 : app.appsStatus));
    }
    if ($$self.$$.dirty[0] & /*appliance, shape*/
    384) {
      if (applianceShapes.includes(appliance)) {
          $$invalidate(10, last_shape = appliance);
        } else if (shape) {
          $$invalidate(10, last_shape = shape);
        }
    }
    if ($$self.$$.dirty[0] & /*scrollable*/
    32 | $$self.$$.dirty[1] & /*$scroll_height, computed_height*/
    5) {
      max_scroll = scrollable ? $scroll_height + (32 + 8) * 2 - computed_height : 0;
    }
  };
  return [
    app,
    theme,
    language,
    disabled,
    scroll_height,
    scrollable,
    hide_apps,
    shape,
    appliance,
    t,
    last_shape,
    pencil_panel,
    text_panel,
    shapes_panel,
    apps_panel,
    btn_props,
    status,
    memberState,
    c,
    $apps,
    $status,
    top,
    scroll_up,
    scroll_down,
    clicker,
    selector,
    pencil,
    text2,
    select_last_shape,
    eraser,
    clear,
    computed_height,
    hotkeys,
    $scroll_height,
    $memberState,
    div2_binding,
    div3_binding,
    div6_binding,
    func,
    div7_binding
  ];
}
var Contents = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance54,
      create_fragment54,
      safe_not_equal,
      {
        app: 0,
        theme: 1,
        language: 2,
        disabled: 3,
        scroll_height: 4,
        computed_height: 31,
        scrollable: 5,
        hide_apps: 6
      },
      null,
      [-1, -1]
    );
  }
};
var Contents_default = Contents;

// src/components/Toolbar/Toolbar.svelte
function create_else_block7(ctx) {
  let path0;
  let path1;
  return {
    c() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "stroke", "#000");
      attr(path0, "d", "M20 52v16");
      attr(path0, "class", name6 + "-handler-image-stroke-color");
      attr(path1, "fill", "#000");
      attr(path1, "stroke", "none");
      attr(path1, "d", "M16 52v16l-8-8z");
      attr(path1, "class", name6 + "-handler-image-fill-color");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, path1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(path1);
    }
  };
}
function create_if_block7(ctx) {
  let path0;
  let path1;
  return {
    c() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "stroke", "#000");
      attr(path0, "d", "M10 52v16");
      attr(path0, "class", name6 + "-handler-image-stroke-color");
      attr(path1, "fill", "#000");
      attr(path1, "stroke", "none");
      attr(path1, "d", "M14 52v16l8-8z");
      attr(path1, "class", name6 + "-handler-image-fill-color");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, path1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(path1);
    }
  };
}
function create_fragment55(ctx) {
  let div1;
  let div0;
  let contents;
  let div0_class_value;
  let t0;
  let label;
  let input;
  let t1;
  let svg;
  let path0;
  let path1;
  let label_class_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  contents = new Contents_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      ),
      disabled: (
        /*disabled*/
        ctx[7]
      ),
      scroll_height: (
        /*scroll_height*/
        ctx[10]
      ),
      computed_height: (
        /*computed_height*/
        ctx[6]
      ),
      scrollable: (
        /*scrollable*/
        ctx[5]
      ),
      hide_apps: (
        /*hide_apps*/
        ctx[4]
      )
    }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*collapsed*/
      ctx2[3]
    )
      return create_if_block7;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(contents.$$.fragment);
      t0 = space();
      label = element("label");
      input = element("input");
      t1 = space();
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      if_block.c();
      attr(div0, "class", div0_class_value = name6 + "-contents " + /*theme*/
      ctx[1]);
      set_style(
        div0,
        "height",
        /*scrollable*/
        ctx[5] ? (
          /*computed_height*/
          ctx[6] + "px"
        ) : "auto"
      );
      attr(input, "type", "checkbox");
      attr(path0, "fill", "#fff");
      attr(path0, "stroke", "none");
      attr(path0, "d", "m0 0 24 16q6 4 6 14v60q0 10-6 14L0 120");
      attr(path0, "class", name6 + "-handler-bg-color");
      attr(path1, "stroke", "#000");
      attr(path1, "d", "m0 0 24 16q6 4 6 14v60q0 10-6 14L0 120");
      attr(path1, "class", name6 + "-handler-border-color");
      attr(svg, "fill", "none");
      attr(svg, "stroke-width", "2");
      attr(svg, "viewBox", "0 0 32 120");
      attr(label, "class", label_class_value = name6 + "-handler " + /*theme*/
      ctx[1]);
      attr(div1, "class", div1_class_value = name6 + " " + /*theme*/
      ctx[1]);
      toggle_class(
        div1,
        "collapsed",
        /*collapsed*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(contents, div0, null);
      append(div1, t0);
      append(div1, label);
      append(label, input);
      input.checked = /*collapsed*/
      ctx[3];
      append(label, t1);
      append(label, svg);
      append(svg, path0);
      append(svg, path1);
      if_block.m(svg, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[15]
          ),
          action_destroyer(height.call(
            null,
            div1,
            /*container_height*/
            ctx[9]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const contents_changes = {};
      if (dirty & /*app*/
      1)
        contents_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        contents_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        contents_changes.language = /*language*/
        ctx2[2];
      if (dirty & /*disabled*/
      128)
        contents_changes.disabled = /*disabled*/
        ctx2[7];
      if (dirty & /*computed_height*/
      64)
        contents_changes.computed_height = /*computed_height*/
        ctx2[6];
      if (dirty & /*scrollable*/
      32)
        contents_changes.scrollable = /*scrollable*/
        ctx2[5];
      if (dirty & /*hide_apps*/
      16)
        contents_changes.hide_apps = /*hide_apps*/
        ctx2[4];
      contents.$set(contents_changes);
      if (!current || dirty & /*theme*/
      2 && div0_class_value !== (div0_class_value = name6 + "-contents " + /*theme*/
      ctx2[1])) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*scrollable, computed_height*/
      96) {
        set_style(
          div0,
          "height",
          /*scrollable*/
          ctx2[5] ? (
            /*computed_height*/
            ctx2[6] + "px"
          ) : "auto"
        );
      }
      if (dirty & /*collapsed*/
      8) {
        input.checked = /*collapsed*/
        ctx2[3];
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(svg, null);
        }
      }
      if (!current || dirty & /*theme*/
      2 && label_class_value !== (label_class_value = name6 + "-handler " + /*theme*/
      ctx2[1])) {
        attr(label, "class", label_class_value);
      }
      if (!current || dirty & /*theme*/
      2 && div1_class_value !== (div1_class_value = name6 + " " + /*theme*/
      ctx2[1])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*theme, collapsed*/
      10) {
        toggle_class(
          div1,
          "collapsed",
          /*collapsed*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(contents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(contents);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
var name6 = "fastboard-toolbar";
function instance55($$self, $$props, $$invalidate) {
  let writable2;
  let disabled;
  let computed_height;
  let scrollable;
  let hide_apps;
  let $container_height;
  let $scroll_height;
  let $writable, $$unsubscribe_writable = noop, $$subscribe_writable = () => ($$unsubscribe_writable(), $$unsubscribe_writable = subscribe(writable2, ($$value) => $$invalidate(14, $writable = $$value)), writable2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_writable());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { config = {} } = $$props;
  const extra_height = (32 + 4 + 4) * 2;
  let collapsed = false;
  let container_height = writable(0);
  component_subscribe($$self, container_height, (value) => $$invalidate(12, $container_height = value));
  let scroll_height = writable(0);
  component_subscribe($$self, scroll_height, (value) => $$invalidate(13, $scroll_height = value));
  function input_change_handler() {
    collapsed = this.checked;
    $$invalidate(3, collapsed);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(2, language = $$props2.language);
    if ("config" in $$props2)
      $$invalidate(11, config = $$props2.config);
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*app*/
    1) {
      $$subscribe_writable($$invalidate(8, writable2 = app == null ? void 0 : app.writable));
    }
    if ($$self.$$.dirty & /*$writable*/
    16384) {
      $$invalidate(7, disabled = !$writable);
    }
    if ($$self.$$.dirty & /*$container_height, $scroll_height*/
    12288) {
      $$invalidate(6, computed_height = clamp($container_height, extra_height, $scroll_height + extra_height));
    }
    if ($$self.$$.dirty & /*$scroll_height, $container_height*/
    12288) {
      $$invalidate(5, scrollable = $scroll_height + extra_height > $container_height);
    }
    if ($$self.$$.dirty & /*config*/
    2048) {
      $$invalidate(4, hide_apps = ((_a = config.apps) == null ? void 0 : _a.enable) === false);
    }
  };
  return [
    app,
    theme,
    language,
    collapsed,
    hide_apps,
    scrollable,
    computed_height,
    disabled,
    writable2,
    container_height,
    scroll_height,
    config,
    $container_height,
    $scroll_height,
    $writable,
    input_change_handler
  ];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, {
      app: 0,
      theme: 1,
      language: 2,
      config: 11
    });
  }
};
var Toolbar_default = Toolbar;

// src/components/PlayerControl/PlayerControl.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_else_block_13(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.play[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[play]",
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.play[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      268435457) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.pause[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[pause]",
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.pause[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      268435457) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      src: (
        /*icons*/
        (_a = ctx[1]) == null ? void 0 : _a.loading[
          /*type*/
          ctx[5]
        ]
      ),
      alt: "[loading]",
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const icon_changes = {};
      if (dirty & /*icons, type*/
      34)
        icon_changes.src = /*icons*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.loading[
          /*type*/
          ctx2[5]
        ];
      if (dirty & /*$$scope, theme*/
      268435457) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_default_slot_54(ctx) {
  let icons_play;
  let current;
  icons_play = new Icons_default.Play({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_play.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_play, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_play_changes = {};
      if (dirty & /*theme*/
      1)
        icons_play_changes.theme = /*theme*/
        ctx2[0];
      icons_play.$set(icons_play_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_play.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_play.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_play, detaching);
    }
  };
}
function create_default_slot_44(ctx) {
  let icons_pause;
  let current;
  icons_pause = new Icons_default.Pause({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_pause.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_pause, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_pause_changes = {};
      if (dirty & /*theme*/
      1)
        icons_pause_changes.theme = /*theme*/
        ctx2[0];
      icons_pause.$set(icons_pause_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_pause.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_pause.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_pause, detaching);
    }
  };
}
function create_default_slot_35(ctx) {
  let icons_loading;
  let current;
  icons_loading = new Icons_default.Loading({ props: { theme: (
    /*theme*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(icons_loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icons_loading, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icons_loading_changes = {};
      if (dirty & /*theme*/
      1)
        icons_loading_changes.theme = /*theme*/
        ctx2[0];
      icons_loading.$set(icons_loading_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icons_loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icons_loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icons_loading, detaching);
    }
  };
}
function create_default_slot_25(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_if_block_22, create_else_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[3]
    )
      return 0;
    if (
      /*playing*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block8(ctx) {
  let slider;
  let t0;
  let span3;
  let span0;
  let t1_value = format(
    /*$current*/
    ctx[13]
  ) + "";
  let t1;
  let t2;
  let span1;
  let t3;
  let t4;
  let span2;
  let t5_value = format(
    /*$duration*/
    ctx[14]
  ) + "";
  let t5;
  let current;
  slider = new Slider_default({
    props: {
      class: name7 + "-slider",
      theme: (
        /*theme*/
        ctx[0]
      ),
      value: (
        /*$current*/
        ctx[13] / 1e3
      ),
      min: 0,
      max: (
        /*$duration*/
        ctx[14] / 1e3
      )
    }
  });
  slider.$on(
    "change",
    /*seek*/
    ctx[17]
  );
  return {
    c() {
      create_component(slider.$$.fragment);
      t0 = space();
      span3 = element("span");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      t3 = text("/");
      t4 = space();
      span2 = element("span");
      t5 = text(t5_value);
      attr(span0, "class", name7 + "-current");
      attr(span1, "class", name7 + "-slash");
      attr(span2, "class", name7 + "-duration");
      attr(span3, "class", name7 + "-progress");
    },
    m(target, anchor) {
      mount_component(slider, target, anchor);
      insert(target, t0, anchor);
      insert(target, span3, anchor);
      append(span3, span0);
      append(span0, t1);
      append(span3, t2);
      append(span3, span1);
      append(span1, t3);
      append(span3, t4);
      append(span3, span2);
      append(span2, t5);
      current = true;
    },
    p(ctx2, dirty) {
      const slider_changes = {};
      if (dirty & /*theme*/
      1)
        slider_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*$current*/
      8192)
        slider_changes.value = /*$current*/
        ctx2[13] / 1e3;
      if (dirty & /*$duration*/
      16384)
        slider_changes.max = /*$duration*/
        ctx2[14] / 1e3;
      slider.$set(slider_changes);
      if ((!current || dirty & /*$current*/
      8192) && t1_value !== (t1_value = format(
        /*$current*/
        ctx2[13]
      ) + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*$duration*/
      16384) && t5_value !== (t5_value = format(
        /*$duration*/
        ctx2[14]
      ) + ""))
        set_data(t5, t5_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slider, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span3);
    }
  };
}
function create_if_block8(ctx) {
  let slider;
  let t0;
  let span;
  let t1;
  let current;
  slider = new Slider_default({
    props: {
      class: name7 + "-slider",
      disabled: true
    }
  });
  return {
    c() {
      create_component(slider.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text("\u2026/\u2026");
      attr(span, "class", name7 + "-progress loading");
    },
    m(target, anchor) {
      mount_component(slider, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slider, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_15(ctx) {
  let span;
  let t0_value = (
    /*$playbackRate*/
    (ctx[15] || 1) + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text("x");
      attr(span, "class", name7 + "-speed-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$playbackRate*/
      32768 && t0_value !== (t0_value = /*$playbackRate*/
      (ctx2[15] || 1) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot5(ctx) {
  let t0_value = (
    /*s*/
    ctx[25] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text("x\n      ");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block5(key_1, ctx) {
  let first;
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[23](
        /*s*/
        ctx[25]
      )
    );
  }
  button = new Button_default({
    props: {
      class: "speed " + /*s*/
      (ctx[25] === /*$playbackRate*/
      ctx[15] ? "is-active" : ""),
      name: name7,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(button.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$playbackRate*/
      32768)
        button_changes.class = "speed " + /*s*/
        (ctx[25] === /*$playbackRate*/
        ctx[15] ? "is-active" : "");
      if (dirty & /*theme*/
      1)
        button_changes.theme = /*theme*/
        ctx[0];
      if (dirty & /*disabled*/
      16)
        button_changes.disabled = /*disabled*/
        ctx[4];
      if (dirty & /*$$scope*/
      268435456) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(button, detaching);
    }
  };
}
function create_fragment56(ctx) {
  let div0;
  let button0;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let button1;
  let div0_class_value;
  let t2;
  let div2;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  button0 = new Button_default({
    props: {
      class: (
        /*className*/
        ctx[7]
      ),
      name: name7,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      content: (
        /*loading*/
        ctx[3] ? "" : (
          /*playing*/
          ctx[2] ? (
            /*t*/
            ctx[12].pause
          ) : (
            /*t*/
            ctx[12].play
          )
        )
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*toggle*/
    ctx[16]
  );
  const if_block_creators = [create_if_block8, create_else_block8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$current*/
      ctx2[13] == null || /*$duration*/
      ctx2[14] == null || /*$duration*/
      ctx2[14] === 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  button1 = new Button_default({
    props: {
      class: "speed",
      name: name7,
      theme: (
        /*theme*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[4]
      ),
      content: (
        /*t*/
        ctx[12].speed
      ),
      menu: (
        /*speed_panel*/
        ctx[6]
      ),
      menu_placement: "top-end",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  let each_value = speeds;
  const get_key = (ctx2) => (
    /*s*/
    ctx2[25]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  return {
    c() {
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      create_component(button1.$$.fragment);
      t2 = space();
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", div0_class_value = name7 + " " + /*theme*/
      ctx[0]);
      attr(div1, "class", name7 + "-panel speed");
      set_style(div2, "display", "none");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(button0, div0, null);
      append(div0, t0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t1);
      mount_component(button1, div0, null);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      ctx[24](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*className*/
      128)
        button0_changes.class = /*className*/
        ctx2[7];
      if (dirty & /*theme*/
      1)
        button0_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*disabled*/
      16)
        button0_changes.disabled = /*disabled*/
        ctx2[4];
      if (dirty & /*loading, playing, t*/
      4108)
        button0_changes.content = /*loading*/
        ctx2[3] ? "" : (
          /*playing*/
          ctx2[2] ? (
            /*t*/
            ctx2[12].pause
          ) : (
            /*t*/
            ctx2[12].play
          )
        );
      if (dirty & /*$$scope, icons, type, theme, loading, playing*/
      268435503) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, t1);
      }
      const button1_changes = {};
      if (dirty & /*theme*/
      1)
        button1_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*disabled*/
      16)
        button1_changes.disabled = /*disabled*/
        ctx2[4];
      if (dirty & /*t*/
      4096)
        button1_changes.content = /*t*/
        ctx2[12].speed;
      if (dirty & /*speed_panel*/
      64)
        button1_changes.menu = /*speed_panel*/
        ctx2[6];
      if (dirty & /*$$scope, $playbackRate*/
      268468224) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      if (!current || dirty & /*theme*/
      1 && div0_class_value !== (div0_class_value = name7 + " " + /*theme*/
      ctx2[0])) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*speeds, $playbackRate, name, theme, disabled, setPlaybackRate*/
      294929) {
        each_value = speeds;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block5, null, get_each_context5);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(if_block);
      transition_in(button1.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(if_block);
      transition_out(button1.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(button0);
      if_blocks[current_block_type_index].d();
      destroy_component(button1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[24](null);
    }
  };
}
var speeds = [2, 1.5, 1.25, 1, 0.75, 0.5];
var i18n6 = {
  en: {
    play: "Play",
    pause: "Pause",
    speed: "Speed"
  },
  "zh-CN": {
    play: "\u64AD\u653E",
    pause: "\u6682\u505C",
    speed: "\u901F\u5EA6"
  }
};
function format(ms) {
  const s = Math.floor(ms / 1e3);
  const m = Math.floor(s / 60);
  return String(m).padStart(2, "0") + ":" + String(s % 60).padStart(2, "0");
}
var name7 = "fastboard-player-control";
function instance56($$self, $$props, $$invalidate) {
  let t;
  let canPlay;
  let disabled;
  let duration;
  let current;
  let playbackRate;
  let phase;
  let loading;
  let playing;
  let className;
  let $phase, $$unsubscribe_phase = noop, $$subscribe_phase = () => ($$unsubscribe_phase(), $$unsubscribe_phase = subscribe(phase, ($$value) => $$invalidate(22, $phase = $$value)), phase);
  let $current, $$unsubscribe_current = noop, $$subscribe_current = () => ($$unsubscribe_current(), $$unsubscribe_current = subscribe(current, ($$value) => $$invalidate(13, $current = $$value)), current);
  let $duration, $$unsubscribe_duration = noop, $$subscribe_duration = () => ($$unsubscribe_duration(), $$unsubscribe_duration = subscribe(duration, ($$value) => $$invalidate(14, $duration = $$value)), duration);
  let $playbackRate, $$unsubscribe_playbackRate = noop, $$subscribe_playbackRate = () => ($$unsubscribe_playbackRate(), $$unsubscribe_playbackRate = subscribe(playbackRate, ($$value) => $$invalidate(15, $playbackRate = $$value)), playbackRate);
  $$self.$$.on_destroy.push(() => $$unsubscribe_phase());
  $$self.$$.on_destroy.push(() => $$unsubscribe_current());
  $$self.$$.on_destroy.push(() => $$unsubscribe_duration());
  $$self.$$.on_destroy.push(() => $$unsubscribe_playbackRate());
  let { player = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { icons = void 0 } = $$props;
  let type;
  let speed_panel;
  function toggle() {
    if (!player)
      return;
    switch (player.player.phase) {
      case "waitingFirstFrame":
      case "pause":
      case "ended": {
        player.play();
        break;
      }
      case "playing": {
        player.pause();
        break;
      }
    }
  }
  function seek({ detail: seconds }) {
    if (!player)
      return;
    player.seek(seconds * 1e3);
  }
  function setPlaybackRate(speed) {
    if (!player)
      return;
    player.setPlaybackRate(speed);
  }
  const click_handler = (s) => setPlaybackRate(s);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      speed_panel = $$value;
      $$invalidate(6, speed_panel);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("player" in $$props2)
      $$invalidate(19, player = $$props2.player);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(20, language = $$props2.language);
    if ("icons" in $$props2)
      $$invalidate(1, icons = $$props2.icons);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*language*/
    1048576) {
      $$invalidate(12, t = i18n6[language]);
    }
    if ($$self.$$.dirty & /*player*/
    524288) {
      $$invalidate(21, canPlay = player == null ? void 0 : player.canplay);
    }
    if ($$self.$$.dirty & /*canPlay*/
    2097152) {
      $$invalidate(4, disabled = !canPlay);
    }
    if ($$self.$$.dirty & /*disabled*/
    16) {
      $$invalidate(5, type = disabled ? "disable" : "normal");
    }
    if ($$self.$$.dirty & /*player*/
    524288) {
      $$subscribe_duration($$invalidate(11, duration = player == null ? void 0 : player.duration));
    }
    if ($$self.$$.dirty & /*player*/
    524288) {
      $$subscribe_current($$invalidate(10, current = player == null ? void 0 : player.currentTime));
    }
    if ($$self.$$.dirty & /*player*/
    524288) {
      $$subscribe_playbackRate($$invalidate(9, playbackRate = player == null ? void 0 : player.playbackRate));
    }
    if ($$self.$$.dirty & /*player*/
    524288) {
      $$subscribe_phase($$invalidate(8, phase = player == null ? void 0 : player.phase));
    }
    if ($$self.$$.dirty & /*$phase*/
    4194304) {
      $$invalidate(3, loading = $phase === "waitingFirstFrame" || $phase === "buffering");
    }
    if ($$self.$$.dirty & /*$phase*/
    4194304) {
      $$invalidate(2, playing = $phase === "playing");
    }
    if ($$self.$$.dirty & /*loading, playing*/
    12) {
      $$invalidate(7, className = [loading ? "loading" : "", playing ? "pause" : "play"].filter(Boolean).join(" "));
    }
  };
  return [
    theme,
    icons,
    playing,
    loading,
    disabled,
    type,
    speed_panel,
    className,
    phase,
    playbackRate,
    current,
    duration,
    t,
    $current,
    $duration,
    $playbackRate,
    toggle,
    seek,
    setPlaybackRate,
    player,
    language,
    canPlay,
    $phase,
    click_handler,
    div1_binding
  ];
}
var PlayerControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment56, safe_not_equal, {
      player: 19,
      theme: 0,
      language: 20,
      icons: 1
    });
  }
};
var PlayerControl_default = PlayerControl;

// src/components/Fastboard/ReplayFastboard.svelte
function create_if_block9(ctx) {
  let playercontrol;
  let current;
  playercontrol = new PlayerControl_default({
    props: {
      player: (
        /*player*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(playercontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(playercontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const playercontrol_changes = {};
      if (dirty & /*player*/
      1)
        playercontrol_changes.player = /*player*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        playercontrol_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        playercontrol_changes.language = /*language*/
        ctx2[2];
      playercontrol.$set(playercontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(playercontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(playercontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(playercontrol, detaching);
    }
  };
}
function create_fragment57(ctx) {
  var _a;
  let div2;
  let div0;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*config*/
    ((_a = ctx[3].player_control) == null ? void 0 : _a.enable) !== false && create_if_block9(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", name8 + "-view");
      attr(div1, "class", name8 + "-bottom");
      attr(div2, "class", name8 + "-root");
      toggle_class(div2, "loading", !/*player*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      ctx[8](div0);
      append(div2, t);
      append(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "touchstart",
          /*focus_me*/
          ctx[5],
          { passive: true, capture: true }
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (
        /*config*/
        ((_a2 = ctx2[3].player_control) == null ? void 0 : _a2.enable) !== false
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*config*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*player*/
      1) {
        toggle_class(div2, "loading", !/*player*/
        ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      ctx[8](null);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
var name8 = "fastboard";
function instance57($$self, $$props, $$invalidate) {
  let { player = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { containerRef = void 0 } = $$props;
  let { config = {} } = $$props;
  let container;
  let mounted = false;
  onMount(() => {
    if (containerRef) {
      containerRef(container);
      return () => {
        if (containerRef)
          containerRef(null);
      };
    }
  });
  function focus_me() {
    tippy_hide_all();
    let a = document.activeElement;
    a && a.blur && a.blur();
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(4, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("player" in $$props2)
      $$invalidate(0, player = $$props2.player);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(2, language = $$props2.language);
    if ("containerRef" in $$props2)
      $$invalidate(6, containerRef = $$props2.containerRef);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*player, container*/
    17) {
      try {
          if (player && container) {
            player.bindContainer(container);
            $$invalidate(7, mounted = true);
          }
        } catch (err) {
          console.error("[fastboard] An error occurred while binding container");
          console.error(err);
        }
    }
    if ($$self.$$.dirty & /*player, theme, mounted*/
    131) {
      if (player && theme && mounted) {
          player.manager.setPrefersColorScheme(theme);
        }
    }
  };
  return [
    player,
    theme,
    language,
    config,
    container,
    focus_me,
    containerRef,
    mounted,
    div0_binding
  ];
}
var ReplayFastboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment57, not_equal, {
      player: 0,
      theme: 1,
      language: 2,
      containerRef: 6,
      config: 3
    });
  }
};
var ReplayFastboard_default = ReplayFastboard;

// src/components/Fastboard/Fastboard.svelte
function create_if_block_32(ctx) {
  let toolbar;
  let current;
  toolbar = new Toolbar_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      ),
      config: (
        /*config*/
        ctx[3].toolbar
      )
    }
  });
  return {
    c() {
      create_component(toolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toolbar_changes = {};
      if (dirty & /*app*/
      1)
        toolbar_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        toolbar_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        toolbar_changes.language = /*language*/
        ctx2[2];
      if (dirty & /*config*/
      8)
        toolbar_changes.config = /*config*/
        ctx2[3].toolbar;
      toolbar.$set(toolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let redoundo;
  let current;
  redoundo = new RedoUndo_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(redoundo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(redoundo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const redoundo_changes = {};
      if (dirty & /*app*/
      1)
        redoundo_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        redoundo_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        redoundo_changes.language = /*language*/
        ctx2[2];
      redoundo.$set(redoundo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(redoundo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(redoundo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(redoundo, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let zoomcontrol;
  let current;
  zoomcontrol = new ZoomControl_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(zoomcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(zoomcontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const zoomcontrol_changes = {};
      if (dirty & /*app*/
      1)
        zoomcontrol_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        zoomcontrol_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        zoomcontrol_changes.language = /*language*/
        ctx2[2];
      zoomcontrol.$set(zoomcontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(zoomcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(zoomcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(zoomcontrol, detaching);
    }
  };
}
function create_if_block10(ctx) {
  let pagecontrol;
  let current;
  pagecontrol = new PageControl_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      language: (
        /*language*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(pagecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pagecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pagecontrol_changes = {};
      if (dirty & /*app*/
      1)
        pagecontrol_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*theme*/
      2)
        pagecontrol_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*language*/
      4)
        pagecontrol_changes.language = /*language*/
        ctx2[2];
      pagecontrol.$set(pagecontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pagecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pagecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pagecontrol, detaching);
    }
  };
}
function create_fragment58(ctx) {
  var _a, _b, _c, _d;
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let t3;
  let div3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*config*/
    ((_a = ctx[3].toolbar) == null ? void 0 : _a.enable) !== false && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*config*/
    ((_b = ctx[3].redo_undo) == null ? void 0 : _b.enable) !== false && create_if_block_23(ctx)
  );
  let if_block2 = (
    /*config*/
    ((_c = ctx[3].zoom_control) == null ? void 0 : _c.enable) !== false && create_if_block_14(ctx)
  );
  let if_block3 = (
    /*config*/
    ((_d = ctx[3].page_control) == null ? void 0 : _d.enable) !== false && create_if_block10(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      div3 = element("div");
      if (if_block3)
        if_block3.c();
      attr(div0, "class", name9 + "-view");
      attr(div1, "class", name9 + "-left");
      toggle_class(div1, "hidden", !/*layout*/
      (ctx[5] === "visible" || /*layout*/
      ctx[5] === "toolbar-only"));
      attr(div2, "class", name9 + "-bottom-left");
      toggle_class(
        div2,
        "hidden",
        /*layout*/
        ctx[5] !== "visible"
      );
      attr(div3, "class", name9 + "-bottom-right");
      toggle_class(
        div3,
        "hidden",
        /*layout*/
        ctx[5] !== "visible"
      );
      attr(div4, "class", name9 + "-root");
      toggle_class(div4, "loading", !/*app*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      ctx[15](div0);
      append(div4, t0);
      append(div4, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div4, t1);
      append(div4, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div4, t3);
      append(div4, div3);
      if (if_block3)
        if_block3.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "touchstart",
          /*focus_me*/
          ctx[9],
          { passive: true, capture: true }
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      if (
        /*config*/
        ((_a2 = ctx2[3].toolbar) == null ? void 0 : _a2.enable) !== false
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*config*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*layout*/
      32) {
        toggle_class(div1, "hidden", !/*layout*/
        (ctx2[5] === "visible" || /*layout*/
        ctx2[5] === "toolbar-only"));
      }
      if (
        /*config*/
        ((_b2 = ctx2[3].redo_undo) == null ? void 0 : _b2.enable) !== false
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*config*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_23(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*config*/
        ((_c2 = ctx2[3].zoom_control) == null ? void 0 : _c2.enable) !== false
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*config*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_14(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*layout*/
      32) {
        toggle_class(
          div2,
          "hidden",
          /*layout*/
          ctx2[5] !== "visible"
        );
      }
      if (
        /*config*/
        ((_d2 = ctx2[3].page_control) == null ? void 0 : _d2.enable) !== false
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*config*/
          8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block10(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*layout*/
      32) {
        toggle_class(
          div3,
          "hidden",
          /*layout*/
          ctx2[5] !== "visible"
        );
      }
      if (!current || dirty & /*app*/
      1) {
        toggle_class(div4, "loading", !/*app*/
        ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      dispose();
    }
  };
}
var name9 = "fastboard";
function instance58($$self, $$props, $$invalidate) {
  let writable2;
  let boxState;
  let focusedApp;
  let $focusedApp, $$unsubscribe_focusedApp = noop, $$subscribe_focusedApp = () => ($$unsubscribe_focusedApp(), $$unsubscribe_focusedApp = subscribe(focusedApp, ($$value) => $$invalidate(12, $focusedApp = $$value)), focusedApp);
  let $boxState, $$unsubscribe_boxState = noop, $$subscribe_boxState = () => ($$unsubscribe_boxState(), $$unsubscribe_boxState = subscribe(boxState, ($$value) => $$invalidate(13, $boxState = $$value)), boxState);
  let $writable, $$unsubscribe_writable = noop, $$subscribe_writable = () => ($$unsubscribe_writable(), $$unsubscribe_writable = subscribe(writable2, ($$value) => $$invalidate(14, $writable = $$value)), writable2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_focusedApp());
  $$self.$$.on_destroy.push(() => $$unsubscribe_boxState());
  $$self.$$.on_destroy.push(() => $$unsubscribe_writable());
  let { app = null } = $$props;
  let { theme = "light" } = $$props;
  let { language = "en" } = $$props;
  let { containerRef = void 0 } = $$props;
  let { config = {} } = $$props;
  const AppsShowToolbar = ["DocsViewer", "Slide"];
  let container;
  let layout = "hidden";
  let mounted = false;
  onMount(() => {
    if (containerRef) {
      containerRef(container);
      return () => {
        if (containerRef)
          containerRef(null);
      };
    }
  });
  function focus_me() {
    tippy_hide_all();
    let a = document.activeElement;
    a && a.blur && a.blur();
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(4, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("language" in $$props2)
      $$invalidate(2, language = $$props2.language);
    if ("containerRef" in $$props2)
      $$invalidate(10, containerRef = $$props2.containerRef);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*app*/
    1) {
      $$subscribe_writable($$invalidate(8, writable2 = app == null ? void 0 : app.writable));
    }
    if ($$self.$$.dirty & /*app*/
    1) {
      $$subscribe_boxState($$invalidate(7, boxState = app == null ? void 0 : app.boxState));
    }
    if ($$self.$$.dirty & /*app*/
    1) {
      $$subscribe_focusedApp($$invalidate(6, focusedApp = app == null ? void 0 : app.focusedApp));
    }
    if ($$self.$$.dirty & /*$writable, $boxState, $focusedApp*/
    28672) {
      if (!$writable) {
          $$invalidate(5, layout = "hidden");
        } else if ($boxState === "maximized") {
          if ($focusedApp && AppsShowToolbar.some((kind) => ($focusedApp || "").includes(kind))) {
            $$invalidate(5, layout = "toolbar-only");
          } else {
            $$invalidate(5, layout = "hidden");
          }
        } else {
          $$invalidate(5, layout = "visible");
        }
    }
    if ($$self.$$.dirty & /*app, container*/
    17) {
      try {
          if (app && container) {
            app.bindContainer(container);
            $$invalidate(11, mounted = true);
          }
        } catch (err) {
          console.error("[fastboard] An error occurred while binding container");
          console.error(err);
        }
    }
    if ($$self.$$.dirty & /*app, theme, mounted*/
    2051) {
      if (app && theme && mounted) {
          app.manager.setPrefersColorScheme(theme);
        }
    }
  };
  return [
    app,
    theme,
    language,
    config,
    container,
    layout,
    focusedApp,
    boxState,
    writable2,
    focus_me,
    containerRef,
    mounted,
    $focusedApp,
    $boxState,
    $writable,
    div0_binding
  ];
}
var Fastboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance58, create_fragment58, not_equal, {
      app: 0,
      theme: 1,
      language: 2,
      containerRef: 10,
      config: 3
    });
  }
};
var Fastboard_default = Fastboard;

// src/helpers/index.ts
function createUI(app, div) {
  let fastboard;
  const ui = {
    mount(div2, props) {
      if (fastboard) {
        fastboard.$destroy();
      }
      fastboard = new Fastboard_default({ target: div2, props: __spreadValues({ app }, props) });
      return ui;
    },
    update(props) {
      if (fastboard && props) {
        fastboard.$set(props);
      }
    },
    destroy() {
      if (fastboard) {
        fastboard.$destroy();
      }
      fastboard = void 0;
    }
  };
  if (div) {
    ui.mount(div, { app });
  }
  return ui;
}
function createReplayUI(player, div) {
  let fastboard;
  const ui = {
    mount(div2, props) {
      if (fastboard) {
        fastboard.$destroy();
      }
      fastboard = new ReplayFastboard_default({ target: div2, props: __spreadValues({ player }, props) });
      return ui;
    },
    update(props) {
      if (fastboard && props) {
        fastboard.$set(props);
      }
    },
    destroy() {
      if (fastboard) {
        fastboard.$destroy();
      }
      fastboard = void 0;
    }
  };
  if (div) {
    ui.mount(div, { player });
  }
  return ui;
}

export { Fastboard_default as Fastboard, PageControl_default as PageControl, PlayerControl_default as PlayerControl, RedoUndo_default as RedoUndo, ReplayFastboard_default as ReplayFastboard, SvelteComponentTyped, Toolbar_default as Toolbar, ZoomControl_default as ZoomControl, apps, createReplayUI, createUI };
//# sourceMappingURL=index.mjs.map
