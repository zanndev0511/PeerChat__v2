{"version":3,"file":"synced-store.cjs.js","sources":["../src/utils.ts","../src/refine.ts","../src/storage.ts","../src/synced-store.ts","../src/invisible-plugin.ts","../src/create-plugin.ts"],"sourcesContent":["declare module \"white-web-sdk\" {\n  export function isRoom(displayer: Displayer): displayer is Room;\n}\n\nexport const isObject = <O>(obj?: O): obj is O =>\n  typeof obj === \"object\" && obj !== null;\n\nexport const ensureObject = (obj: any, method: string): void => {\n  if (!isObject(obj)) {\n    throw new TypeError(\n      `[SyncedStore]: ${method} expects an object, got ${typeof obj}`\n    );\n  }\n};\n\nconst objHas = Object.prototype.hasOwnProperty;\n\nexport const has = <O, K extends string>(\n  obj: O,\n  key: K\n): obj is O & Record<K, Required<O>[Extract<K, keyof O>]> => {\n  return objHas.call(obj, key);\n};\n\nexport const plainObjectKeys = Object.keys as <T>(\n  o: T\n) => Array<Extract<keyof T, string>>;\n\nexport const toJS = <O>(obj: O): O => {\n  return isObject(obj) ? JSON.parse(JSON.stringify(obj)) : obj;\n};\n","import { genUID } from \"side-effect-manager\";\nimport type { Diff, DiffOne } from \"./typings\";\nimport { has, isObject, plainObjectKeys } from \"./utils\";\n\nconst REFINE_KEY = \"__IsReFiNe\";\n\nexport type RefineValue<TValue = any> = {\n  k: string;\n  v: TValue;\n  [REFINE_KEY]: 1;\n};\n\nexport type MaybeRefineValue<TValue = any> = TValue | RefineValue<TValue>;\n\nexport type RefineState<TState = any> = {\n  [K in keyof TState]: MaybeRefineValue<TState[K]>;\n};\n\nexport type ExtractRawValue<TValue> = TValue extends RefineValue<\n  infer TRefineValue\n>\n  ? TRefineValue\n  : TValue;\n\nexport function isRefineValue<TValue>(\n  value: MaybeRefineValue<TValue>\n): value is RefineValue<TValue> {\n  return isObject(value) && (value as RefineValue<TValue>)[REFINE_KEY] === 1;\n}\n\nexport function isMaybeRefineValue<TValue>(\n  value: MaybeRefineValue<TValue>\n): value is MaybeRefineValue<TValue> {\n  return !isObject(value) || (value as RefineValue<TValue>)[REFINE_KEY] === 1;\n}\n\nexport function makeRefineValue<TValue>(\n  value: TValue,\n  key: string = genUID()\n): RefineValue<TValue> {\n  return { [REFINE_KEY]: 1, k: key, v: value };\n}\n\nexport class Refine<TState = any> {\n  public state: TState;\n\n  public constructor(refState?: RefineState<TState>, defaultState?: TState) {\n    this.state = {} as TState;\n    this.replaceState(refState || defaultState || ({} as TState));\n  }\n\n  public replaceState(state: RefineState<TState>): Diff<TState> | null {\n    if (!isObject(state)) {\n      throw new Error(\"[SyncedStore] replaceState: state must be an object\");\n    }\n    const diff = {} as Diff<TState>;\n    let hasDiff = false;\n    const allKeys = new Set([\n      ...plainObjectKeys(this.state),\n      ...plainObjectKeys(state),\n    ]);\n    allKeys.forEach(key => {\n      const diffOne = this.setValue(key, state[key]);\n      if (diffOne) {\n        hasDiff = true;\n        diff[key] = diffOne;\n      }\n    });\n    return hasDiff ? diff : null;\n  }\n\n  public toRefState(): RefineState<TState> {\n    return plainObjectKeys(this.state).reduce((refState, key) => {\n      refState[key] = this.toRefValue(this.state[key]);\n      return refState;\n    }, {} as RefineState<TState>);\n  }\n\n  public setValue<TKey extends Extract<keyof TState, string>>(\n    key: TKey,\n    maybeRefValue: MaybeRefineValue<TState[TKey]> | undefined\n  ): DiffOne<TState[TKey]> | null {\n    if (isObject(maybeRefValue)) {\n      const refValue = this.ensureRefValue(maybeRefValue);\n      if (this.state[key] !== refValue.v) {\n        const oldValue = this.deleteRefKey(key);\n        this.state[key] = refValue.v;\n        return { oldValue, newValue: refValue.v };\n      }\n    } else if (typeof maybeRefValue === \"undefined\") {\n      if (has(this.state, key)) {\n        const oldValue = this.deleteRefKey(key);\n        delete this.state[key];\n        return { oldValue, newValue: undefined as unknown as TState[TKey] };\n      }\n    } else {\n      const value = maybeRefValue as TState[TKey];\n      if (this.state[key] !== value) {\n        const oldValue = this.deleteRefKey(key);\n        this.state[key] = value;\n        return { oldValue, newValue: value };\n      }\n    }\n    return null;\n  }\n\n  public toRefValue<TKey extends Extract<keyof TState, string>>(\n    maybeRefValue: MaybeRefineValue<TState[TKey]>\n  ): RefineValue<TState[TKey]> {\n    return isObject(maybeRefValue)\n      ? this.ensureRefValue(maybeRefValue)\n      : maybeRefValue;\n  }\n\n  public ensureRefValue<TValue>(\n    value: MaybeRefineValue<TValue>\n  ): RefineValue<TValue> {\n    if (isRefineValue(value)) {\n      this.refMap.set(value.v, value);\n      return value;\n    }\n    let refValue = this.refMap.get(value);\n    if (!refValue) {\n      refValue = makeRefineValue(value, this.genKey());\n      this.refMap.set(value, refValue);\n    }\n    this.refKeys.add(refValue.k);\n    return refValue;\n  }\n\n  private refMap: Map<any, RefineValue<any>> = new Map();\n\n  private refKeys = new Set<string>();\n  private genKey = (): string => {\n    let key: string;\n    do {\n      key = genUID();\n    } while (this.refKeys.has(key));\n    this.refKeys.add(key);\n    return key;\n  };\n\n  private deleteRefKey<TKey extends Extract<keyof TState, string>>(\n    key: TKey\n  ): TState[TKey] {\n    const value = this.state[key];\n    const refValue = this.refMap.get(value);\n    if (refValue) {\n      this.refKeys.delete(refValue.k);\n    }\n    return value;\n  }\n}\n","import type { ReadonlyVal } from \"value-enhancer\";\nimport type { AkkoObjectUpdatedListener, InvisiblePlugin } from \"white-web-sdk\";\nimport {\n  listenUpdated,\n  reaction,\n  RoomPhase,\n  unlistenUpdated,\n  toJS,\n} from \"white-web-sdk\";\nimport type { Diff } from \"./typings\";\nimport { isObject, plainObjectKeys } from \"./utils\";\nimport type { RefineState } from \"./refine\";\nimport { Refine } from \"./refine\";\nimport type { SideEffectDisposer } from \"side-effect-manager\";\nimport { SideEffectManager } from \"side-effect-manager\";\nimport type {\n  RemitterDisposer,\n  RemitterEventNames,\n  RemitterListener,\n} from \"remitter\";\nimport { Remitter } from \"remitter\";\n\nexport const STORAGE_NS = \"_WM-StOrAgE_\";\n\nexport const MAIN_STORAGE = \"_WM-MaIn-StOrAgE_\";\n\nexport interface StorageEventData<TState> {\n  stateChanged: Diff<TState>;\n  disconnected: void;\n}\n\nexport interface StorageConfig<TState = any> {\n  namespace?: string;\n  plugin$: ReadonlyVal<InvisiblePlugin<any> | null>;\n  isWritable$: ReadonlyVal<boolean>;\n  defaultState?: TState;\n}\n\nexport class Storage<TState extends Record<string, any> = any> {\n  public readonly namespace: string;\n  public defaultState: Readonly<TState>;\n  private _plugin$: StorageConfig[\"plugin$\"];\n  private _isWritable$: StorageConfig[\"isWritable$\"];\n  private _refine: Refine<TState>;\n  private _sideEffect = new SideEffectManager();\n  private _events = new Remitter<StorageEventData<TState>>();\n\n  public constructor({\n    plugin$,\n    isWritable$,\n    namespace = MAIN_STORAGE,\n    defaultState = {} as TState,\n  }: StorageConfig<TState>) {\n    if (defaultState && !isObject(defaultState)) {\n      throw new Error(\n        `Default state for Storage ${namespace} is not an object.`\n      );\n    }\n\n    this.on = this._events.on.bind(this._events);\n    this.off = this._events.off.bind(this._events);\n\n    const getRawState = (): RefineState<TState> =>\n      plugin$.value?.attributes[STORAGE_NS]?.[namespace];\n\n    this.namespace = namespace;\n    this.defaultState = defaultState;\n    this._plugin$ = plugin$;\n    this._isWritable$ = isWritable$;\n    this._refine = new Refine(toJS(getRawState()), defaultState);\n\n    const onDiff = (diff: Diff<TState> | null): void => {\n      if (diff) {\n        this._events.emit(\"stateChanged\", diff);\n      }\n    };\n\n    const ensureInitState = (\n      plugin: InvisiblePlugin<any>\n    ): SideEffectDisposer => {\n      return isWritable$.subscribe(isWritable => {\n        if (isWritable) {\n          if (!isObject(plugin.attributes[STORAGE_NS])) {\n            plugin.updateAttributes([STORAGE_NS], {});\n          }\n          if (!isObject(toJS(getRawState()))) {\n            plugin.updateAttributes(\n              [STORAGE_NS, namespace],\n              this._refine.toRefState()\n            );\n          }\n        }\n      });\n    };\n\n    const listenNamespaceProps = (\n      rawState: RefineState<TState>\n    ): SideEffectDisposer => {\n      const handler: AkkoObjectUpdatedListener<TState> = actions => {\n        if (actions.length <= 0) return;\n        const diff = {} as Diff<TState>;\n        let hasDiff = false;\n        for (let i = 0; i < actions.length; i++) {\n          const action = actions[i];\n          const key = action.key as Extract<keyof TState, string>;\n          if (key === STORAGE_NS) {\n            continue;\n          }\n\n          const value = toJS(action.value);\n          const diffOne = this._refine.setValue(key, value);\n          if (diffOne) {\n            hasDiff = true;\n            diff[key] = diffOne;\n          }\n        }\n        if (hasDiff) {\n          onDiff(diff);\n        }\n      };\n      listenUpdated(rawState, handler);\n      return () => unlistenUpdated(rawState, handler);\n    };\n\n    const listenNamespace = (): SideEffectDisposer => {\n      let propsDisposer: SideEffectDisposer | undefined;\n      const reactionDisposer = reaction(\n        getRawState,\n        () => {\n          const rawState = getRawState();\n          if (rawState) {\n            onDiff(this._refine.replaceState(toJS(rawState)));\n            propsDisposer?.();\n            propsDisposer = listenNamespaceProps(rawState);\n          }\n        },\n        { fireImmediately: true }\n      );\n      return () => {\n        reactionDisposer();\n        propsDisposer?.();\n      };\n    };\n\n    const listenStorageChange = (\n      plugin: InvisiblePlugin<any>\n    ): SideEffectDisposer => {\n      let disposer = listenNamespace();\n\n      const handler = async (phase: RoomPhase): Promise<void> => {\n        if (phase === RoomPhase.Connected) {\n          disposer();\n          disposer = listenNamespace();\n        }\n      };\n      plugin.displayer.callbacks.on(\"onPhaseChanged\", handler);\n\n      return () => {\n        plugin.displayer.callbacks.off(\"onPhaseChanged\", handler);\n        disposer();\n      };\n    };\n\n    this._sideEffect.addDisposer(\n      this._plugin$.subscribe(plugin => {\n        const disposers: SideEffectDisposer[] = [];\n        this._sideEffect.flush(\"plugin-init\");\n        if (plugin) {\n          const rawState = toJS(getRawState());\n          if (isObject(rawState)) {\n            onDiff(this._refine.replaceState(rawState));\n          } else {\n            disposers.push(ensureInitState(plugin));\n          }\n          disposers.push(listenStorageChange(plugin));\n        } else {\n          onDiff(this._refine.replaceState(defaultState));\n        }\n        if (disposers.length > 0) {\n          this._sideEffect.addDisposer(disposers, \"plugin-init\");\n        }\n      })\n    );\n  }\n\n  public get isWritable(): boolean {\n    return this._isWritable$.value;\n  }\n\n  public get state(): Readonly<TState> {\n    return this._refine.state;\n  }\n\n  public setState(state: Partial<TState>): void {\n    const plugin = this._requireAccess(\"setState\");\n\n    if (!this.isWritable) {\n      throw new Error(\n        `Cannot setState on Storage \"${this.namespace}\" without writable access`\n      );\n    }\n\n    const keys = plainObjectKeys(state);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = state[key];\n      plugin.updateAttributes(\n        [STORAGE_NS, this.namespace, key],\n        isObject(value) ? this._refine.ensureRefValue(value) : value\n      );\n    }\n  }\n\n  /** reset storage state to default state */\n  public resetState(): void {\n    const plugin = this._requireAccess(\"resetState\");\n    plugin.updateAttributes([STORAGE_NS, this.namespace], this.defaultState);\n  }\n\n  /** delete synced storage data and disconnect from synced storage */\n  public deleteStorage(): void {\n    const plugin = this._requireAccess(\"deleteStorage\");\n    this.disconnect();\n    plugin.updateAttributes([STORAGE_NS, this.namespace], undefined);\n  }\n\n  /**\n   * Add a listener to the eventName.\n   */\n  public on: <TEventName extends RemitterEventNames<StorageEventData<TState>>>(\n    eventName: TEventName,\n    listener: RemitterListener<StorageEventData<TState>, TEventName>\n  ) => RemitterDisposer;\n\n  /**\n   * Remove a listener from the eventName.\n   */\n  public off: <TEventName extends RemitterEventNames<StorageEventData<TState>>>(\n    eventName: TEventName,\n    listener: RemitterListener<StorageEventData<TState>, TEventName>\n  ) => boolean;\n\n  /** Disconnect from synced storage and release listeners */\n  public disconnect(): void {\n    this._disconnected = true;\n    this._sideEffect.flushAll();\n    this._events.emit(\"disconnected\");\n    this._events.destroy();\n  }\n\n  public get disconnected(): boolean {\n    return this._disconnected;\n  }\n\n  private _disconnected = false;\n\n  private _requireAccess(method: string): InvisiblePlugin<any> {\n    if (this._disconnected) {\n      throw new Error(\n        `Cannot call ${method} on destroyed Storage '${this.namespace}'.`\n      );\n    }\n\n    const plugin = this._plugin$.value;\n    if (!plugin) {\n      throw new Error(\n        `[SyncedStore]: cannot call '${method}' on Storage '${this.namespace}' because plugin is not initialized.`\n      );\n    }\n\n    if (!this.isWritable) {\n      throw new Error(\n        `[SyncedStore]: cannot call '${method}' on Storage '${this.namespace}' without writable permission`\n      );\n    }\n\n    return plugin;\n  }\n}\n","import { SideEffectManager, genUID } from \"side-effect-manager\";\nimport type { ReadonlyVal } from \"value-enhancer\";\nimport { combine } from \"value-enhancer\";\nimport type {\n  EventListener as WhiteEventListener,\n  MagixEventListenerOptions,\n  Room,\n  Displayer,\n  InvisiblePlugin,\n} from \"white-web-sdk\";\nimport { isRoom } from \"white-web-sdk\";\nimport { Storage } from \"./storage\";\nimport type {\n  MagixEventTypes,\n  MagixEventHandler,\n  MagixEventListenerDisposer,\n} from \"./typings\";\n\nexport class SyncedStore<TEventData extends Record<string, any> = any> {\n  public readonly displayer: Displayer;\n  public readonly _plugin$: ReadonlyVal<InvisiblePlugin<any> | null>;\n\n  private readonly _isPluginWritable$: ReadonlyVal<boolean>;\n  private readonly _isRoomWritable$: ReadonlyVal<boolean>;\n  private readonly _sideEffect = new SideEffectManager();\n  private readonly _room: Room | null;\n\n  public constructor(\n    displayer: Displayer,\n    invisiblePlugin$: ReadonlyVal<InvisiblePlugin<any> | null>,\n    isRoomWritable$: ReadonlyVal<boolean>\n  ) {\n    this.displayer = displayer;\n    this._plugin$ = invisiblePlugin$;\n    this._isRoomWritable$ = isRoomWritable$;\n    const room = isRoom(displayer) ? displayer : null;\n    this._room = room;\n\n    this._isPluginWritable$ = combine(\n      [this._plugin$, this._isRoomWritable$],\n      ([plugin, isRoomWritable]) => plugin !== null && isRoomWritable\n    );\n  }\n\n  public connectStorage<TState extends Record<string, unknown> = any>(\n    namespace?: string,\n    defaultState?: TState\n  ): Storage<TState> {\n    const storage = new Storage({\n      plugin$: this._plugin$,\n      isWritable$: this._isPluginWritable$,\n      namespace,\n      defaultState,\n    });\n    const disconnectDisposerID = this._sideEffect.addDisposer(() =>\n      storage.disconnect()\n    );\n    const disposerID = this._sideEffect.addDisposer(\n      storage.on(\"disconnected\", () => {\n        this._sideEffect.remove(disconnectDisposerID);\n        this._sideEffect.flush(disposerID);\n      })\n    );\n    return storage;\n  }\n\n  public get isPluginWritable(): boolean {\n    return this._isPluginWritable$.value;\n  }\n\n  public addPluginWritableChangeListener(\n    listener: (isWritable: boolean) => void\n  ): () => void {\n    return this._isPluginWritable$.reaction(listener);\n  }\n\n  public get isRoomWritable(): boolean {\n    return this._isRoomWritable$.value;\n  }\n\n  public async setRoomWritable(isWritable: boolean): Promise<void> {\n    if (!this._room) {\n      throw new Error(\"[SyncedStore]: cannot set room writable in replay mode\");\n    }\n    await this._room.setWritable(isWritable);\n  }\n\n  public addRoomWritableChangeListener(\n    listener: (isWritable: boolean) => void\n  ): () => void {\n    return this._isRoomWritable$.reaction(listener);\n  }\n\n  /** Dispatch events to other clients (and self). */\n  public dispatchEvent<\n    TEvent extends MagixEventTypes<TEventData> = MagixEventTypes<TEventData>\n  >(event: TEvent, payload: TEventData[TEvent]): void {\n    if (!this._room) {\n      throw new Error(\"[SyncedStore] cannot dispatch event in replay mode\");\n    }\n    this._room.dispatchMagixEvent(event, payload);\n  }\n\n  /** Listen to events from others clients (and self messages). */\n  public addEventListener<\n    TEvent extends MagixEventTypes<TEventData> = MagixEventTypes<TEventData>\n  >(\n    event: TEvent,\n    listener: MagixEventHandler<TEventData, TEvent>,\n    options?: MagixEventListenerOptions | undefined\n  ): MagixEventListenerDisposer {\n    this.displayer.addMagixEventListener(\n      event,\n      listener as WhiteEventListener,\n      options\n    );\n    return () =>\n      this.displayer.removeMagixEventListener(\n        event,\n        listener as WhiteEventListener\n      );\n  }\n\n  /** Remove a Magix event listener. */\n  public removeEventListener<\n    TEvent extends MagixEventTypes<TEventData> = MagixEventTypes<TEventData>\n  >(event: TEvent, listener?: MagixEventHandler<TEventData, TEvent>): void {\n    return this.displayer.removeMagixEventListener(\n      event,\n      listener as WhiteEventListener\n    );\n  }\n\n  public nextFrame(): Promise<void> {\n    return new Promise(resolve => {\n      if (isRoom(this.displayer)) {\n        const uid = genUID();\n        const channel = \"SyncedStoreNextFrame\";\n        const handler: WhiteEventListener = ev => {\n          if (ev.payload === uid) {\n            this.displayer.removeMagixEventListener(channel, handler);\n            resolve();\n          }\n        };\n        this.displayer.addMagixEventListener(channel, handler, {\n          fireSelfEventAfterCommit: true,\n        });\n        this.displayer.dispatchMagixEvent(channel, uid);\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  public destroy(): void {\n    this._sideEffect.flushAll();\n    this._isPluginWritable$.destroy();\n  }\n}\n","import { Val } from \"value-enhancer\";\nimport type { Displayer, InvisiblePluginContext } from \"white-web-sdk\";\nimport { RoomPhase } from \"white-web-sdk\";\nimport { InvisiblePlugin, isRoom } from \"white-web-sdk\";\nimport { STORAGE_NS } from \"./storage\";\nimport { SyncedStore } from \"./synced-store\";\n\nexport class SyncedStorePlugin extends InvisiblePlugin<any> {\n  public static readonly kind: string = \"SyncedStore\";\n  public static readonly invisiblePlugins = new Map<\n    Displayer,\n    Val<InvisiblePlugin<any> | null>\n  >();\n\n  public static async init<TEventData extends Record<string, any> = any>(\n    displayer: Displayer\n  ): Promise<SyncedStore<TEventData>> {\n    const isRoomWritable$ = new Val(false);\n    const updateRoomWritable = () =>\n      isRoomWritable$.setValue(isRoom(displayer) && displayer.isWritable);\n    updateRoomWritable();\n    displayer.callbacks.on(\"onEnableWriteNowChanged\", updateRoomWritable);\n\n    const invisiblePlugin$ = new Val<InvisiblePlugin<any> | null>(\n      displayer.getInvisiblePlugin(SyncedStorePlugin.kind)\n    );\n    SyncedStorePlugin.invisiblePlugins.set(displayer, invisiblePlugin$);\n\n    const createSyncedStore = async (\n      isRoomWritable: boolean\n    ): Promise<void> => {\n      if (isRoomWritable && isRoom(displayer)) {\n        try {\n          const plugin = await displayer.createInvisiblePlugin(\n            SyncedStorePlugin,\n            { [STORAGE_NS]: {} }\n          );\n          invisiblePlugin$.setValue(plugin);\n          isRoomWritable$.unsubscribe(createSyncedStore);\n        } catch (e) {\n          // could be error if multiple users create plugin at the same time\n          await new Promise(resolve => setTimeout(resolve, 200));\n          if (!displayer.getInvisiblePlugin(SyncedStorePlugin.kind)) {\n            console.error(e);\n          }\n        }\n      }\n    };\n\n    const removeWritableListener = (plugin: SyncedStorePlugin | null): void => {\n      if (plugin) {\n        isRoomWritable$.unsubscribe(createSyncedStore);\n        invisiblePlugin$.unsubscribe(removeWritableListener);\n      }\n    };\n\n    if (!invisiblePlugin$.value && isRoom(displayer)) {\n      isRoomWritable$.subscribe(createSyncedStore);\n      invisiblePlugin$.subscribe(removeWritableListener);\n    }\n\n    const syncedStore = new SyncedStore(\n      displayer,\n      invisiblePlugin$,\n      isRoomWritable$\n    );\n\n    const onPhaseChanged = (phase: RoomPhase): void => {\n      if (phase === RoomPhase.Disconnected) {\n        displayer.callbacks.off(\"onPhaseChanged\", onPhaseChanged);\n        displayer.callbacks.off(\"onEnableWriteNowChanged\", updateRoomWritable);\n        isRoomWritable$.destroy();\n        invisiblePlugin$.destroy();\n        SyncedStorePlugin.invisiblePlugins.delete(displayer);\n      }\n    };\n    displayer.callbacks.on(\"onPhaseChanged\", onPhaseChanged);\n\n    return syncedStore;\n  }\n\n  public static onCreate(plugin: SyncedStorePlugin): void {\n    SyncedStorePlugin.invisiblePlugins.get(plugin.displayer)?.setValue(plugin);\n  }\n\n  public constructor(context: InvisiblePluginContext) {\n    super(context);\n    SyncedStorePlugin.invisiblePlugins.get(this.displayer)?.setValue(this);\n  }\n}\n","import type { InvisiblePluginContext } from \"white-web-sdk\";\nimport { SyncedStorePlugin } from \"./invisible-plugin\";\n\nexport function createPlugin(\n  kind: string = SyncedStorePlugin.kind\n): new (context: InvisiblePluginContext) => SyncedStorePlugin {\n  return class SyncedStoreCustomPlugin extends SyncedStorePlugin {\n    static override readonly kind = kind;\n  };\n}\n"],"names":["genUID","SideEffectManager","Remitter","toJS","listenUpdated","unlistenUpdated","reaction","RoomPhase","isRoom","combine","InvisiblePlugin","Val"],"mappings":"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"}