import type { Diff, DiffOne } from "./typings";
declare const REFINE_KEY = "__IsReFiNe";
export declare type RefineValue<TValue = any> = {
    k: string;
    v: TValue;
    [REFINE_KEY]: 1;
};
export declare type MaybeRefineValue<TValue = any> = TValue | RefineValue<TValue>;
export declare type RefineState<TState = any> = {
    [K in keyof TState]: MaybeRefineValue<TState[K]>;
};
export declare type ExtractRawValue<TValue> = TValue extends RefineValue<infer TRefineValue> ? TRefineValue : TValue;
export declare function isRefineValue<TValue>(value: MaybeRefineValue<TValue>): value is RefineValue<TValue>;
export declare function isMaybeRefineValue<TValue>(value: MaybeRefineValue<TValue>): value is MaybeRefineValue<TValue>;
export declare function makeRefineValue<TValue>(value: TValue, key?: string): RefineValue<TValue>;
export declare class Refine<TState = any> {
    state: TState;
    constructor(refState?: RefineState<TState>, defaultState?: TState);
    replaceState(state: RefineState<TState>): Diff<TState> | null;
    toRefState(): RefineState<TState>;
    setValue<TKey extends Extract<keyof TState, string>>(key: TKey, maybeRefValue: MaybeRefineValue<TState[TKey]> | undefined): DiffOne<TState[TKey]> | null;
    toRefValue<TKey extends Extract<keyof TState, string>>(maybeRefValue: MaybeRefineValue<TState[TKey]>): RefineValue<TState[TKey]>;
    ensureRefValue<TValue>(value: MaybeRefineValue<TValue>): RefineValue<TValue>;
    private refMap;
    private refKeys;
    private genKey;
    private deleteRefKey;
}
export {};
