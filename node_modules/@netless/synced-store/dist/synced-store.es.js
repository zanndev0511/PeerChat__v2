import { toJS, RoomPhase, reaction, unlistenUpdated, listenUpdated, isRoom, InvisiblePlugin } from "white-web-sdk";
import { genUID, SideEffectManager } from "side-effect-manager";
import { Remitter } from "remitter";
import { combine, Val } from "value-enhancer";
const isObject = (obj) => typeof obj === "object" && obj !== null;
const objHas = Object.prototype.hasOwnProperty;
const has = (obj, key) => {
  return objHas.call(obj, key);
};
const plainObjectKeys = Object.keys;
const REFINE_KEY = "__IsReFiNe";
function isRefineValue(value) {
  return isObject(value) && value[REFINE_KEY] === 1;
}
function makeRefineValue(value, key = genUID()) {
  return { [REFINE_KEY]: 1, k: key, v: value };
}
class Refine {
  constructor(refState, defaultState) {
    this.refMap = /* @__PURE__ */ new Map();
    this.refKeys = /* @__PURE__ */ new Set();
    this.genKey = () => {
      let key;
      do {
        key = genUID();
      } while (this.refKeys.has(key));
      this.refKeys.add(key);
      return key;
    };
    this.state = {};
    this.replaceState(refState || defaultState || {});
  }
  replaceState(state) {
    if (!isObject(state)) {
      throw new Error("[SyncedStore] replaceState: state must be an object");
    }
    const diff = {};
    let hasDiff = false;
    const allKeys = /* @__PURE__ */ new Set([
      ...plainObjectKeys(this.state),
      ...plainObjectKeys(state)
    ]);
    allKeys.forEach((key) => {
      const diffOne = this.setValue(key, state[key]);
      if (diffOne) {
        hasDiff = true;
        diff[key] = diffOne;
      }
    });
    return hasDiff ? diff : null;
  }
  toRefState() {
    return plainObjectKeys(this.state).reduce((refState, key) => {
      refState[key] = this.toRefValue(this.state[key]);
      return refState;
    }, {});
  }
  setValue(key, maybeRefValue) {
    if (isObject(maybeRefValue)) {
      const refValue = this.ensureRefValue(maybeRefValue);
      if (this.state[key] !== refValue.v) {
        const oldValue = this.deleteRefKey(key);
        this.state[key] = refValue.v;
        return { oldValue, newValue: refValue.v };
      }
    } else if (typeof maybeRefValue === "undefined") {
      if (has(this.state, key)) {
        const oldValue = this.deleteRefKey(key);
        delete this.state[key];
        return { oldValue, newValue: void 0 };
      }
    } else {
      const value = maybeRefValue;
      if (this.state[key] !== value) {
        const oldValue = this.deleteRefKey(key);
        this.state[key] = value;
        return { oldValue, newValue: value };
      }
    }
    return null;
  }
  toRefValue(maybeRefValue) {
    return isObject(maybeRefValue) ? this.ensureRefValue(maybeRefValue) : maybeRefValue;
  }
  ensureRefValue(value) {
    if (isRefineValue(value)) {
      this.refMap.set(value.v, value);
      return value;
    }
    let refValue = this.refMap.get(value);
    if (!refValue) {
      refValue = makeRefineValue(value, this.genKey());
      this.refMap.set(value, refValue);
    }
    this.refKeys.add(refValue.k);
    return refValue;
  }
  deleteRefKey(key) {
    const value = this.state[key];
    const refValue = this.refMap.get(value);
    if (refValue) {
      this.refKeys.delete(refValue.k);
    }
    return value;
  }
}
const STORAGE_NS = "_WM-StOrAgE_";
const MAIN_STORAGE = "_WM-MaIn-StOrAgE_";
class Storage {
  constructor({
    plugin$,
    isWritable$,
    namespace = MAIN_STORAGE,
    defaultState = {}
  }) {
    this._sideEffect = new SideEffectManager();
    this._events = new Remitter();
    this._disconnected = false;
    if (defaultState && !isObject(defaultState)) {
      throw new Error(`Default state for Storage ${namespace} is not an object.`);
    }
    this.on = this._events.on.bind(this._events);
    this.off = this._events.off.bind(this._events);
    const getRawState = () => {
      var _a, _b;
      return (_b = (_a = plugin$.value) == null ? void 0 : _a.attributes[STORAGE_NS]) == null ? void 0 : _b[namespace];
    };
    this.namespace = namespace;
    this.defaultState = defaultState;
    this._plugin$ = plugin$;
    this._isWritable$ = isWritable$;
    this._refine = new Refine(toJS(getRawState()), defaultState);
    const onDiff = (diff) => {
      if (diff) {
        this._events.emit("stateChanged", diff);
      }
    };
    const ensureInitState = (plugin) => {
      return isWritable$.subscribe((isWritable) => {
        if (isWritable) {
          if (!isObject(plugin.attributes[STORAGE_NS])) {
            plugin.updateAttributes([STORAGE_NS], {});
          }
          if (!isObject(toJS(getRawState()))) {
            plugin.updateAttributes([STORAGE_NS, namespace], this._refine.toRefState());
          }
        }
      });
    };
    const listenNamespaceProps = (rawState) => {
      const handler = (actions) => {
        if (actions.length <= 0)
          return;
        const diff = {};
        let hasDiff = false;
        for (let i = 0; i < actions.length; i++) {
          const action = actions[i];
          const key = action.key;
          if (key === STORAGE_NS) {
            continue;
          }
          const value = toJS(action.value);
          const diffOne = this._refine.setValue(key, value);
          if (diffOne) {
            hasDiff = true;
            diff[key] = diffOne;
          }
        }
        if (hasDiff) {
          onDiff(diff);
        }
      };
      listenUpdated(rawState, handler);
      return () => unlistenUpdated(rawState, handler);
    };
    const listenNamespace = () => {
      let propsDisposer;
      const reactionDisposer = reaction(getRawState, () => {
        const rawState = getRawState();
        if (rawState) {
          onDiff(this._refine.replaceState(toJS(rawState)));
          propsDisposer == null ? void 0 : propsDisposer();
          propsDisposer = listenNamespaceProps(rawState);
        }
      }, { fireImmediately: true });
      return () => {
        reactionDisposer();
        propsDisposer == null ? void 0 : propsDisposer();
      };
    };
    const listenStorageChange = (plugin) => {
      let disposer = listenNamespace();
      const handler = async (phase) => {
        if (phase === RoomPhase.Connected) {
          disposer();
          disposer = listenNamespace();
        }
      };
      plugin.displayer.callbacks.on("onPhaseChanged", handler);
      return () => {
        plugin.displayer.callbacks.off("onPhaseChanged", handler);
        disposer();
      };
    };
    this._sideEffect.addDisposer(this._plugin$.subscribe((plugin) => {
      const disposers = [];
      this._sideEffect.flush("plugin-init");
      if (plugin) {
        const rawState = toJS(getRawState());
        if (isObject(rawState)) {
          onDiff(this._refine.replaceState(rawState));
        } else {
          disposers.push(ensureInitState(plugin));
        }
        disposers.push(listenStorageChange(plugin));
      } else {
        onDiff(this._refine.replaceState(defaultState));
      }
      if (disposers.length > 0) {
        this._sideEffect.addDisposer(disposers, "plugin-init");
      }
    }));
  }
  get isWritable() {
    return this._isWritable$.value;
  }
  get state() {
    return this._refine.state;
  }
  setState(state) {
    const plugin = this._requireAccess("setState");
    if (!this.isWritable) {
      throw new Error(`Cannot setState on Storage "${this.namespace}" without writable access`);
    }
    const keys = plainObjectKeys(state);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = state[key];
      plugin.updateAttributes([STORAGE_NS, this.namespace, key], isObject(value) ? this._refine.ensureRefValue(value) : value);
    }
  }
  resetState() {
    const plugin = this._requireAccess("resetState");
    plugin.updateAttributes([STORAGE_NS, this.namespace], this.defaultState);
  }
  deleteStorage() {
    const plugin = this._requireAccess("deleteStorage");
    this.disconnect();
    plugin.updateAttributes([STORAGE_NS, this.namespace], void 0);
  }
  disconnect() {
    this._disconnected = true;
    this._sideEffect.flushAll();
    this._events.emit("disconnected");
    this._events.destroy();
  }
  get disconnected() {
    return this._disconnected;
  }
  _requireAccess(method) {
    if (this._disconnected) {
      throw new Error(`Cannot call ${method} on destroyed Storage '${this.namespace}'.`);
    }
    const plugin = this._plugin$.value;
    if (!plugin) {
      throw new Error(`[SyncedStore]: cannot call '${method}' on Storage '${this.namespace}' because plugin is not initialized.`);
    }
    if (!this.isWritable) {
      throw new Error(`[SyncedStore]: cannot call '${method}' on Storage '${this.namespace}' without writable permission`);
    }
    return plugin;
  }
}
class SyncedStore {
  constructor(displayer, invisiblePlugin$, isRoomWritable$) {
    this._sideEffect = new SideEffectManager();
    this.displayer = displayer;
    this._plugin$ = invisiblePlugin$;
    this._isRoomWritable$ = isRoomWritable$;
    const room = isRoom(displayer) ? displayer : null;
    this._room = room;
    this._isPluginWritable$ = combine([this._plugin$, this._isRoomWritable$], ([plugin, isRoomWritable]) => plugin !== null && isRoomWritable);
  }
  connectStorage(namespace, defaultState) {
    const storage = new Storage({
      plugin$: this._plugin$,
      isWritable$: this._isPluginWritable$,
      namespace,
      defaultState
    });
    const disconnectDisposerID = this._sideEffect.addDisposer(() => storage.disconnect());
    const disposerID = this._sideEffect.addDisposer(storage.on("disconnected", () => {
      this._sideEffect.remove(disconnectDisposerID);
      this._sideEffect.flush(disposerID);
    }));
    return storage;
  }
  get isPluginWritable() {
    return this._isPluginWritable$.value;
  }
  addPluginWritableChangeListener(listener) {
    return this._isPluginWritable$.reaction(listener);
  }
  get isRoomWritable() {
    return this._isRoomWritable$.value;
  }
  async setRoomWritable(isWritable) {
    if (!this._room) {
      throw new Error("[SyncedStore]: cannot set room writable in replay mode");
    }
    await this._room.setWritable(isWritable);
  }
  addRoomWritableChangeListener(listener) {
    return this._isRoomWritable$.reaction(listener);
  }
  dispatchEvent(event, payload) {
    if (!this._room) {
      throw new Error("[SyncedStore] cannot dispatch event in replay mode");
    }
    this._room.dispatchMagixEvent(event, payload);
  }
  addEventListener(event, listener, options) {
    this.displayer.addMagixEventListener(event, listener, options);
    return () => this.displayer.removeMagixEventListener(event, listener);
  }
  removeEventListener(event, listener) {
    return this.displayer.removeMagixEventListener(event, listener);
  }
  nextFrame() {
    return new Promise((resolve) => {
      if (isRoom(this.displayer)) {
        const uid = genUID();
        const channel = "SyncedStoreNextFrame";
        const handler = (ev) => {
          if (ev.payload === uid) {
            this.displayer.removeMagixEventListener(channel, handler);
            resolve();
          }
        };
        this.displayer.addMagixEventListener(channel, handler, {
          fireSelfEventAfterCommit: true
        });
        this.displayer.dispatchMagixEvent(channel, uid);
      } else {
        resolve();
      }
    });
  }
  destroy() {
    this._sideEffect.flushAll();
    this._isPluginWritable$.destroy();
  }
}
const _SyncedStorePlugin = class extends InvisiblePlugin {
  static async init(displayer) {
    const isRoomWritable$ = new Val(false);
    const updateRoomWritable = () => isRoomWritable$.setValue(isRoom(displayer) && displayer.isWritable);
    updateRoomWritable();
    displayer.callbacks.on("onEnableWriteNowChanged", updateRoomWritable);
    const invisiblePlugin$ = new Val(displayer.getInvisiblePlugin(_SyncedStorePlugin.kind));
    _SyncedStorePlugin.invisiblePlugins.set(displayer, invisiblePlugin$);
    const createSyncedStore = async (isRoomWritable) => {
      if (isRoomWritable && isRoom(displayer)) {
        try {
          const plugin = await displayer.createInvisiblePlugin(_SyncedStorePlugin, { [STORAGE_NS]: {} });
          invisiblePlugin$.setValue(plugin);
          isRoomWritable$.unsubscribe(createSyncedStore);
        } catch (e) {
          await new Promise((resolve) => setTimeout(resolve, 200));
          if (!displayer.getInvisiblePlugin(_SyncedStorePlugin.kind)) {
            console.error(e);
          }
        }
      }
    };
    const removeWritableListener = (plugin) => {
      if (plugin) {
        isRoomWritable$.unsubscribe(createSyncedStore);
        invisiblePlugin$.unsubscribe(removeWritableListener);
      }
    };
    if (!invisiblePlugin$.value && isRoom(displayer)) {
      isRoomWritable$.subscribe(createSyncedStore);
      invisiblePlugin$.subscribe(removeWritableListener);
    }
    const syncedStore = new SyncedStore(displayer, invisiblePlugin$, isRoomWritable$);
    const onPhaseChanged = (phase) => {
      if (phase === RoomPhase.Disconnected) {
        displayer.callbacks.off("onPhaseChanged", onPhaseChanged);
        displayer.callbacks.off("onEnableWriteNowChanged", updateRoomWritable);
        isRoomWritable$.destroy();
        invisiblePlugin$.destroy();
        _SyncedStorePlugin.invisiblePlugins.delete(displayer);
      }
    };
    displayer.callbacks.on("onPhaseChanged", onPhaseChanged);
    return syncedStore;
  }
  static onCreate(plugin) {
    var _a;
    (_a = _SyncedStorePlugin.invisiblePlugins.get(plugin.displayer)) == null ? void 0 : _a.setValue(plugin);
  }
  constructor(context) {
    var _a;
    super(context);
    (_a = _SyncedStorePlugin.invisiblePlugins.get(this.displayer)) == null ? void 0 : _a.setValue(this);
  }
};
let SyncedStorePlugin = _SyncedStorePlugin;
SyncedStorePlugin.kind = "SyncedStore";
SyncedStorePlugin.invisiblePlugins = /* @__PURE__ */ new Map();
function createPlugin(kind = SyncedStorePlugin.kind) {
  var _a;
  return _a = class extends SyncedStorePlugin {
  }, _a.kind = kind, _a;
}
export { MAIN_STORAGE, STORAGE_NS, Storage, SyncedStore, SyncedStorePlugin, createPlugin };
//# sourceMappingURL=synced-store.es.js.map
