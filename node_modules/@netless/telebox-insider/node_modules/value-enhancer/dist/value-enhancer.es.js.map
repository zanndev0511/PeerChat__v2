{"version":3,"file":"value-enhancer.es.js","sources":["../src/val.ts","../src/combine.ts","../src/with-value-enhancer.ts","../src/side-effect-binder.ts"],"sourcesContent":["import type {\n  ValCompare,\n  ValDisposer,\n  ValSubscriber,\n  ValTransform,\n  ValReactionSubscriber,\n} from \"./typings\";\n\nexport class Val<TValue = any, TMeta = any> {\n  protected _value: TValue;\n\n  public constructor(value: TValue, compare?: ValCompare<TValue>) {\n    this._value = value;\n    if (compare) {\n      this.compare = compare;\n    }\n  }\n\n  public get value(): TValue {\n    return this._value;\n  }\n\n  public setValue(value: TValue, meta?: TMeta): void {\n    if (!this.compare(value, this._value)) {\n      const oldValue = this._value;\n      this._value = value;\n      if (this._subscribers) {\n        this._subscribers.forEach(subscriber =>\n          subscriber(value, oldValue, meta)\n        );\n      }\n    }\n  }\n\n  /**\n   * Subscribe to value changes without immediate emission.\n   */\n  public reaction(\n    subscriber: ValReactionSubscriber<TValue, TMeta>\n  ): ValDisposer {\n    if (!this._subscribers) {\n      this._subscribers = new Set();\n    }\n\n    this._subscribers.add(subscriber);\n\n    return (): void => {\n      /* istanbul ignore else: guard code  */\n      if (this._subscribers) {\n        this._subscribers.delete(subscriber);\n      }\n    };\n  }\n\n  /**\n   * Subscribe to value changes with immediate emission.\n   * @param subscriber\n   * @param meta Meta for the immediate emission\n   */\n  public subscribe(\n    subscriber: ValSubscriber<TValue, TMeta>,\n    meta?: TMeta\n  ): ValDisposer {\n    const disposer = this.reaction(subscriber);\n    subscriber(this._value, void 0, meta);\n    return disposer;\n  }\n\n  public derive<TDerivedValue = any>(\n    transform: ValTransform<TValue, TDerivedValue, TMeta>,\n    compare?: ValCompare<TDerivedValue>,\n    meta?: TMeta\n  ): Val<TDerivedValue, TMeta> {\n    const derivedVal = new Val<TDerivedValue, TMeta>(\n      transform(this.value, undefined, meta),\n      compare\n    );\n    const disposer = this.reaction((newValue, oldValue, meta) => {\n      derivedVal.setValue(transform(newValue, oldValue, meta));\n    });\n    derivedVal.addBeforeDestroy(disposer);\n    return derivedVal;\n  }\n\n  public destroy(): void {\n    if (this._beforeDestroys) {\n      this._beforeDestroys.forEach(beforeDestroy => beforeDestroy());\n      this._beforeDestroys.clear();\n    }\n    if (this._subscribers) {\n      this._subscribers.clear();\n    }\n  }\n\n  /**\n   * Add a callback which will be run before destroy\n   * @param beforeDestroy\n   * @returns Cancel the callback\n   */\n  public addBeforeDestroy(beforeDestroy: () => void): ValDisposer {\n    if (!this._beforeDestroys) {\n      this._beforeDestroys = new Set();\n    }\n    this._beforeDestroys.add(beforeDestroy);\n    return (): void => {\n      /* istanbul ignore else: guard code  */\n      if (this._beforeDestroys) {\n        this._beforeDestroys.delete(beforeDestroy);\n      }\n    };\n  }\n\n  /**\n   * Compare two values. Default `===`.\n   */\n  public compare(newValue: TValue, oldValue: TValue): boolean {\n    return newValue === oldValue;\n  }\n\n  protected _beforeDestroys?: Set<() => void>;\n\n  protected _subscribers?: Set<\n    ValSubscriber<TValue, TMeta> | ValReactionSubscriber<TValue, TMeta>\n  >;\n}\n","import type { ValCompare } from \"./typings\";\nimport { Val } from \"./val\";\n\nexport type TValInputsValueTuple<TValInputs extends readonly Val[]> = Readonly<{\n  [K in keyof TValInputs]: ExtractValValue<TValInputs[K]>;\n}>;\n\nexport type ExtractValValue<TVal> = TVal extends Val<infer TValue, any>\n  ? TValue\n  : never;\n\nexport type ExtractValMeta<TVal> = TVal extends Val<any, infer TMeta>\n  ? TMeta\n  : never;\n\nexport type CombineValTransform<\n  TDerivedValue = any,\n  TValues extends readonly any[] = any[],\n  TMeta = any\n> = (newValues: TValues, oldValues?: TValues, meta?: TMeta) => TDerivedValue;\n\nexport type Combine = <\n  TDerivedValue = any,\n  TValInputs extends readonly Val[] = Val[],\n  TMeta = ExtractValMeta<TValInputs[number]>\n>(\n  valInputs: readonly [...TValInputs],\n  transform: CombineValTransform<\n    TDerivedValue,\n    [...TValInputsValueTuple<TValInputs>],\n    TMeta\n  >,\n  compare?: ValCompare<TDerivedValue>,\n  meta?: TMeta\n) => Val<TDerivedValue, TMeta>;\n\nexport function combine<\n  TDerivedValue = any,\n  TValInputs extends readonly Val[] = Val[],\n  TMeta = ExtractValMeta<TValInputs[number]>\n>(\n  valInputs: readonly [...TValInputs],\n  transform: CombineValTransform<\n    TDerivedValue,\n    [...TValInputsValueTuple<TValInputs>],\n    TMeta\n  >,\n  compare?: ValCompare<TDerivedValue>,\n  meta?: TMeta\n): Val<TDerivedValue, TMeta> {\n  let lastValue = valInputs.map(val => val.value) as [\n    ...TValInputsValueTuple<TValInputs>\n  ];\n  const combinedVal = new Val(transform(lastValue, void 0, meta), compare);\n  valInputs.forEach((val, i) => {\n    const disposer = val.reaction((value, _, meta) => {\n      const newValue = lastValue.slice() as [\n        ...TValInputsValueTuple<TValInputs>\n      ];\n      newValue[i] = value;\n      const oldValue = lastValue;\n      lastValue = newValue;\n      combinedVal.setValue(transform(newValue, oldValue, meta), meta);\n    });\n    combinedVal.addBeforeDestroy(disposer);\n  });\n  return combinedVal;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport type { ExtractValMeta, ExtractValValue } from \"./combine\";\nimport type { Val } from \"./val\";\n\ntype IntersectionFromUnion<TUnion> = (\n  TUnion extends any ? (arg: TUnion) => void : never\n) extends (arg: infer TArg) => void\n  ? TArg\n  : never;\n\ntype ExtractValKeys<TInstance, TKey = keyof TInstance> = TKey extends Extract<\n  keyof TInstance,\n  string\n>\n  ? TInstance[TKey] extends Val\n    ? TKey\n    : never\n  : never;\n\nexport type ValEnhancer<TVal, TKey extends string> = Readonly<\n  Record<TKey, ExtractValValue<TVal>> &\n    Record<`_${TKey}$`, TVal> &\n    Record<\n      `set${Capitalize<TKey>}`,\n      (value: ExtractValValue<TVal>, meta?: ExtractValMeta<TVal>) => void\n    >\n>;\n\nexport type ValEnhancerConfig = Record<string, Val>;\n\ntype ToValUnion<\n  TConfig,\n  TKey = ExtractValKeys<TConfig>\n> = TKey extends ExtractValKeys<TConfig>\n  ? ValEnhancer<TConfig[TKey], TKey>\n  : never;\n\nexport type ValEnhancedResult<TConfig> = IntersectionFromUnion<\n  ToValUnion<TConfig>\n>;\n\nexport function withValueEnhancer<TInstance, TConfig extends ValEnhancerConfig>(\n  instance: TInstance,\n  config: TConfig\n): void {\n  Object.keys(config).forEach(key => {\n    bindInstance(instance, key, config[key]);\n  });\n}\n\nexport type BindVal = <TKey extends string, TValue, TMeta>(\n  key: TKey,\n  val: Val<TValue, TMeta>\n) => Val<TValue, TMeta>;\n\nexport function createInstanceBinder<TInstance>(instance: TInstance): BindVal {\n  const bindVal: BindVal = (key, val) => {\n    bindInstance(instance, key, val);\n    return val;\n  };\n  return bindVal;\n}\n\nexport function bindInstance<TInstance, TKey extends string, TValue, TMeta>(\n  instance: TInstance,\n  key: TKey,\n  val: Val<TValue, TMeta>\n): ValEnhancer<TValue, TKey> & TInstance {\n  Object.defineProperties(instance, {\n    [key]: {\n      get() {\n        return val.value;\n      },\n    },\n    [`_${key}$`]: {\n      value: val,\n    },\n    [`set${capitalize(key)}`]: {\n      value: (value: TValue, meta?: TMeta): void => val.setValue(value, meta),\n    },\n  });\n  return instance as ValEnhancer<TValue, TKey> & TInstance;\n}\n\nfunction capitalize<TStr extends string>(str: TStr): Capitalize<TStr> {\n  return (str[0].toUpperCase() + str.slice(1)) as Capitalize<TStr>;\n}\n","import type { SideEffectManager } from \"side-effect-manager\";\nimport { combine as combineOrigin } from \"./combine\";\nimport type { Combine } from \"./combine\";\nimport { Val } from \"./val\";\nimport type { ValCompare } from \"./typings\";\n\nexport type BindSideEffect = <TVal extends Val>(val: TVal) => TVal;\n\nexport type CreateVal = <TValue = any, TMeta = any>(\n  value: TValue,\n  compare?: ValCompare<TValue>\n) => Val<TValue, TMeta>;\n\nexport type ValSideEffectBinder = {\n  bindSideEffect: BindSideEffect;\n  combine: Combine;\n  createVal: CreateVal;\n};\n\nexport function createSideEffectBinder(\n  sideEffect: SideEffectManager\n): ValSideEffectBinder {\n  const bindSideEffect: BindSideEffect = val => {\n    const disposerID = sideEffect.addDisposer(() => {\n      val.destroy();\n    });\n    val.addBeforeDestroy(() => {\n      sideEffect.remove(disposerID);\n    });\n    return val;\n  };\n\n  const combine: Combine = (valInputs, transform, compare, meta) => {\n    return bindSideEffect(combineOrigin(valInputs, transform, compare, meta));\n  };\n\n  const createVal: CreateVal = (value, compare) => {\n    return bindSideEffect(new Val(value, compare));\n  };\n\n  return {\n    bindSideEffect,\n    combine,\n    createVal,\n  };\n}\n"],"names":["constructor","value","compare","_value","this","setValue","meta","oldValue","_subscribers","forEach","subscriber","reaction","Set","add","delete","subscribe","disposer","derive","transform","derivedVal","Val","newValue","meta2","addBeforeDestroy","destroy","_beforeDestroys","beforeDestroy","clear","valInputs","lastValue","map","val","combinedVal","i","_","slice","instance","config","keys","key","str","defineProperties","get","toUpperCase","sideEffect","bindSideEffect","disposerID","addDisposer","remove","combineOrigin","createVal"],"mappings":"+MAWSA,YAAYC,EAAeC,0EAC3BC,OAASF,EACVC,SACGA,QAAUA,sBAKVE,KAAKD,OAGPE,SAASJ,EAAeK,OACxBF,KAAKF,QAAQD,EAAOG,KAAKD,QAAS,OAC/BI,EAAWH,KAAKD,YACjBA,OAASF,EACVG,KAAKI,mBACFA,aAAaC,YAChBC,EAAWT,EAAOM,EAAUD,MAS7BK,SACLD,UAEKN,KAAKI,oBACHA,aAAe,IAAII,UAGrBJ,aAAaK,IAAIH,GAEf,KAEDN,KAAKI,mBACFA,aAAaM,OAAOJ,IAUxBK,UACLL,EACAJ,SAEMU,EAAWZ,KAAKO,SAASD,YACpBN,KAAKD,YAAQ,EAAQG,GACzBU,EAGFC,OACLC,EACAhB,EACAI,SAEMa,EAAa,IAAIC,EACrBF,EAAUd,KAAKH,WAAO,EAAWK,GACjCJ,GAEIc,EAAWZ,KAAKO,UAAS,CAACU,EAAUd,EAAUe,OACvCjB,SAASa,EAAUG,EAAUd,EAAUe,gBAEzCC,iBAAiBP,GACrBG,EAGFK,UACDpB,KAAKqB,uBACFA,gBAAgBhB,YAAyBiB,WACzCD,gBAAgBE,SAEnBvB,KAAKI,mBACFA,aAAamB,QASfJ,iBAAiBG,UACjBtB,KAAKqB,uBACHA,gBAAkB,IAAIb,UAExBa,gBAAgBZ,IAAIa,GAClB,KAEDtB,KAAKqB,sBACFA,gBAAgBX,OAAOY,IAQ3BxB,QAAQmB,EAAkBd,UACxBc,IAAad,cC3EtBqB,EACAV,EAKAhB,EACAI,OAEIuB,EAAYD,EAAUE,QAAWC,EAAI9B,cAGnC+B,EAAc,IAAIZ,EAAIF,EAAUW,OAAW,EAAQvB,GAAOJ,YACtDO,SAAQ,CAACsB,EAAKE,WAChBjB,EAAWe,EAAIpB,UAAS,CAACV,EAAOiC,EAAGZ,WACjCD,EAAWQ,EAAUM,UAGlBF,GAAKhC,QACRM,EAAWsB,IACLR,IACAhB,SAASa,EAAUG,EAAUd,EAAUe,GAAOA,QAEhDC,iBAAiBP,MAExBgB,aCvBPI,EACAC,UAEOC,KAAKD,GAAQ5B,eACL2B,EAAUG,EAAKF,EAAOE,kBASSH,SACrB,CAACG,EAAKR,OAChBK,EAAUG,EAAKR,GACrBA,cAMTK,EACAG,EACAR,GAkBF,IAAyCS,gBAhBhCC,iBAAiBL,EAAU,EAC/BG,GAAM,CACLG,QACSX,EAAI9B,QAGd,IAAIsC,MAAS,CACZtC,MAAO8B,IAER,MAOoCS,EAPnBD,EAQZC,EAAI,GAAGG,cAAgBH,EAAIL,MAAM,MARZ,CACzBlC,MAAO,CAACA,EAAeK,IAAuByB,EAAI1B,SAASJ,EAAOK,MAG/D8B,aC9DPQ,SAEMC,YACEC,EAAaF,EAAWG,aAAY,OACpCvB,sBAEFD,kBAAiB,OACRyB,OAAOF,MAEbf,SAWF,CACLc,eAAAA,UATuB,CAACjB,EAAWV,EAAWhB,EAASI,IAChDuC,EAAeI,EAAcrB,EAAWV,EAAWhB,EAASI,IAUnE4C,UAP2B,CAACjD,EAAOC,IAC5B2C,EAAe,IAAIzB,EAAInB,EAAOC"}