import type { ExtractValMeta, ExtractValValue } from "./combine";
import type { Val } from "./val";
declare type IntersectionFromUnion<TUnion> = (TUnion extends any ? (arg: TUnion) => void : never) extends (arg: infer TArg) => void ? TArg : never;
declare type ExtractValKeys<TInstance, TKey = keyof TInstance> = TKey extends Extract<keyof TInstance, string> ? TInstance[TKey] extends Val ? TKey : never : never;
export declare type ValEnhancer<TVal, TKey extends string> = Readonly<Record<TKey, ExtractValValue<TVal>> & Record<`_${TKey}$`, TVal> & Record<`set${Capitalize<TKey>}`, (value: ExtractValValue<TVal>, meta?: ExtractValMeta<TVal>) => void>>;
export declare type ValEnhancerConfig = Record<string, Val>;
declare type ToValUnion<TConfig, TKey = ExtractValKeys<TConfig>> = TKey extends ExtractValKeys<TConfig> ? ValEnhancer<TConfig[TKey], TKey> : never;
export declare type ValEnhancedResult<TConfig> = IntersectionFromUnion<ToValUnion<TConfig>>;
export declare function withValueEnhancer<TInstance, TConfig extends ValEnhancerConfig>(instance: TInstance, config: TConfig): void;
export declare type BindVal = <TKey extends string, TValue, TMeta>(key: TKey, val: Val<TValue, TMeta>) => Val<TValue, TMeta>;
export declare function createInstanceBinder<TInstance>(instance: TInstance): BindVal;
export declare function bindInstance<TInstance, TKey extends string, TValue, TMeta>(instance: TInstance, key: TKey, val: Val<TValue, TMeta>): ValEnhancer<TValue, TKey> & TInstance;
export {};
