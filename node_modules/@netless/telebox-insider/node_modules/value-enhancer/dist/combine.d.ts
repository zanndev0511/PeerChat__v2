import type { ValCompare } from "./typings";
import { Val } from "./val";
export declare type TValInputsValueTuple<TValInputs extends readonly Val[]> = Readonly<{
    [K in keyof TValInputs]: ExtractValValue<TValInputs[K]>;
}>;
export declare type ExtractValValue<TVal> = TVal extends Val<infer TValue, any> ? TValue : never;
export declare type ExtractValMeta<TVal> = TVal extends Val<any, infer TMeta> ? TMeta : never;
export declare type CombineValTransform<TDerivedValue = any, TValues extends readonly any[] = any[], TMeta = any> = (newValues: TValues, oldValues?: TValues, meta?: TMeta) => TDerivedValue;
export declare type Combine = <TDerivedValue = any, TValInputs extends readonly Val[] = Val[], TMeta = ExtractValMeta<TValInputs[number]>>(valInputs: readonly [...TValInputs], transform: CombineValTransform<TDerivedValue, [
    ...TValInputsValueTuple<TValInputs>
], TMeta>, compare?: ValCompare<TDerivedValue>, meta?: TMeta) => Val<TDerivedValue, TMeta>;
export declare function combine<TDerivedValue = any, TValInputs extends readonly Val[] = Val[], TMeta = ExtractValMeta<TValInputs[number]>>(valInputs: readonly [...TValInputs], transform: CombineValTransform<TDerivedValue, [
    ...TValInputsValueTuple<TValInputs>
], TMeta>, compare?: ValCompare<TDerivedValue>, meta?: TMeta): Val<TDerivedValue, TMeta>;
