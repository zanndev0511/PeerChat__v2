{"version":3,"file":"side-effect-manager.es.js","sources":["../src/gen-uid.ts","../src/side-effect-manager.ts","../src/async-side-effect-manager.ts"],"sourcesContent":["/**\n * @fileoverview UID generator, from Blockly.\n */\n\n/**\n * Legal characters for the unique ID.\n * Should be all on a US keyboard.  No XML special characters or control codes.\n * @private\n */\nconst SOUP =\n  \"!#%()*+,-./:;=?@[]^_`{|}~\" +\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst SOUP_LEN = SOUP.length;\nconst ID_LEN = 20;\nconst reusedIdCarrier = Array(ID_LEN);\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n */\nexport const genUID = (): string => {\n  for (let i = 0; i < ID_LEN; i++) {\n    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);\n  }\n  return reusedIdCarrier.join(\"\");\n};\n","import { genUID } from \"./gen-uid\";\n\nexport type SideEffectDisposer = () => void;\n\nexport class SideEffectManager {\n  /**\n   * Add a disposer directly.\n   * @param disposer a disposer\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public addDisposer(\n    disposer: SideEffectDisposer,\n    disposerID: string = genUID()\n  ): string {\n    this.flush(disposerID);\n    this.disposers.set(disposerID, disposer);\n    return disposerID;\n  }\n\n  /**\n   * Add a side effect.\n   * @param executor execute side effect\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public add(\n    executor: () => SideEffectDisposer,\n    disposerID: string = genUID()\n  ): string {\n    return this.addDisposer(executor(), disposerID);\n  }\n\n  /**\n   * Sugar for addEventListener.\n   * @param el\n   * @param type\n   * @param listener\n   * @param options\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public addEventListener<K extends keyof WindowEventMap>(\n    el: Window,\n    type: K,\n    listener: (this: Window, ev: WindowEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof DocumentEventMap>(\n    el: Document,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof MediaQueryListEventMap>(\n    el: MediaQueryList,\n    type: K,\n    listener: (this: HTMLElement, ev: MediaQueryListEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener(\n    el: HTMLElement | Window | Document | MediaQueryList,\n    type: string,\n    listener: (this: HTMLElement | Window | Document, ev: Event) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID = genUID()\n  ): string {\n    el.addEventListener(type, listener, options);\n    this.addDisposer(\n      () => el.removeEventListener(type, listener, options),\n      disposerID\n    );\n    return disposerID;\n  }\n\n  /**\n   * Sugar for setTimeout.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public setTimeout(\n    handler: () => void,\n    timeout: number,\n    disposerID: string = genUID()\n  ): string {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposerID);\n      handler();\n    }, timeout);\n    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);\n  }\n\n  /**\n   * Sugar for setInterval.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public setInterval(\n    handler: () => void,\n    timeout: number,\n    disposerID: string = genUID()\n  ): string {\n    const ticket = window.setInterval(handler, timeout);\n    return this.addDisposer(() => window.clearInterval(ticket), disposerID);\n  }\n\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public remove(disposerID: string): SideEffectDisposer | undefined {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public flush(disposerID: string): void {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  /**\n   * Remove and run all of the disposers.\n   */\n  public flushAll(): void {\n    this.disposers.forEach(disposer => {\n      try {\n        disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    });\n    this.disposers.clear();\n  }\n\n  /**\n   * All disposers. Use this only when you know what you are doing.\n   */\n  public readonly disposers = new Map<string, SideEffectDisposer>();\n}\n","import { genUID } from \"./gen-uid\";\n\nexport type AsyncSideEffectDisposer = () => Promise<void> | void;\n\nexport type AsyncSideEffectExecutor = () =>\n  | Promise<AsyncSideEffectDisposer>\n  | AsyncSideEffectDisposer;\n\nexport class AsyncSideEffectManager {\n  /**\n   * Add a side effect.\n   * @param executor execute side effect\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public add(\n    executor: AsyncSideEffectExecutor,\n    disposerID: string = genUID()\n  ): string {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._add(executor, disposerID));\n    } else {\n      this._add(executor, disposerID);\n    }\n    return disposerID;\n  }\n\n  private async _add(\n    executor: AsyncSideEffectExecutor,\n    disposerID: string\n  ): Promise<void> {\n    this._startTask(disposerID);\n\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n\n    try {\n      this.disposers.set(disposerID, await executor());\n    } catch (e) {\n      console.error(e);\n    }\n\n    this._endTask(disposerID);\n\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public remove(disposerID: string): AsyncSideEffectDisposer | undefined {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public flush(disposerID: string): void {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._flush(disposerID));\n    } else {\n      this._flush(disposerID);\n    }\n  }\n\n  private async _flush(disposerID: string): Promise<void> {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      this._startTask(disposerID);\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n      this._endTask(disposerID);\n    }\n\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n\n  /**\n   * Remove and run all of the disposers.\n   */\n  public flushAll(): void {\n    this.disposers.forEach((_, disposerID) => this.flush(disposerID));\n  }\n\n  /**\n   * @returns a Promise resolved when current tasks are finished.\n   */\n  public finished: Promise<void> = Promise.resolve();\n  private _resolveFinished?: () => void;\n\n  /**\n   * All disposers. Use this only when you know what you are doing.\n   */\n  public readonly disposers = new Map<string, AsyncSideEffectDisposer>();\n\n  private readonly _nextTask = new Map<string, () => any>();\n  private readonly _isRunning = new Set<string>();\n\n  private _startTask(disposerID: string): void {\n    this._isRunning.add(disposerID);\n    if (!this._resolveFinished) {\n      this.finished = new Promise(resolve => {\n        this._resolveFinished = resolve;\n      });\n    }\n  }\n\n  private _endTask(disposerID: string): void {\n    this._isRunning.delete(disposerID);\n    if (\n      this._resolveFinished &&\n      this._isRunning.size <= 0 &&\n      this._nextTask.size <= 0\n    ) {\n      this._resolveFinished();\n      this._resolveFinished = undefined;\n    }\n  }\n}\n"],"names":["SOUP","SOUP_LEN","length","reusedIdCarrier","Array","genUID","i","charAt","Math","random","join","constructor","Map","addDisposer","disposer","disposerID","flush","disposers","set","add","executor","this","addEventListener","el","type","listener","options","removeEventListener","setTimeout","handler","timeout","ticket","window","remove","clearTimeout","setInterval","clearInterval","get","delete","e","error","flushAll","forEach","clear","Promise","resolve","Set","_isRunning","has","_nextTask","_add","_startTask","_endTask","task","_flush","_","_resolveFinished","finished","size"],"mappings":"AASA,MAAMA,EACJ,0FAEIC,EAAWD,EAAKE,OAEhBC,EAAkBC,MADT,IAOFC,EAAS,aACXC,EAAI,EAAGA,EARH,GAQeA,MACVA,GAAKN,EAAKO,OAAOC,KAAKC,SAAWR,UAE5CE,EAAgBO,KAAK,aCpBvBC,6BA8JuB,IAAIC,IAvJzBC,YACLC,EACAC,EAAqBV,iBAEhBW,MAAMD,QACNE,UAAUC,IAAIH,EAAYD,GACxBC,EASFI,IACLC,EACAL,EAAqBV,YAEdgB,KAAKR,YAAYO,IAAYL,GAwC/BO,iBACLC,EACAC,EACAC,EACAC,EACAX,EAAaV,cAEViB,iBAAiBE,EAAMC,EAAUC,QAC/Bb,aACH,IAAMU,EAAGI,oBAAoBH,EAAMC,EAAUC,IAC7CX,GAEKA,EAUFa,WACLC,EACAC,EACAf,EAAqBV,WAEf0B,EAASC,OAAOJ,YAAW,UAC1BK,OAAOlB,SAEXe,UACIT,KAAKR,aAAY,IAAMmB,OAAOE,aAAaH,IAAShB,GAUtDoB,YACLN,EACAC,EACAf,EAAqBV,WAEf0B,EAASC,OAAOG,YAAYN,EAASC,UACpCT,KAAKR,aAAY,IAAMmB,OAAOI,cAAcL,IAAShB,GAOvDkB,OAAOlB,SACND,EAAWO,KAAKJ,UAAUoB,IAAItB,eAC/BE,UAAUqB,OAAOvB,GACfD,EAOFE,MAAMD,SACLD,EAAWO,KAAKY,OAAOlB,MACzBD,gBAGOyB,WACCC,MAAMD,IAQbE,gBACAxB,UAAUyB,2BAGJH,WACCC,MAAMD,YAGbtB,UAAU0B,iBCpJZhC,4BAoG4BiC,QAAQC,yBAMb,IAAIjC,mBAEH,IAAIA,oBACH,IAAIkC,IAtG3B3B,IACLC,EACAL,EAAqBV,YAEjBgB,KAAK0B,WAAWC,IAAIjC,QACjBkC,UAAU/B,IAAIH,GAAY,IAAMM,KAAK6B,KAAK9B,EAAUL,UAEpDmC,KAAK9B,EAAUL,GAEfA,aAIPK,EACAL,QAEKoC,WAAWpC,SAEVD,EAAWO,KAAKY,OAAOlB,MACzBD,YAEMA,UACCyB,WACCC,MAAMD,YAKXtB,UAAUC,IAAIH,QAAkBK,WAC9BmB,WACCC,MAAMD,QAGXa,SAASrC,SAERsC,EAAOhC,KAAK4B,UAAUZ,IAAItB,GAC5BsC,SACGJ,UAAUX,OAAOvB,QASnBkB,OAAOlB,SACND,EAAWO,KAAKJ,UAAUoB,IAAItB,eAC/BE,UAAUqB,OAAOvB,GACfD,EAOFE,MAAMD,GACPM,KAAK0B,WAAWC,IAAIjC,QACjBkC,UAAU/B,IAAIH,GAAY,IAAMM,KAAKiC,OAAOvC,UAE5CuC,OAAOvC,gBAIKA,SACbD,EAAWO,KAAKY,OAAOlB,MACzBD,EAAU,MACPqC,WAAWpC,aAERD,UACCyB,WACCC,MAAMD,QAEXa,SAASrC,SAGVsC,EAAOhC,KAAK4B,UAAUZ,IAAItB,GAC5BsC,SACGJ,UAAUX,OAAOvB,QAQnB0B,gBACAxB,UAAUyB,SAAQ,CAACa,EAAGxC,IAAeM,KAAKL,MAAMD,KAiB/CoC,WAAWpC,QACZgC,WAAW5B,IAAIJ,GACfM,KAAKmC,wBACHC,SAAW,IAAIb,kBACbY,iBAAmBX,MAKtBO,SAASrC,QACVgC,WAAWT,OAAOvB,GAErBM,KAAKmC,kBACLnC,KAAK0B,WAAWW,MAAQ,GACxBrC,KAAK4B,UAAUS,MAAQ,SAElBF,wBACAA,sBAAmB"}