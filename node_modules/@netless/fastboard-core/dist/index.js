'use strict';

var whiteWebSdk = require('white-web-sdk');
var windowManager = require('@netless/window-manager');
var syncedStore = require('@netless/synced-store');
var SlideApp = require('@netless/app-slide');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var SlideApp__default = /*#__PURE__*/_interopDefault(SlideApp);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils/store.ts
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function readable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        for (const run of subscribers) {
          run(value);
        }
      }
    }
  }
  function subscribe(run) {
    subscribers.add(run);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run(value);
    return () => {
      subscribers.delete(run);
      if (subscribers.size === 0) {
        stop && stop();
        stop = void 0;
      }
    };
  }
  function reaction(run) {
    subscribers.add(run);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    return () => {
      subscribers.delete(run);
      if (subscribers.size === 0) {
        stop && stop();
        stop = void 0;
      }
    };
  }
  return {
    get value() {
      return value;
    },
    subscribe,
    reaction
  };
}
function writable(value, start = noop, set) {
  const internal = readable(value, start);
  return {
    get value() {
      return internal.value;
    },
    subscribe: internal.subscribe,
    reaction: internal.reaction,
    set,
    update(fn) {
      set(fn(internal.value));
    }
  };
}

// src/utils/misc.ts
function getImageSize(url, fallback, crossOrigin) {
  return new Promise((resolve) => {
    const img = new Image();
    applyCrossOrigin(img, url, crossOrigin);
    img.onload = () => resolve(img);
    img.onerror = () => resolve(fallback);
    img.src = url;
  });
}
function applyCrossOrigin(image, src, crossOrigin) {
  if (crossOrigin === void 0 && !src.startsWith("data:")) {
    image.crossOrigin = determineCrossOrigin(src);
  } else if (crossOrigin !== false) {
    image.crossOrigin = typeof crossOrigin === "string" ? crossOrigin : "anonymous";
  }
}
function determineCrossOrigin(src) {
  if (src.startsWith("data:") || typeof window === "undefined" || !window.location) {
    return "";
  }
  const loc = window.location;
  try {
    const parsedUrl = new URL(src, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  } catch (e) {
    return "";
  }
}
function makeSlideParams(scenes) {
  const emptyScenes = [];
  let taskId = "";
  let url = "";
  const pptSrcRE = new RegExp("^pptx?(?<prefix>:\\/\\/\\S+?dynamicConvert)\\/(?<taskId>\\w+)\\/");
  for (const { name, ppt } of scenes) {
    emptyScenes.push({ name });
    if (!ppt || !ppt.src.startsWith("ppt"))
      continue;
    const match = pptSrcRE.exec(ppt.src);
    if (!match || !match.groups)
      continue;
    taskId = match.groups.taskId;
    url = `https${match.groups.prefix}`;
    break;
  }
  return { scenes: emptyScenes, taskId, url };
}
function convertedFileToScene(f, i) {
  return {
    name: String(i + 1),
    ppt: {
      src: f.conversionFileUrl,
      width: f.width,
      height: f.height,
      previewURL: f.preview
    }
  };
}

// src/utils/uid.ts
var SOUP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var SOUP_LEN = 62;
var ID_LEN = 20;
var reusedIdCarrier = /* @__PURE__ */ Array(ID_LEN);
function genUID() {
  for (let i = 0; i < ID_LEN; i++) {
    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);
  }
  return reusedIdCarrier.join("");
}

// src/utils/warn.ts
var warnings = {
  "no-ppt-in-scenes": "You're probably inserting the slide app in a wrong way, there shouldn't exist `scenes[0].ppt`."
};
var warned = /* @__PURE__ */ new Set();
function warn(id) {
  if (warned.has(id))
    return;
  warned.add(id);
  console.warn(warnings[id]);
}
function ensure_official_plugins(joinRoom) {
  const plugins = new Set(joinRoom.invisiblePlugins || []);
  plugins.add(windowManager.WindowManager);
  plugins.add(syncedStore.SyncedStorePlugin);
  joinRoom.invisiblePlugins = [...plugins];
  return joinRoom;
}
function transform_app_status(status) {
  return status === "start" ? "loading" : status === "failed" ? "failed" : "idle";
}
var DefaultApps = {
  Monaco: {
    src: "https://netless-app.oss-cn-hangzhou.aliyuncs.com/@netless/app-monaco/0.1.14-beta.1/dist/main.iife.js"
  },
  Countdown: {
    src: "https://netless-app.oss-cn-hangzhou.aliyuncs.com/@netless/app-countdown/0.0.2/dist/main.iife.js"
  },
  GeoGebra: {
    src: "https://netless-app.oss-cn-hangzhou.aliyuncs.com/@netless/app-geogebra/0.0.4/dist/main.iife.js",
    appOptions: {
      HTML5Codebase: "https://flat-storage-cn-hz.whiteboard.agora.io/GeoGebra/HTML5/5.0/web3d"
    }
  },
  EmbeddedPage: {
    src: "https://netless-app.oss-cn-hangzhou.aliyuncs.com/@netless/app-embedded-page/0.1.1/dist/main.iife.js"
  },
  Plyr: {
    src: "https://netless-app.oss-cn-hangzhou.aliyuncs.com/@netless/app-plyr/0.1.3/dist/main.iife.js"
  }
};
windowManager.WindowManager.register({
  kind: "Slide",
  appOptions: { debug: false },
  src: SlideApp__default.default,
  addHooks: SlideApp.addHooks
});
for (const kind in DefaultApps) {
  if (Object.prototype.hasOwnProperty.call(DefaultApps, kind)) {
    const options = DefaultApps[kind];
    windowManager.WindowManager.register(__spreadValues({ kind }, options));
  }
}
var register = windowManager.WindowManager.register.bind(windowManager.WindowManager);
var version = "0.3.10";
if (typeof window !== "undefined") {
  let str = window.__netlessUA || "";
  str += ` ${"@netless/fastboard"}@${version} `;
  window.__netlessUA = str;
}

// src/impl/FastboardApp.ts
var FastboardAppBase = class {
  constructor(sdk, room, manager, hotKeys, syncedStore) {
    this.sdk = sdk;
    this.room = room;
    this.manager = manager;
    this.hotKeys = hotKeys;
    this.syncedStore = syncedStore;
    __publicField(this, "_destroyed", false);
  }
  /** @internal */
  _assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("FastboardApp has been destroyed");
    }
  }
  /** @internal */
  _addRoomListener(name, listener) {
    this._assertNotDestroyed();
    this.room.callbacks.on(name, listener);
    return () => this.room.callbacks.off(name, listener);
  }
  /** @internal */
  _addManagerListener(name, listener) {
    this._assertNotDestroyed();
    this.manager.emitter.on(name, listener);
    return () => this.manager.emitter.off(name, listener);
  }
  /** @internal */
  _addMainViewListener(name, listener) {
    this._assertNotDestroyed();
    this.manager.mainView.callbacks.on(name, listener);
    return () => this.manager.mainView.callbacks.off(name, listener);
  }
  /**
   * Destroy fastboard (disconnect from the whiteboard room).
   */
  destroy() {
    this._destroyed = true;
    this.manager.destroy();
    return this.room.disconnect();
  }
};
var FastboardApp = class extends FastboardAppBase {
  constructor() {
    super(...arguments);
    /**
     * Is current room writable?
     */
    __publicField(this, "writable", writable(
      this.room.isWritable,
      (set) => {
        set(this.room.isWritable);
        return this._addRoomListener("onEnableWriteNowChanged", () => set(this.room.isWritable));
      },
      this.room.setWritable.bind(this.room)
    ));
    /**
     * Is current room online?
     */
    __publicField(this, "phase", readable(this.room.phase, (set) => {
      set(this.room.phase);
      return this._addRoomListener("onPhaseChanged", set);
    }));
    /**
     * Current window-manager's windows' state (is it maximized?).
     */
    __publicField(this, "boxState", readable(this.manager.boxState, (set) => {
      set(this.manager.boxState);
      return this._addManagerListener("boxStateChange", set);
    }));
    /**
     * Current window-manager's focused app's id.
     * @example "HelloWorld-1A2b3C4d"
     */
    __publicField(this, "focusedApp", readable(this.manager.focused, (set) => {
      set(this.manager.focused);
      return this._addManagerListener("focusedChange", set);
    }));
    /**
     * How many times can I call `app.redo()`?
     */
    __publicField(this, "canRedoSteps", readable(this.manager.canRedoSteps, (set) => {
      set(this.manager.canRedoSteps);
      return this._addManagerListener("canRedoStepsChange", set);
    }));
    /**
     * How many times can I call `app.undo()`?
     */
    __publicField(this, "canUndoSteps", readable(this.manager.canUndoSteps, (set) => {
      set(this.manager.canUndoSteps);
      return this._addManagerListener("canUndoStepsChange", set);
    }));
    /**
     * Current camera information of main view.
     *
     * Change the camera position by `app.moveCamera()`.
     */
    __publicField(this, "camera", readable(this.manager.cameraState, (set) => {
      set(this.manager.cameraState);
      return this._addManagerListener("cameraStateChange", set);
    }));
    /**
     * Current tool's info, like "is using pencil?", "what color?".
     *
     * Change the tool by `app.setAppliance()`.
     */
    __publicField(this, "memberState", readable(this.room.state.memberState, (set) => {
      set(this.room.state.memberState);
      return this._addRoomListener("onRoomStateChanged", ({ memberState: m }) => m && set(m));
    }));
    /**
     * 0..n-1, current index of main view scenes.
     */
    __publicField(this, "sceneIndex", writable(
      this.manager.mainViewSceneIndex,
      (set) => {
        set(this.manager.mainViewSceneIndex);
        return this._addManagerListener("mainViewSceneIndexChange", set);
      },
      this.manager.setMainViewSceneIndex.bind(this.manager)
    ));
    /**
     * How many pages are in the main view?
     */
    __publicField(this, "sceneLength", readable(this.manager.mainViewScenesLength, (set) => {
      set(this.manager.mainViewScenesLength);
      return this._addManagerListener("mainViewScenesLengthChange", set);
    }));
    /** @internal */
    __publicField(this, "_appsStatus", {});
    /**
     * Apps status.
     */
    __publicField(this, "appsStatus", readable(
      {},
      (set) => this._addManagerListener("loadApp", ({ kind, status, reason }) => {
        this._appsStatus[kind] = { status: transform_app_status(status), reason };
        set(this._appsStatus);
      })
    ));
  }
  /**
   * Render this app to some DOM.
   */
  bindContainer(container) {
    this._assertNotDestroyed();
    this.manager.bindContainer(container);
  }
  /**
   * Move window-manager's collector to some place.
   */
  bindCollector(container) {
    this._assertNotDestroyed();
    this.manager.bindCollectorContainer(container);
  }
  /**
   * Undo a step on main view.
   */
  undo() {
    this._assertNotDestroyed();
    this.manager.undo();
  }
  /**
   * Redo a step on main view.
   */
  redo() {
    this._assertNotDestroyed();
    this.manager.redo();
  }
  /**
   * Move current main view's camera position.
   */
  moveCamera(camera) {
    this._assertNotDestroyed();
    this.manager.moveCamera(camera);
  }
  /**
   * Move current main view's camera to include a rectangle.
   */
  moveCameraToContain(rectangle) {
    this._assertNotDestroyed();
    this.manager.moveCameraToContain(rectangle);
  }
  /**
   * Delete all things on the main view.
   */
  cleanCurrentScene() {
    this._assertNotDestroyed();
    this.manager.cleanCurrentScene();
  }
  /**
   * Set current tool, like "pencil".
   */
  setAppliance(appliance, shape) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({
      currentApplianceName: appliance,
      shapeType: shape
    });
  }
  /**
   * Set pencil and shape's thickness.
   */
  setStrokeWidth(strokeWidth) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ strokeWidth });
  }
  /**
   * Set pencil and shape's color.
   */
  setStrokeColor(strokeColor) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ strokeColor });
  }
  /**
   * Set text size. Default is 16.
   */
  setTextSize(textSize) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ textSize });
  }
  /**
   * Set text color.
   *
   * @example
   * setTextColor([0x66, 0xcc, 0xff])
   */
  setTextColor(textColor) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ textColor });
  }
  /**
   * Toggle dotted line effect on pencil.
   */
  toggleDottedLine(force) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ dottedLine: force != null ? force : !this.memberState.value.dottedLine });
  }
  /**
   * Set pencil eraser size.
   */
  setPencilEraserSize(size) {
    this._assertNotDestroyed();
    this.manager.mainView.setMemberState({ pencilEraserSize: size });
  }
  /**
   * Goto previous page (the main whiteboard view).
   */
  prevPage() {
    this._assertNotDestroyed();
    return this.manager.prevPage();
  }
  /**
   * Goto next page (the main whiteboard view).
   */
  nextPage() {
    this._assertNotDestroyed();
    return this.manager.nextPage();
  }
  /**
   * Goto any page (index range: 0..n-1)
   */
  jumpPage(index) {
    this._assertNotDestroyed();
    return this.manager.jumpPage(index);
  }
  /**
   * Add one page to the main whiteboard view.
   *
   * @example
   * addPage({ after: true }) // add one page right after current one.
   * nextPage() // then, goto that page.
   */
  addPage(params) {
    this._assertNotDestroyed();
    return this.manager.addPage(params);
  }
  /**
   * Remove one page at given index or current page (by default).
   *
   * Requires `@netless/window-manager` >= 0.4.30.
   *
   * @example
   * removePage() // remove current page
   */
  removePage(index) {
    this._assertNotDestroyed();
    return this.manager.removePage(index);
  }
  /**
   * Insert an image to the main view.
   *
   * @param crossOrigin Whether to load the image with CORS enabled, default is `true`.
   *
   * @example
   * insertImage("https://i.imgur.com/CzXTtJV.jpg")
   */
  async insertImage(url, crossOrigin) {
    this._assertNotDestroyed();
    await this.manager.switchMainViewToWriter();
    const { divElement } = this.manager.mainView;
    const containerSize = {
      width: (divElement == null ? void 0 : divElement.scrollWidth) || window.innerWidth,
      height: (divElement == null ? void 0 : divElement.scrollHeight) || window.innerHeight
    };
    const maxWidth = containerSize.width * 0.8;
    let { width, height } = await getImageSize(url, containerSize, crossOrigin);
    const scale = Math.min(maxWidth / width, 1);
    const uuid = genUID();
    const { centerX, centerY } = this.manager.camera;
    width *= scale;
    height *= scale;
    this.manager.mainView.insertImage({
      uuid,
      centerX,
      centerY,
      width,
      height,
      locked: false,
      crossOrigin
    });
    this.manager.mainView.completeImageUpload(uuid, url);
    width /= 0.8;
    height /= 0.8;
    const originX = centerX - width / 2;
    const originY = centerY - height / 2;
    this.manager.moveCameraToContain({ originX, originY, width, height });
  }
  insertDocs(arg1, arg2) {
    this._assertNotDestroyed();
    if (typeof arg1 === "object" && "fileType" in arg1) {
      return this._insertDocsImpl(arg1);
    } else if (arg2 && arg2.status !== "Finished") {
      throw new Error("FastboardApp cannot insert a converting doc.");
    } else if (arg2 && "progress" in arg2) {
      const title = arg1;
      const scenePath = `/${arg2.uuid}/${genUID()}`;
      const scenes1 = arg2.progress.convertedFileList.map(convertedFileToScene);
      const { scenes, taskId, url } = makeSlideParams(scenes1);
      if (taskId && url) {
        return this._insertDocsImpl({ fileType: "pptx", scenePath, scenes, title, taskId, url });
      } else {
        return this._insertDocsImpl({ fileType: "pdf", scenePath, scenes: scenes1, title });
      }
    } else if (arg2 && arg2.prefix) {
      const title = arg1;
      const scenePath = `/${arg2.uuid}/${genUID()}`;
      const taskId = arg2.uuid;
      const url = arg2.prefix;
      this._insertDocsImpl({ fileType: "pptx", scenePath, taskId, title, url });
    } else if (arg2 && arg2.images) {
      const title = arg1;
      const scenePath = `/${arg2.uuid}/${genUID()}`;
      const scenes = [];
      for (const name in arg2.images) {
        const { width, height, url } = arg2.images[name];
        scenes.push({ name, ppt: { width, height, src: url } });
      }
      this._insertDocsImpl({ fileType: "pdf", scenePath, scenes, title });
    } else {
      throw new Error("Invalid input: not found 'progress', 'prefix' nor 'images'");
    }
  }
  /** @internal */
  _insertDocsImpl(_a) {
    var _b = _a, { fileType, scenePath, title, scenes } = _b, attributes = __objRest(_b, ["fileType", "scenePath", "title", "scenes"]);
    this._assertNotDestroyed();
    switch (fileType) {
      case "pdf":
        return this.manager.addApp({
          kind: "DocsViewer",
          options: { scenePath, title, scenes }
        });
      case "pptx":
        if (scenes && scenes[0].ppt) {
          warn("no-ppt-in-scenes");
        }
        return this.manager.addApp({
          kind: "Slide",
          options: { scenePath, title, scenes },
          attributes
        });
    }
  }
  /**
   * Insert the Media Player app.
   */
  insertMedia(title, src) {
    this._assertNotDestroyed();
    return this.manager.addApp({
      kind: windowManager.BuiltinApps.MediaPlayer,
      options: { title },
      attributes: { src }
    });
  }
  /**
   * Insert the Monaco Code Editor app.
   * @deprecated Use `app.manager.addApp({ kind: 'Monaco' })` instead.
   */
  insertCodeEditor() {
    this._assertNotDestroyed();
    return this.manager.addApp({
      kind: "Monaco",
      options: { title: "Code Editor" }
    });
  }
  /**
   * Insert the Countdown app.
   * @deprecated Use `app.manager.addApp({ kind: 'Countdown' })` instead.
   */
  insertCountdown() {
    this._assertNotDestroyed();
    return this.manager.addApp({
      kind: "Countdown",
      options: { title: "Countdown" }
    });
  }
  /**
   * Insert the GeoGebra app.
   * @deprecated Use `app.manager.addApp({ kind: 'GeoGebra' })` instead.
   */
  insertGeoGebra() {
    this._assertNotDestroyed();
    return this.manager.addApp({
      kind: "GeoGebra",
      options: { title: "GeoGebra" }
    });
  }
};
async function createFastboard(_a) {
  var _b = _a, {
    sdkConfig,
    joinRoom: _c
  } = _b, _d = _c, { callbacks } = _d, joinRoomParams = __objRest(_d, ["callbacks"]), {
    managerConfig,
    netlessApps
  } = _b;
  const sdk = new whiteWebSdk.WhiteWebSdk(__spreadProps(__spreadValues({}, sdkConfig), {
    useMobXState: true
  }));
  const hotKeys = joinRoomParams.hotKeys || __spreadProps(__spreadValues({}, whiteWebSdk.DefaultHotKeys), {
    changeToSelector: "s",
    changeToLaserPointer: "z",
    changeToPencil: "p",
    changeToRectangle: "r",
    changeToEllipse: "c",
    changeToEraser: "e",
    changeToText: "t",
    changeToStraight: "l",
    changeToArrow: "a",
    changeToHand: "h"
  });
  if (netlessApps) {
    netlessApps.forEach((app) => {
      register({ kind: app.kind, src: app });
    });
  }
  const room = await sdk.joinRoom(
    __spreadProps(__spreadValues({
      floatBar: true,
      hotKeys
    }, ensure_official_plugins(joinRoomParams)), {
      useMultiViews: true,
      disableNewPencil: false,
      disableMagixEventDispatchLimit: true
    }),
    callbacks
  );
  const syncedStore$1 = await syncedStore.SyncedStorePlugin.init(room);
  const manager = await windowManager.WindowManager.mount(__spreadProps(__spreadValues({
    cursor: true
  }, managerConfig), {
    room
  }));
  manager.mainView.setCameraBound({
    minContentMode: whiteWebSdk.contentModeScale(0.3),
    maxContentMode: whiteWebSdk.contentModeScale(3)
  });
  return new FastboardApp(sdk, room, manager, hotKeys, syncedStore$1);
}
var FastboardPlayerBase = class {
  constructor(sdk, player, manager, syncedStore) {
    this.sdk = sdk;
    this.player = player;
    this.manager = manager;
    this.syncedStore = syncedStore;
    __publicField(this, "_destroyed", false);
  }
  /** @internal */
  _assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("FastboardApp has been destroyed");
    }
  }
  /** @internal */
  _addPlayerListener(name, listener) {
    this._assertNotDestroyed();
    this.player.callbacks.on(name, listener);
    return () => this.player.callbacks.off(name, listener);
  }
  /** @internal */
  _addManagerListener(name, listener) {
    this._assertNotDestroyed();
    this.manager.emitter.on(name, listener);
    return () => this.manager.emitter.off(name, listener);
  }
  /** @internal */
  _addMainViewListener(name, listener) {
    this._assertNotDestroyed();
    this.manager.mainView.callbacks.on(name, listener);
    return () => this.manager.mainView.callbacks.off(name, listener);
  }
  destroy() {
    this._destroyed = true;
    this.manager.destroy();
    return this.player.callbacks.off();
  }
};
var FastboardPlayer = class extends FastboardPlayerBase {
  constructor() {
    super(...arguments);
    /**
     * Player current time in milliseconds.
     */
    __publicField(this, "currentTime", writable(
      this.player.progressTime,
      (set) => {
        set(this.player.progressTime);
        return this._addPlayerListener("onProgressTimeChanged", set);
      },
      this.player.seekToProgressTime.bind(this.player)
    ));
    /**
     * Player state, like "is it playing?".
     */
    __publicField(this, "phase", readable(this.player.phase, (set) => {
      set(this.player.phase);
      return this._addPlayerListener("onPhaseChanged", set);
    }));
    /**
     * Will become true after buffering.
     */
    __publicField(this, "canplay", readable(this.player.isPlayable, (set) => {
      set(this.player.isPlayable);
      return this._addPlayerListener("onIsPlayableChanged", set);
    }));
    /** @internal */
    __publicField(this, "_setPlaybackRate");
    /**
     * Playback speed, default `1`.
     */
    __publicField(this, "playbackRate", writable(
      this.player.playbackSpeed,
      (set) => {
        this._setPlaybackRate = set;
        set(this.player.playbackSpeed);
      },
      (value) => {
        this.player.playbackSpeed = value;
        this._setPlaybackRate(value);
      }
    ));
    /**
     * Playback duration in milliseconds.
     */
    __publicField(this, "duration", readable(this.player.timeDuration, (set) => {
      set(this.player.timeDuration);
    }));
    /**
     * Get state of room at that time, like "who was in the room?".
     */
    __publicField(this, "state", readable(this.player.state, (set) => {
      set(this.player.state);
      return this._addPlayerListener("onPlayerStateChanged", () => set(this.player.state));
    }));
  }
  /**
   * Render this player to some DOM.
   */
  bindContainer(container) {
    this._assertNotDestroyed();
    this.manager.bindContainer(container);
  }
  /**
   * Move window-manager's collector to some place.
   */
  bindCollector(container) {
    this._assertNotDestroyed();
    this.manager.bindCollectorContainer(container);
  }
  /**
   * Seek to some time in milliseconds.
   */
  seek(timestamp) {
    this._assertNotDestroyed();
    return this.player.seekToProgressTime(timestamp);
  }
  /**
   * Change player state to playing.
   */
  play() {
    this._assertNotDestroyed();
    this.player.play();
  }
  /**
   * Change player state to paused.
   */
  pause() {
    this._assertNotDestroyed();
    this.player.pause();
  }
  /**
   * Change player state to stopped.
   */
  stop() {
    this._assertNotDestroyed();
    this.player.stop();
  }
  /**
   * Set playback speed, a shortcut for `speed.set(x)`.
   */
  setPlaybackRate(value) {
    this._assertNotDestroyed();
    this.playbackRate.set(value);
  }
};
async function replayFastboard(_a) {
  var _b = _a, {
    sdkConfig,
    replayRoom: _c
  } = _b, _d = _c, { callbacks } = _d, replayRoomParams = __objRest(_d, ["callbacks"]), {
    managerConfig,
    netlessApps
  } = _b;
  const sdk = new whiteWebSdk.WhiteWebSdk(__spreadProps(__spreadValues({}, sdkConfig), {
    useMobXState: true
  }));
  if (netlessApps) {
    netlessApps.forEach((app) => {
      register({ kind: app.kind, src: app });
    });
  }
  const player = await sdk.replayRoom(
    __spreadProps(__spreadValues({}, ensure_official_plugins(replayRoomParams)), {
      useMultiViews: true
    }),
    callbacks
  );
  const syncedStore$1 = await syncedStore.SyncedStorePlugin.init(player);
  const managerPromise = windowManager.WindowManager.mount(__spreadProps(__spreadValues({
    cursor: true
  }, managerConfig), {
    room: player
  }));
  player.play();
  const manager = await managerPromise;
  player.pause();
  await player.seekToProgressTime(0);
  return new FastboardPlayer(sdk, player, manager, syncedStore$1);
}

// src/helpers/listen.ts
function addRoomListener(room, name, listener) {
  room.callbacks.on(name, listener);
  return () => room.callbacks.off(name, listener);
}
function addPlayerListener(player, name, listener) {
  player.callbacks.on(name, listener);
  return () => player.callbacks.off(name, listener);
}
function addViewListener(view, name, listener) {
  view.callbacks.on(name, listener);
  return () => view.callbacks.off(name, listener);
}
function addManagerListener(manager, name, listener) {
  return manager.emitter.on(name, listener);
}

// src/helpers/docs.ts
function dispatchDocsEvent(fastboard, event, options = {}) {
  var _a, _b, _c;
  const manager = "manager" in fastboard ? fastboard.manager : fastboard;
  const appId = options.appId || manager.focused;
  if (!appId) {
    console.warn("not found " + (options.appId || "focused app"));
    return false;
  }
  let page, input;
  if (appId.startsWith("DocsViewer-")) {
    const dom = (_b = (_a = manager.queryOne(appId)) == null ? void 0 : _a.box) == null ? void 0 : _b.$footer;
    if (!dom) {
      console.warn("not found app with id " + appId);
      return false;
    }
    const click = (el) => {
      el && el.dispatchEvent(new MouseEvent("click"));
    };
    switch (event) {
      case "prevPage":
      case "prevStep":
        click(dom.querySelector('button[class$="btn-page-back"]'));
        break;
      case "nextPage":
      case "nextStep":
        click(dom.querySelector('button[class$="btn-page-next"]'));
        break;
      case "jumpToPage":
        page = options.page;
        input = dom.querySelector('input[class$="page-number-input"]');
        if (!input || typeof page !== "number") {
          console.warn("failed to jump" + (page ? " to page " + page : ""));
          return false;
        }
        input.value = "" + page;
        input.dispatchEvent(new InputEvent("change"));
        break;
      default:
        console.warn("unknown event " + event);
        return false;
    }
    return true;
  } else if (appId.startsWith("Slide-")) {
    const app = (_c = manager.queryOne(appId)) == null ? void 0 : _c.appResult;
    if (!app) {
      console.warn("not found app with id " + appId);
      return false;
    }
    switch (event) {
      case "prevPage":
        return app.prevPage();
      case "nextPage":
        return app.nextPage();
      case "prevStep":
        return app.prevStep();
      case "nextStep":
        return app.nextStep();
      case "jumpToPage":
        page = options.page;
        if (typeof page !== "number") {
          console.warn("failed to jump" + (page ? " to page " + page : ""));
          return false;
        }
        return app.jumpToPage(page);
      default:
        console.warn("unknown event " + event);
        return false;
    }
  } else {
    console.warn("not supported app " + appId);
    return false;
  }
}

Object.defineProperty(exports, 'SlideApp', {
  enumerable: true,
  get: function () { return SlideApp__default.default; }
});
Object.defineProperty(exports, 'addSlideHooks', {
  enumerable: true,
  get: function () { return SlideApp.addHooks; }
});
Object.defineProperty(exports, 'previewSlide', {
  enumerable: true,
  get: function () { return SlideApp.previewSlide; }
});
Object.defineProperty(exports, 'slideApps', {
  enumerable: true,
  get: function () { return SlideApp.apps; }
});
exports.FastboardApp = FastboardApp;
exports.FastboardPlayer = FastboardPlayer;
exports.addManagerListener = addManagerListener;
exports.addPlayerListener = addPlayerListener;
exports.addRoomListener = addRoomListener;
exports.addViewListener = addViewListener;
exports.convertedFileToScene = convertedFileToScene;
exports.createFastboard = createFastboard;
exports.dispatchDocsEvent = dispatchDocsEvent;
exports.genUID = genUID;
exports.getImageSize = getImageSize;
exports.makeSlideParams = makeSlideParams;
exports.readable = readable;
exports.register = register;
exports.replayFastboard = replayFastboard;
exports.version = version;
exports.warn = warn;
exports.writable = writable;
//# sourceMappingURL=index.js.map
