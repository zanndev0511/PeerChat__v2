import { Size, SceneDefinition, ConvertedFile, RoomPhase as RoomPhase$1, ApplianceNames, ShapeType, MemberState, RoomState, CameraState, Camera, AnimationMode, Rectangle, Color, ConversionResponse, WhiteWebSdkConfiguration, JoinRoomParams, RoomCallbacks, WhiteWebSdk, Room, HotKeys, PlayerPhase as PlayerPhase$1, PlayerState, PlayerSeekingResult, ReplayRoomParams, PlayerCallbacks, Player, ViewCallbacks, View } from 'white-web-sdk';
export { AnimationMode, ApplianceNames, Camera, CameraState, Color, ConversionResponse, HotKey, HotKeys, JoinRoomParams, MemberState, PlayerSeekingResult, Rectangle, Room, RoomCallbacks, RoomState, SceneDefinition, ShapeType, ViewCallbacks, WhiteWebSdk, WhiteWebSdkConfiguration } from 'white-web-sdk';
import { AddPageParams, MountParams, NetlessApp, WindowManager, RegisterParams, PublicEvent } from '@netless/window-manager';
export { AddPageParams, MountParams, NetlessApp, PublicEvent, WindowManager } from '@netless/window-manager';
import { SyncedStore } from '@netless/synced-store';
export { Diff, DiffOne, Storage, SyncedStore } from '@netless/synced-store';
export { PreviewParams, default as SlideApp, AppResult as SlideController, AppOptions as SlideOptions, SlidePreviewer, addHooks as addSlideHooks, previewSlide, apps as slideApps } from '@netless/app-slide';

type Subscriber<T> = (value: T) => void;
type Unsubscriber = () => void;
type Updater<T> = (value: T) => T;
type StartStopNotifier<T> = (set: Subscriber<T>) => Unsubscriber | void;
interface Readable<T> {
    readonly value: T;
    subscribe(this: void, run: Subscriber<T>): Unsubscriber;
    reaction(this: void, run: Subscriber<T>): Unsubscriber;
}
interface Writable<T> extends Readable<T> {
    set(this: void, value: T): void;
    update(this: void, updater: Updater<T>): void;
}
declare function readable<T>(value: T, start?: StartStopNotifier<T>): Readable<T>;
declare function writable<T>(value: T, start: StartStopNotifier<T> | undefined, set: Subscriber<T>): Writable<T>;

declare function getImageSize(url: string, fallback: Size, crossOrigin?: boolean | string): Promise<Size>;
declare function makeSlideParams(scenes: SceneDefinition[]): {
    scenes: SceneDefinition[];
    taskId: string;
    url: string;
};
declare function convertedFileToScene(f: ConvertedFile, i: number): SceneDefinition;

declare function genUID(): string;

declare const warnings: {
    readonly "no-ppt-in-scenes": "You're probably inserting the slide app in a wrong way, there shouldn't exist `scenes[0].ppt`.";
};
declare function warn(id: keyof typeof warnings): void;

declare class FastboardAppBase<TEventData extends Record<string, any> = any> {
    readonly sdk: WhiteWebSdk;
    readonly room: Room;
    readonly manager: WindowManager;
    readonly hotKeys: Partial<HotKeys>;
    readonly syncedStore: SyncedStore<TEventData>;
    constructor(sdk: WhiteWebSdk, room: Room, manager: WindowManager, hotKeys: Partial<HotKeys>, syncedStore: SyncedStore<TEventData>);
    protected _destroyed: boolean;
    /**
     * Destroy fastboard (disconnect from the whiteboard room).
     */
    destroy(): Promise<void>;
}
type RoomPhase = `${RoomPhase$1}`;

/** pencil, eraser, rectangle... */
type Appliance = `${ApplianceNames}`;
/** triangle, star... */
type Shape = `${ShapeType}`;
/** Params for static docs, they are rendered as many images. */
interface InsertDocsStatic {
    readonly fileType: "pdf";
    /** Unique string for binding whiteboard view to the doc. Must start with `/`. */
    readonly scenePath: string;
    /** @example [{ name: '1', ppt: { src: 'url/to/ppt/1.png' } }] */
    readonly scenes: SceneDefinition[];
    /** Window title. */
    readonly title?: string;
}
/** Params for slides, they are rendered in @netless/app-slide with animations. */
interface InsertDocsDynamic {
    readonly fileType: "pptx";
    /** Unique string for binding whiteboard view to the doc. Must start with `/`. */
    readonly scenePath: string;
    /** Conversion task id, see https://developer.netless.link/server-en/home/server-conversion#get-query-task-conversion-progress. */
    readonly taskId: string;
    /** Window title. */
    readonly title?: string;
    /** Where the slide resource placed. @default `https://convertcdn.netless.link/dynamicConvert` */
    readonly url?: string;
    /** @example [{ name: '1' }, { name: '2' }, { name: '3' }] */
    readonly scenes?: SceneDefinition[];
}
type InsertDocsParams = InsertDocsStatic | InsertDocsDynamic;
interface ProjectorResponse {
    uuid: string;
    status: "Waiting" | "Converting" | "Finished" | "Fail";
    type: "dynamic" | "static";
    /** 0..100 */
    convertedPercentage: number;
    /** https://example.org/path/to/dynamicConvert, only when type=dynamic */
    prefix?: string;
    pageCount?: number;
    /** {1:"{prefix}/{taskId}/preview/1.png"}, only when type=dynamic and preview=true */
    previews?: Record<number, string>;
    /** {prefix}/{taskId}/jsonOutput/note.json */
    note?: string;
    /** {1:{width,height,url}}, only when type=static */
    images?: Record<number, {
        width: number;
        height: number;
        url: string;
    }>;
    /** 20xxxxx */
    errorCode?: string;
    errorMessage?: string;
}
type SetMemberStateFn = (partialMemberState: Partial<MemberState>) => void;
type RoomStateChanged = (diff: Partial<RoomState>) => void;
/** App download progress. */
interface AppsStatus {
    [kind: string]: {
        status: "idle" | "loading" | "failed";
        /** Exist if status is `failed`. */
        reason?: string;
    };
}
declare class FastboardApp<TEventData extends Record<string, any> = any> extends FastboardAppBase<TEventData> {
    /**
     * Render this app to some DOM.
     */
    bindContainer(container: HTMLElement): void;
    /**
     * Move window-manager's collector to some place.
     */
    bindCollector(container: HTMLElement): void;
    /**
     * Is current room writable?
     */
    readonly writable: Writable<boolean>;
    /**
     * Is current room online?
     */
    readonly phase: Readable<"connecting" | "connected" | "reconnecting" | "disconnecting" | "disconnected">;
    /**
     * Current window-manager's windows' state (is it maximized?).
     */
    readonly boxState: Readable<"minimized" | "maximized" | "normal" | undefined>;
    /**
     * Current window-manager's focused app's id.
     * @example "HelloWorld-1A2b3C4d"
     */
    readonly focusedApp: Readable<string | undefined>;
    /**
     * How many times can I call `app.redo()`?
     */
    readonly canRedoSteps: Readable<number>;
    /**
     * How many times can I call `app.undo()`?
     */
    readonly canUndoSteps: Readable<number>;
    /**
     * Current camera information of main view.
     *
     * Change the camera position by `app.moveCamera()`.
     */
    readonly camera: Readable<CameraState>;
    /**
     * Current tool's info, like "is using pencil?", "what color?".
     *
     * Change the tool by `app.setAppliance()`.
     */
    readonly memberState: Readable<MemberState>;
    /**
     * 0..n-1, current index of main view scenes.
     */
    readonly sceneIndex: Writable<number>;
    /**
     * How many pages are in the main view?
     */
    readonly sceneLength: Readable<number>;
    /**
     * Apps status.
     */
    readonly appsStatus: Readable<AppsStatus>;
    /**
     * Undo a step on main view.
     */
    undo(): void;
    /**
     * Redo a step on main view.
     */
    redo(): void;
    /**
     * Move current main view's camera position.
     */
    moveCamera(camera: Partial<Camera> & {
        animationMode?: AnimationMode | undefined;
    }): void;
    /**
     * Move current main view's camera to include a rectangle.
     */
    moveCameraToContain(rectangle: Rectangle & {
        animationMode?: AnimationMode;
    }): void;
    /**
     * Delete all things on the main view.
     */
    cleanCurrentScene(): void;
    /**
     * Set current tool, like "pencil".
     */
    setAppliance(appliance: ApplianceNames | Appliance, shape?: ShapeType | Shape): void;
    /**
     * Set pencil and shape's thickness.
     */
    setStrokeWidth(strokeWidth: number): void;
    /**
     * Set pencil and shape's color.
     */
    setStrokeColor(strokeColor: Color): void;
    /**
     * Set text size. Default is 16.
     */
    setTextSize(textSize: number): void;
    /**
     * Set text color.
     *
     * @example
     * setTextColor([0x66, 0xcc, 0xff])
     */
    setTextColor(textColor: Color): void;
    /**
     * Toggle dotted line effect on pencil.
     */
    toggleDottedLine(force?: boolean): void;
    /**
     * Set pencil eraser size.
     */
    setPencilEraserSize(size: number): void;
    /**
     * Goto previous page (the main whiteboard view).
     */
    prevPage(): Promise<boolean>;
    /**
     * Goto next page (the main whiteboard view).
     */
    nextPage(): Promise<boolean>;
    /**
     * Goto any page (index range: 0..n-1)
     */
    jumpPage(index: number): Promise<boolean>;
    /**
     * Add one page to the main whiteboard view.
     *
     * @example
     * addPage({ after: true }) // add one page right after current one.
     * nextPage() // then, goto that page.
     */
    addPage(params?: AddPageParams): Promise<void>;
    /**
     * Remove one page at given index or current page (by default).
     *
     * Requires `@netless/window-manager` >= 0.4.30.
     *
     * @example
     * removePage() // remove current page
     */
    removePage(index?: number): Promise<boolean>;
    /**
     * Insert an image to the main view.
     *
     * @param crossOrigin Whether to load the image with CORS enabled, default is `true`.
     *
     * @example
     * insertImage("https://i.imgur.com/CzXTtJV.jpg")
     */
    insertImage(url: string, crossOrigin?: boolean | string): Promise<void>;
    /**
     * Insert PDF/PPTX from conversion result.
     * @param status https://developer.netless.link/server-en/home/server-conversion#get-query-task-conversion-progress
     */
    insertDocs(filename: string, status: ConversionResponse): Promise<string | undefined>;
    /**
     * Insert PDF/PPTX from projector conversion result.
     * @param response https://developer.netless.link/server-zh/home/server-projector#get-%E6%9F%A5%E8%AF%A2%E4%BB%BB%E5%8A%A1%E8%BD%AC%E6%8D%A2%E8%BF%9B%E5%BA%A6
     */
    insertDocs(filename: string, response: ProjectorResponse): Promise<string | undefined>;
    /**
     * Manual way.
     * @example
     * app.insertDocs({
     *   fileType: 'pptx',
     *   scenePath: `/pptx/${conversion.taskId}`,
     *   taskId: conversion.taskId,
     *   title: 'Title',
     * })
     */
    insertDocs(params: InsertDocsParams): Promise<string | undefined>;
    /**
     * Insert the Media Player app.
     */
    insertMedia(title: string, src: string): Promise<string | undefined>;
    /**
     * Insert the Monaco Code Editor app.
     * @deprecated Use `app.manager.addApp({ kind: 'Monaco' })` instead.
     */
    insertCodeEditor(): Promise<string | undefined>;
    /**
     * Insert the Countdown app.
     * @deprecated Use `app.manager.addApp({ kind: 'Countdown' })` instead.
     */
    insertCountdown(): Promise<string | undefined>;
    /**
     * Insert the GeoGebra app.
     * @deprecated Use `app.manager.addApp({ kind: 'GeoGebra' })` instead.
     */
    insertGeoGebra(): Promise<string | undefined>;
}
interface FastboardOptions {
    sdkConfig: Omit<WhiteWebSdkConfiguration, "useMobXState"> & {
        region: NonNullable<WhiteWebSdkConfiguration["region"]>;
    };
    joinRoom: Omit<JoinRoomParams, "useMultiViews" | "disableNewPencil" | "disableMagixEventDispatchLimit"> & {
        callbacks?: Partial<Omit<RoomCallbacks, "onCanRedoStepsUpdate" | "onCanUndoStepsUpdate">>;
    };
    managerConfig?: Omit<MountParams, "room">;
    netlessApps?: NetlessApp[];
}
/**
 * Create a FastboardApp instance.
 * @example
 * let app = await createFastboard({
 *   sdkConfig: {
 *     appIdentifier: import.meta.env.VITE_APPID,
 *     region: 'cn-hz',
 *   },
 *   joinRoom: {
 *     uid: unique_id,
 *     uuid: import.meta.env.VITE_ROOM_UUID,
 *     roomToken: import.meta.env.VITE_ROOM_TOKEN,
 *   },
 * })
 */
declare function createFastboard<TEventData extends Record<string, any> = any>({ sdkConfig, joinRoom: { callbacks, ...joinRoomParams }, managerConfig, netlessApps, }: FastboardOptions): Promise<FastboardApp<TEventData>>;

declare class FastboardPlayerBase<TEventData extends Record<string, any> = any> {
    readonly sdk: WhiteWebSdk;
    readonly player: Player;
    readonly manager: WindowManager;
    readonly syncedStore: SyncedStore<TEventData>;
    constructor(sdk: WhiteWebSdk, player: Player, manager: WindowManager, syncedStore: SyncedStore<TEventData>);
    protected _destroyed: boolean;
    destroy(): void;
}
type PlayerPhase = `${PlayerPhase$1}`;

declare class FastboardPlayer<TEventData extends Record<string, any> = any> extends FastboardPlayerBase<TEventData> {
    /**
     * Render this player to some DOM.
     */
    bindContainer(container: HTMLElement): void;
    /**
     * Move window-manager's collector to some place.
     */
    bindCollector(container: HTMLElement): void;
    /**
     * Player current time in milliseconds.
     */
    readonly currentTime: Writable<number>;
    /**
     * Player state, like "is it playing?".
     */
    readonly phase: Readable<"waitingFirstFrame" | "playing" | "pause" | "stop" | "ended" | "buffering">;
    /**
     * Will become true after buffering.
     */
    readonly canplay: Readable<boolean>;
    /**
     * Playback speed, default `1`.
     */
    readonly playbackRate: Writable<number>;
    /**
     * Playback duration in milliseconds.
     */
    readonly duration: Readable<number>;
    /**
     * Get state of room at that time, like "who was in the room?".
     */
    readonly state: Readable<PlayerState>;
    /**
     * Seek to some time in milliseconds.
     */
    seek(timestamp: number): Promise<PlayerSeekingResult>;
    /**
     * Change player state to playing.
     */
    play(): void;
    /**
     * Change player state to paused.
     */
    pause(): void;
    /**
     * Change player state to stopped.
     */
    stop(): void;
    /**
     * Set playback speed, a shortcut for `speed.set(x)`.
     */
    setPlaybackRate(value: number): void;
}
interface FastboardReplayOptions {
    sdkConfig: Omit<WhiteWebSdkConfiguration, "useMobXState"> & {
        region: NonNullable<WhiteWebSdkConfiguration["region"]>;
    };
    replayRoom: Omit<ReplayRoomParams, "useMultiViews"> & {
        callbacks?: Partial<PlayerCallbacks>;
    };
    managerConfig?: Omit<MountParams, "room">;
    netlessApps?: NetlessApp[];
}
/**
 * Create a FastboardPlayer instance.
 * @example
 * let player = await replayFastboard({
 *   sdkConfig: {
 *     appIdentifier: import.meta.env.VITE_APPID,
 *     region: 'cn-hz',
 *   },
 *   replayRoom: {
 *     room: "room uuid",
 *     roomToken: "NETLESSROOM_...",
 *     beginTimestamp: 1646619090394,
 *     duration: 70448,
 *   },
 * })
 */
declare function replayFastboard<TEventData extends Record<string, any> = any>({ sdkConfig, replayRoom: { callbacks, ...replayRoomParams }, managerConfig, netlessApps, }: FastboardReplayOptions): Promise<FastboardPlayer<TEventData>>;

interface AppsConfig {
    [kind: string]: Omit<RegisterParams, "kind">;
}
declare const register: typeof WindowManager.register;
declare const version: string;

declare function addRoomListener<K extends keyof RoomCallbacks>(room: Room, name: K, listener: RoomCallbacks[K]): () => void;
declare function addPlayerListener<K extends keyof PlayerCallbacks>(player: Player, name: K, listener: PlayerCallbacks[K]): () => void;
/**
 * Note: view listeners will be invalid on reconnection.
 * You have to rebind them after the phase changed.
 * @example
 * const bindCamera = () => addViewListener(mainView, "onCameraUpdated", setCamera)
 * let dispose = bindCamera(), phase_ = "disconnected"
 * setCamera(mainView.camera)
 * addRoomListener(room, "onPhaseChanged", (phase) => {
 *   if (phase === "connected" && phase_ === "reconnecting") {
 *     dispose()
 *     dispose = bindCamera()
 *     setCamera(mainView.camera)
 *   }
 *   phase_ = phase
 * })
 */
declare function addViewListener<K extends keyof ViewCallbacks>(view: View, name: K, listener: (value: ViewCallbacks[K]) => void): () => void;
declare function addManagerListener<K extends keyof PublicEvent>(manager: WindowManager, name: K, listener: (value: PublicEvent[K]) => void): () => void;

interface DocsEventOptions {
    /** If provided, will dispatch to the specific app. Default to the focused app. */
    appId?: string;
    /** Used by `jumpToPage` event, range from 1 to total pages count. */
    page?: number;
}
/**
 * Send specific command to the static docs / slide app.
 * Only works for apps that were created by `insertDocs()`.
 *
 * Returns false if failed to find the app or not writable.
 *
 * For static docs, `nextPage` equals to `nextStep`, as with `prevPage` and `prevStep`.
 *
 * @example
 * ```js
 * // send "next page" to the focused app
 * dispatchDocsEvent(fastboard, "nextPage")
 *
 * // send "prev page" to some app
 * dispatchDocsEvent(fastboard, "prevPage", {appId:"Slide-1a2b3c4d"})
 * ```
 */
declare function dispatchDocsEvent(fastboard: FastboardApp | WindowManager, event: "prevPage" | "nextPage" | "prevStep" | "nextStep" | "jumpToPage", options?: DocsEventOptions): boolean;

export { Appliance, AppsConfig, AppsStatus, DocsEventOptions, FastboardApp, FastboardOptions, FastboardPlayer, FastboardReplayOptions, InsertDocsDynamic, InsertDocsParams, InsertDocsStatic, PlayerPhase, ProjectorResponse, Readable, RoomPhase, RoomStateChanged, SetMemberStateFn, Shape, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable, addManagerListener, addPlayerListener, addRoomListener, addViewListener, convertedFileToScene, createFastboard, dispatchDocsEvent, genUID, getImageSize, makeSlideParams, readable, register, replayFastboard, version, warn, writable };
