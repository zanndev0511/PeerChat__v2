{"version":3,"file":"side-effect-manager.cjs.js","sources":["../src/gen-uid.ts","../src/async-side-effect-manager.ts","../src/side-effect-manager.ts"],"sourcesContent":["/**\n * @fileoverview UID generator, from Blockly.\n */\n\n/**\n * Legal characters for the unique ID.\n * Should be all on a US keyboard.  No XML special characters or control codes.\n * @private\n */\nconst SOUP =\n  \"!#%()*+,-./:;=?@[]^_`{|}~\" +\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst SOUP_LEN = SOUP.length;\nconst ID_LEN = 20;\nconst reusedIdCarrier = Array(ID_LEN);\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n */\nexport const genUID = (): string => {\n  for (let i = 0; i < ID_LEN; i++) {\n    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);\n  }\n  return reusedIdCarrier.join(\"\");\n};\n","import { genUID } from \"./gen-uid\";\n\nexport type AsyncSideEffectDisposer = () => Promise<void> | void;\n\nexport type AsyncSideEffectExecutor = () =>\n  | Promise<AsyncSideEffectDisposer>\n  | AsyncSideEffectDisposer;\n\nexport class AsyncSideEffectManager {\n  /**\n   * Add a side effect.\n   * @param executor execute side effect\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public add(\n    executor: AsyncSideEffectExecutor,\n    disposerID: string = genUID()\n  ): string {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._add(executor, disposerID));\n    } else {\n      this._add(executor, disposerID);\n    }\n    return disposerID;\n  }\n\n  private async _add(\n    executor: AsyncSideEffectExecutor,\n    disposerID: string\n  ): Promise<void> {\n    this._startTask(disposerID);\n\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n\n    try {\n      this.disposers.set(disposerID, await executor());\n    } catch (e) {\n      console.error(e);\n    }\n\n    this._endTask(disposerID);\n\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public remove(disposerID: string): AsyncSideEffectDisposer | undefined {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public flush(disposerID: string): void {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._flush(disposerID));\n    } else {\n      this._flush(disposerID);\n    }\n  }\n\n  private async _flush(disposerID: string): Promise<void> {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      this._startTask(disposerID);\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n      this._endTask(disposerID);\n    }\n\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n\n  /**\n   * Remove and run all of the disposers.\n   */\n  public flushAll(): void {\n    this.disposers.forEach((_, disposerID) => this.flush(disposerID));\n  }\n\n  /**\n   * @returns a Promise resolved when current tasks are finished.\n   */\n  public finished: Promise<void> = Promise.resolve();\n  private _resolveFinished?: () => void;\n\n  /**\n   * All disposers. Use this only when you know what you are doing.\n   */\n  public readonly disposers = new Map<string, AsyncSideEffectDisposer>();\n\n  private readonly _nextTask = new Map<string, () => any>();\n  private readonly _isRunning = new Set<string>();\n\n  private _startTask(disposerID: string): void {\n    this._isRunning.add(disposerID);\n    if (!this._resolveFinished) {\n      this.finished = new Promise(resolve => {\n        this._resolveFinished = resolve;\n      });\n    }\n  }\n\n  private _endTask(disposerID: string): void {\n    this._isRunning.delete(disposerID);\n    if (\n      this._resolveFinished &&\n      this._isRunning.size <= 0 &&\n      this._nextTask.size <= 0\n    ) {\n      this._resolveFinished();\n      this._resolveFinished = undefined;\n    }\n  }\n}\n","import { genUID } from \"./gen-uid\";\n\nexport type SideEffectDisposer = () => void;\n\nexport class SideEffectManager {\n  /**\n   * Add a disposer directly.\n   * @param disposer a disposer\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public addDisposer(\n    disposer: SideEffectDisposer,\n    disposerID: string = genUID()\n  ): string {\n    this.flush(disposerID);\n    this.disposers.set(disposerID, disposer);\n    return disposerID;\n  }\n\n  /**\n   * Add a side effect.\n   * @param executor execute side effect\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public add(\n    executor: () => SideEffectDisposer,\n    disposerID: string = genUID()\n  ): string {\n    return this.addDisposer(executor(), disposerID);\n  }\n\n  /**\n   * Sugar for addEventListener.\n   * @param el\n   * @param type\n   * @param listener\n   * @param options\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public addEventListener<K extends keyof WindowEventMap>(\n    el: Window,\n    type: K,\n    listener: (this: Window, ev: WindowEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof DocumentEventMap>(\n    el: Document,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener<K extends keyof MediaQueryListEventMap>(\n    el: MediaQueryList,\n    type: K,\n    listener: (this: HTMLElement, ev: MediaQueryListEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID?: string\n  ): string;\n  public addEventListener(\n    el: HTMLElement | Window | Document | MediaQueryList,\n    type: string,\n    listener: (this: HTMLElement | Window | Document, ev: Event) => unknown,\n    options?: boolean | AddEventListenerOptions,\n    disposerID = genUID()\n  ): string {\n    el.addEventListener(type, listener, options);\n    this.addDisposer(\n      () => el.removeEventListener(type, listener, options),\n      disposerID\n    );\n    return disposerID;\n  }\n\n  /**\n   * Sugar for setTimeout.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public setTimeout(\n    handler: () => void,\n    timeout: number,\n    disposerID: string = genUID()\n  ): string {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposerID);\n      handler();\n    }, timeout);\n    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);\n  }\n\n  /**\n   * Sugar for setInterval.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  public setInterval(\n    handler: () => void,\n    timeout: number,\n    disposerID: string = genUID()\n  ): string {\n    const ticket = window.setInterval(handler, timeout);\n    return this.addDisposer(() => window.clearInterval(ticket), disposerID);\n  }\n\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public remove(disposerID: string): SideEffectDisposer | undefined {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  public flush(disposerID: string): void {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  /**\n   * Remove and run all of the disposers.\n   */\n  public flushAll(): void {\n    this.disposers.forEach(disposer => {\n      try {\n        disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    });\n    this.disposers.clear();\n  }\n\n  /**\n   * All disposers. Use this only when you know what you are doing.\n   */\n  public readonly disposers = new Map<string, SideEffectDisposer>();\n}\n"],"names":["SOUP","SOUP_LEN","length","reusedIdCarrier","Array","genUID","i","charAt","Math","random","join","constructor","Promise","resolve","Map","Set","add","executor","disposerID","this","_isRunning","has","_nextTask","set","_add","_startTask","disposer","remove","e","error","disposers","_endTask","task","get","delete","flush","_flush","flushAll","forEach","_","_resolveFinished","finished","size","addDisposer","addEventListener","el","type","listener","options","removeEventListener","setTimeout","handler","timeout","ticket","window","clearTimeout","setInterval","clearInterval","clear"],"mappings":"yGASA,MAAMA,EACJ,0FAEIC,EAAWD,EAAKE,OAEhBC,EAAkBC,MADT,IAOFC,EAAS,aACXC,EAAI,EAAGA,EARH,GAQeA,MACVA,GAAKN,EAAKO,OAAOC,KAAKC,SAAWR,UAE5CE,EAAgBO,KAAK,0CChBvBC,4BAoG4BC,QAAQC,yBAMb,IAAIC,mBAEH,IAAIA,oBACH,IAAIC,IAtG3BC,IACLC,EACAC,EAAqBb,YAEjBc,KAAKC,WAAWC,IAAIH,QACjBI,UAAUC,IAAIL,GAAY,IAAMC,KAAKK,KAAKP,EAAUC,UAEpDM,KAAKP,EAAUC,GAEfA,aAIPD,EACAC,QAEKO,WAAWP,SAEVQ,EAAWP,KAAKQ,OAAOT,MACzBQ,YAEMA,UACCE,WACCC,MAAMD,YAKXE,UAAUP,IAAIL,QAAkBD,WAC9BW,WACCC,MAAMD,QAGXG,SAASb,SAERc,EAAOb,KAAKG,UAAUW,IAAIf,GAC5Bc,SACGV,UAAUY,OAAOhB,QASnBS,OAAOT,SACNQ,EAAWP,KAAKW,UAAUG,IAAIf,eAC/BY,UAAUI,OAAOhB,GACfQ,EAOFS,MAAMjB,GACPC,KAAKC,WAAWC,IAAIH,QACjBI,UAAUC,IAAIL,GAAY,IAAMC,KAAKiB,OAAOlB,UAE5CkB,OAAOlB,gBAIKA,SACbQ,EAAWP,KAAKQ,OAAOT,MACzBQ,EAAU,MACPD,WAAWP,aAERQ,UACCE,WACCC,MAAMD,QAEXG,SAASb,SAGVc,EAAOb,KAAKG,UAAUW,IAAIf,GAC5Bc,SACGV,UAAUY,OAAOhB,QAQnBmB,gBACAP,UAAUQ,SAAQ,CAACC,EAAGrB,IAAeC,KAAKgB,MAAMjB,KAiB/CO,WAAWP,QACZE,WAAWJ,IAAIE,GACfC,KAAKqB,wBACHC,SAAW,IAAI7B,kBACb4B,iBAAmB3B,MAKtBkB,SAASb,QACVE,WAAWc,OAAOhB,GAErBC,KAAKqB,kBACLrB,KAAKC,WAAWsB,MAAQ,GACxBvB,KAAKG,UAAUoB,MAAQ,SAElBF,wBACAA,sBAAmB,qCCpIvB7B,6BA8JuB,IAAIG,IAvJzB6B,YACLjB,EACAR,EAAqBb,iBAEhB8B,MAAMjB,QACNY,UAAUP,IAAIL,EAAYQ,GACxBR,EASFF,IACLC,EACAC,EAAqBb,YAEdc,KAAKwB,YAAY1B,IAAYC,GAwC/B0B,iBACLC,EACAC,EACAC,EACAC,EACA9B,EAAab,cAEVuC,iBAAiBE,EAAMC,EAAUC,QAC/BL,aACH,IAAME,EAAGI,oBAAoBH,EAAMC,EAAUC,IAC7C9B,GAEKA,EAUFgC,WACLC,EACAC,EACAlC,EAAqBb,WAEfgD,EAASC,OAAOJ,YAAW,UAC1BvB,OAAOT,SAEXkC,UACIjC,KAAKwB,aAAY,IAAMW,OAAOC,aAAaF,IAASnC,GAUtDsC,YACLL,EACAC,EACAlC,EAAqBb,WAEfgD,EAASC,OAAOE,YAAYL,EAASC,UACpCjC,KAAKwB,aAAY,IAAMW,OAAOG,cAAcJ,IAASnC,GAOvDS,OAAOT,SACNQ,EAAWP,KAAKW,UAAUG,IAAIf,eAC/BY,UAAUI,OAAOhB,GACfQ,EAOFS,MAAMjB,SACLQ,EAAWP,KAAKQ,OAAOT,MACzBQ,gBAGOE,WACCC,MAAMD,IAQbS,gBACAP,UAAUQ,2BAGJV,WACCC,MAAMD,YAGbE,UAAU4B"}