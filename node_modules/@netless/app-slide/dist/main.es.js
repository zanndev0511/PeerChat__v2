var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var Slide = function(t) {
  var e = {};
  function i(n) {
    if (e[n])
      return e[n].exports;
    var r = e[n] = { i: n, l: false, exports: {} };
    return t[n].call(r.exports, r, r.exports, i), r.l = true, r.exports;
  }
  return i.m = t, i.c = e, i.d = function(t2, e2, n) {
    i.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
  }, i.r = function(t2) {
    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  }, i.t = function(t2, e2) {
    if (1 & e2 && (t2 = i(t2)), 8 & e2)
      return t2;
    if (4 & e2 && typeof t2 == "object" && t2 && t2.__esModule)
      return t2;
    var n = /* @__PURE__ */ Object.create(null);
    if (i.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && typeof t2 != "string")
      for (var r in t2)
        i.d(n, r, function(e3) {
          return t2[e3];
        }.bind(null, r));
    return n;
  }, i.n = function(t2) {
    var e2 = t2 && t2.__esModule ? function() {
      return t2.default;
    } : function() {
      return t2;
    };
    return i.d(e2, "a", e2), e2;
  }, i.o = function(t2, e2) {
    return Object.prototype.hasOwnProperty.call(t2, e2);
  }, i.p = "", i(i.s = 229);
}([function(t, e, i) {
  /*!
  * @pixi/constants - v6.4.2
  * Compiled Thu, 02 Jun 2022 15:39:26 UTC
  *
  * @pixi/constants is licensed under the MIT License.
  * http://www.opensource.org/licenses/mit-license
  */
  var n, r, o, s, a, l, h, u, c, d, p, f, m, g, v, _, y, x, b;
  i.d(e, "a", function() {
    return m;
  }), i.d(e, "b", function() {
    return s;
  }), i.d(e, "c", function() {
    return o;
  }), i.d(e, "d", function() {
    return b;
  }), i.d(e, "e", function() {
    return g;
  }), i.d(e, "f", function() {
    return a;
  }), i.d(e, "g", function() {
    return n;
  }), i.d(e, "h", function() {
    return l;
  }), i.d(e, "i", function() {
    return v;
  }), i.d(e, "j", function() {
    return y;
  }), i.d(e, "k", function() {
    return f;
  }), i.d(e, "l", function() {
    return x;
  }), i.d(e, "m", function() {
    return _;
  }), i.d(e, "n", function() {
    return r;
  }), i.d(e, "o", function() {
    return c;
  }), i.d(e, "p", function() {
    return d;
  }), i.d(e, "q", function() {
    return h;
  }), i.d(e, "r", function() {
    return u;
  }), i.d(e, "s", function() {
    return p;
  }), function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(n || (n = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(r || (r = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(o || (o = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(s || (s = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(a || (a = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(l || (l = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(h || (h = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(u || (u = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(c || (c = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(d || (d = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(p || (p = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(f || (f = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(m || (m = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(g || (g = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(v || (v = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(_ || (_ = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(y || (y = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(x || (x = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(b || (b = {}));
}, function(t, e, i) {
  i.d(e, "a", function() {
    return u;
  }), i.d(e, "b", function() {
    return s;
  }), i.d(e, "c", function() {
    return c;
  }), i.d(e, "d", function() {
    return m;
  }), i.d(e, "e", function() {
    return f;
  }), i.d(e, "f", function() {
    return r;
  }), i.d(e, "g", function() {
    return a;
  }), i.d(e, "h", function() {
    return d;
  }), i.d(e, "i", function() {
    return o;
  }), i.d(e, "j", function() {
    return h;
  }), i.d(e, "k", function() {
    return p;
  }), i.d(e, "l", function() {
    return n;
  }), i.d(e, "m", function() {
    return S;
  }), i.d(e, "n", function() {
    return E;
  });
  /*!
   * @pixi/math - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var n, r = 2 * Math.PI, o = 180 / Math.PI, s = Math.PI / 180;
  !function(t2) {
    t2[t2.POLY = 0] = "POLY", t2[t2.RECT = 1] = "RECT", t2[t2.CIRC = 2] = "CIRC", t2[t2.ELIP = 3] = "ELIP", t2[t2.RREC = 4] = "RREC";
  }(n || (n = {}));
  var a = function() {
    function t2(t3, e2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), this.x = 0, this.y = 0, this.x = t3, this.y = e2;
    }
    return t2.prototype.clone = function() {
      return new t2(this.x, this.y);
    }, t2.prototype.copyFrom = function(t3) {
      return this.set(t3.x, t3.y), this;
    }, t2.prototype.copyTo = function(t3) {
      return t3.set(this.x, this.y), t3;
    }, t2.prototype.equals = function(t3) {
      return t3.x === this.x && t3.y === this.y;
    }, t2.prototype.set = function(t3, e2) {
      return t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = t3), this.x = t3, this.y = e2, this;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, t2;
  }(), l = [new a(), new a(), new a(), new a()], h = function() {
    function t2(t3, e2, i2, r2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), this.x = Number(t3), this.y = Number(e2), this.width = Number(i2), this.height = Number(r2), this.type = n.RECT;
    }
    return Object.defineProperty(t2.prototype, "left", { get: function() {
      return this.x;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "right", { get: function() {
      return this.x + this.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "top", { get: function() {
      return this.y;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "bottom", { get: function() {
      return this.y + this.height;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "EMPTY", { get: function() {
      return new t2(0, 0, 0, 0);
    }, enumerable: false, configurable: true }), t2.prototype.clone = function() {
      return new t2(this.x, this.y, this.width, this.height);
    }, t2.prototype.copyFrom = function(t3) {
      return this.x = t3.x, this.y = t3.y, this.width = t3.width, this.height = t3.height, this;
    }, t2.prototype.copyTo = function(t3) {
      return t3.x = this.x, t3.y = this.y, t3.width = this.width, t3.height = this.height, t3;
    }, t2.prototype.contains = function(t3, e2) {
      return !(this.width <= 0 || this.height <= 0) && (t3 >= this.x && t3 < this.x + this.width && e2 >= this.y && e2 < this.y + this.height);
    }, t2.prototype.intersects = function(t3, e2) {
      if (!e2) {
        var i2 = this.x < t3.x ? t3.x : this.x;
        if ((this.right > t3.right ? t3.right : this.right) <= i2)
          return false;
        var n2 = this.y < t3.y ? t3.y : this.y;
        return (this.bottom > t3.bottom ? t3.bottom : this.bottom) > n2;
      }
      var r2 = this.left, o2 = this.right, s2 = this.top, a2 = this.bottom;
      if (o2 <= r2 || a2 <= s2)
        return false;
      var h2 = l[0].set(t3.left, t3.top), u2 = l[1].set(t3.left, t3.bottom), c2 = l[2].set(t3.right, t3.top), d2 = l[3].set(t3.right, t3.bottom);
      if (c2.x <= h2.x || u2.y <= h2.y)
        return false;
      var p2 = Math.sign(e2.a * e2.d - e2.b * e2.c);
      if (p2 === 0)
        return false;
      if (e2.apply(h2, h2), e2.apply(u2, u2), e2.apply(c2, c2), e2.apply(d2, d2), Math.max(h2.x, u2.x, c2.x, d2.x) <= r2 || Math.min(h2.x, u2.x, c2.x, d2.x) >= o2 || Math.max(h2.y, u2.y, c2.y, d2.y) <= s2 || Math.min(h2.y, u2.y, c2.y, d2.y) >= a2)
        return false;
      var f2 = p2 * (u2.y - h2.y), m2 = p2 * (h2.x - u2.x), g2 = f2 * r2 + m2 * s2, v2 = f2 * o2 + m2 * s2, _2 = f2 * r2 + m2 * a2, y2 = f2 * o2 + m2 * a2;
      if (Math.max(g2, v2, _2, y2) <= f2 * h2.x + m2 * h2.y || Math.min(g2, v2, _2, y2) >= f2 * d2.x + m2 * d2.y)
        return false;
      var x2 = p2 * (h2.y - c2.y), b2 = p2 * (c2.x - h2.x), T2 = x2 * r2 + b2 * s2, E2 = x2 * o2 + b2 * s2, S2 = x2 * r2 + b2 * a2, w = x2 * o2 + b2 * a2;
      return !(Math.max(T2, E2, S2, w) <= x2 * h2.x + b2 * h2.y || Math.min(T2, E2, S2, w) >= x2 * d2.x + b2 * d2.y);
    }, t2.prototype.pad = function(t3, e2) {
      return t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = t3), this.x -= t3, this.y -= e2, this.width += 2 * t3, this.height += 2 * e2, this;
    }, t2.prototype.fit = function(t3) {
      var e2 = Math.max(this.x, t3.x), i2 = Math.min(this.x + this.width, t3.x + t3.width), n2 = Math.max(this.y, t3.y), r2 = Math.min(this.y + this.height, t3.y + t3.height);
      return this.x = e2, this.width = Math.max(i2 - e2, 0), this.y = n2, this.height = Math.max(r2 - n2, 0), this;
    }, t2.prototype.ceil = function(t3, e2) {
      t3 === void 0 && (t3 = 1), e2 === void 0 && (e2 = 1e-3);
      var i2 = Math.ceil((this.x + this.width - e2) * t3) / t3, n2 = Math.ceil((this.y + this.height - e2) * t3) / t3;
      return this.x = Math.floor((this.x + e2) * t3) / t3, this.y = Math.floor((this.y + e2) * t3) / t3, this.width = i2 - this.x, this.height = n2 - this.y, this;
    }, t2.prototype.enlarge = function(t3) {
      var e2 = Math.min(this.x, t3.x), i2 = Math.max(this.x + this.width, t3.x + t3.width), n2 = Math.min(this.y, t3.y), r2 = Math.max(this.y + this.height, t3.y + t3.height);
      return this.x = e2, this.width = i2 - e2, this.y = n2, this.height = r2 - n2, this;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, t2;
  }(), u = function() {
    function t2(t3, e2, i2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), this.x = t3, this.y = e2, this.radius = i2, this.type = n.CIRC;
    }
    return t2.prototype.clone = function() {
      return new t2(this.x, this.y, this.radius);
    }, t2.prototype.contains = function(t3, e2) {
      if (this.radius <= 0)
        return false;
      var i2 = this.radius * this.radius, n2 = this.x - t3, r2 = this.y - e2;
      return (n2 *= n2) + (r2 *= r2) <= i2;
    }, t2.prototype.getBounds = function() {
      return new h(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, t2;
  }(), c = function() {
    function t2(t3, e2, i2, r2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), this.x = t3, this.y = e2, this.width = i2, this.height = r2, this.type = n.ELIP;
    }
    return t2.prototype.clone = function() {
      return new t2(this.x, this.y, this.width, this.height);
    }, t2.prototype.contains = function(t3, e2) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      var i2 = (t3 - this.x) / this.width, n2 = (e2 - this.y) / this.height;
      return (i2 *= i2) + (n2 *= n2) <= 1;
    }, t2.prototype.getBounds = function() {
      return new h(this.x - this.width, this.y - this.height, this.width, this.height);
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, t2;
  }(), d = function() {
    function t2() {
      for (var t3 = arguments, e2 = [], i2 = 0; i2 < arguments.length; i2++)
        e2[i2] = t3[i2];
      var r2 = Array.isArray(e2[0]) ? e2[0] : e2;
      if (typeof r2[0] != "number") {
        for (var o2 = [], s2 = 0, a2 = r2.length; s2 < a2; s2++)
          o2.push(r2[s2].x, r2[s2].y);
        r2 = o2;
      }
      this.points = r2, this.type = n.POLY, this.closeStroke = true;
    }
    return t2.prototype.clone = function() {
      var e2 = new t2(this.points.slice());
      return e2.closeStroke = this.closeStroke, e2;
    }, t2.prototype.contains = function(t3, e2) {
      for (var i2 = false, n2 = this.points.length / 2, r2 = 0, o2 = n2 - 1; r2 < n2; o2 = r2++) {
        var s2 = this.points[2 * r2], a2 = this.points[2 * r2 + 1], l2 = this.points[2 * o2], h2 = this.points[2 * o2 + 1];
        a2 > e2 != h2 > e2 && t3 < (e2 - a2) / (h2 - a2) * (l2 - s2) + s2 && (i2 = !i2);
      }
      return i2;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:PolygoncloseStroke=" + this.closeStroke + "points=" + this.points.reduce(function(t3, e2) {
        return t3 + ", " + e2;
      }, "") + "]";
    }, t2;
  }(), p = function() {
    function t2(t3, e2, i2, r2, o2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = 20), this.x = t3, this.y = e2, this.width = i2, this.height = r2, this.radius = o2, this.type = n.RREC;
    }
    return t2.prototype.clone = function() {
      return new t2(this.x, this.y, this.width, this.height, this.radius);
    }, t2.prototype.contains = function(t3, e2) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      if (t3 >= this.x && t3 <= this.x + this.width && e2 >= this.y && e2 <= this.y + this.height) {
        var i2 = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e2 >= this.y + i2 && e2 <= this.y + this.height - i2 || t3 >= this.x + i2 && t3 <= this.x + this.width - i2)
          return true;
        var n2 = t3 - (this.x + i2), r2 = e2 - (this.y + i2), o2 = i2 * i2;
        if (n2 * n2 + r2 * r2 <= o2)
          return true;
        if ((n2 = t3 - (this.x + this.width - i2)) * n2 + r2 * r2 <= o2)
          return true;
        if (n2 * n2 + (r2 = e2 - (this.y + this.height - i2)) * r2 <= o2)
          return true;
        if ((n2 = t3 - (this.x + i2)) * n2 + r2 * r2 <= o2)
          return true;
      }
      return false;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + "width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]";
    }, t2;
  }(), f = function() {
    function t2(t3, e2, i2, n2) {
      i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 0), this._x = i2, this._y = n2, this.cb = t3, this.scope = e2;
    }
    return t2.prototype.clone = function(e2, i2) {
      return e2 === void 0 && (e2 = this.cb), i2 === void 0 && (i2 = this.scope), new t2(e2, i2, this._x, this._y);
    }, t2.prototype.set = function(t3, e2) {
      return t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = t3), this._x === t3 && this._y === e2 || (this._x = t3, this._y = e2, this.cb.call(this.scope)), this;
    }, t2.prototype.copyFrom = function(t3) {
      return this._x === t3.x && this._y === t3.y || (this._x = t3.x, this._y = t3.y, this.cb.call(this.scope)), this;
    }, t2.prototype.copyTo = function(t3) {
      return t3.set(this._x, this._y), t3;
    }, t2.prototype.equals = function(t3) {
      return t3.x === this._x && t3.y === this._y;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(t2.prototype, "x", { get: function() {
      return this._x;
    }, set: function(t3) {
      this._x !== t3 && (this._x = t3, this.cb.call(this.scope));
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "y", { get: function() {
      return this._y;
    }, set: function(t3) {
      this._y !== t3 && (this._y = t3, this.cb.call(this.scope));
    }, enumerable: false, configurable: true }), t2;
  }(), m = function() {
    function t2(t3, e2, i2, n2, r2, o2) {
      t3 === void 0 && (t3 = 1), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 1), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = 0), this.array = null, this.a = t3, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2;
    }
    return t2.prototype.fromArray = function(t3) {
      this.a = t3[0], this.b = t3[1], this.c = t3[3], this.d = t3[4], this.tx = t3[2], this.ty = t3[5];
    }, t2.prototype.set = function(t3, e2, i2, n2, r2, o2) {
      return this.a = t3, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2, this;
    }, t2.prototype.toArray = function(t3, e2) {
      this.array || (this.array = new Float32Array(9));
      var i2 = e2 || this.array;
      return t3 ? (i2[0] = this.a, i2[1] = this.b, i2[2] = 0, i2[3] = this.c, i2[4] = this.d, i2[5] = 0, i2[6] = this.tx, i2[7] = this.ty, i2[8] = 1) : (i2[0] = this.a, i2[1] = this.c, i2[2] = this.tx, i2[3] = this.b, i2[4] = this.d, i2[5] = this.ty, i2[6] = 0, i2[7] = 0, i2[8] = 1), i2;
    }, t2.prototype.apply = function(t3, e2) {
      e2 = e2 || new a();
      var i2 = t3.x, n2 = t3.y;
      return e2.x = this.a * i2 + this.c * n2 + this.tx, e2.y = this.b * i2 + this.d * n2 + this.ty, e2;
    }, t2.prototype.applyInverse = function(t3, e2) {
      e2 = e2 || new a();
      var i2 = 1 / (this.a * this.d + this.c * -this.b), n2 = t3.x, r2 = t3.y;
      return e2.x = this.d * i2 * n2 + -this.c * i2 * r2 + (this.ty * this.c - this.tx * this.d) * i2, e2.y = this.a * i2 * r2 + -this.b * i2 * n2 + (-this.ty * this.a + this.tx * this.b) * i2, e2;
    }, t2.prototype.translate = function(t3, e2) {
      return this.tx += t3, this.ty += e2, this;
    }, t2.prototype.scale = function(t3, e2) {
      return this.a *= t3, this.d *= e2, this.c *= t3, this.b *= e2, this.tx *= t3, this.ty *= e2, this;
    }, t2.prototype.rotate = function(t3) {
      var e2 = Math.cos(t3), i2 = Math.sin(t3), n2 = this.a, r2 = this.c, o2 = this.tx;
      return this.a = n2 * e2 - this.b * i2, this.b = n2 * i2 + this.b * e2, this.c = r2 * e2 - this.d * i2, this.d = r2 * i2 + this.d * e2, this.tx = o2 * e2 - this.ty * i2, this.ty = o2 * i2 + this.ty * e2, this;
    }, t2.prototype.append = function(t3) {
      var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d;
      return this.a = t3.a * e2 + t3.b * n2, this.b = t3.a * i2 + t3.b * r2, this.c = t3.c * e2 + t3.d * n2, this.d = t3.c * i2 + t3.d * r2, this.tx = t3.tx * e2 + t3.ty * n2 + this.tx, this.ty = t3.tx * i2 + t3.ty * r2 + this.ty, this;
    }, t2.prototype.setTransform = function(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
      return this.a = Math.cos(s2 + l2) * r2, this.b = Math.sin(s2 + l2) * r2, this.c = -Math.sin(s2 - a2) * o2, this.d = Math.cos(s2 - a2) * o2, this.tx = t3 - (i2 * this.a + n2 * this.c), this.ty = e2 - (i2 * this.b + n2 * this.d), this;
    }, t2.prototype.prepend = function(t3) {
      var e2 = this.tx;
      if (t3.a !== 1 || t3.b !== 0 || t3.c !== 0 || t3.d !== 1) {
        var i2 = this.a, n2 = this.c;
        this.a = i2 * t3.a + this.b * t3.c, this.b = i2 * t3.b + this.b * t3.d, this.c = n2 * t3.a + this.d * t3.c, this.d = n2 * t3.b + this.d * t3.d;
      }
      return this.tx = e2 * t3.a + this.ty * t3.c + t3.tx, this.ty = e2 * t3.b + this.ty * t3.d + t3.ty, this;
    }, t2.prototype.decompose = function(t3) {
      var e2 = this.a, i2 = this.b, n2 = this.c, o2 = this.d, s2 = t3.pivot, a2 = -Math.atan2(-n2, o2), l2 = Math.atan2(i2, e2), h2 = Math.abs(a2 + l2);
      return h2 < 1e-5 || Math.abs(r - h2) < 1e-5 ? (t3.rotation = l2, t3.skew.x = t3.skew.y = 0) : (t3.rotation = 0, t3.skew.x = a2, t3.skew.y = l2), t3.scale.x = Math.sqrt(e2 * e2 + i2 * i2), t3.scale.y = Math.sqrt(n2 * n2 + o2 * o2), t3.position.x = this.tx + (s2.x * e2 + s2.y * n2), t3.position.y = this.ty + (s2.x * i2 + s2.y * o2), t3;
    }, t2.prototype.invert = function() {
      var t3 = this.a, e2 = this.b, i2 = this.c, n2 = this.d, r2 = this.tx, o2 = t3 * n2 - e2 * i2;
      return this.a = n2 / o2, this.b = -e2 / o2, this.c = -i2 / o2, this.d = t3 / o2, this.tx = (i2 * this.ty - n2 * r2) / o2, this.ty = -(t3 * this.ty - e2 * r2) / o2, this;
    }, t2.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, t2.prototype.clone = function() {
      var e2 = new t2();
      return e2.a = this.a, e2.b = this.b, e2.c = this.c, e2.d = this.d, e2.tx = this.tx, e2.ty = this.ty, e2;
    }, t2.prototype.copyTo = function(t3) {
      return t3.a = this.a, t3.b = this.b, t3.c = this.c, t3.d = this.d, t3.tx = this.tx, t3.ty = this.ty, t3;
    }, t2.prototype.copyFrom = function(t3) {
      return this.a = t3.a, this.b = t3.b, this.c = t3.c, this.d = t3.d, this.tx = t3.tx, this.ty = t3.ty, this;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(t2, "IDENTITY", { get: function() {
      return new t2();
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "TEMP_MATRIX", { get: function() {
      return new t2();
    }, enumerable: false, configurable: true }), t2;
  }(), g = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], v = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], _ = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], y = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], x = [], b = [], T = Math.sign;
  !function() {
    for (var t2 = 0; t2 < 16; t2++) {
      var e2 = [];
      x.push(e2);
      for (var i2 = 0; i2 < 16; i2++)
        for (var n2 = T(g[t2] * g[i2] + _[t2] * v[i2]), r2 = T(v[t2] * g[i2] + y[t2] * v[i2]), o2 = T(g[t2] * _[i2] + _[t2] * y[i2]), s2 = T(v[t2] * _[i2] + y[t2] * y[i2]), a2 = 0; a2 < 16; a2++)
          if (g[a2] === n2 && v[a2] === r2 && _[a2] === o2 && y[a2] === s2) {
            e2.push(a2);
            break;
          }
    }
    for (t2 = 0; t2 < 16; t2++) {
      var l2 = new m();
      l2.set(g[t2], v[t2], _[t2], y[t2], 0, 0), b.push(l2);
    }
  }();
  var E = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function(t2) {
    return g[t2];
  }, uY: function(t2) {
    return v[t2];
  }, vX: function(t2) {
    return _[t2];
  }, vY: function(t2) {
    return y[t2];
  }, inv: function(t2) {
    return 8 & t2 ? 15 & t2 : 7 & -t2;
  }, add: function(t2, e2) {
    return x[t2][e2];
  }, sub: function(t2, e2) {
    return x[t2][E.inv(e2)];
  }, rotate180: function(t2) {
    return 4 ^ t2;
  }, isVertical: function(t2) {
    return (3 & t2) == 2;
  }, byDirection: function(t2, e2) {
    return 2 * Math.abs(t2) <= Math.abs(e2) ? e2 >= 0 ? E.S : E.N : 2 * Math.abs(e2) <= Math.abs(t2) ? t2 > 0 ? E.E : E.W : e2 > 0 ? t2 > 0 ? E.SE : E.SW : t2 > 0 ? E.NE : E.NW;
  }, matrixAppendRotationInv: function(t2, e2, i2, n2) {
    i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 0);
    var r2 = b[E.inv(e2)];
    r2.tx = i2, r2.ty = n2, t2.append(r2);
  } }, S = function() {
    function t2() {
      this.worldTransform = new m(), this.localTransform = new m(), this.position = new f(this.onChange, this, 0, 0), this.scale = new f(this.onChange, this, 1, 1), this.pivot = new f(this.onChange, this, 0, 0), this.skew = new f(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return t2.prototype.onChange = function() {
      this._localID++;
    }, t2.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, t2.prototype.toString = function() {
      return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
    }, t2.prototype.updateLocalTransform = function() {
      var t3 = this.localTransform;
      this._localID !== this._currentLocalID && (t3.a = this._cx * this.scale.x, t3.b = this._sx * this.scale.x, t3.c = this._cy * this.scale.y, t3.d = this._sy * this.scale.y, t3.tx = this.position.x - (this.pivot.x * t3.a + this.pivot.y * t3.c), t3.ty = this.position.y - (this.pivot.x * t3.b + this.pivot.y * t3.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, t2.prototype.updateTransform = function(t3) {
      var e2 = this.localTransform;
      if (this._localID !== this._currentLocalID && (e2.a = this._cx * this.scale.x, e2.b = this._sx * this.scale.x, e2.c = this._cy * this.scale.y, e2.d = this._sy * this.scale.y, e2.tx = this.position.x - (this.pivot.x * e2.a + this.pivot.y * e2.c), e2.ty = this.position.y - (this.pivot.x * e2.b + this.pivot.y * e2.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t3._worldID) {
        var i2 = t3.worldTransform, n2 = this.worldTransform;
        n2.a = e2.a * i2.a + e2.b * i2.c, n2.b = e2.a * i2.b + e2.b * i2.d, n2.c = e2.c * i2.a + e2.d * i2.c, n2.d = e2.c * i2.b + e2.d * i2.d, n2.tx = e2.tx * i2.a + e2.ty * i2.c + i2.tx, n2.ty = e2.tx * i2.b + e2.ty * i2.d + i2.ty, this._parentID = t3._worldID, this._worldID++;
      }
    }, t2.prototype.setFromMatrix = function(t3) {
      t3.decompose(this), this._localID++;
    }, Object.defineProperty(t2.prototype, "rotation", { get: function() {
      return this._rotation;
    }, set: function(t3) {
      this._rotation !== t3 && (this._rotation = t3, this.updateSkew());
    }, enumerable: false, configurable: true }), t2.IDENTITY = new t2(), t2;
  }();
}, function(t, e, i) {
  i.d(e, "a", function() {
    return le;
  }), i.d(e, "b", function() {
    return I;
  }), i.d(e, "c", function() {
    return v;
  }), i.d(e, "d", function() {
    return me;
  }), i.d(e, "e", function() {
    return xe;
  }), i.d(e, "f", function() {
    return Ee;
  }), i.d(e, "g", function() {
    return ge;
  }), i.d(e, "h", function() {
    return k;
  }), i.d(e, "i", function() {
    return m;
  }), i.d(e, "j", function() {
    return b;
  }), i.d(e, "k", function() {
    return Lt;
  }), i.d(e, "l", function() {
    return V;
  }), i.d(e, "m", function() {
    return $;
  }), i.d(e, "n", function() {
    return Pt;
  }), i.d(e, "o", function() {
    return W;
  }), i.d(e, "p", function() {
    return D;
  }), i.d(e, "q", function() {
    return ce;
  }), i.d(e, "r", function() {
    return Ot;
  }), i.d(e, "s", function() {
    return Nt;
  }), i.d(e, "t", function() {
    return L;
  }), i.d(e, "u", function() {
    return Ft;
  }), i.d(e, "v", function() {
    return q;
  }), i.d(e, "w", function() {
    return w;
  }), i.d(e, "x", function() {
    return ve;
  }), i.d(e, "y", function() {
    return de;
  }), i.d(e, "z", function() {
    return fe;
  }), i.d(e, "A", function() {
    return pe;
  });
  var n = i(4), r = i(0), o = i(3), s = i(12), a = i(7), l = i(1);
  /*!
   * @pixi/core - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/core is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  n.b.PREFER_ENV = o.isMobile.any ? r.g.WEBGL : r.g.WEBGL2, n.b.STRICT_TEXTURE_CACHE = false;
  var h = [];
  function u(t2, e2) {
    if (!t2)
      return null;
    var i2 = "";
    if (typeof t2 == "string") {
      var n2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(t2);
      n2 && (i2 = n2[1].toLowerCase());
    }
    for (var r2 = h.length - 1; r2 >= 0; --r2) {
      var o2 = h[r2];
      if (o2.test && o2.test(t2, i2))
        return new o2(t2, e2);
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var c = function(t2, e2) {
    return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function d(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    c(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var p = function() {
    return (p = Object.assign || function(t2) {
      for (var e2, i2 = arguments, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var o2 in e2 = i2[n2])
          Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
      return t2;
    }).apply(this, arguments);
  };
  var f = function() {
    function t2(t3, e2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = 0), this._width = t3, this._height = e2, this.destroyed = false, this.internal = false, this.onResize = new s.a("setRealSize"), this.onUpdate = new s.a("update"), this.onError = new s.a("onError");
    }
    return t2.prototype.bind = function(t3) {
      this.onResize.add(t3), this.onUpdate.add(t3), this.onError.add(t3), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, t2.prototype.unbind = function(t3) {
      this.onResize.remove(t3), this.onUpdate.remove(t3), this.onError.remove(t3);
    }, t2.prototype.resize = function(t3, e2) {
      t3 === this._width && e2 === this._height || (this._width = t3, this._height = e2, this.onResize.emit(t3, e2));
    }, Object.defineProperty(t2.prototype, "valid", { get: function() {
      return !!this._width && !!this._height;
    }, enumerable: false, configurable: true }), t2.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, t2.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(t2.prototype, "width", { get: function() {
      return this._width;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "height", { get: function() {
      return this._height;
    }, enumerable: false, configurable: true }), t2.prototype.style = function(t3, e2, i2) {
      return false;
    }, t2.prototype.dispose = function() {
    }, t2.prototype.destroy = function() {
      this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, t2.test = function(t3, e2) {
      return false;
    }, t2;
  }(), m = function(t2) {
    function e2(e3, i2) {
      var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
      if (!o2 || !s2)
        throw new Error("BufferResource width or height invalid");
      return (n2 = t2.call(this, o2, s2) || this).data = e3, n2;
    }
    return d(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
      var n2 = t3.gl;
      n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
      var o2 = e3.realWidth, s2 = e3.realHeight;
      return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
    }, e2.prototype.dispose = function() {
      this.data = null;
    }, e2.test = function(t3) {
      return t3 instanceof Float32Array || t3 instanceof Uint8Array || t3 instanceof Uint32Array;
    }, e2;
  }(f), g = { scaleMode: r.p.NEAREST, format: r.h.RGBA, alphaMode: r.a.NPM }, v = function(t2) {
    function e2(e3, i2) {
      e3 === void 0 && (e3 = null), i2 === void 0 && (i2 = null);
      var s2 = t2.call(this) || this, a2 = (i2 = i2 || {}).alphaMode, l2 = i2.mipmap, h2 = i2.anisotropicLevel, c2 = i2.scaleMode, d2 = i2.width, p2 = i2.height, m2 = i2.wrapMode, g2 = i2.format, v2 = i2.type, _2 = i2.target, y2 = i2.resolution, x2 = i2.resourceOptions;
      return !e3 || e3 instanceof f || ((e3 = u(e3, x2)).internal = true), s2.resolution = y2 || n.b.RESOLUTION, s2.width = Math.round((d2 || 0) * s2.resolution) / s2.resolution, s2.height = Math.round((p2 || 0) * s2.resolution) / s2.resolution, s2._mipmap = l2 !== void 0 ? l2 : n.b.MIPMAP_TEXTURES, s2.anisotropicLevel = h2 !== void 0 ? h2 : n.b.ANISOTROPIC_LEVEL, s2._wrapMode = m2 || n.b.WRAP_MODE, s2._scaleMode = c2 !== void 0 ? c2 : n.b.SCALE_MODE, s2.format = g2 || r.h.RGBA, s2.type = v2 || r.r.UNSIGNED_BYTE, s2.target = _2 || r.q.TEXTURE_2D, s2.alphaMode = a2 !== void 0 ? a2 : r.a.UNPACK, s2.uid = Object(o.uid)(), s2.touched = 0, s2.isPowerOfTwo = false, s2._refreshPOT(), s2._glTextures = {}, s2.dirtyId = 0, s2.dirtyStyleId = 0, s2.cacheId = null, s2.valid = d2 > 0 && p2 > 0, s2.textureCacheIds = [], s2.destroyed = false, s2.resource = null, s2._batchEnabled = 0, s2._batchLocation = 0, s2.parentTextureArray = null, s2.setResource(e3), s2;
    }
    return d(e2, t2), Object.defineProperty(e2.prototype, "realWidth", { get: function() {
      return Math.round(this.width * this.resolution);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "realHeight", { get: function() {
      return Math.round(this.height * this.resolution);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mipmap", { get: function() {
      return this._mipmap;
    }, set: function(t3) {
      this._mipmap !== t3 && (this._mipmap = t3, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scaleMode", { get: function() {
      return this._scaleMode;
    }, set: function(t3) {
      this._scaleMode !== t3 && (this._scaleMode = t3, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "wrapMode", { get: function() {
      return this._wrapMode;
    }, set: function(t3) {
      this._wrapMode !== t3 && (this._wrapMode = t3, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), e2.prototype.setStyle = function(t3, e3) {
      var i2;
      return t3 !== void 0 && t3 !== this.scaleMode && (this.scaleMode = t3, i2 = true), e3 !== void 0 && e3 !== this.mipmap && (this.mipmap = e3, i2 = true), i2 && this.dirtyStyleId++, this;
    }, e2.prototype.setSize = function(t3, e3, i2) {
      return i2 = i2 || this.resolution, this.setRealSize(t3 * i2, e3 * i2, i2);
    }, e2.prototype.setRealSize = function(t3, e3, i2) {
      return this.resolution = i2 || this.resolution, this.width = Math.round(t3) / this.resolution, this.height = Math.round(e3) / this.resolution, this._refreshPOT(), this.update(), this;
    }, e2.prototype._refreshPOT = function() {
      this.isPowerOfTwo = Object(o.isPow2)(this.realWidth) && Object(o.isPow2)(this.realHeight);
    }, e2.prototype.setResolution = function(t3) {
      var e3 = this.resolution;
      return e3 === t3 || (this.resolution = t3, this.valid && (this.width = Math.round(this.width * e3) / t3, this.height = Math.round(this.height * e3) / t3, this.emit("update", this)), this._refreshPOT()), this;
    }, e2.prototype.setResource = function(t3) {
      if (this.resource === t3)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return t3.bind(this), this.resource = t3, this;
    }, e2.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
    }, e2.prototype.onError = function(t3) {
      this.emit("error", this, t3);
    }, e2.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete o.BaseTextureCache[this.cacheId], delete o.TextureCache[this.cacheId], this.cacheId = null), this.dispose(), e2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
    }, e2.prototype.dispose = function() {
      this.emit("dispose", this);
    }, e2.prototype.castToBaseTexture = function() {
      return this;
    }, e2.from = function(t3, i2, r2) {
      r2 === void 0 && (r2 = n.b.STRICT_TEXTURE_CACHE);
      var s2 = typeof t3 == "string", a2 = null;
      if (s2)
        a2 = t3;
      else {
        if (!t3._pixiId) {
          var l2 = i2 && i2.pixiIdPrefix || "pixiid";
          t3._pixiId = l2 + "_" + Object(o.uid)();
        }
        a2 = t3._pixiId;
      }
      var h2 = o.BaseTextureCache[a2];
      if (s2 && r2 && !h2)
        throw new Error('The cacheId "' + a2 + '" does not exist in BaseTextureCache.');
      return h2 || ((h2 = new e2(t3, i2)).cacheId = a2, e2.addToCache(h2, a2)), h2;
    }, e2.fromBuffer = function(t3, i2, n2, o2) {
      t3 = t3 || new Float32Array(i2 * n2 * 4);
      var s2 = new m(t3, { width: i2, height: n2 }), a2 = t3 instanceof Float32Array ? r.r.FLOAT : r.r.UNSIGNED_BYTE;
      return new e2(s2, Object.assign(g, o2 || { width: i2, height: n2, type: a2 }));
    }, e2.addToCache = function(t3, e3) {
      e3 && (t3.textureCacheIds.indexOf(e3) === -1 && t3.textureCacheIds.push(e3), o.BaseTextureCache[e3] && console.warn("BaseTexture added to the cache with an id [" + e3 + "] that already had an entry"), o.BaseTextureCache[e3] = t3);
    }, e2.removeFromCache = function(t3) {
      if (typeof t3 == "string") {
        var e3 = o.BaseTextureCache[t3];
        if (e3) {
          var i2 = e3.textureCacheIds.indexOf(t3);
          return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete o.BaseTextureCache[t3], e3;
        }
      } else if (t3 && t3.textureCacheIds) {
        for (var n2 = 0; n2 < t3.textureCacheIds.length; ++n2)
          delete o.BaseTextureCache[t3.textureCacheIds[n2]];
        return t3.textureCacheIds.length = 0, t3;
      }
      return null;
    }, e2._globalBatch = 0, e2;
  }(o.EventEmitter), _ = function(t2) {
    function e2(e3, i2) {
      var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
      (n2 = t2.call(this, o2, s2) || this).items = [], n2.itemDirtyIds = [];
      for (var a2 = 0; a2 < e3; a2++) {
        var l2 = new v();
        n2.items.push(l2), n2.itemDirtyIds.push(-2);
      }
      return n2.length = e3, n2._load = null, n2.baseTexture = null, n2;
    }
    return d(e2, t2), e2.prototype.initFromArray = function(t3, e3) {
      for (var i2 = 0; i2 < this.length; i2++)
        t3[i2] && (t3[i2].castToBaseTexture ? this.addBaseTextureAt(t3[i2].castToBaseTexture(), i2) : t3[i2] instanceof f ? this.addResourceAt(t3[i2], i2) : this.addResourceAt(u(t3[i2], e3), i2));
    }, e2.prototype.dispose = function() {
      for (var t3 = 0, e3 = this.length; t3 < e3; t3++)
        this.items[t3].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, e2.prototype.addResourceAt = function(t3, e3) {
      if (!this.items[e3])
        throw new Error("Index " + e3 + " is out of bounds");
      return t3.valid && !this.valid && this.resize(t3.width, t3.height), this.items[e3].setResource(t3), this;
    }, e2.prototype.bind = function(e3) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      t2.prototype.bind.call(this, e3);
      for (var i2 = 0; i2 < this.length; i2++)
        this.items[i2].parentTextureArray = e3, this.items[i2].on("update", e3.update, e3);
    }, e2.prototype.unbind = function(e3) {
      t2.prototype.unbind.call(this, e3);
      for (var i2 = 0; i2 < this.length; i2++)
        this.items[i2].parentTextureArray = null, this.items[i2].off("update", e3.update, e3);
    }, e2.prototype.load = function() {
      var t3 = this;
      if (this._load)
        return this._load;
      var e3 = this.items.map(function(t4) {
        return t4.resource;
      }).filter(function(t4) {
        return t4;
      }).map(function(t4) {
        return t4.load();
      });
      return this._load = Promise.all(e3).then(function() {
        var e4 = t3.items[0], i2 = e4.realWidth, n2 = e4.realHeight;
        return t3.resize(i2, n2), Promise.resolve(t3);
      }), this._load;
    }, e2;
  }(f), y = function(t2) {
    function e2(e3, i2) {
      var n2, r2, o2 = this, s2 = i2 || {}, a2 = s2.width, l2 = s2.height;
      return Array.isArray(e3) ? (n2 = e3, r2 = e3.length) : r2 = e3, o2 = t2.call(this, r2, { width: a2, height: l2 }) || this, n2 && o2.initFromArray(n2, i2), o2;
    }
    return d(e2, t2), e2.prototype.addBaseTextureAt = function(t3, e3) {
      if (!t3.resource)
        throw new Error("ArrayResource does not support RenderTexture");
      return this.addResourceAt(t3.resource, e3), this;
    }, e2.prototype.bind = function(e3) {
      t2.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_2D_ARRAY;
    }, e2.prototype.upload = function(t3, e3, i2) {
      var n2 = this.length, r2 = this.itemDirtyIds, o2 = this.items, s2 = t3.gl;
      i2.dirtyId < 0 && s2.texImage3D(s2.TEXTURE_2D_ARRAY, 0, i2.internalFormat, this._width, this._height, n2, 0, e3.format, i2.type, null);
      for (var a2 = 0; a2 < n2; a2++) {
        var l2 = o2[a2];
        r2[a2] < l2.dirtyId && (r2[a2] = l2.dirtyId, l2.valid && s2.texSubImage3D(s2.TEXTURE_2D_ARRAY, 0, 0, 0, a2, l2.resource.width, l2.resource.height, 1, e3.format, i2.type, l2.resource.source));
      }
      return true;
    }, e2;
  }(_), x = function(t2) {
    function e2(e3) {
      var i2 = this, n2 = e3, r2 = n2.naturalWidth || n2.videoWidth || n2.width, o2 = n2.naturalHeight || n2.videoHeight || n2.height;
      return (i2 = t2.call(this, r2, o2) || this).source = e3, i2.noSubImage = false, i2;
    }
    return d(e2, t2), e2.crossOrigin = function(t3, e3, i2) {
      i2 === void 0 && e3.indexOf("data:") !== 0 ? t3.crossOrigin = Object(o.determineCrossOrigin)(e3) : i2 !== false && (t3.crossOrigin = typeof i2 == "string" ? i2 : "anonymous");
    }, e2.prototype.upload = function(t3, e3, i2, n2) {
      var o2 = t3.gl, s2 = e3.realWidth, a2 = e3.realHeight;
      if ((n2 = n2 || this.source) instanceof HTMLImageElement) {
        if (!n2.complete || n2.naturalWidth === 0)
          return false;
      } else if (n2 instanceof HTMLVideoElement && n2.readyState <= 1)
        return false;
      return o2.pixelStorei(o2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK), this.noSubImage || e3.target !== o2.TEXTURE_2D || i2.width !== s2 || i2.height !== a2 ? (i2.width = s2, i2.height = a2, o2.texImage2D(e3.target, 0, i2.internalFormat, e3.format, i2.type, n2)) : o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e3.format, i2.type, n2), true;
    }, e2.prototype.update = function() {
      if (!this.destroyed) {
        var e3 = this.source, i2 = e3.naturalWidth || e3.videoWidth || e3.width, n2 = e3.naturalHeight || e3.videoHeight || e3.height;
        this.resize(i2, n2), t2.prototype.update.call(this);
      }
    }, e2.prototype.dispose = function() {
      this.source = null;
    }, e2;
  }(f), b = function(t2) {
    function e2(e3) {
      return t2.call(this, e3) || this;
    }
    return d(e2, t2), e2.test = function(t3) {
      var e3 = globalThis.OffscreenCanvas;
      return !!(e3 && t3 instanceof e3) || globalThis.HTMLCanvasElement && t3 instanceof HTMLCanvasElement;
    }, e2;
  }(x), T = function(t2) {
    function e2(i2, n2) {
      var o2 = this, s2 = n2 || {}, a2 = s2.width, l2 = s2.height, h2 = s2.autoLoad, u2 = s2.linkBaseTexture;
      if (i2 && i2.length !== e2.SIDES)
        throw new Error("Invalid length. Got " + i2.length + ", expected 6");
      o2 = t2.call(this, 6, { width: a2, height: l2 }) || this;
      for (var c2 = 0; c2 < e2.SIDES; c2++)
        o2.items[c2].target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + c2;
      return o2.linkBaseTexture = u2 !== false, i2 && o2.initFromArray(i2, n2), h2 !== false && o2.load(), o2;
    }
    return d(e2, t2), e2.prototype.bind = function(e3) {
      t2.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_CUBE_MAP;
    }, e2.prototype.addBaseTextureAt = function(t3, e3, i2) {
      if (!this.items[e3])
        throw new Error("Index " + e3 + " is out of bounds");
      if (!this.linkBaseTexture || t3.parentTextureArray || Object.keys(t3._glTextures).length > 0) {
        if (!t3.resource)
          throw new Error("CubeResource does not support copying of renderTexture.");
        this.addResourceAt(t3.resource, e3);
      } else
        t3.target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + e3, t3.parentTextureArray = this.baseTexture, this.items[e3] = t3;
      return t3.valid && !this.valid && this.resize(t3.realWidth, t3.realHeight), this.items[e3] = t3, this;
    }, e2.prototype.upload = function(t3, i2, n2) {
      for (var r2 = this.itemDirtyIds, o2 = 0; o2 < e2.SIDES; o2++) {
        var s2 = this.items[o2];
        r2[o2] < s2.dirtyId && (s2.valid && s2.resource ? (s2.resource.upload(t3, s2, n2), r2[o2] = s2.dirtyId) : r2[o2] < -1 && (t3.gl.texImage2D(s2.target, 0, n2.internalFormat, i2.realWidth, i2.realHeight, 0, i2.format, n2.type, null), r2[o2] = -1));
      }
      return true;
    }, e2.test = function(t3) {
      return Array.isArray(t3) && t3.length === e2.SIDES;
    }, e2.SIDES = 6, e2;
  }(_), E = function(t2) {
    function e2(e3, i2) {
      var r2 = this;
      if (i2 = i2 || {}, !(e3 instanceof HTMLImageElement)) {
        var o2 = new Image();
        x.crossOrigin(o2, e3, i2.crossorigin), o2.src = e3, e3 = o2;
      }
      return r2 = t2.call(this, e3) || this, !e3.complete && r2._width && r2._height && (r2._width = 0, r2._height = 0), r2.url = e3.src, r2._process = null, r2.preserveBitmap = false, r2.createBitmap = (i2.createBitmap !== void 0 ? i2.createBitmap : n.b.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, r2.alphaMode = typeof i2.alphaMode == "number" ? i2.alphaMode : null, r2.bitmap = null, r2._load = null, i2.autoLoad !== false && r2.load(), r2;
    }
    return d(e2, t2), e2.prototype.load = function(t3) {
      var e3 = this;
      return this._load || (t3 !== void 0 && (this.createBitmap = t3), this._load = new Promise(function(t4, i2) {
        var n2 = e3.source;
        e3.url = n2.src;
        var r2 = function() {
          e3.destroyed || (n2.onload = null, n2.onerror = null, e3.resize(n2.width, n2.height), e3._load = null, e3.createBitmap ? t4(e3.process()) : t4(e3));
        };
        n2.complete && n2.src ? r2() : (n2.onload = r2, n2.onerror = function(t5) {
          i2(t5), e3.onError.emit(t5);
        });
      })), this._load;
    }, e2.prototype.process = function() {
      var t3 = this, e3 = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var i2 = globalThis.createImageBitmap, n2 = !e3.crossOrigin || e3.crossOrigin === "anonymous";
      return this._process = fetch(e3.src, { mode: n2 ? "cors" : "no-cors" }).then(function(t4) {
        return t4.blob();
      }).then(function(n3) {
        return i2(n3, 0, 0, e3.width, e3.height, { premultiplyAlpha: t3.alphaMode === r.a.UNPACK ? "premultiply" : "none" });
      }).then(function(e4) {
        return t3.destroyed ? Promise.reject() : (t3.bitmap = e4, t3.update(), t3._process = null, Promise.resolve(t3));
      }), this._process;
    }, e2.prototype.upload = function(e3, i2, n2) {
      if (typeof this.alphaMode == "number" && (i2.alphaMode = this.alphaMode), !this.createBitmap)
        return t2.prototype.upload.call(this, e3, i2, n2);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return false;
      if (t2.prototype.upload.call(this, e3, i2, n2, this.bitmap), !this.preserveBitmap) {
        var r2 = true, o2 = i2._glTextures;
        for (var s2 in o2) {
          var a2 = o2[s2];
          if (a2 !== n2 && a2.dirtyId !== i2.dirtyId) {
            r2 = false;
            break;
          }
        }
        r2 && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return true;
    }, e2.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, t2.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, e2.test = function(t3) {
      return typeof t3 == "string" || t3 instanceof HTMLImageElement;
    }, e2;
  }(x), S = function(t2) {
    function e2(e3, i2) {
      var n2 = this;
      return i2 = i2 || {}, (n2 = t2.call(this, document.createElement("canvas")) || this)._width = 0, n2._height = 0, n2.svg = e3, n2.scale = i2.scale || 1, n2._overrideWidth = i2.width, n2._overrideHeight = i2.height, n2._resolve = null, n2._crossorigin = i2.crossorigin, n2._load = null, i2.autoLoad !== false && n2.load(), n2;
    }
    return d(e2, t2), e2.prototype.load = function() {
      var t3 = this;
      return this._load || (this._load = new Promise(function(i2) {
        if (t3._resolve = function() {
          t3.resize(t3.source.width, t3.source.height), i2(t3);
        }, e2.SVG_XML.test(t3.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          t3.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t3.svg)));
        }
        t3._loadSvg();
      })), this._load;
    }, e2.prototype._loadSvg = function() {
      var t3 = this, e3 = new Image();
      x.crossOrigin(e3, this.svg, this._crossorigin), e3.src = this.svg, e3.onerror = function(i2) {
        t3._resolve && (e3.onerror = null, t3.onError.emit(i2));
      }, e3.onload = function() {
        if (t3._resolve) {
          var i2 = e3.width, n2 = e3.height;
          if (!i2 || !n2)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var r2 = i2 * t3.scale, s2 = n2 * t3.scale;
          (t3._overrideWidth || t3._overrideHeight) && (r2 = t3._overrideWidth || t3._overrideHeight / n2 * i2, s2 = t3._overrideHeight || t3._overrideWidth / i2 * n2), r2 = Math.round(r2), s2 = Math.round(s2);
          var a2 = t3.source;
          a2.width = r2, a2.height = s2, a2._pixiId = "canvas_" + Object(o.uid)(), a2.getContext("2d").drawImage(e3, 0, 0, i2, n2, 0, 0, r2, s2), t3._resolve(), t3._resolve = null;
        }
      };
    }, e2.getSize = function(t3) {
      var i2 = e2.SVG_SIZE.exec(t3), n2 = {};
      return i2 && (n2[i2[1]] = Math.round(parseFloat(i2[3])), n2[i2[5]] = Math.round(parseFloat(i2[7]))), n2;
    }, e2.prototype.dispose = function() {
      t2.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, e2.test = function(t3, i2) {
      return i2 === "svg" || typeof t3 == "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t3) || typeof t3 == "string" && e2.SVG_XML.test(t3);
    }, e2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e2;
  }(x), w = function(t2) {
    function e2(i2, n2) {
      var r2 = this;
      if (n2 = n2 || {}, !(i2 instanceof HTMLVideoElement)) {
        var o2 = document.createElement("video");
        o2.setAttribute("preload", "auto"), o2.setAttribute("webkit-playsinline", ""), o2.setAttribute("playsinline", ""), typeof i2 == "string" && (i2 = [i2]);
        var s2 = i2[0].src || i2[0];
        x.crossOrigin(o2, s2, n2.crossorigin);
        for (var a2 = 0; a2 < i2.length; ++a2) {
          var l2 = document.createElement("source"), h2 = i2[a2], u2 = h2.src, c2 = h2.mime, d2 = (u2 = u2 || i2[a2]).split("?").shift().toLowerCase(), p2 = d2.slice(d2.lastIndexOf(".") + 1);
          c2 = c2 || e2.MIME_TYPES[p2] || "video/" + p2, l2.src = u2, l2.type = c2, o2.appendChild(l2);
        }
        i2 = o2;
      }
      return (r2 = t2.call(this, i2) || this).noSubImage = true, r2._autoUpdate = true, r2._isConnectedToTicker = false, r2._updateFPS = n2.updateFPS || 0, r2._msToNextUpdate = 0, r2.autoPlay = n2.autoPlay !== false, r2._load = null, r2._resolve = null, r2._onCanPlay = r2._onCanPlay.bind(r2), r2._onError = r2._onError.bind(r2), n2.autoLoad !== false && r2.load(), r2;
    }
    return d(e2, t2), e2.prototype.update = function(e3) {
      if (!this.destroyed) {
        var i2 = a.a.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - i2), (!this._updateFPS || this._msToNextUpdate <= 0) && (t2.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, e2.prototype.load = function() {
      var t3 = this;
      if (this._load)
        return this._load;
      var e3 = this.source;
      return (e3.readyState === e3.HAVE_ENOUGH_DATA || e3.readyState === e3.HAVE_FUTURE_DATA) && e3.width && e3.height && (e3.complete = true), e3.addEventListener("play", this._onPlayStart.bind(this)), e3.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e3.addEventListener("canplay", this._onCanPlay), e3.addEventListener("canplaythrough", this._onCanPlay), e3.addEventListener("error", this._onError, true)), this._load = new Promise(function(i2) {
        t3.valid ? i2(t3) : (t3._resolve = i2, e3.load());
      }), this._load;
    }, e2.prototype._onError = function(t3) {
      this.source.removeEventListener("error", this._onError, true), this.onError.emit(t3);
    }, e2.prototype._isSourcePlaying = function() {
      var t3 = this.source;
      return t3.currentTime > 0 && t3.paused === false && t3.ended === false && t3.readyState > 2;
    }, e2.prototype._isSourceReady = function() {
      var t3 = this.source;
      return t3.readyState === 3 || t3.readyState === 4;
    }, e2.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (a.a.shared.add(this.update, this), this._isConnectedToTicker = true);
    }, e2.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false);
    }, e2.prototype._onCanPlay = function() {
      var t3 = this.source;
      t3.removeEventListener("canplay", this._onCanPlay), t3.removeEventListener("canplaythrough", this._onCanPlay);
      var e3 = this.valid;
      this.resize(t3.videoWidth, t3.videoHeight), !e3 && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t3.play();
    }, e2.prototype.dispose = function() {
      this._isConnectedToTicker && (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false);
      var e3 = this.source;
      e3 && (e3.removeEventListener("error", this._onError, true), e3.pause(), e3.src = "", e3.load()), t2.prototype.dispose.call(this);
    }, Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
      return this._autoUpdate;
    }, set: function(t3) {
      t3 !== this._autoUpdate && (this._autoUpdate = t3, !this._autoUpdate && this._isConnectedToTicker ? (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (a.a.shared.add(this.update, this), this._isConnectedToTicker = true));
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "updateFPS", { get: function() {
      return this._updateFPS;
    }, set: function(t3) {
      t3 !== this._updateFPS && (this._updateFPS = t3);
    }, enumerable: false, configurable: true }), e2.test = function(t3, i2) {
      return globalThis.HTMLVideoElement && t3 instanceof HTMLVideoElement || e2.TYPES.indexOf(i2) > -1;
    }, e2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e2.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e2;
  }(x), A = function(t2) {
    function e2(e3) {
      return t2.call(this, e3) || this;
    }
    return d(e2, t2), e2.test = function(t3) {
      return !!globalThis.createImageBitmap && t3 instanceof ImageBitmap;
    }, e2;
  }(x);
  h.push(E, A, b, w, S, m, T, y);
  var R = function(t2) {
    function e2() {
      return t2 !== null && t2.apply(this, arguments) || this;
    }
    return d(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
      var n2 = t3.gl;
      n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
      var o2 = e3.realWidth, s2 = e3.realHeight;
      return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
    }, e2;
  }(m), C = function() {
    function t2(t3, e2) {
      this.width = Math.round(t3 || 100), this.height = Math.round(e2 || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new s.a("disposeFramebuffer"), this.multisample = r.l.NONE;
    }
    return Object.defineProperty(t2.prototype, "colorTexture", { get: function() {
      return this.colorTextures[0];
    }, enumerable: false, configurable: true }), t2.prototype.addColorTexture = function(t3, e2) {
      return t3 === void 0 && (t3 = 0), this.colorTextures[t3] = e2 || new v(null, { scaleMode: r.p.NEAREST, resolution: 1, mipmap: r.k.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this;
    }, t2.prototype.addDepthTexture = function(t3) {
      return this.depthTexture = t3 || new v(new R(null, { width: this.width, height: this.height }), { scaleMode: r.p.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: r.k.OFF, format: r.h.DEPTH_COMPONENT, type: r.r.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this;
    }, t2.prototype.enableDepth = function() {
      return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
    }, t2.prototype.enableStencil = function() {
      return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
    }, t2.prototype.resize = function(t3, e2) {
      if (t3 = Math.round(t3), e2 = Math.round(e2), t3 !== this.width || e2 !== this.height) {
        this.width = t3, this.height = e2, this.dirtyId++, this.dirtySize++;
        for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
          var n2 = this.colorTextures[i2], r2 = n2.resolution;
          n2.setSize(t3 / r2, e2 / r2);
        }
        if (this.depthTexture) {
          r2 = this.depthTexture.resolution;
          this.depthTexture.setSize(t3 / r2, e2 / r2);
        }
      }
    }, t2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t2.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, t2;
  }(), I = function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = {});
      var i2 = this;
      if (typeof e3 == "number") {
        var n2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
        e3 = { width: n2, height: o2, scaleMode: s2, resolution: a2 };
      }
      return e3.width = e3.width || 100, e3.height = e3.height || 100, e3.multisample = e3.multisample !== void 0 ? e3.multisample : r.l.NONE, (i2 = t2.call(this, null, e3) || this).mipmap = r.k.OFF, i2.valid = true, i2.clearColor = [0, 0, 0, 0], i2.framebuffer = new C(i2.realWidth, i2.realHeight).addColorTexture(0, i2), i2.framebuffer.multisample = e3.multisample, i2.maskStack = [], i2.filterStack = [{}], i2;
    }
    return d(e2, t2), e2.prototype.resize = function(t3, e3) {
      this.framebuffer.resize(t3 * this.resolution, e3 * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, e2.prototype.dispose = function() {
      this.framebuffer.dispose(), t2.prototype.dispose.call(this);
    }, e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, e2;
  }(v), P = function() {
    function t2() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return t2.prototype.set = function(t3, e2, i2) {
      var n2 = e2.width, r2 = e2.height;
      if (i2) {
        var o2 = t3.width / 2 / n2, s2 = t3.height / 2 / r2, a2 = t3.x / n2 + o2, h2 = t3.y / r2 + s2;
        i2 = l.n.add(i2, l.n.NW), this.x0 = a2 + o2 * l.n.uX(i2), this.y0 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x1 = a2 + o2 * l.n.uX(i2), this.y1 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x2 = a2 + o2 * l.n.uX(i2), this.y2 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x3 = a2 + o2 * l.n.uX(i2), this.y3 = h2 + s2 * l.n.uY(i2);
      } else
        this.x0 = t3.x / n2, this.y0 = t3.y / r2, this.x1 = (t3.x + t3.width) / n2, this.y1 = t3.y / r2, this.x2 = (t3.x + t3.width) / n2, this.y2 = (t3.y + t3.height) / r2, this.x3 = t3.x / n2, this.y3 = (t3.y + t3.height) / r2;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, t2.prototype.toString = function() {
      return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]";
    }, t2;
  }(), O = new P();
  function N(t2) {
    t2.destroy = function() {
    }, t2.on = function() {
    }, t2.once = function() {
    }, t2.emit = function() {
    };
  }
  var L = function(t2) {
    function e2(i2, n2, r2, o2, s2, a2) {
      var h2 = t2.call(this) || this;
      if (h2.noFrame = false, n2 || (h2.noFrame = true, n2 = new l.j(0, 0, 1, 1)), i2 instanceof e2 && (i2 = i2.baseTexture), h2.baseTexture = i2, h2._frame = n2, h2.trim = o2, h2.valid = false, h2._uvs = O, h2.uvMatrix = null, h2.orig = r2 || n2, h2._rotate = Number(s2 || 0), s2 === true)
        h2._rotate = 2;
      else if (h2._rotate % 2 != 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return h2.defaultAnchor = a2 ? new l.g(a2.x, a2.y) : new l.g(0, 0), h2._updateID = 0, h2.textureCacheIds = [], i2.valid ? h2.noFrame ? i2.valid && h2.onBaseTextureUpdated(i2) : h2.frame = n2 : i2.once("loaded", h2.onBaseTextureUpdated, h2), h2.noFrame && i2.on("update", h2.onBaseTextureUpdated, h2), h2;
    }
    return d(e2, t2), e2.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, e2.prototype.onBaseTextureUpdated = function(t3) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = t3.width, this._frame.height = t3.height, this.valid = true, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, e2.prototype.destroy = function(t3) {
      if (this.baseTexture) {
        if (t3) {
          var i2 = this.baseTexture.resource;
          i2 && i2.url && o.TextureCache[i2.url] && e2.removeFromCache(i2.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e2.removeFromCache(this), this.textureCacheIds = null;
    }, e2.prototype.clone = function() {
      var t3 = this._frame.clone(), i2 = this._frame === this.orig ? t3 : this.orig.clone(), n2 = new e2(this.baseTexture, !this.noFrame && t3, i2, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (n2._frame = t3), n2;
    }, e2.prototype.updateUvs = function() {
      this._uvs === O && (this._uvs = new P()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, e2.from = function(t3, i2, r2) {
      i2 === void 0 && (i2 = {}), r2 === void 0 && (r2 = n.b.STRICT_TEXTURE_CACHE);
      var s2 = typeof t3 == "string", a2 = null;
      if (s2)
        a2 = t3;
      else if (t3 instanceof v) {
        if (!t3.cacheId) {
          var l2 = i2 && i2.pixiIdPrefix || "pixiid";
          t3.cacheId = l2 + "-" + Object(o.uid)(), v.addToCache(t3, t3.cacheId);
        }
        a2 = t3.cacheId;
      } else {
        if (!t3._pixiId) {
          l2 = i2 && i2.pixiIdPrefix || "pixiid";
          t3._pixiId = l2 + "_" + Object(o.uid)();
        }
        a2 = t3._pixiId;
      }
      var h2 = o.TextureCache[a2];
      if (s2 && r2 && !h2)
        throw new Error('The cacheId "' + a2 + '" does not exist in TextureCache.');
      return h2 || t3 instanceof v ? !h2 && t3 instanceof v && (h2 = new e2(t3), e2.addToCache(h2, a2)) : (i2.resolution || (i2.resolution = Object(o.getResolutionOfUrl)(t3)), (h2 = new e2(new v(t3, i2))).baseTexture.cacheId = a2, v.addToCache(h2.baseTexture, a2), e2.addToCache(h2, a2)), h2;
    }, e2.fromURL = function(t3, i2) {
      var n2 = Object.assign({ autoLoad: false }, i2 == null ? void 0 : i2.resourceOptions), r2 = e2.from(t3, Object.assign({ resourceOptions: n2 }, i2), false), o2 = r2.baseTexture.resource;
      return r2.baseTexture.valid ? Promise.resolve(r2) : o2.load().then(function() {
        return Promise.resolve(r2);
      });
    }, e2.fromBuffer = function(t3, i2, n2, r2) {
      return new e2(v.fromBuffer(t3, i2, n2, r2));
    }, e2.fromLoader = function(t3, i2, r2, s2) {
      var a2 = new v(t3, Object.assign({ scaleMode: n.b.SCALE_MODE, resolution: Object(o.getResolutionOfUrl)(i2) }, s2)), l2 = a2.resource;
      l2 instanceof E && (l2.url = i2);
      var h2 = new e2(a2);
      return r2 || (r2 = i2), v.addToCache(h2.baseTexture, r2), e2.addToCache(h2, r2), r2 !== i2 && (v.addToCache(h2.baseTexture, i2), e2.addToCache(h2, i2)), h2.baseTexture.valid ? Promise.resolve(h2) : new Promise(function(t4) {
        h2.baseTexture.once("loaded", function() {
          return t4(h2);
        });
      });
    }, e2.addToCache = function(t3, e3) {
      e3 && (t3.textureCacheIds.indexOf(e3) === -1 && t3.textureCacheIds.push(e3), o.TextureCache[e3] && console.warn("Texture added to the cache with an id [" + e3 + "] that already had an entry"), o.TextureCache[e3] = t3);
    }, e2.removeFromCache = function(t3) {
      if (typeof t3 == "string") {
        var e3 = o.TextureCache[t3];
        if (e3) {
          var i2 = e3.textureCacheIds.indexOf(t3);
          return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete o.TextureCache[t3], e3;
        }
      } else if (t3 && t3.textureCacheIds) {
        for (var n2 = 0; n2 < t3.textureCacheIds.length; ++n2)
          o.TextureCache[t3.textureCacheIds[n2]] === t3 && delete o.TextureCache[t3.textureCacheIds[n2]];
        return t3.textureCacheIds.length = 0, t3;
      }
      return null;
    }, Object.defineProperty(e2.prototype, "resolution", { get: function() {
      return this.baseTexture.resolution;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "frame", { get: function() {
      return this._frame;
    }, set: function(t3) {
      this._frame = t3, this.noFrame = false;
      var e3 = t3.x, i2 = t3.y, n2 = t3.width, r2 = t3.height, o2 = e3 + n2 > this.baseTexture.width, s2 = i2 + r2 > this.baseTexture.height;
      if (o2 || s2) {
        var a2 = o2 && s2 ? "and" : "or", l2 = "X: " + e3 + " + " + n2 + " = " + (e3 + n2) + " > " + this.baseTexture.width, h2 = "Y: " + i2 + " + " + r2 + " = " + (i2 + r2) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l2 + " " + a2 + " " + h2);
      }
      this.valid = n2 && r2 && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t3), this.valid && this.updateUvs();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotate", { get: function() {
      return this._rotate;
    }, set: function(t3) {
      this._rotate = t3, this.valid && this.updateUvs();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.orig.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.orig.height;
    }, enumerable: false, configurable: true }), e2.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(e2, "EMPTY", { get: function() {
      return e2._EMPTY || (e2._EMPTY = new e2(new v()), N(e2._EMPTY), N(e2._EMPTY.baseTexture)), e2._EMPTY;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2, "WHITE", { get: function() {
      if (!e2._WHITE) {
        var t3 = document.createElement("canvas"), i2 = t3.getContext("2d");
        t3.width = 16, t3.height = 16, i2.fillStyle = "white", i2.fillRect(0, 0, 16, 16), e2._WHITE = new e2(new v(new b(t3))), N(e2._WHITE), N(e2._WHITE.baseTexture);
      }
      return e2._WHITE;
    }, enumerable: false, configurable: true }), e2;
  }(o.EventEmitter), D = function(t2) {
    function e2(e3, i2) {
      var n2 = t2.call(this, e3, i2) || this;
      return n2.valid = true, n2.filterFrame = null, n2.filterPoolKey = null, n2.updateUvs(), n2;
    }
    return d(e2, t2), Object.defineProperty(e2.prototype, "framebuffer", { get: function() {
      return this.baseTexture.framebuffer;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "multisample", { get: function() {
      return this.framebuffer.multisample;
    }, set: function(t3) {
      this.framebuffer.multisample = t3;
    }, enumerable: false, configurable: true }), e2.prototype.resize = function(t3, e3, i2) {
      i2 === void 0 && (i2 = true);
      var n2 = this.baseTexture.resolution, r2 = Math.round(t3 * n2) / n2, o2 = Math.round(e3 * n2) / n2;
      this.valid = r2 > 0 && o2 > 0, this._frame.width = this.orig.width = r2, this._frame.height = this.orig.height = o2, i2 && this.baseTexture.resize(r2, o2), this.updateUvs();
    }, e2.prototype.setResolution = function(t3) {
      var e3 = this.baseTexture;
      e3.resolution !== t3 && (e3.setResolution(t3), this.resize(e3.width, e3.height, false));
    }, e2.create = function(t3) {
      for (var i2 = arguments, n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = i2[r2];
      return typeof t3 == "number" && (Object(o.deprecation)("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t3 = { width: t3, height: n2[0], scaleMode: n2[1], resolution: n2[2] }), new e2(new I(t3));
    }, e2;
  }(L), F = function() {
    function t2(t3) {
      this.texturePool = {}, this.textureOptions = t3 || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return t2.prototype.createTexture = function(t3, e2, i2) {
      i2 === void 0 && (i2 = r.l.NONE);
      var n2 = new I(Object.assign({ width: t3, height: e2, resolution: 1, multisample: i2 }, this.textureOptions));
      return new D(n2);
    }, t2.prototype.getOptimalTexture = function(t3, e2, i2, n2) {
      var s2;
      i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = r.l.NONE), t3 = Math.ceil(t3 * i2 - 1e-6), e2 = Math.ceil(e2 * i2 - 1e-6), this.enableFullScreen && t3 === this._pixelsWidth && e2 === this._pixelsHeight ? s2 = n2 > 1 ? -n2 : -1 : (s2 = ((65535 & (t3 = Object(o.nextPow2)(t3))) << 16 | 65535 & (e2 = Object(o.nextPow2)(e2))) >>> 0, n2 > 1 && (s2 += 4294967296 * n2)), this.texturePool[s2] || (this.texturePool[s2] = []);
      var a2 = this.texturePool[s2].pop();
      return a2 || (a2 = this.createTexture(t3, e2, n2)), a2.filterPoolKey = s2, a2.setResolution(i2), a2;
    }, t2.prototype.getFilterTexture = function(t3, e2, i2) {
      var n2 = this.getOptimalTexture(t3.width, t3.height, e2 || t3.resolution, i2 || r.l.NONE);
      return n2.filterFrame = t3.filterFrame, n2;
    }, t2.prototype.returnTexture = function(t3) {
      var e2 = t3.filterPoolKey;
      t3.filterFrame = null, this.texturePool[e2].push(t3);
    }, t2.prototype.returnFilterTexture = function(t3) {
      this.returnTexture(t3);
    }, t2.prototype.clear = function(t3) {
      if (t3 = t3 !== false)
        for (var e2 in this.texturePool) {
          var i2 = this.texturePool[e2];
          if (i2)
            for (var n2 = 0; n2 < i2.length; n2++)
              i2[n2].destroy(true);
        }
      this.texturePool = {};
    }, t2.prototype.setScreenSize = function(t3) {
      if (t3.width !== this._pixelsWidth || t3.height !== this._pixelsHeight) {
        for (var e2 in this.enableFullScreen = t3.width > 0 && t3.height > 0, this.texturePool)
          if (Number(e2) < 0) {
            var i2 = this.texturePool[e2];
            if (i2)
              for (var n2 = 0; n2 < i2.length; n2++)
                i2[n2].destroy(true);
            this.texturePool[e2] = [];
          }
        this._pixelsWidth = t3.width, this._pixelsHeight = t3.height;
      }
    }, t2.SCREEN_KEY = -1, t2;
  }(), B = function() {
    function t2(t3, e2, i2, n2, o2, s2, a2) {
      e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = false), n2 === void 0 && (n2 = r.r.FLOAT), this.buffer = t3, this.size = e2, this.normalized = i2, this.type = n2, this.stride = o2, this.start = s2, this.instance = a2;
    }
    return t2.prototype.destroy = function() {
      this.buffer = null;
    }, t2.from = function(e2, i2, n2, r2, o2) {
      return new t2(e2, i2, n2, r2, o2);
    }, t2;
  }(), U = 0, k = function() {
    function t2(t3, e2, i2) {
      e2 === void 0 && (e2 = true), i2 === void 0 && (i2 = false), this.data = t3 || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i2, this.static = e2, this.id = U++, this.disposeRunner = new s.a("disposeBuffer");
    }
    return t2.prototype.update = function(t3) {
      t3 instanceof Array && (t3 = new Float32Array(t3)), this.data = t3 || this.data, this._updateID++;
    }, t2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t2.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(t2.prototype, "index", { get: function() {
      return this.type === r.d.ELEMENT_ARRAY_BUFFER;
    }, set: function(t3) {
      this.type = t3 ? r.d.ELEMENT_ARRAY_BUFFER : r.d.ARRAY_BUFFER;
    }, enumerable: false, configurable: true }), t2.from = function(e2) {
      return e2 instanceof Array && (e2 = new Float32Array(e2)), new t2(e2);
    }, t2;
  }(), G = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  var H = { 5126: 4, 5123: 2, 5121: 1 }, j = 0, z = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }, V = function() {
    function t2(t3, e2) {
      t3 === void 0 && (t3 = []), e2 === void 0 && (e2 = {}), this.buffers = t3, this.indexBuffer = null, this.attributes = e2, this.glVertexArrayObjects = {}, this.id = j++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new s.a("disposeGeometry"), this.refCount = 0;
    }
    return t2.prototype.addAttribute = function(t3, e2, i2, n2, r2, o2, s2, a2) {
      if (i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = false), a2 === void 0 && (a2 = false), !e2)
        throw new Error("You must pass a buffer when creating an attribute");
      e2 instanceof k || (e2 instanceof Array && (e2 = new Float32Array(e2)), e2 = new k(e2));
      var l2 = t3.split("|");
      if (l2.length > 1) {
        for (var h2 = 0; h2 < l2.length; h2++)
          this.addAttribute(l2[h2], e2, i2, n2, r2);
        return this;
      }
      var u2 = this.buffers.indexOf(e2);
      return u2 === -1 && (this.buffers.push(e2), u2 = this.buffers.length - 1), this.attributes[t3] = new B(u2, i2, n2, r2, o2, s2, a2), this.instanced = this.instanced || a2, this;
    }, t2.prototype.getAttribute = function(t3) {
      return this.attributes[t3];
    }, t2.prototype.getBuffer = function(t3) {
      return this.buffers[this.getAttribute(t3).buffer];
    }, t2.prototype.addIndex = function(t3) {
      return t3 instanceof k || (t3 instanceof Array && (t3 = new Uint16Array(t3)), t3 = new k(t3)), t3.type = r.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t3, this.buffers.indexOf(t3) === -1 && this.buffers.push(t3), this;
    }, t2.prototype.getIndex = function() {
      return this.indexBuffer;
    }, t2.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t3, e2 = [], i2 = [], n2 = new k();
      for (t3 in this.attributes) {
        var r2 = this.attributes[t3], s2 = this.buffers[r2.buffer];
        e2.push(s2.data), i2.push(r2.size * H[r2.type] / 4), r2.buffer = 0;
      }
      for (n2.data = function(t4, e3) {
        for (var i3 = 0, n3 = 0, r3 = {}, s3 = 0; s3 < t4.length; s3++)
          n3 += e3[s3], i3 += t4[s3].length;
        var a2 = new ArrayBuffer(4 * i3), l2 = null, h2 = 0;
        for (s3 = 0; s3 < t4.length; s3++) {
          var u2 = e3[s3], c2 = t4[s3], d2 = Object(o.getBufferType)(c2);
          r3[d2] || (r3[d2] = new G[d2](a2)), l2 = r3[d2];
          for (var p2 = 0; p2 < c2.length; p2++) {
            l2[(p2 / u2 | 0) * n3 + h2 + p2 % u2] = c2[p2];
          }
          h2 += u2;
        }
        return new Float32Array(a2);
      }(e2, i2), t3 = 0; t3 < this.buffers.length; t3++)
        this.buffers[t3] !== this.indexBuffer && this.buffers[t3].destroy();
      return this.buffers = [n2], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, t2.prototype.getSize = function() {
      for (var t3 in this.attributes) {
        var e2 = this.attributes[t3];
        return this.buffers[e2.buffer].data.length / (e2.stride / 4 || e2.size);
      }
      return 0;
    }, t2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t2.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, t2.prototype.clone = function() {
      for (var e2 = new t2(), i2 = 0; i2 < this.buffers.length; i2++)
        e2.buffers[i2] = new k(this.buffers[i2].data.slice(0));
      for (var i2 in this.attributes) {
        var n2 = this.attributes[i2];
        e2.attributes[i2] = new B(n2.buffer, n2.size, n2.normalized, n2.type, n2.stride, n2.start, n2.instance);
      }
      return this.indexBuffer && (e2.indexBuffer = e2.buffers[this.buffers.indexOf(this.indexBuffer)], e2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER), e2;
    }, t2.merge = function(e2) {
      for (var i2, n2 = new t2(), s2 = [], a2 = [], l2 = [], h2 = 0; h2 < e2.length; h2++) {
        i2 = e2[h2];
        for (var u2 = 0; u2 < i2.buffers.length; u2++)
          a2[u2] = a2[u2] || 0, a2[u2] += i2.buffers[u2].data.length, l2[u2] = 0;
      }
      for (h2 = 0; h2 < i2.buffers.length; h2++)
        s2[h2] = new z[Object(o.getBufferType)(i2.buffers[h2].data)](a2[h2]), n2.buffers[h2] = new k(s2[h2]);
      for (h2 = 0; h2 < e2.length; h2++) {
        i2 = e2[h2];
        for (u2 = 0; u2 < i2.buffers.length; u2++)
          s2[u2].set(i2.buffers[u2].data, l2[u2]), l2[u2] += i2.buffers[u2].data.length;
      }
      if (n2.attributes = i2.attributes, i2.indexBuffer) {
        n2.indexBuffer = n2.buffers[i2.buffers.indexOf(i2.indexBuffer)], n2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER;
        var c2 = 0, d2 = 0, p2 = 0, f2 = 0;
        for (h2 = 0; h2 < i2.buffers.length; h2++)
          if (i2.buffers[h2] !== i2.indexBuffer) {
            f2 = h2;
            break;
          }
        for (var h2 in i2.attributes) {
          var m2 = i2.attributes[h2];
          (0 | m2.buffer) === f2 && (d2 += m2.size * H[m2.type] / 4);
        }
        for (h2 = 0; h2 < e2.length; h2++) {
          var g2 = e2[h2].indexBuffer.data;
          for (u2 = 0; u2 < g2.length; u2++)
            n2.indexBuffer.data[u2 + p2] += c2;
          c2 += e2[h2].buffers[f2].data.length / d2, p2 += g2.length;
        }
      }
      return n2;
    }, t2;
  }(), X = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e3;
    }
    return d(e2, t2), e2;
  }(V), W = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e3.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e3.vertexBuffer = new k(e3.vertices), e3.uvBuffer = new k(e3.uvs), e3.addAttribute("aVertexPosition", e3.vertexBuffer).addAttribute("aTextureCoord", e3.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e3;
    }
    return d(e2, t2), e2.prototype.map = function(t3, e3) {
      var i2 = 0, n2 = 0;
      return this.uvs[0] = i2, this.uvs[1] = n2, this.uvs[2] = i2 + e3.width / t3.width, this.uvs[3] = n2, this.uvs[4] = i2 + e3.width / t3.width, this.uvs[5] = n2 + e3.height / t3.height, this.uvs[6] = i2, this.uvs[7] = n2 + e3.height / t3.height, i2 = e3.x, n2 = e3.y, this.vertices[0] = i2, this.vertices[1] = n2, this.vertices[2] = i2 + e3.width, this.vertices[3] = n2, this.vertices[4] = i2 + e3.width, this.vertices[5] = n2 + e3.height, this.vertices[6] = i2, this.vertices[7] = n2 + e3.height, this.invalidate(), this;
    }, e2.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, e2;
  }(V), Y = 0, q = function() {
    function t2(t3, e2, i2) {
      this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = Y++, this.static = !!e2, this.ubo = !!i2, t3 instanceof k ? (this.buffer = t3, this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = t3, this.ubo && (this.buffer = new k(new Float32Array(1)), this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = true));
    }
    return t2.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, t2.prototype.add = function(e2, i2, n2) {
      if (this.ubo)
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      this.uniforms[e2] = new t2(i2, n2);
    }, t2.from = function(e2, i2, n2) {
      return new t2(e2, i2, n2);
    }, t2.uboFrom = function(e2, i2) {
      return new t2(e2, i2 == null || i2, true);
    }, t2;
  }(), Z = function() {
    function t2() {
      this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = r.l.NONE, this.sourceFrame = new l.j(), this.destinationFrame = new l.j(), this.bindingSourceFrame = new l.j(), this.bindingDestinationFrame = new l.j(), this.filters = [], this.transform = null;
    }
    return t2.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, t2;
  }(), J = [new l.g(), new l.g(), new l.g(), new l.g()], K = new l.d(), Q = function() {
    function t2(t3) {
      this.renderer = t3, this.defaultFilterStack = [{}], this.texturePool = new F(), this.texturePool.setScreenSize(t3.view), this.statePool = [], this.quad = new X(), this.quadUv = new W(), this.tempRect = new l.j(), this.activeState = {}, this.globalUniforms = new q({ outputFrame: new l.j(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, true), this.forceClear = false, this.useMaxPadding = false;
    }
    return t2.prototype.push = function(t3, e2) {
      for (var i2, n2, r2 = this.renderer, o2 = this.defaultFilterStack, s2 = this.statePool.pop() || new Z(), a2 = this.renderer.renderTexture, l2 = e2[0].resolution, h2 = e2[0].multisample, u2 = e2[0].padding, c2 = e2[0].autoFit, d2 = (i2 = e2[0].legacy) === null || i2 === void 0 || i2, p2 = 1; p2 < e2.length; p2++) {
        var f2 = e2[p2];
        l2 = Math.min(l2, f2.resolution), h2 = Math.min(h2, f2.multisample), u2 = this.useMaxPadding ? Math.max(u2, f2.padding) : u2 + f2.padding, c2 = c2 && f2.autoFit, d2 = d2 || (n2 = f2.legacy) === null || n2 === void 0 || n2;
      }
      o2.length === 1 && (this.defaultFilterStack[0].renderTexture = a2.current), o2.push(s2), s2.resolution = l2, s2.multisample = h2, s2.legacy = d2, s2.target = t3, s2.sourceFrame.copyFrom(t3.filterArea || t3.getBounds(true)), s2.sourceFrame.pad(u2);
      var m2 = this.tempRect.copyFrom(a2.sourceFrame);
      r2.projection.transform && this.transformAABB(K.copyFrom(r2.projection.transform).invert(), m2), c2 ? (s2.sourceFrame.fit(m2), (s2.sourceFrame.width <= 0 || s2.sourceFrame.height <= 0) && (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0)) : s2.sourceFrame.intersects(m2) || (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0), this.roundFrame(s2.sourceFrame, a2.current ? a2.current.resolution : r2.resolution, a2.sourceFrame, a2.destinationFrame, r2.projection.transform), s2.renderTexture = this.getOptimalFilterTexture(s2.sourceFrame.width, s2.sourceFrame.height, l2, h2), s2.filters = e2, s2.destinationFrame.width = s2.renderTexture.width, s2.destinationFrame.height = s2.renderTexture.height;
      var g2 = this.tempRect;
      g2.x = 0, g2.y = 0, g2.width = s2.sourceFrame.width, g2.height = s2.sourceFrame.height, s2.renderTexture.filterFrame = s2.sourceFrame, s2.bindingSourceFrame.copyFrom(a2.sourceFrame), s2.bindingDestinationFrame.copyFrom(a2.destinationFrame), s2.transform = r2.projection.transform, r2.projection.transform = null, a2.bind(s2.renderTexture, s2.sourceFrame, g2), r2.framebuffer.clear(0, 0, 0, 0);
    }, t2.prototype.pop = function() {
      var t3 = this.defaultFilterStack, e2 = t3.pop(), i2 = e2.filters;
      this.activeState = e2;
      var n2 = this.globalUniforms.uniforms;
      n2.outputFrame = e2.sourceFrame, n2.resolution = e2.resolution;
      var o2 = n2.inputSize, s2 = n2.inputPixel, a2 = n2.inputClamp;
      if (o2[0] = e2.destinationFrame.width, o2[1] = e2.destinationFrame.height, o2[2] = 1 / o2[0], o2[3] = 1 / o2[1], s2[0] = Math.round(o2[0] * e2.resolution), s2[1] = Math.round(o2[1] * e2.resolution), s2[2] = 1 / s2[0], s2[3] = 1 / s2[1], a2[0] = 0.5 * s2[2], a2[1] = 0.5 * s2[3], a2[2] = e2.sourceFrame.width * o2[2] - 0.5 * s2[2], a2[3] = e2.sourceFrame.height * o2[3] - 0.5 * s2[3], e2.legacy) {
        var l2 = n2.filterArea;
        l2[0] = e2.destinationFrame.width, l2[1] = e2.destinationFrame.height, l2[2] = e2.sourceFrame.x, l2[3] = e2.sourceFrame.y, n2.filterClamp = n2.inputClamp;
      }
      this.globalUniforms.update();
      var h2 = t3[t3.length - 1];
      if (this.renderer.framebuffer.blit(), i2.length === 1)
        i2[0].apply(this, e2.renderTexture, h2.renderTexture, r.e.BLEND, e2), this.returnFilterTexture(e2.renderTexture);
      else {
        var u2 = e2.renderTexture, c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution);
        c2.filterFrame = u2.filterFrame;
        var d2 = 0;
        for (d2 = 0; d2 < i2.length - 1; ++d2) {
          d2 === 1 && e2.multisample > 1 && ((c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution)).filterFrame = u2.filterFrame), i2[d2].apply(this, u2, c2, r.e.CLEAR, e2);
          var p2 = u2;
          u2 = c2, c2 = p2;
        }
        i2[d2].apply(this, u2, h2.renderTexture, r.e.BLEND, e2), d2 > 1 && e2.multisample > 1 && this.returnFilterTexture(e2.renderTexture), this.returnFilterTexture(u2), this.returnFilterTexture(c2);
      }
      e2.clear(), this.statePool.push(e2);
    }, t2.prototype.bindAndClear = function(t3, e2) {
      e2 === void 0 && (e2 = r.e.CLEAR);
      var i2 = this.renderer, n2 = i2.renderTexture, o2 = i2.state;
      if (t3 === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t3 && t3.filterFrame) {
        var s2 = this.tempRect;
        s2.x = 0, s2.y = 0, s2.width = t3.filterFrame.width, s2.height = t3.filterFrame.height, n2.bind(t3, t3.filterFrame, s2);
      } else
        t3 !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n2.bind(t3) : this.renderer.renderTexture.bind(t3, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var a2 = 1 & o2.stateId || this.forceClear;
      (e2 === r.e.CLEAR || e2 === r.e.BLIT && a2) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, t2.prototype.applyFilter = function(t3, e2, i2, n2) {
      var o2 = this.renderer;
      o2.state.set(t3.state), this.bindAndClear(i2, n2), t3.uniforms.uSampler = e2, t3.uniforms.filterGlobals = this.globalUniforms, o2.shader.bind(t3), t3.legacy = !!t3.program.attributeData.aTextureCoord, t3.legacy ? (this.quadUv.map(e2._frame, e2.filterFrame), o2.geometry.bind(this.quadUv), o2.geometry.draw(r.f.TRIANGLES)) : (o2.geometry.bind(this.quad), o2.geometry.draw(r.f.TRIANGLE_STRIP));
    }, t2.prototype.calculateSpriteMatrix = function(t3, e2) {
      var i2 = this.activeState, n2 = i2.sourceFrame, r2 = i2.destinationFrame, o2 = e2._texture.orig, s2 = t3.set(r2.width, 0, 0, r2.height, n2.x, n2.y), a2 = e2.worldTransform.copyTo(l.d.TEMP_MATRIX);
      return a2.invert(), s2.prepend(a2), s2.scale(1 / o2.width, 1 / o2.height), s2.translate(e2.anchor.x, e2.anchor.y), s2;
    }, t2.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(false);
    }, t2.prototype.getOptimalFilterTexture = function(t3, e2, i2, n2) {
      return i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = r.l.NONE), this.texturePool.getOptimalTexture(t3, e2, i2, n2);
    }, t2.prototype.getFilterTexture = function(t3, e2, i2) {
      if (typeof t3 == "number") {
        var n2 = t3;
        t3 = e2, e2 = n2;
      }
      t3 = t3 || this.activeState.renderTexture;
      var o2 = this.texturePool.getOptimalTexture(t3.width, t3.height, e2 || t3.resolution, i2 || r.l.NONE);
      return o2.filterFrame = t3.filterFrame, o2;
    }, t2.prototype.returnFilterTexture = function(t3) {
      this.texturePool.returnTexture(t3);
    }, t2.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    }, t2.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, t2.prototype.transformAABB = function(t3, e2) {
      var i2 = J[0], n2 = J[1], r2 = J[2], o2 = J[3];
      i2.set(e2.left, e2.top), n2.set(e2.left, e2.bottom), r2.set(e2.right, e2.top), o2.set(e2.right, e2.bottom), t3.apply(i2, i2), t3.apply(n2, n2), t3.apply(r2, r2), t3.apply(o2, o2);
      var s2 = Math.min(i2.x, n2.x, r2.x, o2.x), a2 = Math.min(i2.y, n2.y, r2.y, o2.y), l2 = Math.max(i2.x, n2.x, r2.x, o2.x), h2 = Math.max(i2.y, n2.y, r2.y, o2.y);
      e2.x = s2, e2.y = a2, e2.width = l2 - s2, e2.height = h2 - a2;
    }, t2.prototype.roundFrame = function(t3, e2, i2, n2, r2) {
      if (!(t3.width <= 0 || t3.height <= 0 || i2.width <= 0 || i2.height <= 0)) {
        if (r2) {
          var o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d;
          if ((Math.abs(s2) > 1e-4 || Math.abs(a2) > 1e-4) && (Math.abs(o2) > 1e-4 || Math.abs(l2) > 1e-4))
            return;
        }
        (r2 = r2 ? K.copyFrom(r2) : K.identity()).translate(-i2.x, -i2.y).scale(n2.width / i2.width, n2.height / i2.height).translate(n2.x, n2.y), this.transformAABB(r2, t3), t3.ceil(e2), this.transformAABB(r2.invert(), t3);
      }
    }, t2;
  }(), $ = function() {
    function t2(t3) {
      this.renderer = t3;
    }
    return t2.prototype.flush = function() {
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2.prototype.start = function() {
    }, t2.prototype.stop = function() {
      this.flush();
    }, t2.prototype.render = function(t3) {
    }, t2;
  }(), tt = function() {
    function t2(t3) {
      this.renderer = t3, this.emptyRenderer = new $(t3), this.currentRenderer = this.emptyRenderer;
    }
    return t2.prototype.setObjectRenderer = function(t3) {
      this.currentRenderer !== t3 && (this.currentRenderer.stop(), this.currentRenderer = t3, this.currentRenderer.start());
    }, t2.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, t2.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, t2.prototype.copyBoundTextures = function(t3, e2) {
      for (var i2 = this.renderer.texture.boundTextures, n2 = e2 - 1; n2 >= 0; --n2)
        t3[n2] = i2[n2] || null, t3[n2] && (t3[n2]._batchLocation = n2);
    }, t2.prototype.boundArray = function(t3, e2, i2, n2) {
      for (var r2 = t3.elements, o2 = t3.ids, s2 = t3.count, a2 = 0, l2 = 0; l2 < s2; l2++) {
        var h2 = r2[l2], u2 = h2._batchLocation;
        if (u2 >= 0 && u2 < n2 && e2[u2] === h2)
          o2[l2] = u2;
        else
          for (; a2 < n2; ) {
            var c2 = e2[a2];
            if (!c2 || c2._batchEnabled !== i2 || c2._batchLocation !== a2) {
              o2[l2] = a2, h2._batchLocation = a2, e2[a2] = h2;
              break;
            }
            a2++;
          }
      }
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), et = 0, it = function() {
    function t2(t3) {
      this.renderer = t3, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: false }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t3.view.addEventListener("webglcontextlost", this.handleContextLost, false), t3.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    return Object.defineProperty(t2.prototype, "isLost", { get: function() {
      return !this.gl || this.gl.isContextLost();
    }, enumerable: false, configurable: true }), t2.prototype.contextChange = function(t3) {
      this.gl = t3, this.renderer.gl = t3, this.renderer.CONTEXT_UID = et++, t3.isContextLost() && t3.getExtension("WEBGL_lose_context") && t3.getExtension("WEBGL_lose_context").restoreContext();
    }, t2.prototype.initFromContext = function(t3) {
      this.gl = t3, this.validateContext(t3), this.renderer.gl = t3, this.renderer.CONTEXT_UID = et++, this.renderer.runners.contextChange.emit(t3);
    }, t2.prototype.initFromOptions = function(t3) {
      var e2 = this.createContext(this.renderer.view, t3);
      this.initFromContext(e2);
    }, t2.prototype.createContext = function(t3, e2) {
      var i2;
      if (n.b.PREFER_ENV >= r.g.WEBGL2 && (i2 = t3.getContext("webgl2", e2)), i2)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, !(i2 = t3.getContext("webgl", e2) || t3.getContext("experimental-webgl", e2)))
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = i2, this.getExtensions(), this.gl;
    }, t2.prototype.getExtensions = function() {
      var t3 = this.gl, e2 = { anisotropicFiltering: t3.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t3.getExtension("OES_texture_float_linear"), s3tc: t3.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t3.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t3.getExtension("WEBGL_compressed_texture_etc"), etc1: t3.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t3.getExtension("WEBGL_compressed_texture_pvrtc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t3.getExtension("WEBGL_compressed_texture_atc"), astc: t3.getExtension("WEBGL_compressed_texture_astc") };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e2, { drawBuffers: t3.getExtension("WEBGL_draw_buffers"), depthTexture: t3.getExtension("WEBGL_depth_texture"), loseContext: t3.getExtension("WEBGL_lose_context"), vertexArrayObject: t3.getExtension("OES_vertex_array_object") || t3.getExtension("MOZ_OES_vertex_array_object") || t3.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t3.getExtension("OES_element_index_uint"), floatTexture: t3.getExtension("OES_texture_float"), floatTextureLinear: t3.getExtension("OES_texture_float_linear"), textureHalfFloat: t3.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t3.getExtension("OES_texture_half_float_linear") }) : this.webGLVersion === 2 && Object.assign(this.extensions, e2, { colorBufferFloat: t3.getExtension("EXT_color_buffer_float") });
    }, t2.prototype.handleContextLost = function(t3) {
      t3.preventDefault();
    }, t2.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, t2.prototype.destroy = function() {
      var t3 = this.renderer.view;
      this.renderer = null, t3.removeEventListener("webglcontextlost", this.handleContextLost), t3.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, t2.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, t2.prototype.validateContext = function(t3) {
      var e2 = t3.getContextAttributes(), i2 = "WebGL2RenderingContext" in globalThis && t3 instanceof globalThis.WebGL2RenderingContext;
      i2 && (this.webGLVersion = 2), e2 && !e2.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var n2 = i2 || !!t3.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = n2, n2 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, t2;
  }(), nt = function(t2) {
    this.framebuffer = t2, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = r.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }, rt = new l.j(), ot = function() {
    function t2(t3) {
      this.renderer = t3, this.managedFramebuffers = [], this.unknownFramebuffer = new C(10, 10), this.msaaSamples = null;
    }
    return t2.prototype.contextChange = function() {
      var t3 = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new l.j(), this.hasMRT = true, this.writeDepthTexture = true, this.disposeAll(true), this.renderer.context.webGLVersion === 1) {
        var e2 = this.renderer.context.extensions.drawBuffers, i2 = this.renderer.context.extensions.depthTexture;
        n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (e2 = null, i2 = null), e2 ? t3.drawBuffers = function(t4) {
          return e2.drawBuffersWEBGL(t4);
        } : (this.hasMRT = false, t3.drawBuffers = function() {
        }), i2 || (this.writeDepthTexture = false);
      } else
        this.msaaSamples = t3.getInternalformatParameter(t3.RENDERBUFFER, t3.RGBA8, t3.SAMPLES);
    }, t2.prototype.bind = function(t3, e2, i2) {
      i2 === void 0 && (i2 = 0);
      var n2 = this.gl;
      if (t3) {
        var r2 = t3.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t3);
        this.current !== t3 && (this.current = t3, n2.bindFramebuffer(n2.FRAMEBUFFER, r2.framebuffer)), r2.mipLevel !== i2 && (t3.dirtyId++, t3.dirtyFormat++, r2.mipLevel = i2), r2.dirtyId !== t3.dirtyId && (r2.dirtyId = t3.dirtyId, r2.dirtyFormat !== t3.dirtyFormat ? (r2.dirtyFormat = t3.dirtyFormat, r2.dirtySize = t3.dirtySize, this.updateFramebuffer(t3, i2)) : r2.dirtySize !== t3.dirtySize && (r2.dirtySize = t3.dirtySize, this.resizeFramebuffer(t3)));
        for (var o2 = 0; o2 < t3.colorTextures.length; o2++) {
          var s2 = t3.colorTextures[o2];
          this.renderer.texture.unbind(s2.parentTextureArray || s2);
        }
        if (t3.depthTexture && this.renderer.texture.unbind(t3.depthTexture), e2) {
          var a2 = e2.width >> i2, l2 = e2.height >> i2, h2 = a2 / e2.width;
          this.setViewport(e2.x * h2, e2.y * h2, a2, l2);
        } else {
          a2 = t3.width >> i2, l2 = t3.height >> i2;
          this.setViewport(0, 0, a2, l2);
        }
      } else
        this.current && (this.current = null, n2.bindFramebuffer(n2.FRAMEBUFFER, null)), e2 ? this.setViewport(e2.x, e2.y, e2.width, e2.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, t2.prototype.setViewport = function(t3, e2, i2, n2) {
      var r2 = this.viewport;
      t3 = Math.round(t3), e2 = Math.round(e2), i2 = Math.round(i2), n2 = Math.round(n2), r2.width === i2 && r2.height === n2 && r2.x === t3 && r2.y === e2 || (r2.x = t3, r2.y = e2, r2.width = i2, r2.height = n2, this.gl.viewport(t3, e2, i2, n2));
    }, Object.defineProperty(t2.prototype, "size", { get: function() {
      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }, enumerable: false, configurable: true }), t2.prototype.clear = function(t3, e2, i2, n2, o2) {
      o2 === void 0 && (o2 = r.c.COLOR | r.c.DEPTH);
      var s2 = this.gl;
      s2.clearColor(t3, e2, i2, n2), s2.clear(o2);
    }, t2.prototype.initFramebuffer = function(t3) {
      var e2 = this.gl, i2 = new nt(e2.createFramebuffer());
      return i2.multisample = this.detectSamples(t3.multisample), t3.glFramebuffers[this.CONTEXT_UID] = i2, this.managedFramebuffers.push(t3), t3.disposeRunner.add(this), i2;
    }, t2.prototype.resizeFramebuffer = function(t3) {
      var e2 = this.gl, i2 = t3.glFramebuffers[this.CONTEXT_UID];
      i2.msaaBuffer && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.msaaBuffer), e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.RGBA8, t3.width, t3.height)), i2.stencil && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.stencil), i2.msaaBuffer ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.DEPTH24_STENCIL8, t3.width, t3.height) : e2.renderbufferStorage(e2.RENDERBUFFER, e2.DEPTH_STENCIL, t3.width, t3.height));
      var n2 = t3.colorTextures, r2 = n2.length;
      e2.drawBuffers || (r2 = Math.min(r2, 1));
      for (var o2 = 0; o2 < r2; o2++) {
        var s2 = n2[o2], a2 = s2.parentTextureArray || s2;
        this.renderer.texture.bind(a2, 0);
      }
      t3.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t3.depthTexture, 0);
    }, t2.prototype.updateFramebuffer = function(t3, e2) {
      var i2 = this.gl, n2 = t3.glFramebuffers[this.CONTEXT_UID], r2 = t3.colorTextures, o2 = r2.length;
      i2.drawBuffers || (o2 = Math.min(o2, 1)), n2.multisample > 1 && this.canMultisampleFramebuffer(t3) ? (n2.msaaBuffer = n2.msaaBuffer || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.msaaBuffer), i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.RGBA8, t3.width, t3.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.RENDERBUFFER, n2.msaaBuffer)) : n2.msaaBuffer && (i2.deleteRenderbuffer(n2.msaaBuffer), n2.msaaBuffer = null, n2.blitFramebuffer && (n2.blitFramebuffer.dispose(), n2.blitFramebuffer = null));
      for (var s2 = [], a2 = 0; a2 < o2; a2++) {
        var l2 = r2[a2], h2 = l2.parentTextureArray || l2;
        this.renderer.texture.bind(h2, 0), a2 === 0 && n2.msaaBuffer || (i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0 + a2, l2.target, h2._glTextures[this.CONTEXT_UID].texture, e2), s2.push(i2.COLOR_ATTACHMENT0 + a2));
      }
      if ((s2.length > 1 && i2.drawBuffers(s2), t3.depthTexture) && this.writeDepthTexture) {
        var u2 = t3.depthTexture;
        this.renderer.texture.bind(u2, 0), i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.DEPTH_ATTACHMENT, i2.TEXTURE_2D, u2._glTextures[this.CONTEXT_UID].texture, e2);
      }
      !t3.stencil && !t3.depth || t3.depthTexture && this.writeDepthTexture ? n2.stencil && (i2.deleteRenderbuffer(n2.stencil), n2.stencil = null) : (n2.stencil = n2.stencil || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.stencil), n2.msaaBuffer ? i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.DEPTH24_STENCIL8, t3.width, t3.height) : i2.renderbufferStorage(i2.RENDERBUFFER, i2.DEPTH_STENCIL, t3.width, t3.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.DEPTH_STENCIL_ATTACHMENT, i2.RENDERBUFFER, n2.stencil));
    }, t2.prototype.canMultisampleFramebuffer = function(t3) {
      return this.renderer.context.webGLVersion !== 1 && t3.colorTextures.length <= 1 && !t3.depthTexture;
    }, t2.prototype.detectSamples = function(t3) {
      var e2 = this.msaaSamples, i2 = r.l.NONE;
      if (t3 <= 1 || e2 === null)
        return i2;
      for (var n2 = 0; n2 < e2.length; n2++)
        if (e2[n2] <= t3) {
          i2 = e2[n2];
          break;
        }
      return i2 === 1 && (i2 = r.l.NONE), i2;
    }, t2.prototype.blit = function(t3, e2, i2) {
      var n2 = this.current, r2 = this.renderer, o2 = this.gl, s2 = this.CONTEXT_UID;
      if (r2.context.webGLVersion === 2 && n2) {
        var a2 = n2.glFramebuffers[s2];
        if (a2) {
          if (!t3) {
            if (!a2.msaaBuffer)
              return;
            var l2 = n2.colorTextures[0];
            if (!l2)
              return;
            a2.blitFramebuffer || (a2.blitFramebuffer = new C(n2.width, n2.height), a2.blitFramebuffer.addColorTexture(0, l2)), (t3 = a2.blitFramebuffer).colorTextures[0] !== l2 && (t3.colorTextures[0] = l2, t3.dirtyId++, t3.dirtyFormat++), t3.width === n2.width && t3.height === n2.height || (t3.width = n2.width, t3.height = n2.height, t3.dirtyId++, t3.dirtySize++);
          }
          e2 || ((e2 = rt).width = n2.width, e2.height = n2.height), i2 || (i2 = e2);
          var h2 = e2.width === i2.width && e2.height === i2.height;
          this.bind(t3), o2.bindFramebuffer(o2.READ_FRAMEBUFFER, a2.framebuffer), o2.blitFramebuffer(e2.left, e2.top, e2.right, e2.bottom, i2.left, i2.top, i2.right, i2.bottom, o2.COLOR_BUFFER_BIT, h2 ? o2.NEAREST : o2.LINEAR);
        }
      }
    }, t2.prototype.disposeFramebuffer = function(t3, e2) {
      var i2 = t3.glFramebuffers[this.CONTEXT_UID], n2 = this.gl;
      if (i2) {
        delete t3.glFramebuffers[this.CONTEXT_UID];
        var r2 = this.managedFramebuffers.indexOf(t3);
        r2 >= 0 && this.managedFramebuffers.splice(r2, 1), t3.disposeRunner.remove(this), e2 || (n2.deleteFramebuffer(i2.framebuffer), i2.msaaBuffer && n2.deleteRenderbuffer(i2.msaaBuffer), i2.stencil && n2.deleteRenderbuffer(i2.stencil)), i2.blitFramebuffer && i2.blitFramebuffer.dispose();
      }
    }, t2.prototype.disposeAll = function(t3) {
      var e2 = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i2 = 0; i2 < e2.length; i2++)
        this.disposeFramebuffer(e2[i2], t3);
    }, t2.prototype.forceStencil = function() {
      var t3 = this.current;
      if (t3) {
        var e2 = t3.glFramebuffers[this.CONTEXT_UID];
        if (e2 && !e2.stencil) {
          t3.stencil = true;
          var i2 = t3.width, n2 = t3.height, r2 = this.gl, o2 = r2.createRenderbuffer();
          r2.bindRenderbuffer(r2.RENDERBUFFER, o2), e2.msaaBuffer ? r2.renderbufferStorageMultisample(r2.RENDERBUFFER, e2.multisample, r2.DEPTH24_STENCIL8, i2, n2) : r2.renderbufferStorage(r2.RENDERBUFFER, r2.DEPTH_STENCIL, i2, n2), e2.stencil = o2, r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, o2);
        }
      }
    }, t2.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new l.j();
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), st = { 5126: 4, 5123: 2, 5121: 1 }, at = function() {
    function t2(t3) {
      this.renderer = t3, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
    }
    return t2.prototype.contextChange = function() {
      this.disposeAll(true);
      var t3 = this.gl = this.renderer.gl, e2 = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e2.webGLVersion !== 2) {
        var i2 = this.renderer.context.extensions.vertexArrayObject;
        n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (i2 = null), i2 ? (t3.createVertexArray = function() {
          return i2.createVertexArrayOES();
        }, t3.bindVertexArray = function(t4) {
          return i2.bindVertexArrayOES(t4);
        }, t3.deleteVertexArray = function(t4) {
          return i2.deleteVertexArrayOES(t4);
        }) : (this.hasVao = false, t3.createVertexArray = function() {
          return null;
        }, t3.bindVertexArray = function() {
          return null;
        }, t3.deleteVertexArray = function() {
          return null;
        });
      }
      if (e2.webGLVersion !== 2) {
        var o2 = t3.getExtension("ANGLE_instanced_arrays");
        o2 ? (t3.vertexAttribDivisor = function(t4, e3) {
          return o2.vertexAttribDivisorANGLE(t4, e3);
        }, t3.drawElementsInstanced = function(t4, e3, i3, n2, r2) {
          return o2.drawElementsInstancedANGLE(t4, e3, i3, n2, r2);
        }, t3.drawArraysInstanced = function(t4, e3, i3, n2) {
          return o2.drawArraysInstancedANGLE(t4, e3, i3, n2);
        }) : this.hasInstance = false;
      }
      this.canUseUInt32ElementIndex = e2.webGLVersion === 2 || !!e2.extensions.uint32ElementIndex;
    }, t2.prototype.bind = function(t3, e2) {
      e2 = e2 || this.renderer.shader.shader;
      var i2 = this.gl, n2 = t3.glVertexArrayObjects[this.CONTEXT_UID], r2 = false;
      n2 || (this.managedGeometries[t3.id] = t3, t3.disposeRunner.add(this), t3.glVertexArrayObjects[this.CONTEXT_UID] = n2 = {}, r2 = true);
      var o2 = n2[e2.program.id] || this.initGeometryVao(t3, e2, r2);
      this._activeGeometry = t3, this._activeVao !== o2 && (this._activeVao = o2, this.hasVao ? i2.bindVertexArray(o2) : this.activateVao(t3, e2.program)), this.updateBuffers();
    }, t2.prototype.reset = function() {
      this.unbind();
    }, t2.prototype.updateBuffers = function() {
      for (var t3 = this._activeGeometry, e2 = this.renderer.buffer, i2 = 0; i2 < t3.buffers.length; i2++) {
        var n2 = t3.buffers[i2];
        e2.update(n2);
      }
    }, t2.prototype.checkCompatibility = function(t3, e2) {
      var i2 = t3.attributes, n2 = e2.attributeData;
      for (var r2 in n2)
        if (!i2[r2])
          throw new Error('shader and geometry incompatible, geometry missing the "' + r2 + '" attribute');
    }, t2.prototype.getSignature = function(t3, e2) {
      var i2 = t3.attributes, n2 = e2.attributeData, r2 = ["g", t3.id];
      for (var o2 in i2)
        n2[o2] && r2.push(o2, n2[o2].location);
      return r2.join("-");
    }, t2.prototype.initGeometryVao = function(t3, e2, i2) {
      i2 === void 0 && (i2 = true);
      var n2 = this.gl, r2 = this.CONTEXT_UID, o2 = this.renderer.buffer, s2 = e2.program;
      s2.glPrograms[r2] || this.renderer.shader.generateProgram(e2), this.checkCompatibility(t3, s2);
      var a2 = this.getSignature(t3, s2), l2 = t3.glVertexArrayObjects[this.CONTEXT_UID], h2 = l2[a2];
      if (h2)
        return l2[s2.id] = h2, h2;
      var u2 = t3.buffers, c2 = t3.attributes, d2 = {}, p2 = {};
      for (var f2 in u2)
        d2[f2] = 0, p2[f2] = 0;
      for (var f2 in c2)
        !c2[f2].size && s2.attributeData[f2] ? c2[f2].size = s2.attributeData[f2].size : c2[f2].size || console.warn("PIXI Geometry attribute '" + f2 + "' size cannot be determined (likely the bound shader does not have the attribute)"), d2[c2[f2].buffer] += c2[f2].size * st[c2[f2].type];
      for (var f2 in c2) {
        var m2 = c2[f2], g2 = m2.size;
        m2.stride === void 0 && (d2[m2.buffer] === g2 * st[m2.type] ? m2.stride = 0 : m2.stride = d2[m2.buffer]), m2.start === void 0 && (m2.start = p2[m2.buffer], p2[m2.buffer] += g2 * st[m2.type]);
      }
      h2 = n2.createVertexArray(), n2.bindVertexArray(h2);
      for (var v2 = 0; v2 < u2.length; v2++) {
        var _2 = u2[v2];
        o2.bind(_2), i2 && _2._glBuffers[r2].refCount++;
      }
      return this.activateVao(t3, s2), this._activeVao = h2, l2[s2.id] = h2, l2[a2] = h2, h2;
    }, t2.prototype.disposeGeometry = function(t3, e2) {
      var i2;
      if (this.managedGeometries[t3.id]) {
        delete this.managedGeometries[t3.id];
        var n2 = t3.glVertexArrayObjects[this.CONTEXT_UID], r2 = this.gl, o2 = t3.buffers, s2 = (i2 = this.renderer) === null || i2 === void 0 ? void 0 : i2.buffer;
        if (t3.disposeRunner.remove(this), n2) {
          if (s2)
            for (var a2 = 0; a2 < o2.length; a2++) {
              var l2 = o2[a2]._glBuffers[this.CONTEXT_UID];
              l2 && (l2.refCount--, l2.refCount !== 0 || e2 || s2.dispose(o2[a2], e2));
            }
          if (!e2) {
            for (var h2 in n2)
              if (h2[0] === "g") {
                var u2 = n2[h2];
                this._activeVao === u2 && this.unbind(), r2.deleteVertexArray(u2);
              }
          }
          delete t3.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, t2.prototype.disposeAll = function(t3) {
      for (var e2 = Object.keys(this.managedGeometries), i2 = 0; i2 < e2.length; i2++)
        this.disposeGeometry(this.managedGeometries[e2[i2]], t3);
    }, t2.prototype.activateVao = function(t3, e2) {
      var i2 = this.gl, n2 = this.CONTEXT_UID, r2 = this.renderer.buffer, o2 = t3.buffers, s2 = t3.attributes;
      t3.indexBuffer && r2.bind(t3.indexBuffer);
      var a2 = null;
      for (var l2 in s2) {
        var h2 = s2[l2], u2 = o2[h2.buffer], c2 = u2._glBuffers[n2];
        if (e2.attributeData[l2]) {
          a2 !== c2 && (r2.bind(u2), a2 = c2);
          var d2 = e2.attributeData[l2].location;
          if (i2.enableVertexAttribArray(d2), i2.vertexAttribPointer(d2, h2.size, h2.type || i2.FLOAT, h2.normalized, h2.stride, h2.start), h2.instance) {
            if (!this.hasInstance)
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            i2.vertexAttribDivisor(d2, 1);
          }
        }
      }
    }, t2.prototype.draw = function(t3, e2, i2, n2) {
      var r2 = this.gl, o2 = this._activeGeometry;
      if (o2.indexBuffer) {
        var s2 = o2.indexBuffer.data.BYTES_PER_ELEMENT, a2 = s2 === 2 ? r2.UNSIGNED_SHORT : r2.UNSIGNED_INT;
        s2 === 2 || s2 === 4 && this.canUseUInt32ElementIndex ? o2.instanced ? r2.drawElementsInstanced(t3, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2, n2 || 1) : r2.drawElements(t3, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2) : console.warn("unsupported index buffer type: uint32");
      } else
        o2.instanced ? r2.drawArraysInstanced(t3, i2, e2 || o2.getSize(), n2 || 1) : r2.drawArrays(t3, i2, e2 || o2.getSize());
      return this;
    }, t2.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), lt = function() {
    function t2(t3) {
      t3 === void 0 && (t3 = null), this.type = r.j.NONE, this.autoDetect = true, this.maskObject = t3 || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = n.b.FILTER_MULTISAMPLE, this.enabled = true, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null;
    }
    return Object.defineProperty(t2.prototype, "filter", { get: function() {
      return this._filters ? this._filters[0] : null;
    }, set: function(t3) {
      t3 ? this._filters ? this._filters[0] = t3 : this._filters = [t3] : this._filters = null;
    }, enumerable: false, configurable: true }), t2.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = r.j.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
    }, t2.prototype.copyCountersOrReset = function(t3) {
      t3 ? (this._stencilCounter = t3._stencilCounter, this._scissorCounter = t3._scissorCounter, this._scissorRect = t3._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, t2;
  }();
  function ht(t2, e2, i2) {
    var n2 = t2.createShader(e2);
    return t2.shaderSource(n2, i2), t2.compileShader(n2), n2;
  }
  function ut(t2, e2) {
    var i2 = t2.getShaderSource(e2).split("\n").map(function(t3, e3) {
      return e3 + ": " + t3;
    }), n2 = t2.getShaderInfoLog(e2), r2 = n2.split("\n"), o2 = {}, s2 = r2.map(function(t3) {
      return parseFloat(t3.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
    }).filter(function(t3) {
      return !(!t3 || o2[t3]) && (o2[t3] = true, true);
    }), a2 = [""];
    s2.forEach(function(t3) {
      i2[t3 - 1] = "%c" + i2[t3 - 1] + "%c", a2.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    var l2 = i2.join("\n");
    a2[0] = l2, console.error(n2), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a2), console.groupEnd();
  }
  function ct(t2) {
    for (var e2 = new Array(t2), i2 = 0; i2 < e2.length; i2++)
      e2[i2] = false;
    return e2;
  }
  function dt(t2, e2) {
    switch (t2) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * e2);
      case "vec3":
        return new Float32Array(3 * e2);
      case "vec4":
        return new Float32Array(4 * e2);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * e2);
      case "ivec3":
        return new Int32Array(3 * e2);
      case "ivec4":
        return new Int32Array(4 * e2);
      case "uvec2":
        return new Uint32Array(2 * e2);
      case "uvec3":
        return new Uint32Array(3 * e2);
      case "uvec4":
        return new Uint32Array(4 * e2);
      case "bool":
        return false;
      case "bvec2":
        return ct(2 * e2);
      case "bvec3":
        return ct(3 * e2);
      case "bvec4":
        return ct(4 * e2);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    return null;
  }
  var pt, ft = {}, mt = ft;
  function gt() {
    if (!pt) {
      pt = r.m.MEDIUM;
      var t2 = function() {
        if (mt === ft || mt && mt.isContextLost()) {
          var t3 = document.createElement("canvas"), e3 = void 0;
          n.b.PREFER_ENV >= r.g.WEBGL2 && (e3 = t3.getContext("webgl2", {})), e3 || ((e3 = t3.getContext("webgl", {}) || t3.getContext("experimental-webgl", {})) ? e3.getExtension("WEBGL_draw_buffers") : e3 = null), mt = e3;
        }
        return mt;
      }();
      if (t2 && t2.getShaderPrecisionFormat) {
        var e2 = t2.getShaderPrecisionFormat(t2.FRAGMENT_SHADER, t2.HIGH_FLOAT);
        pt = e2.precision ? r.m.HIGH : r.m.MEDIUM;
      }
    }
    return pt;
  }
  function vt(t2, e2, i2) {
    if (t2.substring(0, 9) !== "precision") {
      var n2 = e2;
      return e2 === r.m.HIGH && i2 !== r.m.HIGH && (n2 = r.m.MEDIUM), "precision " + n2 + " float;\n" + t2;
    }
    return i2 !== r.m.HIGH && t2.substring(0, 15) === "precision highp" ? t2.replace("precision highp", "precision mediump") : t2;
  }
  var _t = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
  function yt(t2) {
    return _t[t2];
  }
  var xt = null, bt = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" };
  function Tt(t2, e2) {
    if (!xt) {
      var i2 = Object.keys(bt);
      xt = {};
      for (var n2 = 0; n2 < i2.length; ++n2) {
        var r2 = i2[n2];
        xt[t2[r2]] = bt[r2];
      }
    }
    return xt[e2];
  }
  var Et = [{ test: function(t2) {
    return t2.type === "float" && t2.size === 1;
  }, code: function(t2) {
    return '\n            if(uv["' + t2 + '"] !== ud["' + t2 + '"].value)\n            {\n                ud["' + t2 + '"].value = uv["' + t2 + '"]\n                gl.uniform1f(ud["' + t2 + '"].location, uv["' + t2 + '"])\n            }\n            ';
  } }, { test: function(t2) {
    return (t2.type === "sampler2D" || t2.type === "samplerCube" || t2.type === "sampler2DArray") && t2.size === 1 && !t2.isArray;
  }, code: function(t2) {
    return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t2 + '"], t);\n\n            if(ud["' + t2 + '"].value !== t)\n            {\n                ud["' + t2 + '"].value = t;\n                gl.uniform1i(ud["' + t2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
  } }, { test: function(t2, e2) {
    return t2.type === "mat3" && t2.size === 1 && e2.a !== void 0;
  }, code: function(t2) {
    return '\n            gl.uniformMatrix3fv(ud["' + t2 + '"].location, false, uv["' + t2 + '"].toArray(true));\n            ';
  }, codeUbo: function(t2) {
    return "\n                var " + t2 + "_matrix = uv." + t2 + ".toArray(true);\n\n                data[offset] = " + t2 + "_matrix[0];\n                data[offset+1] = " + t2 + "_matrix[1];\n                data[offset+2] = " + t2 + "_matrix[2];\n        \n                data[offset + 4] = " + t2 + "_matrix[3];\n                data[offset + 5] = " + t2 + "_matrix[4];\n                data[offset + 6] = " + t2 + "_matrix[5];\n        \n                data[offset + 8] = " + t2 + "_matrix[6];\n                data[offset + 9] = " + t2 + "_matrix[7];\n                data[offset + 10] = " + t2 + "_matrix[8];\n            ";
  } }, { test: function(t2, e2) {
    return t2.type === "vec2" && t2.size === 1 && e2.x !== void 0;
  }, code: function(t2) {
    return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t2 + '"].location, v.x, v.y);\n                }';
  }, codeUbo: function(t2) {
    return "\n                v = uv." + t2 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
  } }, { test: function(t2) {
    return t2.type === "vec2" && t2.size === 1;
  }, code: function(t2) {
    return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t2 + '"].location, v[0], v[1]);\n                }\n            ';
  } }, { test: function(t2, e2) {
    return t2.type === "vec4" && t2.size === 1 && e2.width !== void 0;
  }, code: function(t2) {
    return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
  }, codeUbo: function(t2) {
    return "\n                    v = uv." + t2 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
  } }, { test: function(t2) {
    return t2.type === "vec4" && t2.size === 1;
  }, code: function(t2) {
    return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
  } }], St = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, wt = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" };
  var At, Mt = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
  function Rt(t2) {
    for (var e2 = "", i2 = 0; i2 < t2; ++i2)
      i2 > 0 && (e2 += "\nelse "), i2 < t2 - 1 && (e2 += "if(test == " + i2 + ".0){}");
    return e2;
  }
  var Ct = 0, It = {}, Pt = function() {
    function t2(e2, i2, o2) {
      o2 === void 0 && (o2 = "pixi-shader"), this.id = Ct++, this.vertexSrc = e2 || t2.defaultVertexSrc, this.fragmentSrc = i2 || t2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (o2 = o2.replace(/\s+/g, "-"), It[o2] ? (It[o2]++, o2 += "-" + It[o2]) : It[o2] = 1, this.vertexSrc = "#define SHADER_NAME " + o2 + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o2 + "\n" + this.fragmentSrc, this.vertexSrc = vt(this.vertexSrc, n.b.PRECISION_VERTEX, r.m.HIGH), this.fragmentSrc = vt(this.fragmentSrc, n.b.PRECISION_FRAGMENT, gt())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(t2, "defaultVertexSrc", { get: function() {
      return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "defaultFragmentSrc", { get: function() {
      return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
    }, enumerable: false, configurable: true }), t2.from = function(e2, i2, n2) {
      var r2 = e2 + i2, s2 = o.ProgramCache[r2];
      return s2 || (o.ProgramCache[r2] = s2 = new t2(e2, i2, n2)), s2;
    }, t2;
  }(), Ot = function() {
    function t2(t3, e2) {
      this.uniformBindCount = 0, this.program = t3, this.uniformGroup = e2 ? e2 instanceof q ? e2 : new q(e2) : new q({});
    }
    return t2.prototype.checkUniformExists = function(t3, e2) {
      if (e2.uniforms[t3])
        return true;
      for (var i2 in e2.uniforms) {
        var n2 = e2.uniforms[i2];
        if (n2.group && this.checkUniformExists(t3, n2))
          return true;
      }
      return false;
    }, t2.prototype.destroy = function() {
      this.uniformGroup = null;
    }, Object.defineProperty(t2.prototype, "uniforms", { get: function() {
      return this.uniformGroup.uniforms;
    }, enumerable: false, configurable: true }), t2.from = function(e2, i2, n2) {
      return new t2(Pt.from(e2, i2), n2);
    }, t2;
  }(), Nt = function() {
    function t2() {
      this.data = 0, this.blendMode = r.b.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
    }
    return Object.defineProperty(t2.prototype, "blend", { get: function() {
      return !!(1 & this.data);
    }, set: function(t3) {
      !!(1 & this.data) !== t3 && (this.data ^= 1);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "offsets", { get: function() {
      return !!(2 & this.data);
    }, set: function(t3) {
      !!(2 & this.data) !== t3 && (this.data ^= 2);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "culling", { get: function() {
      return !!(4 & this.data);
    }, set: function(t3) {
      !!(4 & this.data) !== t3 && (this.data ^= 4);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "depthTest", { get: function() {
      return !!(8 & this.data);
    }, set: function(t3) {
      !!(8 & this.data) !== t3 && (this.data ^= 8);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "depthMask", { get: function() {
      return !!(32 & this.data);
    }, set: function(t3) {
      !!(32 & this.data) !== t3 && (this.data ^= 32);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "clockwiseFrontFace", { get: function() {
      return !!(16 & this.data);
    }, set: function(t3) {
      !!(16 & this.data) !== t3 && (this.data ^= 16);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "blendMode", { get: function() {
      return this._blendMode;
    }, set: function(t3) {
      this.blend = t3 !== r.b.NONE, this._blendMode = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "polygonOffset", { get: function() {
      return this._polygonOffset;
    }, set: function(t3) {
      this.offsets = !!t3, this._polygonOffset = t3;
    }, enumerable: false, configurable: true }), t2.prototype.toString = function() {
      return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]";
    }, t2.for2d = function() {
      var e2 = new t2();
      return e2.depthTest = false, e2.blend = true, e2;
    }, t2;
  }(), Lt = function(t2) {
    function e2(i2, r2, o2) {
      var s2 = this, a2 = Pt.from(i2 || e2.defaultVertexSrc, r2 || e2.defaultFragmentSrc);
      return (s2 = t2.call(this, a2, o2) || this).padding = 0, s2.resolution = n.b.FILTER_RESOLUTION, s2.multisample = n.b.FILTER_MULTISAMPLE, s2.enabled = true, s2.autoFit = true, s2.state = new Nt(), s2;
    }
    return d(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2, r2) {
      t3.applyFilter(this, e3, i2, n2);
    }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t3) {
      this.state.blendMode = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
      return this._resolution;
    }, set: function(t3) {
      this._resolution = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultVertexSrc", { get: function() {
      return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultFragmentSrc", { get: function() {
      return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
    }, enumerable: false, configurable: true }), e2;
  }(Ot), Dt = new l.d(), Ft = function() {
    function t2(t3, e2) {
      this._texture = t3, this.mapCoord = new l.d(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = e2 === void 0 ? 0.5 : e2, this.isSimple = false;
    }
    return Object.defineProperty(t2.prototype, "texture", { get: function() {
      return this._texture;
    }, set: function(t3) {
      this._texture = t3, this._textureID = -1;
    }, enumerable: false, configurable: true }), t2.prototype.multiplyUvs = function(t3, e2) {
      e2 === void 0 && (e2 = t3);
      for (var i2 = this.mapCoord, n2 = 0; n2 < t3.length; n2 += 2) {
        var r2 = t3[n2], o2 = t3[n2 + 1];
        e2[n2] = r2 * i2.a + o2 * i2.c + i2.tx, e2[n2 + 1] = r2 * i2.b + o2 * i2.d + i2.ty;
      }
      return e2;
    }, t2.prototype.update = function(t3) {
      var e2 = this._texture;
      if (!e2 || !e2.valid)
        return false;
      if (!t3 && this._textureID === e2._updateID)
        return false;
      this._textureID = e2._updateID, this._updateID++;
      var i2 = e2._uvs;
      this.mapCoord.set(i2.x1 - i2.x0, i2.y1 - i2.y0, i2.x3 - i2.x0, i2.y3 - i2.y0, i2.x0, i2.y0);
      var n2 = e2.orig, r2 = e2.trim;
      r2 && (Dt.set(n2.width / r2.width, 0, 0, n2.height / r2.height, -r2.x / r2.width, -r2.y / r2.height), this.mapCoord.append(Dt));
      var o2 = e2.baseTexture, s2 = this.uClampFrame, a2 = this.clampMargin / o2.resolution, l2 = this.clampOffset;
      return s2[0] = (e2._frame.x + a2 + l2) / o2.width, s2[1] = (e2._frame.y + a2 + l2) / o2.height, s2[2] = (e2._frame.x + e2._frame.width - a2 + l2) / o2.width, s2[3] = (e2._frame.y + e2._frame.height - a2 + l2) / o2.height, this.uClampOffset[0] = l2 / o2.realWidth, this.uClampOffset[1] = l2 / o2.realHeight, this.isSimple = e2._frame.width === o2.width && e2._frame.height === o2.height && e2.rotate === 0, true;
    }, t2;
  }(), Bt = function(t2) {
    function e2(e3, i2, n2) {
      var r2 = this, o2 = null;
      return typeof e3 != "string" && i2 === void 0 && n2 === void 0 && (o2 = e3, e3 = void 0, i2 = void 0, n2 = void 0), (r2 = t2.call(this, e3 || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", i2 || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", n2) || this).maskSprite = o2, r2.maskMatrix = new l.d(), r2;
    }
    return d(e2, t2), Object.defineProperty(e2.prototype, "maskSprite", { get: function() {
      return this._maskSprite;
    }, set: function(t3) {
      this._maskSprite = t3, this._maskSprite && (this._maskSprite.renderable = false);
    }, enumerable: false, configurable: true }), e2.prototype.apply = function(t3, e3, i2, n2) {
      var r2 = this._maskSprite, o2 = r2._texture;
      o2.valid && (o2.uvMatrix || (o2.uvMatrix = new Ft(o2, 0)), o2.uvMatrix.update(), this.uniforms.npmAlpha = o2.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o2, this.uniforms.otherMatrix = t3.calculateSpriteMatrix(this.maskMatrix, r2).prepend(o2.uvMatrix.mapCoord), this.uniforms.alpha = r2.worldAlpha, this.uniforms.maskClamp = o2.uvMatrix.uClampFrame, t3.applyFilter(this, e3, i2, n2));
    }, e2;
  }(Lt), Ut = function() {
    function t2(t3) {
      this.renderer = t3, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return t2.prototype.setMaskStack = function(t3) {
      this.maskStack = t3, this.renderer.scissor.setMaskStack(t3), this.renderer.stencil.setMaskStack(t3);
    }, t2.prototype.push = function(t3, e2) {
      var i2 = e2;
      if (!i2.isMaskData) {
        var n2 = this.maskDataPool.pop() || new lt();
        n2.pooled = true, n2.maskObject = e2, i2 = n2;
      }
      var o2 = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (i2.copyCountersOrReset(o2), i2.autoDetect && this.detect(i2), i2._target = t3, i2.type !== r.j.SPRITE && this.maskStack.push(i2), i2.enabled)
        switch (i2.type) {
          case r.j.SCISSOR:
            this.renderer.scissor.push(i2);
            break;
          case r.j.STENCIL:
            this.renderer.stencil.push(i2);
            break;
          case r.j.SPRITE:
            i2.copyCountersOrReset(null), this.pushSpriteMask(i2);
        }
      i2.type === r.j.SPRITE && this.maskStack.push(i2);
    }, t2.prototype.pop = function(t3) {
      var e2 = this.maskStack.pop();
      if (e2 && e2._target === t3) {
        if (e2.enabled)
          switch (e2.type) {
            case r.j.SCISSOR:
              this.renderer.scissor.pop();
              break;
            case r.j.STENCIL:
              this.renderer.stencil.pop(e2.maskObject);
              break;
            case r.j.SPRITE:
              this.popSpriteMask(e2);
          }
        if (e2.reset(), e2.pooled && this.maskDataPool.push(e2), this.maskStack.length !== 0) {
          var i2 = this.maskStack[this.maskStack.length - 1];
          i2.type === r.j.SPRITE && i2._filters && (i2._filters[0].maskSprite = i2.maskObject);
        }
      }
    }, t2.prototype.detect = function(t3) {
      t3.maskObject.isSprite ? t3.type = r.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t3) ? t3.type = r.j.SCISSOR : t3.type = r.j.STENCIL;
    }, t2.prototype.pushSpriteMask = function(t3) {
      var e2, i2, n2 = t3.maskObject, r2 = t3._target, o2 = t3._filters;
      o2 || (o2 = this.alphaMaskPool[this.alphaMaskIndex]) || (o2 = this.alphaMaskPool[this.alphaMaskIndex] = [new Bt()]);
      var s2, a2, l2 = this.renderer, h2 = l2.renderTexture;
      if (h2.current) {
        var u2 = h2.current;
        s2 = t3.resolution || u2.resolution, a2 = (e2 = t3.multisample) !== null && e2 !== void 0 ? e2 : u2.multisample;
      } else
        s2 = t3.resolution || l2.resolution, a2 = (i2 = t3.multisample) !== null && i2 !== void 0 ? i2 : l2.multisample;
      o2[0].resolution = s2, o2[0].multisample = a2, o2[0].maskSprite = n2;
      var c2 = r2.filterArea;
      r2.filterArea = n2.getBounds(true), l2.filter.push(r2, o2), r2.filterArea = c2, t3._filters || this.alphaMaskIndex++;
    }, t2.prototype.popSpriteMask = function(t3) {
      this.renderer.filter.pop(), t3._filters ? t3._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), kt = function() {
    function t2(t3) {
      this.renderer = t3, this.maskStack = [], this.glConst = 0;
    }
    return t2.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, t2.prototype.setMaskStack = function(t3) {
      var e2 = this.renderer.gl, i2 = this.getStackLength();
      this.maskStack = t3;
      var n2 = this.getStackLength();
      n2 !== i2 && (n2 === 0 ? e2.disable(this.glConst) : (e2.enable(this.glConst), this._useCurrent()));
    }, t2.prototype._useCurrent = function() {
    }, t2.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, t2;
  }(), Gt = new l.d(), Ht = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.glConst = WebGLRenderingContext.SCISSOR_TEST, i2;
    }
    return d(e2, t2), e2.prototype.getStackLength = function() {
      var t3 = this.maskStack[this.maskStack.length - 1];
      return t3 ? t3._scissorCounter : 0;
    }, e2.prototype.calcScissorRect = function(t3) {
      if (!t3._scissorRectLocal) {
        var e3 = t3._scissorRect, i2 = t3.maskObject, n2 = this.renderer, r2 = n2.renderTexture;
        i2.renderable = true;
        var o2 = i2.getBounds();
        this.roundFrameToPixels(o2, r2.current ? r2.current.resolution : n2.resolution, r2.sourceFrame, r2.destinationFrame, n2.projection.transform), i2.renderable = false, e3 && o2.fit(e3), t3._scissorRectLocal = o2;
      }
    }, e2.isMatrixRotated = function(t3) {
      if (!t3)
        return false;
      var e3 = t3.a, i2 = t3.b, n2 = t3.c, r2 = t3.d;
      return (Math.abs(i2) > 1e-4 || Math.abs(n2) > 1e-4) && (Math.abs(e3) > 1e-4 || Math.abs(r2) > 1e-4);
    }, e2.prototype.testScissor = function(t3) {
      var i2 = t3.maskObject;
      if (!i2.isFastRect || !i2.isFastRect())
        return false;
      if (e2.isMatrixRotated(i2.worldTransform))
        return false;
      if (e2.isMatrixRotated(this.renderer.projection.transform))
        return false;
      this.calcScissorRect(t3);
      var n2 = t3._scissorRectLocal;
      return n2.width > 0 && n2.height > 0;
    }, e2.prototype.roundFrameToPixels = function(t3, i2, n2, r2, o2) {
      e2.isMatrixRotated(o2) || ((o2 = o2 ? Gt.copyFrom(o2) : Gt.identity()).translate(-n2.x, -n2.y).scale(r2.width / n2.width, r2.height / n2.height).translate(r2.x, r2.y), this.renderer.filter.transformAABB(o2, t3), t3.fit(r2), t3.x = Math.round(t3.x * i2), t3.y = Math.round(t3.y * i2), t3.width = Math.round(t3.width * i2), t3.height = Math.round(t3.height * i2));
    }, e2.prototype.push = function(t3) {
      t3._scissorRectLocal || this.calcScissorRect(t3);
      var e3 = this.renderer.gl;
      t3._scissorRect || e3.enable(e3.SCISSOR_TEST), t3._scissorCounter++, t3._scissorRect = t3._scissorRectLocal, this._useCurrent();
    }, e2.prototype.pop = function() {
      var t3 = this.renderer.gl;
      this.getStackLength() > 0 ? this._useCurrent() : t3.disable(t3.SCISSOR_TEST);
    }, e2.prototype._useCurrent = function() {
      var t3, e3 = this.maskStack[this.maskStack.length - 1]._scissorRect;
      t3 = this.renderer.renderTexture.current ? e3.y : this.renderer.height - e3.height - e3.y, this.renderer.gl.scissor(e3.x, t3, e3.width, e3.height);
    }, e2;
  }(kt), jt = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.glConst = WebGLRenderingContext.STENCIL_TEST, i2;
    }
    return d(e2, t2), e2.prototype.getStackLength = function() {
      var t3 = this.maskStack[this.maskStack.length - 1];
      return t3 ? t3._stencilCounter : 0;
    }, e2.prototype.push = function(t3) {
      var e3 = t3.maskObject, i2 = this.renderer.gl, n2 = t3._stencilCounter;
      n2 === 0 && (this.renderer.framebuffer.forceStencil(), i2.clearStencil(0), i2.clear(i2.STENCIL_BUFFER_BIT), i2.enable(i2.STENCIL_TEST)), t3._stencilCounter++, i2.colorMask(false, false, false, false), i2.stencilFunc(i2.EQUAL, n2, 4294967295), i2.stencilOp(i2.KEEP, i2.KEEP, i2.INCR), e3.renderable = true, e3.render(this.renderer), this.renderer.batch.flush(), e3.renderable = false, this._useCurrent();
    }, e2.prototype.pop = function(t3) {
      var e3 = this.renderer.gl;
      this.getStackLength() === 0 ? e3.disable(e3.STENCIL_TEST) : (e3.colorMask(false, false, false, false), e3.stencilOp(e3.KEEP, e3.KEEP, e3.DECR), t3.renderable = true, t3.render(this.renderer), this.renderer.batch.flush(), t3.renderable = false, this._useCurrent());
    }, e2.prototype._useCurrent = function() {
      var t3 = this.renderer.gl;
      t3.colorMask(true, true, true, true), t3.stencilFunc(t3.EQUAL, this.getStackLength(), 4294967295), t3.stencilOp(t3.KEEP, t3.KEEP, t3.KEEP);
    }, e2;
  }(kt), zt = function() {
    function t2(t3) {
      this.renderer = t3, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new l.d(), this.transform = null;
    }
    return t2.prototype.update = function(t3, e2, i2, n2) {
      this.destinationFrame = t3 || this.destinationFrame || this.defaultFrame, this.sourceFrame = e2 || this.sourceFrame || t3, this.calculateProjection(this.destinationFrame, this.sourceFrame, i2, n2), this.transform && this.projectionMatrix.append(this.transform);
      var r2 = this.renderer;
      r2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r2.globalUniforms.update(), r2.shader.shader && r2.shader.syncUniformGroup(r2.shader.shader.uniforms.globals);
    }, t2.prototype.calculateProjection = function(t3, e2, i2, n2) {
      var r2 = this.projectionMatrix, o2 = n2 ? -1 : 1;
      r2.identity(), r2.a = 1 / e2.width * 2, r2.d = o2 * (1 / e2.height * 2), r2.tx = -1 - e2.x * r2.a, r2.ty = -o2 - e2.y * r2.d;
    }, t2.prototype.setTransform = function(t3) {
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), Vt = new l.j(), Xt = new l.j(), Wt = function() {
    function t2(t3) {
      this.renderer = t3, this.clearColor = t3._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new l.j(), this.destinationFrame = new l.j(), this.viewportFrame = new l.j();
    }
    return t2.prototype.bind = function(t3, e2, i2) {
      t3 === void 0 && (t3 = null);
      var n2, r2, o2, s2 = this.renderer;
      this.current = t3, t3 ? (o2 = (n2 = t3.baseTexture).resolution, e2 || (Vt.width = t3.frame.width, Vt.height = t3.frame.height, e2 = Vt), i2 || (Xt.x = t3.frame.x, Xt.y = t3.frame.y, Xt.width = e2.width, Xt.height = e2.height, i2 = Xt), r2 = n2.framebuffer) : (o2 = s2.resolution, e2 || (Vt.width = s2.screen.width, Vt.height = s2.screen.height, e2 = Vt), i2 || ((i2 = Vt).width = e2.width, i2.height = e2.height));
      var a2 = this.viewportFrame;
      a2.x = i2.x * o2, a2.y = i2.y * o2, a2.width = i2.width * o2, a2.height = i2.height * o2, t3 || (a2.y = s2.view.height - (a2.y + a2.height)), a2.ceil(), this.renderer.framebuffer.bind(r2, a2), this.renderer.projection.update(i2, e2, o2, !r2), t3 ? this.renderer.mask.setMaskStack(n2.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e2), this.destinationFrame.copyFrom(i2);
    }, t2.prototype.clear = function(t3, e2) {
      t3 = this.current ? t3 || this.current.baseTexture.clearColor : t3 || this.clearColor;
      var i2 = this.destinationFrame, n2 = this.current ? this.current.baseTexture : this.renderer.screen, r2 = i2.width !== n2.width || i2.height !== n2.height;
      if (r2) {
        var o2 = this.viewportFrame, s2 = o2.x, a2 = o2.y, l2 = o2.width, h2 = o2.height;
        s2 = Math.round(s2), a2 = Math.round(a2), l2 = Math.round(l2), h2 = Math.round(h2), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s2, a2, l2, h2);
      }
      this.renderer.framebuffer.clear(t3[0], t3[1], t3[2], t3[3], e2), r2 && this.renderer.scissor.pop();
    }, t2.prototype.resize = function() {
      this.bind(null);
    }, t2.prototype.reset = function() {
      this.bind(null);
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }();
  function Yt(t2, e2, i2, n2, r2) {
    i2.buffer.update(r2);
  }
  var qt = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, Zt = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
  function Jt(t2, e2) {
    if (!t2.autoManage)
      return { size: 0, syncFunc: Yt };
    for (var i2 = function(t3) {
      for (var e3 = t3.map(function(t4) {
        return { data: t4, offset: 0, dataLen: 0, dirty: 0 };
      }), i3 = 0, n3 = 0, r3 = 0, o3 = 0; o3 < e3.length; o3++) {
        var s3 = e3[o3];
        if (i3 = Zt[s3.data.type], s3.data.size > 1 && (i3 = Math.max(i3, 16) * s3.data.size), s3.dataLen = i3, n3 % i3 != 0 && n3 < 16) {
          var a3 = n3 % i3 % 16;
          n3 += a3, r3 += a3;
        }
        n3 + i3 > 16 ? (r3 = 16 * Math.ceil(r3 / 16), s3.offset = r3, r3 += i3, n3 = i3) : (s3.offset = r3, n3 += i3, r3 += i3);
      }
      return { uboElements: e3, size: r3 = 16 * Math.ceil(r3 / 16) };
    }(function(t3, e3) {
      var i3 = [];
      for (var n3 in t3)
        e3[n3] && i3.push(e3[n3]);
      return i3.sort(function(t4, e4) {
        return t4.index - e4.index;
      }), i3;
    }(t2.uniforms, e2)), n2 = i2.uboElements, r2 = i2.size, o2 = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s2 = 0; s2 < n2.length; s2++) {
      for (var a2 = n2[s2], l2 = t2.uniforms[a2.data.name], h2 = a2.data.name, u2 = false, c2 = 0; c2 < Et.length; c2++) {
        var d2 = Et[c2];
        if (d2.codeUbo && d2.test(a2.data, l2)) {
          o2.push("offset = " + a2.offset / 4 + ";", Et[c2].codeUbo(a2.data.name, l2)), u2 = true;
          break;
        }
      }
      if (!u2)
        if (a2.data.size > 1) {
          var p2 = yt(a2.data.type), f2 = Math.max(Zt[a2.data.type] / 16, 1), m2 = p2 / f2, g2 = (4 - m2 % 4) % 4;
          o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a2.data.size * f2 + "; i++)\n                {\n                    for(var j = 0; j < " + m2 + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g2 + ";\n                }\n\n                ");
        } else {
          var v2 = qt[a2.data.type];
          o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n                " + v2 + ";\n                ");
        }
    }
    return o2.push("\n       renderer.buffer.update(buffer);\n    "), { size: r2, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o2.join("\n")) };
  }
  var Kt = function() {
    function t2(t3, e2) {
      this.program = t3, this.uniformData = e2, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return t2.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, t2;
  }();
  function Qt(t2, e2) {
    var i2 = ht(t2, t2.VERTEX_SHADER, e2.vertexSrc), n2 = ht(t2, t2.FRAGMENT_SHADER, e2.fragmentSrc), r2 = t2.createProgram();
    if (t2.attachShader(r2, i2), t2.attachShader(r2, n2), t2.linkProgram(r2), t2.getProgramParameter(r2, t2.LINK_STATUS) || function(t3, e3, i3, n3) {
      t3.getProgramParameter(e3, t3.LINK_STATUS) || (t3.getShaderParameter(i3, t3.COMPILE_STATUS) || ut(t3, i3), t3.getShaderParameter(n3, t3.COMPILE_STATUS) || ut(t3, n3), console.error("PixiJS Error: Could not initialize shader."), t3.getProgramInfoLog(e3) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t3.getProgramInfoLog(e3)));
    }(t2, r2, i2, n2), e2.attributeData = function(t3, e3) {
      for (var i3 = {}, n3 = e3.getProgramParameter(t3, e3.ACTIVE_ATTRIBUTES), r3 = 0; r3 < n3; r3++) {
        var o3 = e3.getActiveAttrib(t3, r3);
        if (o3.name.indexOf("gl_") !== 0) {
          var s3 = Tt(e3, o3.type), a3 = { type: s3, name: o3.name, size: yt(s3), location: e3.getAttribLocation(t3, o3.name) };
          i3[o3.name] = a3;
        }
      }
      return i3;
    }(r2, t2), e2.uniformData = function(t3, e3) {
      for (var i3 = {}, n3 = e3.getProgramParameter(t3, e3.ACTIVE_UNIFORMS), r3 = 0; r3 < n3; r3++) {
        var o3 = e3.getActiveUniform(t3, r3), s3 = o3.name.replace(/\[.*?\]$/, ""), a3 = !!o3.name.match(/\[.*?\]$/), l3 = Tt(e3, o3.type);
        i3[s3] = { name: s3, index: r3, type: l3, size: o3.size, isArray: a3, value: dt(l3, o3.size) };
      }
      return i3;
    }(r2, t2), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e2.vertexSrc)) {
      var o2 = Object.keys(e2.attributeData);
      o2.sort(function(t3, e3) {
        return t3 > e3 ? 1 : -1;
      });
      for (var s2 = 0; s2 < o2.length; s2++)
        e2.attributeData[o2[s2]].location = s2, t2.bindAttribLocation(r2, s2, o2[s2]);
      t2.linkProgram(r2);
    }
    t2.deleteShader(i2), t2.deleteShader(n2);
    var a2 = {};
    for (var s2 in e2.uniformData) {
      var l2 = e2.uniformData[s2];
      a2[s2] = { location: t2.getUniformLocation(r2, s2), value: dt(l2.type, l2.size) };
    }
    return new Kt(r2, a2);
  }
  var $t = 0, te = { textureCount: 0, uboCount: 0 }, ee = function() {
    function t2(t3) {
      this.destroyed = false, this.renderer = t3, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = $t++;
    }
    return t2.prototype.systemCheck = function() {
      if (!function() {
        if (typeof At == "boolean")
          return At;
        try {
          var t3 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
          At = t3({ a: "b" }, "a", "b") === true;
        } catch (t4) {
          At = false;
        }
        return At;
      }())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, t2.prototype.contextChange = function(t3) {
      this.gl = t3, this.reset();
    }, t2.prototype.bind = function(t3, e2) {
      t3.uniforms.globals = this.renderer.globalUniforms;
      var i2 = t3.program, n2 = i2.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t3);
      return this.shader = t3, this.program !== i2 && (this.program = i2, this.gl.useProgram(n2.program)), e2 || (te.textureCount = 0, te.uboCount = 0, this.syncUniformGroup(t3.uniformGroup, te)), n2;
    }, t2.prototype.setUniforms = function(t3) {
      var e2 = this.shader.program, i2 = e2.glPrograms[this.renderer.CONTEXT_UID];
      e2.syncUniforms(i2.uniformData, t3, this.renderer);
    }, t2.prototype.syncUniformGroup = function(t3, e2) {
      var i2 = this.getGlProgram();
      t3.static && t3.dirtyId === i2.uniformDirtyGroups[t3.id] || (i2.uniformDirtyGroups[t3.id] = t3.dirtyId, this.syncUniforms(t3, i2, e2));
    }, t2.prototype.syncUniforms = function(t3, e2, i2) {
      (t3.syncUniforms[this.shader.program.id] || this.createSyncGroups(t3))(e2.uniformData, t3.uniforms, this.renderer, i2);
    }, t2.prototype.createSyncGroups = function(t3) {
      var e2 = this.getSignature(t3, this.shader.program.uniformData, "u");
      return this.cache[e2] || (this.cache[e2] = function(t4, e3) {
        var i2, n2 = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
        for (var r2 in t4.uniforms) {
          var o2 = e3[r2];
          if (o2) {
            for (var s2 = t4.uniforms[r2], a2 = false, l2 = 0; l2 < Et.length; l2++)
              if (Et[l2].test(o2, s2)) {
                n2.push(Et[l2].code(r2, s2)), a2 = true;
                break;
              }
            if (!a2) {
              var h2 = (o2.size === 1 ? St : wt)[o2.type].replace("location", 'ud["' + r2 + '"].location');
              n2.push('\n            cu = ud["' + r2 + '"];\n            cv = cu.value;\n            v = uv["' + r2 + '"];\n            ' + h2 + ";");
            }
          } else
            ((i2 = t4.uniforms[r2]) === null || i2 === void 0 ? void 0 : i2.group) && (t4.uniforms[r2].ubo ? n2.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + r2 + ", '" + r2 + "');\n                    ") : n2.push("\n                        renderer.shader.syncUniformGroup(uv." + r2 + ", syncData);\n                    "));
        }
        return new Function("ud", "uv", "renderer", "syncData", n2.join("\n"));
      }(t3, this.shader.program.uniformData)), t3.syncUniforms[this.shader.program.id] = this.cache[e2], t3.syncUniforms[this.shader.program.id];
    }, t2.prototype.syncUniformBufferGroup = function(t3, e2) {
      var i2 = this.getGlProgram();
      if (!t3.static || t3.dirtyId !== 0 || !i2.uniformGroups[t3.id]) {
        t3.dirtyId = 0;
        var n2 = i2.uniformGroups[t3.id] || this.createSyncBufferGroup(t3, i2, e2);
        t3.buffer.update(), n2(i2.uniformData, t3.uniforms, this.renderer, te, t3.buffer);
      }
      this.renderer.buffer.bindBufferBase(t3.buffer, i2.uniformBufferBindings[e2]);
    }, t2.prototype.createSyncBufferGroup = function(t3, e2, i2) {
      var n2 = this.renderer.gl;
      this.renderer.buffer.bind(t3.buffer);
      var r2 = this.gl.getUniformBlockIndex(e2.program, i2);
      e2.uniformBufferBindings[i2] = this.shader.uniformBindCount, n2.uniformBlockBinding(e2.program, r2, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var o2 = this.getSignature(t3, this.shader.program.uniformData, "ubo"), s2 = this._uboCache[o2];
      if (s2 || (s2 = this._uboCache[o2] = Jt(t3, this.shader.program.uniformData)), t3.autoManage) {
        var a2 = new Float32Array(s2.size / 4);
        t3.buffer.update(a2);
      }
      return e2.uniformGroups[t3.id] = s2.syncFunc, e2.uniformGroups[t3.id];
    }, t2.prototype.getSignature = function(t3, e2, i2) {
      var n2 = t3.uniforms, r2 = [i2 + "-"];
      for (var o2 in n2)
        r2.push(o2), e2[o2] && r2.push(e2[o2].type);
      return r2.join("-");
    }, t2.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, t2.prototype.generateProgram = function(t3) {
      var e2 = this.gl, i2 = t3.program, n2 = Qt(e2, i2);
      return i2.glPrograms[this.renderer.CONTEXT_UID] = n2, n2;
    }, t2.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, t2.prototype.destroy = function() {
      this.renderer = null, this.destroyed = true;
    }, t2;
  }();
  var ie = function() {
    function t2() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = r.b.NONE, this._blendEq = false, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Nt(), this.defaultState.blend = true;
    }
    return t2.prototype.contextChange = function(t3) {
      this.gl = t3, this.blendModes = function(t4, e2) {
        return e2 === void 0 && (e2 = []), e2[r.b.NORMAL] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD] = [t4.ONE, t4.ONE], e2[r.b.MULTIPLY] = [t4.DST_COLOR, t4.ONE_MINUS_SRC_ALPHA, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SCREEN] = [t4.ONE, t4.ONE_MINUS_SRC_COLOR, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.OVERLAY] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DARKEN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.LIGHTEN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_DODGE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_BURN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.HARD_LIGHT] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SOFT_LIGHT] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DIFFERENCE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.EXCLUSION] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.HUE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SATURATION] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.LUMINOSITY] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.NONE] = [0, 0], e2[r.b.NORMAL_NPM] = [t4.SRC_ALPHA, t4.ONE_MINUS_SRC_ALPHA, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD_NPM] = [t4.SRC_ALPHA, t4.ONE, t4.ONE, t4.ONE], e2[r.b.SCREEN_NPM] = [t4.SRC_ALPHA, t4.ONE_MINUS_SRC_COLOR, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SRC_IN] = [t4.DST_ALPHA, t4.ZERO], e2[r.b.SRC_OUT] = [t4.ONE_MINUS_DST_ALPHA, t4.ZERO], e2[r.b.SRC_ATOP] = [t4.DST_ALPHA, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_OVER] = [t4.ONE_MINUS_DST_ALPHA, t4.ONE], e2[r.b.DST_IN] = [t4.ZERO, t4.SRC_ALPHA], e2[r.b.DST_OUT] = [t4.ZERO, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_ATOP] = [t4.ONE_MINUS_DST_ALPHA, t4.SRC_ALPHA], e2[r.b.XOR] = [t4.ONE_MINUS_DST_ALPHA, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SUBTRACT] = [t4.ONE, t4.ONE, t4.ONE, t4.ONE, t4.FUNC_REVERSE_SUBTRACT, t4.FUNC_ADD], e2;
      }(t3), this.set(this.defaultState), this.reset();
    }, t2.prototype.set = function(t3) {
      if (t3 = t3 || this.defaultState, this.stateId !== t3.data) {
        for (var e2 = this.stateId ^ t3.data, i2 = 0; e2; )
          1 & e2 && this.map[i2].call(this, !!(t3.data & 1 << i2)), e2 >>= 1, i2++;
        this.stateId = t3.data;
      }
      for (i2 = 0; i2 < this.checks.length; i2++)
        this.checks[i2](this, t3);
    }, t2.prototype.forceState = function(t3) {
      t3 = t3 || this.defaultState;
      for (var e2 = 0; e2 < this.map.length; e2++)
        this.map[e2].call(this, !!(t3.data & 1 << e2));
      for (e2 = 0; e2 < this.checks.length; e2++)
        this.checks[e2](this, t3);
      this.stateId = t3.data;
    }, t2.prototype.setBlend = function(e2) {
      this.updateCheck(t2.checkBlendMode, e2), this.gl[e2 ? "enable" : "disable"](this.gl.BLEND);
    }, t2.prototype.setOffset = function(e2) {
      this.updateCheck(t2.checkPolygonOffset, e2), this.gl[e2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, t2.prototype.setDepthTest = function(t3) {
      this.gl[t3 ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, t2.prototype.setDepthMask = function(t3) {
      this.gl.depthMask(t3);
    }, t2.prototype.setCullFace = function(t3) {
      this.gl[t3 ? "enable" : "disable"](this.gl.CULL_FACE);
    }, t2.prototype.setFrontFace = function(t3) {
      this.gl.frontFace(this.gl[t3 ? "CW" : "CCW"]);
    }, t2.prototype.setBlendMode = function(t3) {
      if (t3 !== this.blendMode) {
        this.blendMode = t3;
        var e2 = this.blendModes[t3], i2 = this.gl;
        e2.length === 2 ? i2.blendFunc(e2[0], e2[1]) : i2.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), e2.length === 6 ? (this._blendEq = true, i2.blendEquationSeparate(e2[4], e2[5])) : this._blendEq && (this._blendEq = false, i2.blendEquationSeparate(i2.FUNC_ADD, i2.FUNC_ADD));
      }
    }, t2.prototype.setPolygonOffset = function(t3, e2) {
      this.gl.polygonOffset(t3, e2);
    }, t2.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
    }, t2.prototype.updateCheck = function(t3, e2) {
      var i2 = this.checks.indexOf(t3);
      e2 && i2 === -1 ? this.checks.push(t3) : e2 || i2 === -1 || this.checks.splice(i2, 1);
    }, t2.checkBlendMode = function(t3, e2) {
      t3.setBlendMode(e2.blendMode);
    }, t2.checkPolygonOffset = function(t3, e2) {
      t3.setPolygonOffset(1, e2.polygonOffset);
    }, t2.prototype.destroy = function() {
      this.gl = null;
    }, t2;
  }(), ne = function() {
    function t2(t3) {
      this.renderer = t3, this.count = 0, this.checkCount = 0, this.maxIdle = n.b.GC_MAX_IDLE, this.checkCountMax = n.b.GC_MAX_CHECK_COUNT, this.mode = n.b.GC_MODE;
    }
    return t2.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== r.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, t2.prototype.run = function() {
      for (var t3 = this.renderer.texture, e2 = t3.managedTextures, i2 = false, n2 = 0; n2 < e2.length; n2++) {
        var r2 = e2[n2];
        !r2.framebuffer && this.count - r2.touched > this.maxIdle && (t3.destroyTexture(r2, true), e2[n2] = null, i2 = true);
      }
      if (i2) {
        var o2 = 0;
        for (n2 = 0; n2 < e2.length; n2++)
          e2[n2] !== null && (e2[o2++] = e2[n2]);
        e2.length = o2;
      }
    }, t2.prototype.unload = function(t3) {
      var e2 = this.renderer.texture, i2 = t3._texture;
      i2 && !i2.framebuffer && e2.destroyTexture(i2);
      for (var n2 = t3.children.length - 1; n2 >= 0; n2--)
        this.unload(t3.children[n2]);
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }();
  var re = function(t2) {
    this.texture = t2, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = r.r.UNSIGNED_BYTE, this.internalFormat = r.h.RGBA, this.samplerType = 0;
  }, oe = function() {
    function t2(t3) {
      this.renderer = t3, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new v(), this.hasIntegerTextures = false;
    }
    return t2.prototype.contextChange = function() {
      var t3 = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t4) {
        var e3, i3, n3, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
        return "WebGL2RenderingContext" in globalThis && t4 instanceof globalThis.WebGL2RenderingContext ? ((e3 = {})[r.r.UNSIGNED_BYTE] = ((i3 = {})[r.h.RGBA] = t4.RGBA8, i3[r.h.RGB] = t4.RGB8, i3[r.h.RG] = t4.RG8, i3[r.h.RED] = t4.R8, i3[r.h.RGBA_INTEGER] = t4.RGBA8UI, i3[r.h.RGB_INTEGER] = t4.RGB8UI, i3[r.h.RG_INTEGER] = t4.RG8UI, i3[r.h.RED_INTEGER] = t4.R8UI, i3[r.h.ALPHA] = t4.ALPHA, i3[r.h.LUMINANCE] = t4.LUMINANCE, i3[r.h.LUMINANCE_ALPHA] = t4.LUMINANCE_ALPHA, i3), e3[r.r.BYTE] = ((n3 = {})[r.h.RGBA] = t4.RGBA8_SNORM, n3[r.h.RGB] = t4.RGB8_SNORM, n3[r.h.RG] = t4.RG8_SNORM, n3[r.h.RED] = t4.R8_SNORM, n3[r.h.RGBA_INTEGER] = t4.RGBA8I, n3[r.h.RGB_INTEGER] = t4.RGB8I, n3[r.h.RG_INTEGER] = t4.RG8I, n3[r.h.RED_INTEGER] = t4.R8I, n3), e3[r.r.UNSIGNED_SHORT] = ((o2 = {})[r.h.RGBA_INTEGER] = t4.RGBA16UI, o2[r.h.RGB_INTEGER] = t4.RGB16UI, o2[r.h.RG_INTEGER] = t4.RG16UI, o2[r.h.RED_INTEGER] = t4.R16UI, o2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT16, o2), e3[r.r.SHORT] = ((s2 = {})[r.h.RGBA_INTEGER] = t4.RGBA16I, s2[r.h.RGB_INTEGER] = t4.RGB16I, s2[r.h.RG_INTEGER] = t4.RG16I, s2[r.h.RED_INTEGER] = t4.R16I, s2), e3[r.r.UNSIGNED_INT] = ((a2 = {})[r.h.RGBA_INTEGER] = t4.RGBA32UI, a2[r.h.RGB_INTEGER] = t4.RGB32UI, a2[r.h.RG_INTEGER] = t4.RG32UI, a2[r.h.RED_INTEGER] = t4.R32UI, a2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT24, a2), e3[r.r.INT] = ((l2 = {})[r.h.RGBA_INTEGER] = t4.RGBA32I, l2[r.h.RGB_INTEGER] = t4.RGB32I, l2[r.h.RG_INTEGER] = t4.RG32I, l2[r.h.RED_INTEGER] = t4.R32I, l2), e3[r.r.FLOAT] = ((h2 = {})[r.h.RGBA] = t4.RGBA32F, h2[r.h.RGB] = t4.RGB32F, h2[r.h.RG] = t4.RG32F, h2[r.h.RED] = t4.R32F, h2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT32F, h2), e3[r.r.HALF_FLOAT] = ((u2 = {})[r.h.RGBA] = t4.RGBA16F, u2[r.h.RGB] = t4.RGB16F, u2[r.h.RG] = t4.RG16F, u2[r.h.RED] = t4.R16F, u2), e3[r.r.UNSIGNED_SHORT_5_6_5] = ((c2 = {})[r.h.RGB] = t4.RGB565, c2), e3[r.r.UNSIGNED_SHORT_4_4_4_4] = ((d2 = {})[r.h.RGBA] = t4.RGBA4, d2), e3[r.r.UNSIGNED_SHORT_5_5_5_1] = ((p2 = {})[r.h.RGBA] = t4.RGB5_A1, p2), e3[r.r.UNSIGNED_INT_2_10_10_10_REV] = ((f2 = {})[r.h.RGBA] = t4.RGB10_A2, f2[r.h.RGBA_INTEGER] = t4.RGB10_A2UI, f2), e3[r.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m2 = {})[r.h.RGB] = t4.R11F_G11F_B10F, m2), e3[r.r.UNSIGNED_INT_5_9_9_9_REV] = ((g2 = {})[r.h.RGB] = t4.RGB9_E5, g2), e3[r.r.UNSIGNED_INT_24_8] = ((v2 = {})[r.h.DEPTH_STENCIL] = t4.DEPTH24_STENCIL8, v2), e3[r.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_2 = {})[r.h.DEPTH_STENCIL] = t4.DEPTH32F_STENCIL8, _2), S2 = e3) : ((y2 = {})[r.r.UNSIGNED_BYTE] = ((x2 = {})[r.h.RGBA] = t4.RGBA, x2[r.h.RGB] = t4.RGB, x2[r.h.ALPHA] = t4.ALPHA, x2[r.h.LUMINANCE] = t4.LUMINANCE, x2[r.h.LUMINANCE_ALPHA] = t4.LUMINANCE_ALPHA, x2), y2[r.r.UNSIGNED_SHORT_5_6_5] = ((b2 = {})[r.h.RGB] = t4.RGB, b2), y2[r.r.UNSIGNED_SHORT_4_4_4_4] = ((T2 = {})[r.h.RGBA] = t4.RGBA, T2), y2[r.r.UNSIGNED_SHORT_5_5_5_1] = ((E2 = {})[r.h.RGBA] = t4.RGBA, E2), S2 = y2), S2;
      }(t3);
      var e2 = t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e2;
      for (var i2 = 0; i2 < e2; i2++)
        this.boundTextures[i2] = null;
      this.emptyTextures = {};
      var n2 = new re(t3.createTexture());
      t3.bindTexture(t3.TEXTURE_2D, n2.texture), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, 1, 1, 0, t3.RGBA, t3.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t3.TEXTURE_2D] = n2, this.emptyTextures[t3.TEXTURE_CUBE_MAP] = new re(t3.createTexture()), t3.bindTexture(t3.TEXTURE_CUBE_MAP, this.emptyTextures[t3.TEXTURE_CUBE_MAP].texture);
      for (i2 = 0; i2 < 6; i2++)
        t3.texImage2D(t3.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, t3.RGBA, 1, 1, 0, t3.RGBA, t3.UNSIGNED_BYTE, null);
      t3.texParameteri(t3.TEXTURE_CUBE_MAP, t3.TEXTURE_MAG_FILTER, t3.LINEAR), t3.texParameteri(t3.TEXTURE_CUBE_MAP, t3.TEXTURE_MIN_FILTER, t3.LINEAR);
      for (i2 = 0; i2 < this.boundTextures.length; i2++)
        this.bind(null, i2);
    }, t2.prototype.bind = function(t3, e2) {
      e2 === void 0 && (e2 = 0);
      var i2 = this.gl;
      if ((t3 = t3 == null ? void 0 : t3.castToBaseTexture()) && t3.valid && !t3.parentTextureArray) {
        t3.touched = this.renderer.textureGC.count;
        var n2 = t3._glTextures[this.CONTEXT_UID] || this.initTexture(t3);
        this.boundTextures[e2] !== t3 && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(t3.target, n2.texture)), n2.dirtyId !== t3.dirtyId && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), this.updateTexture(t3)), this.boundTextures[e2] = t3;
      } else
        this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(i2.TEXTURE_2D, this.emptyTextures[i2.TEXTURE_2D].texture), this.boundTextures[e2] = null;
    }, t2.prototype.reset = function() {
      this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
      for (var t3 = 0; t3 < this.boundTextures.length; t3++)
        this.boundTextures[t3] = this.unknownTexture;
    }, t2.prototype.unbind = function(t3) {
      var e2 = this.gl, i2 = this.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var n2 = 0; n2 < i2.length; n2++)
          i2[n2] === this.unknownTexture && this.bind(null, n2);
      }
      for (n2 = 0; n2 < i2.length; n2++)
        i2[n2] === t3 && (this.currentLocation !== n2 && (e2.activeTexture(e2.TEXTURE0 + n2), this.currentLocation = n2), e2.bindTexture(t3.target, this.emptyTextures[t3.target].texture), i2[n2] = null);
    }, t2.prototype.ensureSamplerType = function(t3) {
      var e2 = this.boundTextures, i2 = this.hasIntegerTextures, n2 = this.CONTEXT_UID;
      if (i2)
        for (var o2 = t3 - 1; o2 >= 0; --o2) {
          var s2 = e2[o2];
          if (s2)
            s2._glTextures[n2].samplerType !== r.o.FLOAT && this.renderer.texture.unbind(s2);
        }
    }, t2.prototype.initTexture = function(t3) {
      var e2 = new re(this.gl.createTexture());
      return e2.dirtyId = -1, t3._glTextures[this.CONTEXT_UID] = e2, this.managedTextures.push(t3), t3.on("dispose", this.destroyTexture, this), e2;
    }, t2.prototype.initTextureType = function(t3, e2) {
      var i2, n2;
      e2.internalFormat = (n2 = (i2 = this.internalFormats[t3.type]) === null || i2 === void 0 ? void 0 : i2[t3.format]) !== null && n2 !== void 0 ? n2 : t3.format, this.webGLVersion === 2 && t3.type === r.r.HALF_FLOAT ? e2.type = this.gl.HALF_FLOAT : e2.type = t3.type;
    }, t2.prototype.updateTexture = function(t3) {
      var e2 = t3._glTextures[this.CONTEXT_UID];
      if (e2) {
        var i2 = this.renderer;
        if (this.initTextureType(t3, e2), t3.resource && t3.resource.upload(i2, t3, e2))
          e2.samplerType !== r.o.FLOAT && (this.hasIntegerTextures = true);
        else {
          var n2 = t3.realWidth, o2 = t3.realHeight, s2 = i2.gl;
          (e2.width !== n2 || e2.height !== o2 || e2.dirtyId < 0) && (e2.width = n2, e2.height = o2, s2.texImage2D(t3.target, 0, e2.internalFormat, n2, o2, 0, t3.format, e2.type, null));
        }
        t3.dirtyStyleId !== e2.dirtyStyleId && this.updateTextureStyle(t3), e2.dirtyId = t3.dirtyId;
      }
    }, t2.prototype.destroyTexture = function(t3, e2) {
      var i2 = this.gl;
      if ((t3 = t3.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t3), i2.deleteTexture(t3._glTextures[this.CONTEXT_UID].texture), t3.off("dispose", this.destroyTexture, this), delete t3._glTextures[this.CONTEXT_UID], !e2)) {
        var n2 = this.managedTextures.indexOf(t3);
        n2 !== -1 && Object(o.removeItems)(this.managedTextures, n2, 1);
      }
    }, t2.prototype.updateTextureStyle = function(t3) {
      var e2 = t3._glTextures[this.CONTEXT_UID];
      e2 && (t3.mipmap !== r.k.POW2 && this.webGLVersion === 2 || t3.isPowerOfTwo ? e2.mipmap = t3.mipmap >= 1 : e2.mipmap = false, this.webGLVersion === 2 || t3.isPowerOfTwo ? e2.wrapMode = t3.wrapMode : e2.wrapMode = r.s.CLAMP, t3.resource && t3.resource.style(this.renderer, t3, e2) || this.setStyle(t3, e2), e2.dirtyStyleId = t3.dirtyStyleId);
    }, t2.prototype.setStyle = function(t3, e2) {
      var i2 = this.gl;
      if (e2.mipmap && t3.mipmap !== r.k.ON_MANUAL && i2.generateMipmap(t3.target), i2.texParameteri(t3.target, i2.TEXTURE_WRAP_S, e2.wrapMode), i2.texParameteri(t3.target, i2.TEXTURE_WRAP_T, e2.wrapMode), e2.mipmap) {
        i2.texParameteri(t3.target, i2.TEXTURE_MIN_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR_MIPMAP_LINEAR : i2.NEAREST_MIPMAP_NEAREST);
        var n2 = this.renderer.context.extensions.anisotropicFiltering;
        if (n2 && t3.anisotropicLevel > 0 && t3.scaleMode === r.p.LINEAR) {
          var o2 = Math.min(t3.anisotropicLevel, i2.getParameter(n2.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          i2.texParameterf(t3.target, n2.TEXTURE_MAX_ANISOTROPY_EXT, o2);
        }
      } else
        i2.texParameteri(t3.target, i2.TEXTURE_MIN_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
      i2.texParameteri(t3.target, i2.TEXTURE_MAG_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), ae = new l.d(), le = function(t2) {
    function e2(e3, i2) {
      e3 === void 0 && (e3 = r.n.UNKNOWN);
      var s2 = t2.call(this) || this;
      return i2 = Object.assign({}, n.b.RENDER_OPTIONS, i2), s2.options = i2, s2.type = e3, s2.screen = new l.j(0, 0, i2.width, i2.height), s2.view = i2.view || document.createElement("canvas"), s2.resolution = i2.resolution || n.b.RESOLUTION, s2.useContextAlpha = i2.useContextAlpha, s2.autoDensity = !!i2.autoDensity, s2.preserveDrawingBuffer = i2.preserveDrawingBuffer, s2.clearBeforeRender = i2.clearBeforeRender, s2._backgroundColor = 0, s2._backgroundColorRgba = [0, 0, 0, 1], s2._backgroundColorString = "#000000", s2.backgroundColor = i2.backgroundColor || s2._backgroundColor, s2.backgroundAlpha = i2.backgroundAlpha, i2.transparent !== void 0 && (Object(o.deprecation)("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), s2.useContextAlpha = i2.transparent, s2.backgroundAlpha = i2.transparent ? 0 : 1), s2._lastObjectRendered = null, s2.plugins = {}, s2;
    }
    return d(e2, t2), e2.prototype.initPlugins = function(t3) {
      for (var e3 in t3)
        this.plugins[e3] = new t3[e3](this);
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.view.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.view.height;
    }, enumerable: false, configurable: true }), e2.prototype.resize = function(t3, e3) {
      this.view.width = Math.round(t3 * this.resolution), this.view.height = Math.round(e3 * this.resolution);
      var i2 = this.view.width / this.resolution, n2 = this.view.height / this.resolution;
      this.screen.width = i2, this.screen.height = n2, this.autoDensity && (this.view.style.width = i2 + "px", this.view.style.height = n2 + "px"), this.emit("resize", i2, n2);
    }, e2.prototype.generateTexture = function(t3, e3, i2, n2) {
      e3 === void 0 && (e3 = {}), typeof e3 == "number" && (Object(o.deprecation)("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e3 = { scaleMode: e3, resolution: i2, region: n2 });
      var r2 = e3.region, s2 = function(t4, e4) {
        var i3 = {};
        for (var n3 in t4)
          Object.prototype.hasOwnProperty.call(t4, n3) && e4.indexOf(n3) < 0 && (i3[n3] = t4[n3]);
        if (t4 != null && typeof Object.getOwnPropertySymbols == "function") {
          var r3 = 0;
          for (n3 = Object.getOwnPropertySymbols(t4); r3 < n3.length; r3++)
            e4.indexOf(n3[r3]) < 0 && (i3[n3[r3]] = t4[n3[r3]]);
        }
        return i3;
      }(e3, ["region"]);
      (n2 = r2 || t3.getLocalBounds(null, true)).width === 0 && (n2.width = 1), n2.height === 0 && (n2.height = 1);
      var a2 = D.create(p({ width: n2.width, height: n2.height }, s2));
      return ae.tx = -n2.x, ae.ty = -n2.y, this.render(t3, { renderTexture: a2, clear: false, transform: ae, skipUpdateTransform: !!t3.parent }), a2;
    }, e2.prototype.destroy = function(t3) {
      for (var e3 in this.plugins)
        this.plugins[e3].destroy(), this.plugins[e3] = null;
      t3 && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      this.plugins = null, this.type = r.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(e2.prototype, "backgroundColor", { get: function() {
      return this._backgroundColor;
    }, set: function(t3) {
      this._backgroundColor = t3, this._backgroundColorString = Object(o.hex2string)(t3), Object(o.hex2rgb)(t3, this._backgroundColorRgba);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "backgroundAlpha", { get: function() {
      return this._backgroundColorRgba[3];
    }, set: function(t3) {
      this._backgroundColorRgba[3] = t3;
    }, enumerable: false, configurable: true }), e2;
  }(o.EventEmitter), he = function(t2) {
    this.buffer = t2 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }, ue = function() {
    function t2(t3) {
      this.renderer = t3, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2.prototype.contextChange = function() {
      this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, t2.prototype.bind = function(t3) {
      var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t3._glBuffers[i2] || this.createGLBuffer(t3);
      e2.bindBuffer(t3.type, n2.buffer);
    }, t2.prototype.bindBufferBase = function(t3, e2) {
      var i2 = this.gl, n2 = this.CONTEXT_UID;
      if (this.boundBufferBases[e2] !== t3) {
        var r2 = t3._glBuffers[n2] || this.createGLBuffer(t3);
        this.boundBufferBases[e2] = t3, i2.bindBufferBase(i2.UNIFORM_BUFFER, e2, r2.buffer);
      }
    }, t2.prototype.bindBufferRange = function(t3, e2, i2) {
      var n2 = this.gl, r2 = this.CONTEXT_UID;
      i2 = i2 || 0;
      var o2 = t3._glBuffers[r2] || this.createGLBuffer(t3);
      n2.bindBufferRange(n2.UNIFORM_BUFFER, e2 || 0, o2.buffer, 256 * i2, 256);
    }, t2.prototype.update = function(t3) {
      var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t3._glBuffers[i2];
      if (t3._updateID !== n2.updateID)
        if (n2.updateID = t3._updateID, e2.bindBuffer(t3.type, n2.buffer), n2.byteLength >= t3.data.byteLength)
          e2.bufferSubData(t3.type, 0, t3.data);
        else {
          var r2 = t3.static ? e2.STATIC_DRAW : e2.DYNAMIC_DRAW;
          n2.byteLength = t3.data.byteLength, e2.bufferData(t3.type, t3.data, r2);
        }
    }, t2.prototype.dispose = function(t3, e2) {
      if (this.managedBuffers[t3.id]) {
        delete this.managedBuffers[t3.id];
        var i2 = t3._glBuffers[this.CONTEXT_UID], n2 = this.gl;
        t3.disposeRunner.remove(this), i2 && (e2 || n2.deleteBuffer(i2.buffer), delete t3._glBuffers[this.CONTEXT_UID]);
      }
    }, t2.prototype.disposeAll = function(t3) {
      for (var e2 = Object.keys(this.managedBuffers), i2 = 0; i2 < e2.length; i2++)
        this.dispose(this.managedBuffers[e2[i2]], t3);
    }, t2.prototype.createGLBuffer = function(t3) {
      var e2 = this.CONTEXT_UID, i2 = this.gl;
      return t3._glBuffers[e2] = new he(i2.createBuffer()), this.managedBuffers[t3.id] = t3, t3.disposeRunner.add(this), t3._glBuffers[e2];
    }, t2;
  }(), ce = function(t2) {
    function e2(i2) {
      var n2 = t2.call(this, r.n.WEBGL, i2) || this;
      return i2 = n2.options, n2.gl = null, n2.CONTEXT_UID = 0, n2.runners = { destroy: new s.a("destroy"), contextChange: new s.a("contextChange"), reset: new s.a("reset"), update: new s.a("update"), postrender: new s.a("postrender"), prerender: new s.a("prerender"), resize: new s.a("resize") }, n2.runners.contextChange.add(n2), n2.globalUniforms = new q({ projectionMatrix: new l.d() }, true), n2.addSystem(Ut, "mask").addSystem(it, "context").addSystem(ie, "state").addSystem(ee, "shader").addSystem(oe, "texture").addSystem(ue, "buffer").addSystem(at, "geometry").addSystem(ot, "framebuffer").addSystem(Ht, "scissor").addSystem(jt, "stencil").addSystem(zt, "projection").addSystem(ne, "textureGC").addSystem(Q, "filter").addSystem(Wt, "renderTexture").addSystem(tt, "batch"), n2.initPlugins(e2.__plugins), n2.multisample = void 0, i2.context ? n2.context.initFromContext(i2.context) : n2.context.initFromOptions({ alpha: !!n2.useContextAlpha, antialias: i2.antialias, premultipliedAlpha: n2.useContextAlpha && n2.useContextAlpha !== "notMultiplied", stencil: true, preserveDrawingBuffer: i2.preserveDrawingBuffer, powerPreference: n2.options.powerPreference }), n2.renderingToScreen = true, Object(o.sayHello)(n2.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), n2.resize(n2.options.width, n2.options.height), n2;
    }
    return d(e2, t2), e2.create = function(t3) {
      if (Object(o.isWebGLSupported)())
        return new e2(t3);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, e2.prototype.contextChange = function() {
      var t3, e3 = this.gl;
      if (this.context.webGLVersion === 1) {
        var i2 = e3.getParameter(e3.FRAMEBUFFER_BINDING);
        e3.bindFramebuffer(e3.FRAMEBUFFER, null), t3 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.FRAMEBUFFER, i2);
      } else {
        i2 = e3.getParameter(e3.DRAW_FRAMEBUFFER_BINDING);
        e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, null), t3 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, i2);
      }
      t3 >= r.l.HIGH ? this.multisample = r.l.HIGH : t3 >= r.l.MEDIUM ? this.multisample = r.l.MEDIUM : t3 >= r.l.LOW ? this.multisample = r.l.LOW : this.multisample = r.l.NONE;
    }, e2.prototype.addSystem = function(t3, e3) {
      var i2 = new t3(this);
      if (this[e3])
        throw new Error('Whoops! The name "' + e3 + '" is already in use');
      for (var n2 in this[e3] = i2, this.runners)
        this.runners[n2].add(i2);
      return this;
    }, e2.prototype.render = function(t3, e3) {
      var i2, n2, r2, s2;
      if (e3 && (e3 instanceof D ? (Object(o.deprecation)("6.0.0", "Renderer#render arguments changed, use options instead."), i2 = e3, n2 = arguments[2], r2 = arguments[3], s2 = arguments[4]) : (i2 = e3.renderTexture, n2 = e3.clear, r2 = e3.transform, s2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = r2, !this.context.isLost) {
        if (i2 || (this._lastObjectRendered = t3), !s2) {
          var a2 = t3.enableTempParent();
          t3.updateTransform(), t3.disableTempParent(a2);
        }
        this.renderTexture.bind(i2), this.batch.currentRenderer.start(), (n2 !== void 0 ? n2 : this.clearBeforeRender) && this.renderTexture.clear(), t3.render(this), this.batch.currentRenderer.flush(), i2 && i2.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, e2.prototype.generateTexture = function(e3, i2, n2, r2) {
      i2 === void 0 && (i2 = {});
      var o2 = t2.prototype.generateTexture.call(this, e3, i2, n2, r2);
      return this.framebuffer.blit(), o2;
    }, e2.prototype.resize = function(e3, i2) {
      t2.prototype.resize.call(this, e3, i2), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, e2.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, e2.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, e2.prototype.destroy = function(e3) {
      for (var i2 in this.runners.destroy.emit(), this.runners)
        this.runners[i2].destroy();
      t2.prototype.destroy.call(this, e3), this.gl = null;
    }, Object.defineProperty(e2.prototype, "extract", { get: function() {
      return Object(o.deprecation)("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
    }, enumerable: false, configurable: true }), e2.registerPlugin = function(t3, i2) {
      e2.__plugins = e2.__plugins || {}, e2.__plugins[t3] = i2;
    }, e2;
  }(le);
  function de(t2) {
    return ce.create(t2);
  }
  var pe = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", fe = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", me = function() {
    this.texArray = null, this.blend = 0, this.type = r.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }, ge = function() {
    function t2() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return t2.prototype.clear = function() {
      for (var t3 = 0; t3 < this.count; t3++)
        this.elements[t3] = null;
      this.count = 0;
    }, t2;
  }(), ve = function() {
    function t2(t3) {
      typeof t3 == "number" ? this.rawBinaryData = new ArrayBuffer(t3) : t3 instanceof Uint8Array ? this.rawBinaryData = t3.buffer : this.rawBinaryData = t3, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(t2.prototype, "int8View", { get: function() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "uint8View", { get: function() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "int16View", { get: function() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "uint16View", { get: function() {
      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "int32View", { get: function() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }, enumerable: false, configurable: true }), t2.prototype.view = function(t3) {
      return this[t3 + "View"];
    }, t2.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, t2.sizeOf = function(t3) {
      switch (t3) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t3 + " isn't a valid view type");
      }
    }, t2;
  }(), _e = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.shaderGenerator = null, i2.geometryClass = null, i2.vertexSize = null, i2.state = Nt.for2d(), i2.size = 4 * n.b.SPRITE_BATCH_SIZE, i2._vertexCount = 0, i2._indexCount = 0, i2._bufferedElements = [], i2._bufferedTextures = [], i2._bufferSize = 0, i2._shader = null, i2._packedGeometries = [], i2._packedGeometryPoolSize = 2, i2._flushId = 0, i2._aBuffers = {}, i2._iBuffers = {}, i2.MAX_TEXTURES = 1, i2.renderer.on("prerender", i2.onPrerender, i2), e3.runners.contextChange.add(i2), i2._dcIndex = 0, i2._aIndex = 0, i2._iIndex = 0, i2._attributeBuffer = null, i2._indexBuffer = null, i2._tempBoundTextures = [], i2;
    }
    return d(e2, t2), e2.prototype.contextChange = function() {
      var t3 = this.renderer.gl;
      n.b.PREFER_ENV === r.g.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS), n.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t4, e4) {
        if (t4 === 0)
          throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        for (var i2 = e4.createShader(e4.FRAGMENT_SHADER); ; ) {
          var n2 = Mt.replace(/%forloop%/gi, Rt(t4));
          if (e4.shaderSource(i2, n2), e4.compileShader(i2), e4.getShaderParameter(i2, e4.COMPILE_STATUS))
            break;
          t4 = t4 / 2 | 0;
        }
        return t4;
      }(this.MAX_TEXTURES, t3)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++)
        this._packedGeometries[e3] = new this.geometryClass();
      this.initFlushBuffers();
    }, e2.prototype.initFlushBuffers = function() {
      for (var t3 = e2._drawCallPool, i2 = e2._textureArrayPool, n2 = this.size / 4, r2 = Math.floor(n2 / this.MAX_TEXTURES) + 1; t3.length < n2; )
        t3.push(new me());
      for (; i2.length < r2; )
        i2.push(new ge());
      for (var o2 = 0; o2 < this.MAX_TEXTURES; o2++)
        this._tempBoundTextures[o2] = null;
    }, e2.prototype.onPrerender = function() {
      this._flushId = 0;
    }, e2.prototype.render = function(t3) {
      t3._texture.valid && (this._vertexCount + t3.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t3.vertexData.length / 2, this._indexCount += t3.indices.length, this._bufferedTextures[this._bufferSize] = t3._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t3);
    }, e2.prototype.buildTexturesAndDrawCalls = function() {
      var t3 = this._bufferedTextures, i2 = this.MAX_TEXTURES, n2 = e2._textureArrayPool, r2 = this.renderer.batch, o2 = this._tempBoundTextures, s2 = this.renderer.textureGC.count, a2 = ++v._globalBatch, l2 = 0, h2 = n2[0], u2 = 0;
      r2.copyBoundTextures(o2, i2);
      for (var c2 = 0; c2 < this._bufferSize; ++c2) {
        var d2 = t3[c2];
        t3[c2] = null, d2._batchEnabled !== a2 && (h2.count >= i2 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, c2), u2 = c2, h2 = n2[++l2], ++a2), d2._batchEnabled = a2, d2.touched = s2, h2.elements[h2.count++] = d2);
      }
      h2.count > 0 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, this._bufferSize), ++l2, ++a2);
      for (c2 = 0; c2 < o2.length; c2++)
        o2[c2] = null;
      v._globalBatch = a2;
    }, e2.prototype.buildDrawCalls = function(t3, i2, n2) {
      var r2 = this._bufferedElements, s2 = this._attributeBuffer, a2 = this._indexBuffer, l2 = this.vertexSize, h2 = e2._drawCallPool, u2 = this._dcIndex, c2 = this._aIndex, d2 = this._iIndex, p2 = h2[u2];
      p2.start = this._iIndex, p2.texArray = t3;
      for (var f2 = i2; f2 < n2; ++f2) {
        var m2 = r2[f2], g2 = m2._texture.baseTexture, v2 = o.premultiplyBlendMode[g2.alphaMode ? 1 : 0][m2.blendMode];
        r2[f2] = null, i2 < f2 && p2.blend !== v2 && (p2.size = d2 - p2.start, i2 = f2, (p2 = h2[++u2]).texArray = t3, p2.start = d2), this.packInterleavedGeometry(m2, s2, a2, c2, d2), c2 += m2.vertexData.length / 2 * l2, d2 += m2.indices.length, p2.blend = v2;
      }
      i2 < n2 && (p2.size = d2 - p2.start, ++u2), this._dcIndex = u2, this._aIndex = c2, this._iIndex = d2;
    }, e2.prototype.bindAndClearTexArray = function(t3) {
      for (var e3 = this.renderer.texture, i2 = 0; i2 < t3.count; i2++)
        e3.bind(t3.elements[i2], t3.ids[i2]), t3.elements[i2] = null;
      t3.count = 0;
    }, e2.prototype.updateGeometry = function() {
      var t3 = this._packedGeometries, e3 = this._attributeBuffer, i2 = this._indexBuffer;
      n.b.CAN_UPLOAD_SAME_BUFFER ? (t3[this._flushId]._buffer.update(e3.rawBinaryData), t3[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t3[this._flushId] = new this.geometryClass()), t3[this._flushId]._buffer.update(e3.rawBinaryData), t3[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.bind(t3[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, e2.prototype.drawBatches = function() {
      for (var t3 = this._dcIndex, i2 = this.renderer, n2 = i2.gl, r2 = i2.state, o2 = e2._drawCallPool, s2 = null, a2 = 0; a2 < t3; a2++) {
        var l2 = o2[a2], h2 = l2.texArray, u2 = l2.type, c2 = l2.size, d2 = l2.start, p2 = l2.blend;
        s2 !== h2 && (s2 = h2, this.bindAndClearTexArray(h2)), this.state.blendMode = p2, r2.set(this.state), n2.drawElements(u2, c2, n2.UNSIGNED_SHORT, 2 * d2);
      }
    }, e2.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, e2.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), n.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, e2.prototype.stop = function() {
      this.flush();
    }, e2.prototype.destroy = function() {
      for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++)
        this._packedGeometries[e3] && this._packedGeometries[e3].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t2.prototype.destroy.call(this);
    }, e2.prototype.getAttributeBuffer = function(t3) {
      var e3 = Object(o.nextPow2)(Math.ceil(t3 / 8)), i2 = Object(o.log2)(e3), n2 = 8 * e3;
      this._aBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
      var r2 = this._aBuffers[n2];
      return r2 || (this._aBuffers[n2] = r2 = new ve(n2 * this.vertexSize * 4)), r2;
    }, e2.prototype.getIndexBuffer = function(t3) {
      var e3 = Object(o.nextPow2)(Math.ceil(t3 / 12)), i2 = Object(o.log2)(e3), n2 = 12 * e3;
      this._iBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
      var r2 = this._iBuffers[i2];
      return r2 || (this._iBuffers[i2] = r2 = new Uint16Array(n2)), r2;
    }, e2.prototype.packInterleavedGeometry = function(t3, e3, i2, n2, r2) {
      for (var s2 = e3.uint32View, a2 = e3.float32View, l2 = n2 / this.vertexSize, h2 = t3.uvs, u2 = t3.indices, c2 = t3.vertexData, d2 = t3._texture.baseTexture._batchLocation, p2 = Math.min(t3.worldAlpha, 1), f2 = p2 < 1 && t3._texture.baseTexture.alphaMode ? Object(o.premultiplyTint)(t3._tintRGB, p2) : t3._tintRGB + (255 * p2 << 24), m2 = 0; m2 < c2.length; m2 += 2)
        a2[n2++] = c2[m2], a2[n2++] = c2[m2 + 1], a2[n2++] = h2[m2], a2[n2++] = h2[m2 + 1], s2[n2++] = f2, a2[n2++] = d2;
      for (m2 = 0; m2 < u2.length; m2++)
        i2[r2++] = l2 + u2[m2];
    }, e2._drawCallPool = [], e2._textureArrayPool = [], e2;
  }($), ye = function() {
    function t2(t3, e2) {
      if (this.vertexSrc = t3, this.fragTemplate = e2, this.programCache = {}, this.defaultGroupCache = {}, e2.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e2.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return t2.prototype.generateShader = function(t3) {
      if (!this.programCache[t3]) {
        for (var e2 = new Int32Array(t3), i2 = 0; i2 < t3; i2++)
          e2[i2] = i2;
        this.defaultGroupCache[t3] = q.from({ uSamplers: e2 }, true);
        var n2 = this.fragTemplate;
        n2 = (n2 = n2.replace(/%count%/gi, "" + t3)).replace(/%forloop%/gi, this.generateSampleSrc(t3)), this.programCache[t3] = new Pt(this.vertexSrc, n2);
      }
      var r2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new l.d(), default: this.defaultGroupCache[t3] };
      return new Ot(this.programCache[t3], r2);
    }, t2.prototype.generateSampleSrc = function(t3) {
      var e2 = "";
      e2 += "\n", e2 += "\n";
      for (var i2 = 0; i2 < t3; i2++)
        i2 > 0 && (e2 += "\nelse "), i2 < t3 - 1 && (e2 += "if(vTextureId < " + i2 + ".5)"), e2 += "\n{", e2 += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);", e2 += "\n}";
      return e2 += "\n", e2 += "\n";
    }, t2;
  }(), xe = function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = false);
      var i2 = t2.call(this) || this;
      return i2._buffer = new k(null, e3, false), i2._indexBuffer = new k(null, e3, true), i2.addAttribute("aVertexPosition", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aTextureCoord", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aColor", i2._buffer, 4, true, r.r.UNSIGNED_BYTE).addAttribute("aTextureId", i2._buffer, 1, true, r.r.FLOAT).addIndex(i2._indexBuffer), i2;
    }
    return d(e2, t2), e2;
  }(V), be = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Te = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n", Ee = function() {
    function t2() {
    }
    return t2.create = function(t3) {
      var e2 = Object.assign({ vertex: be, fragment: Te, geometryClass: xe, vertexSize: 6 }, t3), i2 = e2.vertex, n2 = e2.fragment, r2 = e2.vertexSize, o2 = e2.geometryClass;
      return function(t4) {
        function e3(e4) {
          var s2 = t4.call(this, e4) || this;
          return s2.shaderGenerator = new ye(i2, n2), s2.geometryClass = o2, s2.vertexSize = r2, s2;
        }
        return d(e3, t4), e3;
      }(_e);
    }, Object.defineProperty(t2, "defaultVertexSrc", { get: function() {
      return be;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "defaultFragmentTemplate", { get: function() {
      return Te;
    }, enumerable: false, configurable: true }), t2;
  }().create();
}, function(t, e, i) {
  i.r(e), i.d(e, "BaseTextureCache", function() {
    return H;
  }), i.d(e, "CanvasRenderTarget", function() {
    return V;
  }), i.d(e, "DATA_URI", function() {
    return Y;
  }), i.d(e, "ProgramCache", function() {
    return k;
  }), i.d(e, "TextureCache", function() {
    return G;
  }), i.d(e, "clearTextureCache", function() {
    return z;
  }), i.d(e, "correctBlendMode", function() {
    return T;
  }), i.d(e, "createIndicesForQuads", function() {
    return A;
  }), i.d(e, "decomposeDataUri", function() {
    return q;
  }), i.d(e, "deprecation", function() {
    return U;
  }), i.d(e, "destroyTextureCache", function() {
    return j;
  }), i.d(e, "determineCrossOrigin", function() {
    return Z;
  }), i.d(e, "getBufferType", function() {
    return M;
  }), i.d(e, "getResolutionOfUrl", function() {
    return J;
  }), i.d(e, "hex2rgb", function() {
    return v;
  }), i.d(e, "hex2string", function() {
    return _;
  }), i.d(e, "interleaveTypedArrays", function() {
    return C;
  }), i.d(e, "isPow2", function() {
    return P;
  }), i.d(e, "isWebGLSupported", function() {
    return m;
  }), i.d(e, "log2", function() {
    return O;
  }), i.d(e, "nextPow2", function() {
    return I;
  }), i.d(e, "premultiplyBlendMode", function() {
    return b;
  }), i.d(e, "premultiplyRgba", function() {
    return E;
  }), i.d(e, "premultiplyTint", function() {
    return S;
  }), i.d(e, "premultiplyTintToRgba", function() {
    return w;
  }), i.d(e, "removeItems", function() {
    return N;
  }), i.d(e, "rgb2hex", function() {
    return x;
  }), i.d(e, "sayHello", function() {
    return f;
  }), i.d(e, "sign", function() {
    return L;
  }), i.d(e, "skipHello", function() {
    return p;
  }), i.d(e, "string2hex", function() {
    return y;
  }), i.d(e, "trimCanvas", function() {
    return X;
  }), i.d(e, "uid", function() {
    return F;
  }), i.d(e, "url", function() {
    return u;
  });
  var n = i(4);
  i.d(e, "isMobile", function() {
    return n.a;
  });
  var r = i(52), o = i.n(r);
  i.d(e, "EventEmitter", function() {
    return o.a;
  });
  var s = i(53), a = i.n(s);
  i.d(e, "earcut", function() {
    return a.a;
  });
  var l = i(35), h = i(0), u = { parse: l.parse, format: l.format, resolve: l.resolve };
  n.b.RETINA_PREFIX = /@([0-9\.]+)x/, n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
  var c, d = false;
  function p() {
    d = true;
  }
  function f(t2) {
    var e2;
    if (!d) {
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        var i2 = ["\n %c %c %c PixiJS 6.4.2 - \u2730 " + t2 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
        (e2 = globalThis.console).log.apply(e2, i2);
      } else
        globalThis.console && globalThis.console.log("PixiJS 6.4.2 - " + t2 + " - http://www.pixijs.com/");
      d = true;
    }
  }
  function m() {
    return c === void 0 && (c = function() {
      var t2 = { stencil: true, failIfMajorPerformanceCaveat: n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
      try {
        if (!globalThis.WebGLRenderingContext)
          return false;
        var e2 = document.createElement("canvas"), i2 = e2.getContext("webgl", t2) || e2.getContext("experimental-webgl", t2), r2 = !(!i2 || !i2.getContextAttributes().stencil);
        if (i2) {
          var o2 = i2.getExtension("WEBGL_lose_context");
          o2 && o2.loseContext();
        }
        return i2 = null, r2;
      } catch (t3) {
        return false;
      }
    }()), c;
  }
  var g = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", goldenrod: "#daa520", gold: "#ffd700", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavenderblush: "#fff0f5", lavender: "#e6e6fa", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
  function v(t2, e2) {
    return e2 === void 0 && (e2 = []), e2[0] = (t2 >> 16 & 255) / 255, e2[1] = (t2 >> 8 & 255) / 255, e2[2] = (255 & t2) / 255, e2;
  }
  function _(t2) {
    var e2 = t2.toString(16);
    return "#" + (e2 = "000000".substring(0, 6 - e2.length) + e2);
  }
  function y(t2) {
    return typeof t2 == "string" && (t2 = g[t2.toLowerCase()] || t2)[0] === "#" && (t2 = t2.slice(1)), parseInt(t2, 16);
  }
  function x(t2) {
    return (255 * t2[0] << 16) + (255 * t2[1] << 8) + (255 * t2[2] | 0);
  }
  var b = function() {
    for (var t2 = [], e2 = [], i2 = 0; i2 < 32; i2++)
      t2[i2] = i2, e2[i2] = i2;
    t2[h.b.NORMAL_NPM] = h.b.NORMAL, t2[h.b.ADD_NPM] = h.b.ADD, t2[h.b.SCREEN_NPM] = h.b.SCREEN, e2[h.b.NORMAL] = h.b.NORMAL_NPM, e2[h.b.ADD] = h.b.ADD_NPM, e2[h.b.SCREEN] = h.b.SCREEN_NPM;
    var n2 = [];
    return n2.push(e2), n2.push(t2), n2;
  }();
  function T(t2, e2) {
    return b[e2 ? 1 : 0][t2];
  }
  function E(t2, e2, i2, n2) {
    return i2 = i2 || new Float32Array(4), n2 || n2 === void 0 ? (i2[0] = t2[0] * e2, i2[1] = t2[1] * e2, i2[2] = t2[2] * e2) : (i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2]), i2[3] = e2, i2;
  }
  function S(t2, e2) {
    if (e2 === 1)
      return (255 * e2 << 24) + t2;
    if (e2 === 0)
      return 0;
    var i2 = t2 >> 16 & 255, n2 = t2 >> 8 & 255, r2 = 255 & t2;
    return (255 * e2 << 24) + ((i2 = i2 * e2 + 0.5 | 0) << 16) + ((n2 = n2 * e2 + 0.5 | 0) << 8) + (r2 = r2 * e2 + 0.5 | 0);
  }
  function w(t2, e2, i2, n2) {
    return (i2 = i2 || new Float32Array(4))[0] = (t2 >> 16 & 255) / 255, i2[1] = (t2 >> 8 & 255) / 255, i2[2] = (255 & t2) / 255, (n2 || n2 === void 0) && (i2[0] *= e2, i2[1] *= e2, i2[2] *= e2), i2[3] = e2, i2;
  }
  function A(t2, e2) {
    e2 === void 0 && (e2 = null);
    var i2 = 6 * t2;
    if ((e2 = e2 || new Uint16Array(i2)).length !== i2)
      throw new Error("Out buffer length is incorrect, got " + e2.length + " and expected " + i2);
    for (var n2 = 0, r2 = 0; n2 < i2; n2 += 6, r2 += 4)
      e2[n2 + 0] = r2 + 0, e2[n2 + 1] = r2 + 1, e2[n2 + 2] = r2 + 2, e2[n2 + 3] = r2 + 0, e2[n2 + 4] = r2 + 2, e2[n2 + 5] = r2 + 3;
    return e2;
  }
  function M(t2) {
    if (t2.BYTES_PER_ELEMENT === 4)
      return t2 instanceof Float32Array ? "Float32Array" : t2 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (t2.BYTES_PER_ELEMENT === 2) {
      if (t2 instanceof Uint16Array)
        return "Uint16Array";
    } else if (t2.BYTES_PER_ELEMENT === 1 && t2 instanceof Uint8Array)
      return "Uint8Array";
    return null;
  }
  var R = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function C(t2, e2) {
    for (var i2 = 0, n2 = 0, r2 = {}, o2 = 0; o2 < t2.length; o2++)
      n2 += e2[o2], i2 += t2[o2].length;
    var s2 = new ArrayBuffer(4 * i2), a2 = null, l2 = 0;
    for (o2 = 0; o2 < t2.length; o2++) {
      var h2 = e2[o2], u2 = t2[o2], c2 = M(u2);
      r2[c2] || (r2[c2] = new R[c2](s2)), a2 = r2[c2];
      for (var d2 = 0; d2 < u2.length; d2++) {
        a2[(d2 / h2 | 0) * n2 + l2 + d2 % h2] = u2[d2];
      }
      l2 += h2;
    }
    return new Float32Array(s2);
  }
  function I(t2) {
    return t2 += t2 === 0 ? 1 : 0, --t2, t2 |= t2 >>> 1, t2 |= t2 >>> 2, t2 |= t2 >>> 4, t2 |= t2 >>> 8, (t2 |= t2 >>> 16) + 1;
  }
  function P(t2) {
    return !(t2 & t2 - 1 || !t2);
  }
  function O(t2) {
    var e2 = (t2 > 65535 ? 1 : 0) << 4, i2 = ((t2 >>>= e2) > 255 ? 1 : 0) << 3;
    return e2 |= i2, e2 |= i2 = ((t2 >>>= i2) > 15 ? 1 : 0) << 2, (e2 |= i2 = ((t2 >>>= i2) > 3 ? 1 : 0) << 1) | (t2 >>>= i2) >> 1;
  }
  function N(t2, e2, i2) {
    var n2, r2 = t2.length;
    if (!(e2 >= r2 || i2 === 0)) {
      var o2 = r2 - (i2 = e2 + i2 > r2 ? r2 - e2 : i2);
      for (n2 = e2; n2 < o2; ++n2)
        t2[n2] = t2[n2 + i2];
      t2.length = o2;
    }
  }
  function L(t2) {
    return t2 === 0 ? 0 : t2 < 0 ? -1 : 1;
  }
  var D = 0;
  function F() {
    return ++D;
  }
  var B = {};
  function U(t2, e2, i2) {
    if (i2 === void 0 && (i2 = 3), !B[e2]) {
      var n2 = new Error().stack;
      n2 === void 0 ? console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t2) : (n2 = n2.split("\n").splice(i2).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e2 + "\nDeprecated since v" + t2), console.warn(n2), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t2), console.warn(n2))), B[e2] = true;
    }
  }
  var k = {}, G = /* @__PURE__ */ Object.create(null), H = /* @__PURE__ */ Object.create(null);
  function j() {
    var t2;
    for (t2 in G)
      G[t2].destroy();
    for (t2 in H)
      H[t2].destroy();
  }
  function z() {
    var t2;
    for (t2 in G)
      delete G[t2];
    for (t2 in H)
      delete H[t2];
  }
  var V = function() {
    function t2(t3, e2, i2) {
      this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i2 || n.b.RESOLUTION, this.resize(t3, e2);
    }
    return t2.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, t2.prototype.resize = function(t3, e2) {
      this.canvas.width = Math.round(t3 * this.resolution), this.canvas.height = Math.round(e2 * this.resolution);
    }, t2.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(t2.prototype, "width", { get: function() {
      return this.canvas.width;
    }, set: function(t3) {
      this.canvas.width = Math.round(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "height", { get: function() {
      return this.canvas.height;
    }, set: function(t3) {
      this.canvas.height = Math.round(t3);
    }, enumerable: false, configurable: true }), t2;
  }();
  function X(t2) {
    var e2, i2, n2, r2 = t2.width, o2 = t2.height, s2 = t2.getContext("2d"), a2 = s2.getImageData(0, 0, r2, o2).data, l2 = a2.length, h2 = { top: null, left: null, right: null, bottom: null }, u2 = null;
    for (e2 = 0; e2 < l2; e2 += 4)
      a2[e2 + 3] !== 0 && (i2 = e2 / 4 % r2, n2 = ~~(e2 / 4 / r2), h2.top === null && (h2.top = n2), (h2.left === null || i2 < h2.left) && (h2.left = i2), (h2.right === null || h2.right < i2) && (h2.right = i2 + 1), (h2.bottom === null || h2.bottom < n2) && (h2.bottom = n2));
    return h2.top !== null && (r2 = h2.right - h2.left, o2 = h2.bottom - h2.top + 1, u2 = s2.getImageData(h2.left, h2.top, r2, o2)), { height: o2, width: r2, data: u2 };
  }
  var W, Y = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
  function q(t2) {
    var e2 = Y.exec(t2);
    if (e2)
      return { mediaType: e2[1] ? e2[1].toLowerCase() : void 0, subType: e2[2] ? e2[2].toLowerCase() : void 0, charset: e2[3] ? e2[3].toLowerCase() : void 0, encoding: e2[4] ? e2[4].toLowerCase() : void 0, data: e2[5] };
  }
  function Z(t2, e2) {
    if (e2 === void 0 && (e2 = globalThis.location), t2.indexOf("data:") === 0)
      return "";
    e2 = e2 || globalThis.location, W || (W = document.createElement("a")), W.href = t2;
    var i2 = u.parse(W.href), n2 = !i2.port && e2.port === "" || i2.port === e2.port;
    return i2.hostname === e2.hostname && n2 && i2.protocol === e2.protocol ? "" : "anonymous";
  }
  function J(t2, e2) {
    var i2 = n.b.RETINA_PREFIX.exec(t2);
    return i2 ? parseFloat(i2[1]) : e2 !== void 0 ? e2 : 1;
  }
}, function(t, e, i) {
  i.d(e, "a", function() {
    return U;
  }), i.d(e, "b", function() {
    return k;
  });
  var n = /iPhone/i, r = /iPod/i, o = /iPad/i, s = /\biOS-universal(?:.+)Mac\b/i, a = /\bAndroid(?:.+)Mobile\b/i, l = /Android/i, h = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, u = /Silk/i, c = /Windows Phone/i, d = /\bWindows(?:.+)ARM\b/i, p = /BlackBerry/i, f = /BB10/i, m = /Opera Mini/i, g = /\b(CriOS|Chrome)(?:.+)Mobile/i, v = /Mobile(?:.+)Firefox\b/i, _ = function(t2) {
    return t2 !== void 0 && t2.platform === "MacIntel" && typeof t2.maxTouchPoints == "number" && t2.maxTouchPoints > 1 && typeof MSStream == "undefined";
  };
  /*!
   * @pixi/settings - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var y, x, b, T, E, S, w, A, M, R, C, I, P, O, N, L, D, F, B, U = function(t2) {
    var e2 = { userAgent: "", platform: "", maxTouchPoints: 0 };
    t2 || typeof navigator == "undefined" ? typeof t2 == "string" ? e2.userAgent = t2 : t2 && t2.userAgent && (e2 = { userAgent: t2.userAgent, platform: t2.platform, maxTouchPoints: t2.maxTouchPoints || 0 }) : e2 = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 };
    var i2 = e2.userAgent, y2 = i2.split("[FBAN");
    y2[1] !== void 0 && (i2 = y2[0]), (y2 = i2.split("Twitter"))[1] !== void 0 && (i2 = y2[0]);
    var x2 = function(t3) {
      return function(e3) {
        return e3.test(t3);
      };
    }(i2), b2 = { apple: { phone: x2(n) && !x2(c), ipod: x2(r), tablet: !x2(n) && (x2(o) || _(e2)) && !x2(c), universal: x2(s), device: (x2(n) || x2(r) || x2(o) || x2(s) || _(e2)) && !x2(c) }, amazon: { phone: x2(h), tablet: !x2(h) && x2(u), device: x2(h) || x2(u) }, android: { phone: !x2(c) && x2(h) || !x2(c) && x2(a), tablet: !x2(c) && !x2(h) && !x2(a) && (x2(u) || x2(l)), device: !x2(c) && (x2(h) || x2(u) || x2(a) || x2(l)) || x2(/\bokhttp\b/i) }, windows: { phone: x2(c), tablet: x2(d), device: x2(c) || x2(d) }, other: { blackberry: x2(p), blackberry10: x2(f), opera: x2(m), firefox: x2(v), chrome: x2(g), device: x2(p) || x2(f) || x2(m) || x2(v) || x2(g) }, any: false, phone: false, tablet: false };
    return b2.any = b2.apple.device || b2.android.device || b2.windows.device || b2.other.device, b2.phone = b2.apple.phone || b2.android.phone || b2.windows.phone, b2.tablet = b2.apple.tablet || b2.android.tablet || b2.windows.tablet, b2;
  }(globalThis.navigator);
  !function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(y || (y = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(x || (x = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(b || (b = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(T || (T = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(E || (E = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(S || (S = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(w || (w = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(A || (A = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(M || (M = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(R || (R = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(C || (C = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(I || (I = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(P || (P = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(O || (O = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(N || (N = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(L || (L = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(D || (D = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(F || (F = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(B || (B = {}));
  var k = { MIPMAP_TEXTURES: I.POW2, ANISOTROPIC_LEVEL: 0, RESOLUTION: 1, FILTER_RESOLUTION: 1, FILTER_MULTISAMPLE: F.NONE, SPRITE_MAX_TEXTURES: function(t2) {
    var e2 = true;
    if (U.tablet || U.phone) {
      var i2;
      if (U.apple.device) {
        if (i2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/))
          parseInt(i2[1], 10) < 11 && (e2 = false);
      }
      if (U.android.device) {
        if (i2 = navigator.userAgent.match(/Android\s([0-9.]*)/))
          parseInt(i2[1], 10) < 7 && (e2 = false);
      }
    }
    return e2 ? t2 : 4;
  }(32), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: false, autoDensity: false, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: true, clearBeforeRender: true, preserveDrawingBuffer: false, width: 800, height: 600, legacy: false }, GC_MODE: N.AUTO, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: C.CLAMP, SCALE_MODE: R.LINEAR, PRECISION_VERTEX: L.HIGH, PRECISION_FRAGMENT: U.apple.device ? L.HIGH : L.MEDIUM, CAN_UPLOAD_SAME_BUFFER: !U.apple.device, CREATE_IMAGE_BITMAP: false, ROUND_PIXELS: false };
}, function(t, e, i) {
  i.d(e, "a", function() {
    return s;
  }), i.d(e, "b", function() {
    return P;
  }), i.d(e, "c", function() {
    return R;
  }), i.d(e, "d", function() {
    return C;
  });
  var n = i(4), r = i(1), o = i(3);
  /*!
   * @pixi/display - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  n.b.SORTABLE_CHILDREN = false;
  var s = function() {
    function t2() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return t2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, t2.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, t2.prototype.getRectangle = function(t3) {
      return this.minX > this.maxX || this.minY > this.maxY ? r.j.EMPTY : ((t3 = t3 || new r.j(0, 0, 1, 1)).x = this.minX, t3.y = this.minY, t3.width = this.maxX - this.minX, t3.height = this.maxY - this.minY, t3);
    }, t2.prototype.addPoint = function(t3) {
      this.minX = Math.min(this.minX, t3.x), this.maxX = Math.max(this.maxX, t3.x), this.minY = Math.min(this.minY, t3.y), this.maxY = Math.max(this.maxY, t3.y);
    }, t2.prototype.addPointMatrix = function(t3, e2) {
      var i2 = t3.a, n2 = t3.b, r2 = t3.c, o2 = t3.d, s2 = t3.tx, a2 = t3.ty, l2 = i2 * e2.x + r2 * e2.y + s2, h2 = n2 * e2.x + o2 * e2.y + a2;
      this.minX = Math.min(this.minX, l2), this.maxX = Math.max(this.maxX, l2), this.minY = Math.min(this.minY, h2), this.maxY = Math.max(this.maxY, h2);
    }, t2.prototype.addQuad = function(t3) {
      var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY, o2 = t3[0], s2 = t3[1];
      e2 = o2 < e2 ? o2 : e2, i2 = s2 < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[2]) < e2 ? o2 : e2, i2 = (s2 = t3[3]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[4]) < e2 ? o2 : e2, i2 = (s2 = t3[5]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[6]) < e2 ? o2 : e2, i2 = (s2 = t3[7]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, this.minX = e2, this.minY = i2, this.maxX = n2, this.maxY = r2;
    }, t2.prototype.addFrame = function(t3, e2, i2, n2, r2) {
      this.addFrameMatrix(t3.worldTransform, e2, i2, n2, r2);
    }, t2.prototype.addFrameMatrix = function(t3, e2, i2, n2, r2) {
      var o2 = t3.a, s2 = t3.b, a2 = t3.c, l2 = t3.d, h2 = t3.tx, u2 = t3.ty, c2 = this.minX, d2 = this.minY, p2 = this.maxX, f2 = this.maxY, m2 = o2 * e2 + a2 * i2 + h2, g2 = s2 * e2 + l2 * i2 + u2;
      c2 = m2 < c2 ? m2 : c2, d2 = g2 < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * i2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * i2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * e2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * e2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, this.minX = c2, this.minY = d2, this.maxX = p2, this.maxY = f2;
    }, t2.prototype.addVertexData = function(t3, e2, i2) {
      for (var n2 = this.minX, r2 = this.minY, o2 = this.maxX, s2 = this.maxY, a2 = e2; a2 < i2; a2 += 2) {
        var l2 = t3[a2], h2 = t3[a2 + 1];
        n2 = l2 < n2 ? l2 : n2, r2 = h2 < r2 ? h2 : r2, o2 = l2 > o2 ? l2 : o2, s2 = h2 > s2 ? h2 : s2;
      }
      this.minX = n2, this.minY = r2, this.maxX = o2, this.maxY = s2;
    }, t2.prototype.addVertices = function(t3, e2, i2, n2) {
      this.addVerticesMatrix(t3.worldTransform, e2, i2, n2);
    }, t2.prototype.addVerticesMatrix = function(t3, e2, i2, n2, r2, o2) {
      r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = r2);
      for (var s2 = t3.a, a2 = t3.b, l2 = t3.c, h2 = t3.d, u2 = t3.tx, c2 = t3.ty, d2 = this.minX, p2 = this.minY, f2 = this.maxX, m2 = this.maxY, g2 = i2; g2 < n2; g2 += 2) {
        var v2 = e2[g2], _2 = e2[g2 + 1], y2 = s2 * v2 + l2 * _2 + u2, x2 = h2 * _2 + a2 * v2 + c2;
        d2 = Math.min(d2, y2 - r2), f2 = Math.max(f2, y2 + r2), p2 = Math.min(p2, x2 - o2), m2 = Math.max(m2, x2 + o2);
      }
      this.minX = d2, this.minY = p2, this.maxX = f2, this.maxY = m2;
    }, t2.prototype.addBounds = function(t3) {
      var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY;
      this.minX = t3.minX < e2 ? t3.minX : e2, this.minY = t3.minY < i2 ? t3.minY : i2, this.maxX = t3.maxX > n2 ? t3.maxX : n2, this.maxY = t3.maxY > r2 ? t3.maxY : r2;
    }, t2.prototype.addBoundsMask = function(t3, e2) {
      var i2 = t3.minX > e2.minX ? t3.minX : e2.minX, n2 = t3.minY > e2.minY ? t3.minY : e2.minY, r2 = t3.maxX < e2.maxX ? t3.maxX : e2.maxX, o2 = t3.maxY < e2.maxY ? t3.maxY : e2.maxY;
      if (i2 <= r2 && n2 <= o2) {
        var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
        this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
      }
    }, t2.prototype.addBoundsMatrix = function(t3, e2) {
      this.addFrameMatrix(e2, t3.minX, t3.minY, t3.maxX, t3.maxY);
    }, t2.prototype.addBoundsArea = function(t3, e2) {
      var i2 = t3.minX > e2.x ? t3.minX : e2.x, n2 = t3.minY > e2.y ? t3.minY : e2.y, r2 = t3.maxX < e2.x + e2.width ? t3.maxX : e2.x + e2.width, o2 = t3.maxY < e2.y + e2.height ? t3.maxY : e2.y + e2.height;
      if (i2 <= r2 && n2 <= o2) {
        var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
        this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
      }
    }, t2.prototype.pad = function(t3, e2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = t3), this.isEmpty() || (this.minX -= t3, this.maxX += t3, this.minY -= e2, this.maxY += e2);
    }, t2.prototype.addFramePad = function(t3, e2, i2, n2, r2, o2) {
      t3 -= r2, e2 -= o2, i2 += r2, n2 += o2, this.minX = this.minX < t3 ? this.minX : t3, this.maxX = this.maxX > i2 ? this.maxX : i2, this.minY = this.minY < e2 ? this.minY : e2, this.maxY = this.maxY > n2 ? this.maxY : n2;
    }, t2;
  }(), a = function(t2, e2) {
    return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function l(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    a(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var h, u, c, d, p, f, m, g, v, _, y, x, b, T, E, S, w, A, M, R = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.tempDisplayObjectParent = null, e3.transform = new r.m(), e3.alpha = 1, e3.visible = true, e3.renderable = true, e3.cullable = false, e3.cullArea = null, e3.parent = null, e3.worldAlpha = 1, e3._lastSortedIndex = 0, e3._zIndex = 0, e3.filterArea = null, e3.filters = null, e3._enabledFilters = null, e3._bounds = new s(), e3._localBounds = null, e3._boundsID = 0, e3._boundsRect = null, e3._localBoundsRect = null, e3._mask = null, e3._maskRefCount = 0, e3._destroyed = false, e3.isSprite = false, e3.isMask = false, e3;
    }
    return l(e2, t2), e2.mixin = function(t3) {
      for (var i2 = Object.keys(t3), n2 = 0; n2 < i2.length; ++n2) {
        var r2 = i2[n2];
        Object.defineProperty(e2.prototype, r2, Object.getOwnPropertyDescriptor(t3, r2));
      }
    }, Object.defineProperty(e2.prototype, "destroyed", { get: function() {
      return this._destroyed;
    }, enumerable: false, configurable: true }), e2.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, e2.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, e2.prototype.getBounds = function(t3, e3) {
      return t3 || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e3 || (this._boundsRect || (this._boundsRect = new r.j()), e3 = this._boundsRect), this._bounds.getRectangle(e3);
    }, e2.prototype.getLocalBounds = function(t3) {
      t3 || (this._localBoundsRect || (this._localBoundsRect = new r.j()), t3 = this._localBoundsRect), this._localBounds || (this._localBounds = new s());
      var e3 = this.transform, i2 = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var n2 = this._bounds, o2 = this._boundsID;
      this._bounds = this._localBounds;
      var a2 = this.getBounds(false, t3);
      return this.parent = i2, this.transform = e3, this._bounds = n2, this._bounds.updateID += this._boundsID - o2, a2;
    }, e2.prototype.toGlobal = function(t3, e3, i2) {
      return i2 === void 0 && (i2 = false), i2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t3, e3);
    }, e2.prototype.toLocal = function(t3, e3, i2, n2) {
      return e3 && (t3 = e3.toGlobal(t3, i2, n2)), n2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t3, i2);
    }, e2.prototype.setParent = function(t3) {
      if (!t3 || !t3.addChild)
        throw new Error("setParent: Argument must be a Container");
      return t3.addChild(this), t3;
    }, e2.prototype.setTransform = function(t3, e3, i2, n2, r2, o2, s2, a2, l2) {
      return t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = 0), i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = 1), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = 0), s2 === void 0 && (s2 = 0), a2 === void 0 && (a2 = 0), l2 === void 0 && (l2 = 0), this.position.x = t3, this.position.y = e3, this.scale.x = i2 || 1, this.scale.y = n2 || 1, this.rotation = r2, this.skew.x = o2, this.skew.y = s2, this.pivot.x = a2, this.pivot.y = l2, this;
    }, e2.prototype.destroy = function(t3) {
      this.parent && this.parent.removeChild(this), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(e2.prototype, "_tempDisplayObjectParent", { get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new C()), this.tempDisplayObjectParent;
    }, enumerable: false, configurable: true }), e2.prototype.enableTempParent = function() {
      var t3 = this.parent;
      return this.parent = this._tempDisplayObjectParent, t3;
    }, e2.prototype.disableTempParent = function(t3) {
      this.parent = t3;
    }, Object.defineProperty(e2.prototype, "x", { get: function() {
      return this.position.x;
    }, set: function(t3) {
      this.transform.position.x = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "y", { get: function() {
      return this.position.y;
    }, set: function(t3) {
      this.transform.position.y = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldTransform", { get: function() {
      return this.transform.worldTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "localTransform", { get: function() {
      return this.transform.localTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "position", { get: function() {
      return this.transform.position;
    }, set: function(t3) {
      this.transform.position.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scale", { get: function() {
      return this.transform.scale;
    }, set: function(t3) {
      this.transform.scale.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "pivot", { get: function() {
      return this.transform.pivot;
    }, set: function(t3) {
      this.transform.pivot.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "skew", { get: function() {
      return this.transform.skew;
    }, set: function(t3) {
      this.transform.skew.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotation", { get: function() {
      return this.transform.rotation;
    }, set: function(t3) {
      this.transform.rotation = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "angle", { get: function() {
      return this.transform.rotation * r.i;
    }, set: function(t3) {
      this.transform.rotation = t3 * r.b;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "zIndex", { get: function() {
      return this._zIndex;
    }, set: function(t3) {
      this._zIndex = t3, this.parent && (this.parent.sortDirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldVisible", { get: function() {
      var t3 = this;
      do {
        if (!t3.visible)
          return false;
        t3 = t3.parent;
      } while (t3);
      return true;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mask", { get: function() {
      return this._mask;
    }, set: function(t3) {
      if (this._mask !== t3) {
        var e3;
        if (this._mask)
          (e3 = this._mask.maskObject || this._mask)._maskRefCount--, e3._maskRefCount === 0 && (e3.renderable = true, e3.isMask = false);
        if (this._mask = t3, this._mask)
          (e3 = this._mask.maskObject || this._mask)._maskRefCount === 0 && (e3.renderable = false, e3.isMask = true), e3._maskRefCount++;
      }
    }, enumerable: false, configurable: true }), e2;
  }(o.EventEmitter), C = function(t2) {
    function e2() {
      var e3 = t2 !== null && t2.apply(this, arguments) || this;
      return e3.sortDirty = null, e3;
    }
    return l(e2, t2), e2;
  }(R);
  function I(t2, e2) {
    return t2.zIndex === e2.zIndex ? t2._lastSortedIndex - e2._lastSortedIndex : t2.zIndex - e2.zIndex;
  }
  R.prototype.displayObjectUpdateTransform = R.prototype.updateTransform, function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(h || (h = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(u || (u = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(c || (c = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(d || (d = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(p || (p = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(f || (f = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(m || (m = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(g || (g = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(v || (v = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(_ || (_ = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(y || (y = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(x || (x = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(b || (b = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(T || (T = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(E || (E = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(S || (S = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(w || (w = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(A || (A = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(M || (M = {}));
  var P = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.children = [], e3.sortableChildren = n.b.SORTABLE_CHILDREN, e3.sortDirty = false, e3;
    }
    return l(e2, t2), e2.prototype.onChildrenChange = function(t3) {
    }, e2.prototype.addChild = function() {
      for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++)
        e3[i2] = t3[i2];
      if (e3.length > 1)
        for (var n2 = 0; n2 < e3.length; n2++)
          this.addChild(e3[n2]);
      else {
        var r2 = e3[0];
        r2.parent && r2.parent.removeChild(r2), r2.parent = this, this.sortDirty = true, r2.transform._parentID = -1, this.children.push(r2), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r2, this, this.children.length - 1), r2.emit("added", this);
      }
      return e3[0];
    }, e2.prototype.addChildAt = function(t3, e3) {
      if (e3 < 0 || e3 > this.children.length)
        throw new Error(t3 + "addChildAt: The index " + e3 + " supplied is out of bounds " + this.children.length);
      return t3.parent && t3.parent.removeChild(t3), t3.parent = this, this.sortDirty = true, t3.transform._parentID = -1, this.children.splice(e3, 0, t3), this._boundsID++, this.onChildrenChange(e3), t3.emit("added", this), this.emit("childAdded", t3, this, e3), t3;
    }, e2.prototype.swapChildren = function(t3, e3) {
      if (t3 !== e3) {
        var i2 = this.getChildIndex(t3), n2 = this.getChildIndex(e3);
        this.children[i2] = e3, this.children[n2] = t3, this.onChildrenChange(i2 < n2 ? i2 : n2);
      }
    }, e2.prototype.getChildIndex = function(t3) {
      var e3 = this.children.indexOf(t3);
      if (e3 === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return e3;
    }, e2.prototype.setChildIndex = function(t3, e3) {
      if (e3 < 0 || e3 >= this.children.length)
        throw new Error("The index " + e3 + " supplied is out of bounds " + this.children.length);
      var i2 = this.getChildIndex(t3);
      Object(o.removeItems)(this.children, i2, 1), this.children.splice(e3, 0, t3), this.onChildrenChange(e3);
    }, e2.prototype.getChildAt = function(t3) {
      if (t3 < 0 || t3 >= this.children.length)
        throw new Error("getChildAt: Index (" + t3 + ") does not exist.");
      return this.children[t3];
    }, e2.prototype.removeChild = function() {
      for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++)
        e3[i2] = t3[i2];
      if (e3.length > 1)
        for (var n2 = 0; n2 < e3.length; n2++)
          this.removeChild(e3[n2]);
      else {
        var r2 = e3[0], s2 = this.children.indexOf(r2);
        if (s2 === -1)
          return null;
        r2.parent = null, r2.transform._parentID = -1, Object(o.removeItems)(this.children, s2, 1), this._boundsID++, this.onChildrenChange(s2), r2.emit("removed", this), this.emit("childRemoved", r2, this, s2);
      }
      return e3[0];
    }, e2.prototype.removeChildAt = function(t3) {
      var e3 = this.getChildAt(t3);
      return e3.parent = null, e3.transform._parentID = -1, Object(o.removeItems)(this.children, t3, 1), this._boundsID++, this.onChildrenChange(t3), e3.emit("removed", this), this.emit("childRemoved", e3, this, t3), e3;
    }, e2.prototype.removeChildren = function(t3, e3) {
      t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = this.children.length);
      var i2, n2 = t3, r2 = e3 - n2;
      if (r2 > 0 && r2 <= e3) {
        i2 = this.children.splice(n2, r2);
        for (var o2 = 0; o2 < i2.length; ++o2)
          i2[o2].parent = null, i2[o2].transform && (i2[o2].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(t3);
        for (o2 = 0; o2 < i2.length; ++o2)
          i2[o2].emit("removed", this), this.emit("childRemoved", i2[o2], this, o2);
        return i2;
      }
      if (r2 === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, e2.prototype.sortChildren = function() {
      for (var t3 = false, e3 = 0, i2 = this.children.length; e3 < i2; ++e3) {
        var n2 = this.children[e3];
        n2._lastSortedIndex = e3, t3 || n2.zIndex === 0 || (t3 = true);
      }
      t3 && this.children.length > 1 && this.children.sort(I), this.sortDirty = false;
    }, e2.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var t3 = 0, e3 = this.children.length; t3 < e3; ++t3) {
        var i2 = this.children[t3];
        i2.visible && i2.updateTransform();
      }
    }, e2.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var t3 = 0; t3 < this.children.length; t3++) {
        var e3 = this.children[t3];
        if (e3.visible && e3.renderable)
          if (e3.calculateBounds(), e3._mask) {
            var i2 = e3._mask.maskObject || e3._mask;
            i2.calculateBounds(), this._bounds.addBoundsMask(e3._bounds, i2._bounds);
          } else
            e3.filterArea ? this._bounds.addBoundsArea(e3._bounds, e3.filterArea) : this._bounds.addBounds(e3._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, e2.prototype.getLocalBounds = function(e3, i2) {
      i2 === void 0 && (i2 = false);
      var n2 = t2.prototype.getLocalBounds.call(this, e3);
      if (!i2)
        for (var r2 = 0, o2 = this.children.length; r2 < o2; ++r2) {
          var s2 = this.children[r2];
          s2.visible && s2.updateTransform();
        }
      return n2;
    }, e2.prototype._calculateBounds = function() {
    }, e2.prototype._renderWithCulling = function(t3) {
      var i2 = t3.renderTexture.sourceFrame;
      if (i2.width > 0 && i2.height > 0) {
        var n2, r2;
        if (this.cullArea ? (n2 = this.cullArea, r2 = this.worldTransform) : this._render !== e2.prototype._render && (n2 = this.getBounds(true)), n2 && i2.intersects(n2, r2))
          this._render(t3);
        else if (this.cullArea)
          return;
        for (var o2 = 0, s2 = this.children.length; o2 < s2; ++o2) {
          var a2 = this.children[o2], l2 = a2.cullable;
          a2.cullable = l2 || !this.cullArea, a2.render(t3), a2.cullable = l2;
        }
      }
    }, e2.prototype.render = function(t3) {
      if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(t3);
        else if (this.cullable)
          this._renderWithCulling(t3);
        else {
          this._render(t3);
          for (var e3 = 0, i2 = this.children.length; e3 < i2; ++e3)
            this.children[e3].render(t3);
        }
    }, e2.prototype.renderAdvanced = function(t3) {
      var e3 = this.filters, i2 = this._mask;
      if (e3) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var n2 = 0; n2 < e3.length; n2++)
          e3[n2].enabled && this._enabledFilters.push(e3[n2]);
      }
      var r2 = e3 && this._enabledFilters && this._enabledFilters.length || i2 && (!i2.isMaskData || i2.enabled && (i2.autoDetect || i2.type !== w.NONE));
      if (r2 && t3.batch.flush(), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.push(this, this._enabledFilters), i2 && t3.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(t3);
      else {
        this._render(t3);
        n2 = 0;
        for (var o2 = this.children.length; n2 < o2; ++n2)
          this.children[n2].render(t3);
      }
      r2 && t3.batch.flush(), i2 && t3.mask.pop(this), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.pop();
    }, e2.prototype._render = function(t3) {
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this), this.sortDirty = false;
      var i2 = typeof e3 == "boolean" ? e3 : e3 && e3.children, n2 = this.removeChildren(0, this.children.length);
      if (i2)
        for (var r2 = 0; r2 < n2.length; ++r2)
          n2[r2].destroy(e3);
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.scale.x * this.getLocalBounds().width;
    }, set: function(t3) {
      var e3 = this.getLocalBounds().width;
      this.scale.x = e3 !== 0 ? t3 / e3 : 1, this._width = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.scale.y * this.getLocalBounds().height;
    }, set: function(t3) {
      var e3 = this.getLocalBounds().height;
      this.scale.y = e3 !== 0 ? t3 / e3 : 1, this._height = t3;
    }, enumerable: false, configurable: true }), e2;
  }(R);
  P.prototype.containerUpdateTransform = P.prototype.updateTransform;
}, function(t, e, i) {
  var n = Object.prototype.hasOwnProperty, r = "~";
  function o() {
  }
  function s(t2, e2, i2) {
    this.fn = t2, this.context = e2, this.once = i2 || false;
  }
  function a(t2, e2, i2, n2, o2) {
    if (typeof i2 != "function")
      throw new TypeError("The listener must be a function");
    var a2 = new s(i2, n2 || t2, o2), l2 = r ? r + e2 : e2;
    return t2._events[l2] ? t2._events[l2].fn ? t2._events[l2] = [t2._events[l2], a2] : t2._events[l2].push(a2) : (t2._events[l2] = a2, t2._eventsCount++), t2;
  }
  function l(t2, e2) {
    --t2._eventsCount == 0 ? t2._events = new o() : delete t2._events[e2];
  }
  function h() {
    this._events = new o(), this._eventsCount = 0;
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (r = false)), h.prototype.eventNames = function() {
    var t2, e2, i2 = [];
    if (this._eventsCount === 0)
      return i2;
    for (e2 in t2 = this._events)
      n.call(t2, e2) && i2.push(r ? e2.slice(1) : e2);
    return Object.getOwnPropertySymbols ? i2.concat(Object.getOwnPropertySymbols(t2)) : i2;
  }, h.prototype.listeners = function(t2) {
    var e2 = r ? r + t2 : t2, i2 = this._events[e2];
    if (!i2)
      return [];
    if (i2.fn)
      return [i2.fn];
    for (var n2 = 0, o2 = i2.length, s2 = new Array(o2); n2 < o2; n2++)
      s2[n2] = i2[n2].fn;
    return s2;
  }, h.prototype.listenerCount = function(t2) {
    var e2 = r ? r + t2 : t2, i2 = this._events[e2];
    return i2 ? i2.fn ? 1 : i2.length : 0;
  }, h.prototype.emit = function(t2, e2, i2, n2, o2, s2) {
    var a2 = r ? r + t2 : t2;
    if (!this._events[a2])
      return false;
    var l2, h2, u = this._events[a2], c = arguments.length;
    if (u.fn) {
      switch (u.once && this.removeListener(t2, u.fn, void 0, true), c) {
        case 1:
          return u.fn.call(u.context), true;
        case 2:
          return u.fn.call(u.context, e2), true;
        case 3:
          return u.fn.call(u.context, e2, i2), true;
        case 4:
          return u.fn.call(u.context, e2, i2, n2), true;
        case 5:
          return u.fn.call(u.context, e2, i2, n2, o2), true;
        case 6:
          return u.fn.call(u.context, e2, i2, n2, o2, s2), true;
      }
      for (h2 = 1, l2 = new Array(c - 1); h2 < c; h2++)
        l2[h2 - 1] = arguments[h2];
      u.fn.apply(u.context, l2);
    } else {
      var d, p = u.length;
      for (h2 = 0; h2 < p; h2++)
        switch (u[h2].once && this.removeListener(t2, u[h2].fn, void 0, true), c) {
          case 1:
            u[h2].fn.call(u[h2].context);
            break;
          case 2:
            u[h2].fn.call(u[h2].context, e2);
            break;
          case 3:
            u[h2].fn.call(u[h2].context, e2, i2);
            break;
          case 4:
            u[h2].fn.call(u[h2].context, e2, i2, n2);
            break;
          default:
            if (!l2)
              for (d = 1, l2 = new Array(c - 1); d < c; d++)
                l2[d - 1] = arguments[d];
            u[h2].fn.apply(u[h2].context, l2);
        }
    }
    return true;
  }, h.prototype.on = function(t2, e2, i2) {
    return a(this, t2, e2, i2, false);
  }, h.prototype.once = function(t2, e2, i2) {
    return a(this, t2, e2, i2, true);
  }, h.prototype.removeListener = function(t2, e2, i2, n2) {
    var o2 = r ? r + t2 : t2;
    if (!this._events[o2])
      return this;
    if (!e2)
      return l(this, o2), this;
    var s2 = this._events[o2];
    if (s2.fn)
      s2.fn !== e2 || n2 && !s2.once || i2 && s2.context !== i2 || l(this, o2);
    else {
      for (var a2 = 0, h2 = [], u = s2.length; a2 < u; a2++)
        (s2[a2].fn !== e2 || n2 && !s2[a2].once || i2 && s2[a2].context !== i2) && h2.push(s2[a2]);
      h2.length ? this._events[o2] = h2.length === 1 ? h2[0] : h2 : l(this, o2);
    }
    return this;
  }, h.prototype.removeAllListeners = function(t2) {
    var e2;
    return t2 ? (e2 = r ? r + t2 : t2, this._events[e2] && l(this, e2)) : (this._events = new o(), this._eventsCount = 0), this;
  }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = r, h.EventEmitter = h, t.exports = h;
}, function(t, e, i) {
  i.d(e, "a", function() {
    return s;
  }), i.d(e, "b", function() {
    return a;
  }), i.d(e, "c", function() {
    return n;
  });
  var n, r = i(4);
  /*!
   * @pixi/ticker - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  r.b.TARGET_FPMS = 0.06, function(t2) {
    t2[t2.INTERACTION = 50] = "INTERACTION", t2[t2.HIGH = 25] = "HIGH", t2[t2.NORMAL = 0] = "NORMAL", t2[t2.LOW = -25] = "LOW", t2[t2.UTILITY = -50] = "UTILITY";
  }(n || (n = {}));
  var o = function() {
    function t2(t3, e2, i2, n2) {
      e2 === void 0 && (e2 = null), i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = t3, this.context = e2, this.priority = i2, this.once = n2;
    }
    return t2.prototype.match = function(t3, e2) {
      return e2 === void 0 && (e2 = null), this.fn === t3 && this.context === e2;
    }, t2.prototype.emit = function(t3) {
      this.fn && (this.context ? this.fn.call(this.context, t3) : this.fn(t3));
      var e2 = this.next;
      return this.once && this.destroy(true), this._destroyed && (this.next = null), e2;
    }, t2.prototype.connect = function(t3) {
      this.previous = t3, t3.next && (t3.next.previous = this), this.next = t3.next, t3.next = this;
    }, t2.prototype.destroy = function(t3) {
      t3 === void 0 && (t3 = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e2 = this.next;
      return this.next = t3 ? null : e2, this.previous = null, e2;
    }, t2;
  }(), s = function() {
    function t2() {
      var t3 = this;
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new o(null, null, 1 / 0), this.deltaMS = 1 / r.b.TARGET_FPMS, this.elapsedMS = 1 / r.b.TARGET_FPMS, this._tick = function(e2) {
        t3._requestId = null, t3.started && (t3.update(e2), t3.started && t3._requestId === null && t3._head.next && (t3._requestId = requestAnimationFrame(t3._tick)));
      };
    }
    return t2.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, t2.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, t2.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, t2.prototype.add = function(t3, e2, i2) {
      return i2 === void 0 && (i2 = n.NORMAL), this._addListener(new o(t3, e2, i2));
    }, t2.prototype.addOnce = function(t3, e2, i2) {
      return i2 === void 0 && (i2 = n.NORMAL), this._addListener(new o(t3, e2, i2, true));
    }, t2.prototype._addListener = function(t3) {
      var e2 = this._head.next, i2 = this._head;
      if (e2) {
        for (; e2; ) {
          if (t3.priority > e2.priority) {
            t3.connect(i2);
            break;
          }
          i2 = e2, e2 = e2.next;
        }
        t3.previous || t3.connect(i2);
      } else
        t3.connect(i2);
      return this._startIfPossible(), this;
    }, t2.prototype.remove = function(t3, e2) {
      for (var i2 = this._head.next; i2; )
        i2 = i2.match(t3, e2) ? i2.destroy() : i2.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(t2.prototype, "count", { get: function() {
      if (!this._head)
        return 0;
      for (var t3 = 0, e2 = this._head; e2 = e2.next; )
        t3++;
      return t3;
    }, enumerable: false, configurable: true }), t2.prototype.start = function() {
      this.started || (this.started = true, this._requestIfNeeded());
    }, t2.prototype.stop = function() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }, t2.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t3 = this._head.next; t3; )
          t3 = t3.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }, t2.prototype.update = function(t3) {
      var e2;
      if (t3 === void 0 && (t3 = performance.now()), t3 > this.lastTime) {
        if ((e2 = this.elapsedMS = t3 - this.lastTime) > this._maxElapsedMS && (e2 = this._maxElapsedMS), e2 *= this.speed, this._minElapsedMS) {
          var i2 = t3 - this._lastFrame | 0;
          if (i2 < this._minElapsedMS)
            return;
          this._lastFrame = t3 - i2 % this._minElapsedMS;
        }
        this.deltaMS = e2, this.deltaTime = this.deltaMS * r.b.TARGET_FPMS;
        for (var n2 = this._head, o2 = n2.next; o2; )
          o2 = o2.emit(this.deltaTime);
        n2.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t3;
    }, Object.defineProperty(t2.prototype, "FPS", { get: function() {
      return 1e3 / this.elapsedMS;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "minFPS", { get: function() {
      return 1e3 / this._maxElapsedMS;
    }, set: function(t3) {
      var e2 = Math.min(this.maxFPS, t3), i2 = Math.min(Math.max(0, e2) / 1e3, r.b.TARGET_FPMS);
      this._maxElapsedMS = 1 / i2;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "maxFPS", { get: function() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }, set: function(t3) {
      if (t3 === 0)
        this._minElapsedMS = 0;
      else {
        var e2 = Math.max(this.minFPS, t3);
        this._minElapsedMS = 1 / (e2 / 1e3);
      }
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "shared", { get: function() {
      if (!t2._shared) {
        var e2 = t2._shared = new t2();
        e2.autoStart = true, e2._protected = true;
      }
      return t2._shared;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "system", { get: function() {
      if (!t2._system) {
        var e2 = t2._system = new t2();
        e2.autoStart = true, e2._protected = true;
      }
      return t2._system;
    }, enumerable: false, configurable: true }), t2;
  }(), a = function() {
    function t2() {
    }
    return t2.init = function(t3) {
      var e2 = this;
      t3 = Object.assign({ autoStart: true, sharedTicker: false }, t3), Object.defineProperty(this, "ticker", { set: function(t4) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = t4, t4 && t4.add(this.render, this, n.LOW);
      }, get: function() {
        return this._ticker;
      } }), this.stop = function() {
        e2._ticker.stop();
      }, this.start = function() {
        e2._ticker.start();
      }, this._ticker = null, this.ticker = t3.sharedTicker ? s.shared : new s(), t3.autoStart && this.start();
    }, t2.destroy = function() {
      if (this._ticker) {
        var t3 = this._ticker;
        this.ticker = null, t3.destroy();
      }
    }, t2;
  }();
}, function(t, e, i) {
  i.d(e, "a", function() {
    return f;
  }), i.d(e, "b", function() {
    return g;
  }), i.d(e, "c", function() {
    return m;
  });
  var n = i(2), r = i(1), o = i(0), s = i(5), a = i(4), l = i(3), h = function(t2, e2) {
    return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function u(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    h(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var c = function() {
    function t2(t3, e2) {
      this.uvBuffer = t3, this.uvMatrix = e2, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return t2.prototype.update = function(t3) {
      if (t3 || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e2 = this.uvBuffer.data;
        this.data && this.data.length === e2.length || (this.data = new Float32Array(e2.length)), this.uvMatrix.multiplyUvs(e2, this.data), this._updateID++;
      }
    }, t2;
  }(), d = new r.g(), p = new r.h(), f = function(t2) {
    function e2(e3, i2, r2, s2) {
      s2 === void 0 && (s2 = o.f.TRIANGLES);
      var l2 = t2.call(this) || this;
      return l2.geometry = e3, l2.shader = i2, l2.state = r2 || n.s.for2d(), l2.drawMode = s2, l2.start = 0, l2.size = 0, l2.uvs = null, l2.indices = null, l2.vertexData = new Float32Array(1), l2.vertexDirty = -1, l2._transformID = -1, l2._roundPixels = a.b.ROUND_PIXELS, l2.batchUvs = null, l2;
    }
    return u(e2, t2), Object.defineProperty(e2.prototype, "geometry", { get: function() {
      return this._geometry;
    }, set: function(t3) {
      this._geometry !== t3 && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = t3, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "uvBuffer", { get: function() {
      return this.geometry.buffers[1];
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "verticesBuffer", { get: function() {
      return this.geometry.buffers[0];
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "material", { get: function() {
      return this.shader;
    }, set: function(t3) {
      this.shader = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t3) {
      this.state.blendMode = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t3) {
      this._roundPixels !== t3 && (this._transformID = -1), this._roundPixels = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    }, set: function(t3) {
      this.shader.tint = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "texture", { get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    }, set: function(t3) {
      this.shader.texture = t3;
    }, enumerable: false, configurable: true }), e2.prototype._render = function(t3) {
      var i2 = this.geometry.buffers[0].data;
      this.shader.batchable && this.drawMode === o.f.TRIANGLES && i2.length < 2 * e2.BATCHABLE_SIZE ? this._renderToBatch(t3) : this._renderDefault(t3);
    }, e2.prototype._renderDefault = function(t3) {
      var e3 = this.shader;
      e3.alpha = this.worldAlpha, e3.update && e3.update(), t3.batch.flush(), e3.uniforms.translationMatrix = this.transform.worldTransform.toArray(true), t3.shader.bind(e3), t3.state.set(this.state), t3.geometry.bind(this.geometry, e3), t3.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, e2.prototype._renderToBatch = function(t3) {
      var e3 = this.geometry, i2 = this.shader;
      i2.uvMatrix && (i2.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e3.indexBuffer.data, this._tintRGB = i2._tintRGB, this._texture = i2.texture;
      var n2 = this.material.pluginName;
      t3.batch.setObjectRenderer(t3.plugins[n2]), t3.plugins[n2].render(this);
    }, e2.prototype.calculateVertices = function() {
      var t3 = this.geometry.buffers[0], e3 = t3.data, i2 = t3._updateID;
      if (i2 !== this.vertexDirty || this._transformID !== this.transform._worldID) {
        this._transformID = this.transform._worldID, this.vertexData.length !== e3.length && (this.vertexData = new Float32Array(e3.length));
        for (var n2 = this.transform.worldTransform, r2 = n2.a, o2 = n2.b, s2 = n2.c, l2 = n2.d, h2 = n2.tx, u2 = n2.ty, c2 = this.vertexData, d2 = 0; d2 < c2.length / 2; d2++) {
          var p2 = e3[2 * d2], f2 = e3[2 * d2 + 1];
          c2[2 * d2] = r2 * p2 + s2 * f2 + h2, c2[2 * d2 + 1] = o2 * p2 + l2 * f2 + u2;
        }
        if (this._roundPixels) {
          var m2 = a.b.RESOLUTION;
          for (d2 = 0; d2 < c2.length; ++d2)
            c2[d2] = Math.round((c2[d2] * m2 | 0) / m2);
        }
        this.vertexDirty = i2;
      }
    }, e2.prototype.calculateUvs = function() {
      var t3 = this.geometry.buffers[1], e3 = this.shader;
      e3.uvMatrix.isSimple ? this.uvs = t3.data : (this.batchUvs || (this.batchUvs = new c(t3, e3.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, e2.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, e2.prototype.containsPoint = function(t3) {
      if (!this.getBounds().contains(t3.x, t3.y))
        return false;
      this.worldTransform.applyInverse(t3, d);
      for (var e3 = this.geometry.getBuffer("aVertexPosition").data, i2 = p.points, n2 = this.geometry.getIndex().data, r2 = n2.length, o2 = this.drawMode === 4 ? 3 : 1, s2 = 0; s2 + 2 < r2; s2 += o2) {
        var a2 = 2 * n2[s2], l2 = 2 * n2[s2 + 1], h2 = 2 * n2[s2 + 2];
        if (i2[0] = e3[a2], i2[1] = e3[a2 + 1], i2[2] = e3[l2], i2[3] = e3[l2 + 1], i2[4] = e3[h2], i2[5] = e3[h2 + 1], p.contains(d.x, d.y))
          return true;
      }
      return false;
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this, e3), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, e2.BATCHABLE_SIZE = 100, e2;
  }(s.b), m = function(t2) {
    function e2(e3, i2) {
      var o2 = this, s2 = { uSampler: e3, alpha: 1, uTextureMatrix: r.d.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) };
      return (i2 = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, i2)).uniforms && Object.assign(s2, i2.uniforms), (o2 = t2.call(this, i2.program || n.n.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), s2) || this)._colorDirty = false, o2.uvMatrix = new n.u(e3), o2.batchable = i2.program === void 0, o2.pluginName = i2.pluginName, o2.tint = i2.tint, o2.alpha = i2.alpha, o2;
    }
    return u(e2, t2), Object.defineProperty(e2.prototype, "texture", { get: function() {
      return this.uniforms.uSampler;
    }, set: function(t3) {
      this.uniforms.uSampler !== t3 && (!this.uniforms.uSampler.baseTexture.alphaMode != !t3.baseTexture.alphaMode && (this._colorDirty = true), this.uniforms.uSampler = t3, this.uvMatrix.texture = t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "alpha", { get: function() {
      return this._alpha;
    }, set: function(t3) {
      t3 !== this._alpha && (this._alpha = t3, this._colorDirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t3) {
      t3 !== this._tint && (this._tint = t3, this._tintRGB = (t3 >> 16) + (65280 & t3) + ((255 & t3) << 16), this._colorDirty = true);
    }, enumerable: false, configurable: true }), e2.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = false;
        var t3 = this.texture.baseTexture;
        Object(l.premultiplyTintToRgba)(this._tint, this._alpha, this.uniforms.uColor, t3.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, e2;
  }(n.r), g = function(t2) {
    function e2(e3, i2, r2) {
      var s2 = t2.call(this) || this, a2 = new n.h(e3), l2 = new n.h(i2, true), h2 = new n.h(r2, true, true);
      return s2.addAttribute("aVertexPosition", a2, 2, false, o.r.FLOAT).addAttribute("aTextureCoord", l2, 2, false, o.r.FLOAT).addIndex(h2), s2._updateId = -1, s2;
    }
    return u(e2, t2), Object.defineProperty(e2.prototype, "vertexDirtyId", { get: function() {
      return this.buffers[0]._updateID;
    }, enumerable: false, configurable: true }), e2;
  }(n.l);
}, function(t, e) {
  t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
}, function(t, e, i) {
  i.d(e, "a", function() {
    return p;
  }), i.d(e, "b", function() {
    return f;
  });
  var n = i(2), r = i(3), o = i(1), s = i(0), a = i(4), l = function(t2, e2) {
    return (l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var h = function() {
    function t2(t3) {
      this._foundShapes = [], this.renderer = t3;
    }
    return t2.prototype.pushMask = function(t3) {
      var e2 = this.renderer, i2 = t3.maskObject || t3;
      e2.context.save();
      var n2 = this._foundShapes;
      if (this.recursiveFindShapes(i2, n2), n2.length > 0) {
        var r2 = e2.context;
        r2.beginPath();
        for (var o2 = 0; o2 < n2.length; o2++) {
          var s2 = n2[o2], a2 = s2.transform.worldTransform;
          this.renderer.setContextTransform(a2), this.renderGraphicsShape(s2);
        }
        n2.length = 0, r2.clip();
      }
    }, t2.prototype.recursiveFindShapes = function(t3, e2) {
      t3.geometry && t3.geometry.graphicsData && e2.push(t3);
      var i2 = t3.children;
      if (i2)
        for (var n2 = 0; n2 < i2.length; n2++)
          this.recursiveFindShapes(i2[n2], e2);
    }, t2.prototype.renderGraphicsShape = function(t3) {
      t3.finishPoly();
      var e2 = this.renderer.context, i2 = t3.geometry.graphicsData, n2 = i2.length;
      if (n2 !== 0)
        for (var r2 = 0; r2 < n2; r2++) {
          var s2 = i2[r2], a2 = s2.shape;
          if (a2.type === o.l.POLY) {
            var l2 = a2.points, h2 = s2.holes, u2 = void 0, c2 = void 0, d2 = void 0, p2 = void 0;
            e2.moveTo(l2[0], l2[1]);
            for (var f2 = 1; f2 < l2.length / 2; f2++)
              e2.lineTo(l2[2 * f2], l2[2 * f2 + 1]);
            if (h2.length > 0) {
              u2 = 0, d2 = l2[0], p2 = l2[1];
              for (f2 = 2; f2 + 2 < l2.length; f2 += 2)
                u2 += (l2[f2] - d2) * (l2[f2 + 3] - p2) - (l2[f2 + 2] - d2) * (l2[f2 + 1] - p2);
              for (var m2 = 0; m2 < h2.length; m2++)
                if (l2 = h2[m2].shape.points) {
                  c2 = 0, d2 = l2[0], p2 = l2[1];
                  for (f2 = 2; f2 + 2 < l2.length; f2 += 2)
                    c2 += (l2[f2] - d2) * (l2[f2 + 3] - p2) - (l2[f2 + 2] - d2) * (l2[f2 + 1] - p2);
                  if (c2 * u2 < 0) {
                    e2.moveTo(l2[0], l2[1]);
                    for (f2 = 2; f2 < l2.length; f2 += 2)
                      e2.lineTo(l2[f2], l2[f2 + 1]);
                  } else {
                    e2.moveTo(l2[l2.length - 2], l2[l2.length - 1]);
                    for (f2 = l2.length - 4; f2 >= 0; f2 -= 2)
                      e2.lineTo(l2[f2], l2[f2 + 1]);
                  }
                  h2[m2].shape.closeStroke && e2.closePath();
                }
            }
            l2[0] === l2[l2.length - 2] && l2[1] === l2[l2.length - 1] && e2.closePath();
          } else if (a2.type === o.l.RECT)
            e2.rect(a2.x, a2.y, a2.width, a2.height), e2.closePath();
          else if (a2.type === o.l.CIRC)
            e2.arc(a2.x, a2.y, a2.radius, 0, 2 * Math.PI), e2.closePath();
          else if (a2.type === o.l.ELIP) {
            var g = 2 * a2.width, v = 2 * a2.height, _ = a2.x - g / 2, y = a2.y - v / 2, x = g / 2 * 0.5522848, b = v / 2 * 0.5522848, T = _ + g, E = y + v, S = _ + g / 2, w = y + v / 2;
            e2.moveTo(_, w), e2.bezierCurveTo(_, w - b, S - x, y, S, y), e2.bezierCurveTo(S + x, y, T, w - b, T, w), e2.bezierCurveTo(T, w + b, S + x, E, S, E), e2.bezierCurveTo(S - x, E, _, w + b, _, w), e2.closePath();
          } else if (a2.type === o.l.RREC) {
            var A = a2.x, M = a2.y, R = a2.width, C = a2.height, I = a2.radius, P = Math.min(R, C) / 2;
            I = I > P ? P : I, e2.moveTo(A, M + I), e2.lineTo(A, M + C - I), e2.quadraticCurveTo(A, M + C, A + I, M + C), e2.lineTo(A + R - I, M + C), e2.quadraticCurveTo(A + R, M + C, A + R, M + C - I), e2.lineTo(A + R, M + I), e2.quadraticCurveTo(A + R, M, A + R - I, M), e2.lineTo(A + I, M), e2.quadraticCurveTo(A, M, A, M + I), e2.closePath();
          }
        }
    }, t2.prototype.popMask = function(t3) {
      t3.context.restore(), t3.invalidateBlendMode();
    }, t2.prototype.destroy = function() {
    }, t2;
  }();
  function u(t2) {
    var e2 = document.createElement("canvas");
    e2.width = 6, e2.height = 1;
    var i2 = e2.getContext("2d");
    return i2.fillStyle = t2, i2.fillRect(0, 0, 6, 1), e2;
  }
  function c() {
    if (typeof document == "undefined")
      return false;
    var t2 = u("#ff00ff"), e2 = u("#ffff00"), i2 = document.createElement("canvas");
    i2.width = 6, i2.height = 1;
    var n2 = i2.getContext("2d");
    n2.globalCompositeOperation = "multiply", n2.drawImage(t2, 0, 0), n2.drawImage(e2, 2, 0);
    var r2 = n2.getImageData(2, 0, 1, 1);
    if (!r2)
      return false;
    var o2 = r2.data;
    return o2[0] === 255 && o2[1] === 0 && o2[2] === 0;
  }
  var d = new o.d(), p = function(t2) {
    function e2(i2) {
      var n2, o2 = t2.call(this, s.n.CANVAS, i2) || this;
      if (o2.refresh = true, o2.maskManager = new h(o2), o2.smoothProperty = "imageSmoothingEnabled", o2.blendModes = (n2 === void 0 && (n2 = []), c() ? (n2[s.b.NORMAL] = "source-over", n2[s.b.ADD] = "lighter", n2[s.b.MULTIPLY] = "multiply", n2[s.b.SCREEN] = "screen", n2[s.b.OVERLAY] = "overlay", n2[s.b.DARKEN] = "darken", n2[s.b.LIGHTEN] = "lighten", n2[s.b.COLOR_DODGE] = "color-dodge", n2[s.b.COLOR_BURN] = "color-burn", n2[s.b.HARD_LIGHT] = "hard-light", n2[s.b.SOFT_LIGHT] = "soft-light", n2[s.b.DIFFERENCE] = "difference", n2[s.b.EXCLUSION] = "exclusion", n2[s.b.HUE] = "hue", n2[s.b.SATURATION] = "saturate", n2[s.b.COLOR] = "color", n2[s.b.LUMINOSITY] = "luminosity") : (n2[s.b.NORMAL] = "source-over", n2[s.b.ADD] = "lighter", n2[s.b.MULTIPLY] = "source-over", n2[s.b.SCREEN] = "source-over", n2[s.b.OVERLAY] = "source-over", n2[s.b.DARKEN] = "source-over", n2[s.b.LIGHTEN] = "source-over", n2[s.b.COLOR_DODGE] = "source-over", n2[s.b.COLOR_BURN] = "source-over", n2[s.b.HARD_LIGHT] = "source-over", n2[s.b.SOFT_LIGHT] = "source-over", n2[s.b.DIFFERENCE] = "source-over", n2[s.b.EXCLUSION] = "source-over", n2[s.b.HUE] = "source-over", n2[s.b.SATURATION] = "source-over", n2[s.b.COLOR] = "source-over", n2[s.b.LUMINOSITY] = "source-over"), n2[s.b.NORMAL_NPM] = n2[s.b.NORMAL], n2[s.b.ADD_NPM] = n2[s.b.ADD], n2[s.b.SCREEN_NPM] = n2[s.b.SCREEN], n2[s.b.SRC_IN] = "source-in", n2[s.b.SRC_OUT] = "source-out", n2[s.b.SRC_ATOP] = "source-atop", n2[s.b.DST_OVER] = "destination-over", n2[s.b.DST_IN] = "destination-in", n2[s.b.DST_OUT] = "destination-out", n2[s.b.DST_ATOP] = "destination-atop", n2[s.b.XOR] = "xor", n2[s.b.SUBTRACT] = "source-over", n2), o2.renderingToScreen = false, o2._activeBlendMode = null, o2._projTransform = null, o2._outerBlend = false, o2.rootContext = o2.view.getContext("2d", { alpha: o2.useContextAlpha }), o2.context = o2.rootContext, !o2.rootContext.imageSmoothingEnabled) {
        var a2 = o2.rootContext;
        a2.webkitImageSmoothingEnabled ? o2.smoothProperty = "webkitImageSmoothingEnabled" : a2.mozImageSmoothingEnabled ? o2.smoothProperty = "mozImageSmoothingEnabled" : a2.oImageSmoothingEnabled ? o2.smoothProperty = "oImageSmoothingEnabled" : a2.msImageSmoothingEnabled && (o2.smoothProperty = "msImageSmoothingEnabled");
      }
      return o2.initPlugins(e2.__plugins), Object(r.sayHello)("Canvas"), o2.resize(o2.options.width, o2.options.height), o2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      l(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype.addSystem = function() {
      return this;
    }, e2.prototype.render = function(t3, e3) {
      if (this.view) {
        var i2, o2, a2, l2;
        e3 && (e3 instanceof n.p || e3 instanceof n.b ? (Object(r.deprecation)("6.0.0", "CanvasRenderer#render arguments changed, use options instead."), i2 = e3, o2 = arguments[2], a2 = arguments[3], l2 = arguments[4]) : (i2 = e3.renderTexture, o2 = e3.clear, a2 = e3.transform, l2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.emit("prerender");
        var h2 = this.resolution;
        i2 ? ((i2 = i2.castToBaseTexture())._canvasRenderTarget || (i2._canvasRenderTarget = new r.CanvasRenderTarget(i2.width, i2.height, i2.resolution), i2.resource = new n.j(i2._canvasRenderTarget.canvas), i2.valid = true), this.context = i2._canvasRenderTarget.context, this.resolution = i2._canvasRenderTarget.resolution) : this.context = this.rootContext;
        var u2 = this.context;
        if (this._projTransform = a2 || null, i2 || (this._lastObjectRendered = t3), !l2) {
          var c2 = t3.enableTempParent();
          t3.updateTransform(), t3.disableTempParent(c2);
        }
        if (u2.save(), u2.setTransform(1, 0, 0, 1, 0, 0), u2.globalAlpha = 1, this._activeBlendMode = s.b.NORMAL, this._outerBlend = false, u2.globalCompositeOperation = this.blendModes[s.b.NORMAL], o2 !== void 0 ? o2 : this.clearBeforeRender)
          if (this.renderingToScreen)
            u2.clearRect(0, 0, this.width, this.height), this.backgroundAlpha > 0 && (u2.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1, u2.fillStyle = this._backgroundColorString, u2.fillRect(0, 0, this.width, this.height), u2.globalAlpha = 1);
          else {
            (i2 = i2)._canvasRenderTarget.clear();
            var d2 = i2.clearColor;
            d2[3] > 0 && (u2.globalAlpha = this.useContextAlpha ? d2[3] : 1, u2.fillStyle = Object(r.hex2string)(Object(r.rgb2hex)(d2)), u2.fillRect(0, 0, i2.realWidth, i2.realHeight), u2.globalAlpha = 1);
          }
        var p2 = this.context;
        this.context = u2, t3.renderCanvas(this), this.context = p2, u2.restore(), this.resolution = h2, this._projTransform = null, this.emit("postrender");
      }
    }, e2.prototype.setContextTransform = function(t3, e3, i2) {
      var n2 = t3, r2 = this._projTransform, o2 = this.resolution;
      i2 = i2 || o2, r2 && ((n2 = d).copyFrom(t3), n2.prepend(r2)), e3 ? this.context.setTransform(n2.a * i2, n2.b * i2, n2.c * i2, n2.d * i2, n2.tx * o2 | 0, n2.ty * o2 | 0) : this.context.setTransform(n2.a * i2, n2.b * i2, n2.c * i2, n2.d * i2, n2.tx * o2, n2.ty * o2);
    }, e2.prototype.clear = function(t3, e3) {
      t3 === void 0 && (t3 = this._backgroundColorString), e3 === void 0 && (e3 = this.backgroundAlpha);
      var i2 = this.context;
      i2.clearRect(0, 0, this.width, this.height), t3 && (i2.globalAlpha = this.useContextAlpha ? e3 : 1, i2.fillStyle = t3, i2.fillRect(0, 0, this.width, this.height), i2.globalAlpha = 1);
    }, e2.prototype.setBlendMode = function(t3, e3) {
      var i2 = t3 === s.b.SRC_IN || t3 === s.b.SRC_OUT || t3 === s.b.DST_IN || t3 === s.b.DST_ATOP;
      !e3 && i2 && (t3 = s.b.NORMAL), this._activeBlendMode !== t3 && (this._activeBlendMode = t3, this._outerBlend = i2, this.context.globalCompositeOperation = this.blendModes[t3]);
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this, e3), this.context = null, this.refresh = true, this.maskManager.destroy(), this.maskManager = null, this.smoothProperty = null;
    }, e2.prototype.resize = function(e3, i2) {
      t2.prototype.resize.call(this, e3, i2), this.smoothProperty && (this.rootContext[this.smoothProperty] = a.b.SCALE_MODE === s.p.LINEAR);
    }, e2.prototype.invalidateBlendMode = function() {
      this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
    }, e2.registerPlugin = function(t3, i2) {
      e2.__plugins = e2.__plugins || {}, e2.__plugins[t3] = i2;
    }, e2;
  }(n.a), f = { canvas: null, getTintedCanvas: function(t2, e2) {
    var i2 = t2.texture, n2 = "#" + ("00000" + (0 | (e2 = f.roundColor(e2))).toString(16)).slice(-6);
    i2.tintCache = i2.tintCache || {};
    var r2, o2 = i2.tintCache[n2];
    if (o2) {
      if (o2.tintId === i2._updateID)
        return i2.tintCache[n2];
      r2 = i2.tintCache[n2];
    } else
      r2 = document.createElement("canvas");
    if (f.tintMethod(i2, e2, r2), r2.tintId = i2._updateID, f.convertTintToImage) {
      var s2 = new Image();
      s2.src = r2.toDataURL(), i2.tintCache[n2] = s2;
    } else
      i2.tintCache[n2] = r2;
    return r2;
  }, getTintedPattern: function(t2, e2) {
    var i2 = "#" + ("00000" + (0 | (e2 = f.roundColor(e2))).toString(16)).slice(-6);
    t2.patternCache = t2.patternCache || {};
    var n2 = t2.patternCache[i2];
    return n2 && n2.tintId === t2._updateID || (f.canvas || (f.canvas = document.createElement("canvas")), f.tintMethod(t2, e2, f.canvas), (n2 = f.canvas.getContext("2d").createPattern(f.canvas, "repeat")).tintId = t2._updateID, t2.patternCache[i2] = n2), n2;
  }, tintWithMultiply: function(t2, e2, i2) {
    var n2 = i2.getContext("2d"), r2 = t2._frame.clone(), o2 = t2.baseTexture.resolution;
    r2.x *= o2, r2.y *= o2, r2.width *= o2, r2.height *= o2, i2.width = Math.ceil(r2.width), i2.height = Math.ceil(r2.height), n2.save(), n2.fillStyle = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), n2.fillRect(0, 0, r2.width, r2.height), n2.globalCompositeOperation = "multiply";
    var s2 = t2.baseTexture.getDrawableSource();
    n2.drawImage(s2, r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.globalCompositeOperation = "destination-atop", n2.drawImage(s2, r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.restore();
  }, tintWithOverlay: function(t2, e2, i2) {
    var n2 = i2.getContext("2d"), r2 = t2._frame.clone(), o2 = t2.baseTexture.resolution;
    r2.x *= o2, r2.y *= o2, r2.width *= o2, r2.height *= o2, i2.width = Math.ceil(r2.width), i2.height = Math.ceil(r2.height), n2.save(), n2.globalCompositeOperation = "copy", n2.fillStyle = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), n2.fillRect(0, 0, r2.width, r2.height), n2.globalCompositeOperation = "destination-atop", n2.drawImage(t2.baseTexture.getDrawableSource(), r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.restore();
  }, tintWithPerPixel: function(t2, e2, i2) {
    var n2 = i2.getContext("2d"), o2 = t2._frame.clone(), s2 = t2.baseTexture.resolution;
    o2.x *= s2, o2.y *= s2, o2.width *= s2, o2.height *= s2, i2.width = Math.ceil(o2.width), i2.height = Math.ceil(o2.height), n2.save(), n2.globalCompositeOperation = "copy", n2.drawImage(t2.baseTexture.getDrawableSource(), o2.x, o2.y, o2.width, o2.height, 0, 0, o2.width, o2.height), n2.restore();
    for (var a2 = Object(r.hex2rgb)(e2), l2 = a2[0], h2 = a2[1], u2 = a2[2], c2 = n2.getImageData(0, 0, o2.width, o2.height), d2 = c2.data, p2 = 0; p2 < d2.length; p2 += 4)
      d2[p2 + 0] *= l2, d2[p2 + 1] *= h2, d2[p2 + 2] *= u2;
    n2.putImageData(c2, 0, 0);
  }, roundColor: function(t2) {
    var e2 = f.cacheStepsPerColorChannel, i2 = Object(r.hex2rgb)(t2);
    return i2[0] = Math.min(255, i2[0] / e2 * e2), i2[1] = Math.min(255, i2[1] / e2 * e2), i2[2] = Math.min(255, i2[2] / e2 * e2), Object(r.rgb2hex)(i2);
  }, cacheStepsPerColorChannel: 8, convertTintToImage: false, canUseMultiply: c(), tintMethod: null };
  f.tintMethod = f.canUseMultiply ? f.tintWithMultiply : f.tintWithPerPixel;
  var m = n.q.create;
  n.q.create = function(t2) {
    if (!(t2 && t2.forceCanvas))
      try {
        return m(t2);
      } catch (t3) {
      }
    return new p(t2);
  }, n.c.prototype.getDrawableSource = function() {
    var t2 = this.resource;
    return t2 ? t2.bitmap || t2.source : null;
  }, n.b.prototype._canvasRenderTarget = null, n.t.prototype.patternCache = null, n.t.prototype.tintCache = null;
}, function(t, e) {
  t.exports = function(t2) {
    return t2 === void 0;
  };
}, function(t, e, i) {
  i.d(e, "a", function() {
    return n;
  });
  /*!
   * @pixi/runner - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/runner is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var n = function() {
    function t2(t3) {
      this.items = [], this._name = t3, this._aliasCount = 0;
    }
    return t2.prototype.emit = function(t3, e2, i2, n2, r, o, s, a) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var l = this, h = l.name, u = l.items;
      this._aliasCount++;
      for (var c = 0, d = u.length; c < d; c++)
        u[c][h](t3, e2, i2, n2, r, o, s, a);
      return u === this.items && this._aliasCount--, this;
    }, t2.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, t2.prototype.add = function(t3) {
      return t3[this._name] && (this.ensureNonAliasedItems(), this.remove(t3), this.items.push(t3)), this;
    }, t2.prototype.remove = function(t3) {
      var e2 = this.items.indexOf(t3);
      return e2 !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e2, 1)), this;
    }, t2.prototype.contains = function(t3) {
      return this.items.indexOf(t3) !== -1;
    }, t2.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, t2.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(t2.prototype, "empty", { get: function() {
      return this.items.length === 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "name", { get: function() {
      return this._name;
    }, enumerable: false, configurable: true }), t2;
  }();
  Object.defineProperties(n.prototype, { dispatch: { value: n.prototype.emit }, run: { value: n.prototype.emit } });
}, function(t, e, i) {
  var n = i(20), r = i(15);
  t.exports = function(t2) {
    return typeof t2 == "number" || r(t2) && n(t2) == "[object Number]";
  };
}, function(t, e, i) {
  var n = i(51), r = typeof self == "object" && self && self.Object === Object && self, o = n || r || Function("return this")();
  t.exports = o;
}, function(t, e) {
  t.exports = function(t2) {
    return t2 != null && typeof t2 == "object";
  };
}, function(t, e, i) {
  i.d(e, "a", function() {
    return p;
  }), i.d(e, "b", function() {
    return d;
  }), i.d(e, "c", function() {
    return u;
  });
  var n = i(8), r = i(0), o = i(2), s = function(t2, e2) {
    return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function a(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    s(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var l = function(t2) {
    function e2(e3, i2, n2, r2) {
      e3 === void 0 && (e3 = 100), i2 === void 0 && (i2 = 100), n2 === void 0 && (n2 = 10), r2 === void 0 && (r2 = 10);
      var o2 = t2.call(this) || this;
      return o2.segWidth = n2, o2.segHeight = r2, o2.width = e3, o2.height = i2, o2.build(), o2;
    }
    return a(e2, t2), e2.prototype.build = function() {
      for (var t3 = this.segWidth * this.segHeight, e3 = [], i2 = [], n2 = [], r2 = this.segWidth - 1, o2 = this.segHeight - 1, s2 = this.width / r2, a2 = this.height / o2, l2 = 0; l2 < t3; l2++) {
        var h2 = l2 % this.segWidth, u2 = l2 / this.segWidth | 0;
        e3.push(h2 * s2, u2 * a2), i2.push(h2 / r2, u2 / o2);
      }
      var c2 = r2 * o2;
      for (l2 = 0; l2 < c2; l2++) {
        var d2 = l2 % r2, p2 = l2 / r2 | 0, f = p2 * this.segWidth + d2, m = p2 * this.segWidth + d2 + 1, g = (p2 + 1) * this.segWidth + d2, v = (p2 + 1) * this.segWidth + d2 + 1;
        n2.push(f, m, g, m, v, g);
      }
      this.buffers[0].data = new Float32Array(e3), this.buffers[1].data = new Float32Array(i2), this.indexBuffer.data = new Uint16Array(n2), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, e2;
  }(n.b), h = function(t2) {
    function e2(e3, i2, n2) {
      e3 === void 0 && (e3 = 200), n2 === void 0 && (n2 = 0);
      var r2 = t2.call(this, new Float32Array(4 * i2.length), new Float32Array(4 * i2.length), new Uint16Array(6 * (i2.length - 1))) || this;
      return r2.points = i2, r2._width = e3, r2.textureScale = n2, r2.build(), r2;
    }
    return a(e2, t2), Object.defineProperty(e2.prototype, "width", { get: function() {
      return this._width;
    }, enumerable: false, configurable: true }), e2.prototype.build = function() {
      var t3 = this.points;
      if (t3) {
        var e3 = this.getBuffer("aVertexPosition"), i2 = this.getBuffer("aTextureCoord"), n2 = this.getIndex();
        if (!(t3.length < 1)) {
          e3.data.length / 4 !== t3.length && (e3.data = new Float32Array(4 * t3.length), i2.data = new Float32Array(4 * t3.length), n2.data = new Uint16Array(6 * (t3.length - 1)));
          var r2 = i2.data, o2 = n2.data;
          r2[0] = 0, r2[1] = 0, r2[2] = 0, r2[3] = 1;
          for (var s2 = 0, a2 = t3[0], l2 = this._width * this.textureScale, h2 = t3.length, u2 = 0; u2 < h2; u2++) {
            var c2 = 4 * u2;
            if (this.textureScale > 0) {
              var d2 = a2.x - t3[u2].x, p2 = a2.y - t3[u2].y, f = Math.sqrt(d2 * d2 + p2 * p2);
              a2 = t3[u2], s2 += f / l2;
            } else
              s2 = u2 / (h2 - 1);
            r2[c2] = s2, r2[c2 + 1] = 0, r2[c2 + 2] = s2, r2[c2 + 3] = 1;
          }
          var m = 0;
          for (u2 = 0; u2 < h2 - 1; u2++) {
            c2 = 2 * u2;
            o2[m++] = c2, o2[m++] = c2 + 1, o2[m++] = c2 + 2, o2[m++] = c2 + 2, o2[m++] = c2 + 1, o2[m++] = c2 + 3;
          }
          i2.update(), n2.update(), this.updateVertices();
        }
      }
    }, e2.prototype.updateVertices = function() {
      var t3 = this.points;
      if (!(t3.length < 1)) {
        for (var e3, i2 = t3[0], n2 = 0, r2 = 0, o2 = this.buffers[0].data, s2 = t3.length, a2 = 0; a2 < s2; a2++) {
          var l2 = t3[a2], h2 = 4 * a2;
          r2 = -((e3 = a2 < t3.length - 1 ? t3[a2 + 1] : l2).x - i2.x), n2 = e3.y - i2.y;
          var u2 = Math.sqrt(n2 * n2 + r2 * r2), c2 = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          n2 /= u2, r2 /= u2, n2 *= c2, r2 *= c2, o2[h2] = l2.x + n2, o2[h2 + 1] = l2.y + r2, o2[h2 + 2] = l2.x - n2, o2[h2 + 3] = l2.y - r2, i2 = l2;
        }
        this.buffers[0].update();
      }
    }, e2.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, e2;
  }(n.b), u = function(t2) {
    function e2(e3, i2, o2) {
      o2 === void 0 && (o2 = 0);
      var s2 = this, a2 = new h(e3.height, i2, o2), l2 = new n.c(e3);
      return o2 > 0 && (e3.baseTexture.wrapMode = r.s.REPEAT), (s2 = t2.call(this, a2, l2) || this).autoUpdate = true, s2;
    }
    return a(e2, t2), e2.prototype._render = function(e3) {
      var i2 = this.geometry;
      (this.autoUpdate || i2._width !== this.shader.texture.height) && (i2._width = this.shader.texture.height, i2.update()), t2.prototype._render.call(this, e3);
    }, e2;
  }(n.a), c = function(t2) {
    function e2(e3, i2, r2) {
      var s2 = this, a2 = new l(e3.width, e3.height, i2, r2), h2 = new n.c(o.t.WHITE);
      return (s2 = t2.call(this, a2, h2) || this).texture = e3, s2.autoResize = true, s2;
    }
    return a(e2, t2), e2.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var t3 = this.geometry, e3 = this.shader.texture, i2 = e3.width, n2 = e3.height;
      !this.autoResize || t3.width === i2 && t3.height === n2 || (t3.width = this.shader.texture.width, t3.height = this.shader.texture.height, t3.build());
    }, Object.defineProperty(e2.prototype, "texture", { get: function() {
      return this.shader.texture;
    }, set: function(t3) {
      this.shader.texture !== t3 && (this.shader.texture = t3, this._textureID = -1, t3.baseTexture.valid ? this.textureUpdated() : t3.once("update", this.textureUpdated, this));
    }, enumerable: false, configurable: true }), e2.prototype._render = function(e3) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t2.prototype._render.call(this, e3);
    }, e2.prototype.destroy = function(e3) {
      this.shader.texture.off("update", this.textureUpdated, this), t2.prototype.destroy.call(this, e3);
    }, e2;
  }(n.a), d = function(t2) {
    function e2(e3, i2, r2, s2, a2) {
      e3 === void 0 && (e3 = o.t.EMPTY);
      var l2 = this, h2 = new n.b(i2, r2, s2);
      h2.getBuffer("aVertexPosition").static = false;
      var u2 = new n.c(e3);
      return (l2 = t2.call(this, h2, u2, null, a2) || this).autoUpdate = true, l2;
    }
    return a(e2, t2), Object.defineProperty(e2.prototype, "vertices", { get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }, set: function(t3) {
      this.geometry.getBuffer("aVertexPosition").data = t3;
    }, enumerable: false, configurable: true }), e2.prototype._render = function(e3) {
      this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t2.prototype._render.call(this, e3);
    }, e2;
  }(n.a), p = function(t2) {
    function e2(e3, i2, n2, r2, s2) {
      i2 === void 0 && (i2 = 10), n2 === void 0 && (n2 = 10), r2 === void 0 && (r2 = 10), s2 === void 0 && (s2 = 10);
      var a2 = t2.call(this, o.t.WHITE, 4, 4) || this;
      return a2._origWidth = e3.orig.width, a2._origHeight = e3.orig.height, a2._width = a2._origWidth, a2._height = a2._origHeight, a2._leftWidth = i2, a2._rightWidth = r2, a2._topHeight = n2, a2._bottomHeight = s2, a2.texture = e3, a2;
    }
    return a(e2, t2), e2.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID, this._refresh();
    }, Object.defineProperty(e2.prototype, "vertices", { get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }, set: function(t3) {
      this.geometry.getBuffer("aVertexPosition").data = t3;
    }, enumerable: false, configurable: true }), e2.prototype.updateHorizontalVertices = function() {
      var t3 = this.vertices, e3 = this._getMinScale();
      t3[9] = t3[11] = t3[13] = t3[15] = this._topHeight * e3, t3[17] = t3[19] = t3[21] = t3[23] = this._height - this._bottomHeight * e3, t3[25] = t3[27] = t3[29] = t3[31] = this._height;
    }, e2.prototype.updateVerticalVertices = function() {
      var t3 = this.vertices, e3 = this._getMinScale();
      t3[2] = t3[10] = t3[18] = t3[26] = this._leftWidth * e3, t3[4] = t3[12] = t3[20] = t3[28] = this._width - this._rightWidth * e3, t3[6] = t3[14] = t3[22] = t3[30] = this._width;
    }, e2.prototype._getMinScale = function() {
      var t3 = this._leftWidth + this._rightWidth, e3 = this._width > t3 ? 1 : this._width / t3, i2 = this._topHeight + this._bottomHeight, n2 = this._height > i2 ? 1 : this._height / i2;
      return Math.min(e3, n2);
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this._width;
    }, set: function(t3) {
      this._width = t3, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this._height;
    }, set: function(t3) {
      this._height = t3, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "leftWidth", { get: function() {
      return this._leftWidth;
    }, set: function(t3) {
      this._leftWidth = t3, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rightWidth", { get: function() {
      return this._rightWidth;
    }, set: function(t3) {
      this._rightWidth = t3, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "topHeight", { get: function() {
      return this._topHeight;
    }, set: function(t3) {
      this._topHeight = t3, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "bottomHeight", { get: function() {
      return this._bottomHeight;
    }, set: function(t3) {
      this._bottomHeight = t3, this._refresh();
    }, enumerable: false, configurable: true }), e2.prototype._refresh = function() {
      var t3 = this.texture, e3 = this.geometry.buffers[1].data;
      this._origWidth = t3.orig.width, this._origHeight = t3.orig.height;
      var i2 = 1 / this._origWidth, n2 = 1 / this._origHeight;
      e3[0] = e3[8] = e3[16] = e3[24] = 0, e3[1] = e3[3] = e3[5] = e3[7] = 0, e3[6] = e3[14] = e3[22] = e3[30] = 1, e3[25] = e3[27] = e3[29] = e3[31] = 1, e3[2] = e3[10] = e3[18] = e3[26] = i2 * this._leftWidth, e3[4] = e3[12] = e3[20] = e3[28] = 1 - i2 * this._rightWidth, e3[9] = e3[11] = e3[13] = e3[15] = n2 * this._topHeight, e3[17] = e3[19] = e3[21] = e3[23] = 1 - n2 * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
    }, e2;
  }(c);
}, function(t, e) {
  var i;
  i = function() {
    return this;
  }();
  try {
    i = i || new Function("return this")();
  } catch (t2) {
    typeof window == "object" && (i = window);
  }
  t.exports = i;
}, function(t, e, i) {
  var n;
  !function(r) {
    function o(t2, e2) {
      var i2 = (65535 & t2) + (65535 & e2);
      return (t2 >> 16) + (e2 >> 16) + (i2 >> 16) << 16 | 65535 & i2;
    }
    function s(t2, e2, i2, n2, r2, s2) {
      return o((a2 = o(o(e2, t2), o(n2, s2))) << (l2 = r2) | a2 >>> 32 - l2, i2);
      var a2, l2;
    }
    function a(t2, e2, i2, n2, r2, o2, a2) {
      return s(e2 & i2 | ~e2 & n2, t2, e2, r2, o2, a2);
    }
    function l(t2, e2, i2, n2, r2, o2, a2) {
      return s(e2 & n2 | i2 & ~n2, t2, e2, r2, o2, a2);
    }
    function h(t2, e2, i2, n2, r2, o2, a2) {
      return s(e2 ^ i2 ^ n2, t2, e2, r2, o2, a2);
    }
    function u(t2, e2, i2, n2, r2, o2, a2) {
      return s(i2 ^ (e2 | ~n2), t2, e2, r2, o2, a2);
    }
    function c(t2, e2) {
      var i2, n2, r2, s2, c2;
      t2[e2 >> 5] |= 128 << e2 % 32, t2[14 + (e2 + 64 >>> 9 << 4)] = e2;
      var d2 = 1732584193, p2 = -271733879, f2 = -1732584194, m2 = 271733878;
      for (i2 = 0; i2 < t2.length; i2 += 16)
        n2 = d2, r2 = p2, s2 = f2, c2 = m2, d2 = a(d2, p2, f2, m2, t2[i2], 7, -680876936), m2 = a(m2, d2, p2, f2, t2[i2 + 1], 12, -389564586), f2 = a(f2, m2, d2, p2, t2[i2 + 2], 17, 606105819), p2 = a(p2, f2, m2, d2, t2[i2 + 3], 22, -1044525330), d2 = a(d2, p2, f2, m2, t2[i2 + 4], 7, -176418897), m2 = a(m2, d2, p2, f2, t2[i2 + 5], 12, 1200080426), f2 = a(f2, m2, d2, p2, t2[i2 + 6], 17, -1473231341), p2 = a(p2, f2, m2, d2, t2[i2 + 7], 22, -45705983), d2 = a(d2, p2, f2, m2, t2[i2 + 8], 7, 1770035416), m2 = a(m2, d2, p2, f2, t2[i2 + 9], 12, -1958414417), f2 = a(f2, m2, d2, p2, t2[i2 + 10], 17, -42063), p2 = a(p2, f2, m2, d2, t2[i2 + 11], 22, -1990404162), d2 = a(d2, p2, f2, m2, t2[i2 + 12], 7, 1804603682), m2 = a(m2, d2, p2, f2, t2[i2 + 13], 12, -40341101), f2 = a(f2, m2, d2, p2, t2[i2 + 14], 17, -1502002290), d2 = l(d2, p2 = a(p2, f2, m2, d2, t2[i2 + 15], 22, 1236535329), f2, m2, t2[i2 + 1], 5, -165796510), m2 = l(m2, d2, p2, f2, t2[i2 + 6], 9, -1069501632), f2 = l(f2, m2, d2, p2, t2[i2 + 11], 14, 643717713), p2 = l(p2, f2, m2, d2, t2[i2], 20, -373897302), d2 = l(d2, p2, f2, m2, t2[i2 + 5], 5, -701558691), m2 = l(m2, d2, p2, f2, t2[i2 + 10], 9, 38016083), f2 = l(f2, m2, d2, p2, t2[i2 + 15], 14, -660478335), p2 = l(p2, f2, m2, d2, t2[i2 + 4], 20, -405537848), d2 = l(d2, p2, f2, m2, t2[i2 + 9], 5, 568446438), m2 = l(m2, d2, p2, f2, t2[i2 + 14], 9, -1019803690), f2 = l(f2, m2, d2, p2, t2[i2 + 3], 14, -187363961), p2 = l(p2, f2, m2, d2, t2[i2 + 8], 20, 1163531501), d2 = l(d2, p2, f2, m2, t2[i2 + 13], 5, -1444681467), m2 = l(m2, d2, p2, f2, t2[i2 + 2], 9, -51403784), f2 = l(f2, m2, d2, p2, t2[i2 + 7], 14, 1735328473), d2 = h(d2, p2 = l(p2, f2, m2, d2, t2[i2 + 12], 20, -1926607734), f2, m2, t2[i2 + 5], 4, -378558), m2 = h(m2, d2, p2, f2, t2[i2 + 8], 11, -2022574463), f2 = h(f2, m2, d2, p2, t2[i2 + 11], 16, 1839030562), p2 = h(p2, f2, m2, d2, t2[i2 + 14], 23, -35309556), d2 = h(d2, p2, f2, m2, t2[i2 + 1], 4, -1530992060), m2 = h(m2, d2, p2, f2, t2[i2 + 4], 11, 1272893353), f2 = h(f2, m2, d2, p2, t2[i2 + 7], 16, -155497632), p2 = h(p2, f2, m2, d2, t2[i2 + 10], 23, -1094730640), d2 = h(d2, p2, f2, m2, t2[i2 + 13], 4, 681279174), m2 = h(m2, d2, p2, f2, t2[i2], 11, -358537222), f2 = h(f2, m2, d2, p2, t2[i2 + 3], 16, -722521979), p2 = h(p2, f2, m2, d2, t2[i2 + 6], 23, 76029189), d2 = h(d2, p2, f2, m2, t2[i2 + 9], 4, -640364487), m2 = h(m2, d2, p2, f2, t2[i2 + 12], 11, -421815835), f2 = h(f2, m2, d2, p2, t2[i2 + 15], 16, 530742520), d2 = u(d2, p2 = h(p2, f2, m2, d2, t2[i2 + 2], 23, -995338651), f2, m2, t2[i2], 6, -198630844), m2 = u(m2, d2, p2, f2, t2[i2 + 7], 10, 1126891415), f2 = u(f2, m2, d2, p2, t2[i2 + 14], 15, -1416354905), p2 = u(p2, f2, m2, d2, t2[i2 + 5], 21, -57434055), d2 = u(d2, p2, f2, m2, t2[i2 + 12], 6, 1700485571), m2 = u(m2, d2, p2, f2, t2[i2 + 3], 10, -1894986606), f2 = u(f2, m2, d2, p2, t2[i2 + 10], 15, -1051523), p2 = u(p2, f2, m2, d2, t2[i2 + 1], 21, -2054922799), d2 = u(d2, p2, f2, m2, t2[i2 + 8], 6, 1873313359), m2 = u(m2, d2, p2, f2, t2[i2 + 15], 10, -30611744), f2 = u(f2, m2, d2, p2, t2[i2 + 6], 15, -1560198380), p2 = u(p2, f2, m2, d2, t2[i2 + 13], 21, 1309151649), d2 = u(d2, p2, f2, m2, t2[i2 + 4], 6, -145523070), m2 = u(m2, d2, p2, f2, t2[i2 + 11], 10, -1120210379), f2 = u(f2, m2, d2, p2, t2[i2 + 2], 15, 718787259), p2 = u(p2, f2, m2, d2, t2[i2 + 9], 21, -343485551), d2 = o(d2, n2), p2 = o(p2, r2), f2 = o(f2, s2), m2 = o(m2, c2);
      return [d2, p2, f2, m2];
    }
    function d(t2) {
      var e2, i2 = "", n2 = 32 * t2.length;
      for (e2 = 0; e2 < n2; e2 += 8)
        i2 += String.fromCharCode(t2[e2 >> 5] >>> e2 % 32 & 255);
      return i2;
    }
    function p(t2) {
      var e2, i2 = [];
      for (i2[(t2.length >> 2) - 1] = void 0, e2 = 0; e2 < i2.length; e2 += 1)
        i2[e2] = 0;
      var n2 = 8 * t2.length;
      for (e2 = 0; e2 < n2; e2 += 8)
        i2[e2 >> 5] |= (255 & t2.charCodeAt(e2 / 8)) << e2 % 32;
      return i2;
    }
    function f(t2) {
      var e2, i2, n2 = "";
      for (i2 = 0; i2 < t2.length; i2 += 1)
        e2 = t2.charCodeAt(i2), n2 += "0123456789abcdef".charAt(e2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & e2);
      return n2;
    }
    function m(t2) {
      return unescape(encodeURIComponent(t2));
    }
    function g(t2) {
      return function(t3) {
        return d(c(p(t3), 8 * t3.length));
      }(m(t2));
    }
    function v(t2, e2) {
      return function(t3, e3) {
        var i2, n2, r2 = p(t3), o2 = [], s2 = [];
        for (o2[15] = s2[15] = void 0, r2.length > 16 && (r2 = c(r2, 8 * t3.length)), i2 = 0; i2 < 16; i2 += 1)
          o2[i2] = 909522486 ^ r2[i2], s2[i2] = 1549556828 ^ r2[i2];
        return n2 = c(o2.concat(p(e3)), 512 + 8 * e3.length), d(c(s2.concat(n2), 640));
      }(m(t2), m(e2));
    }
    function _(t2, e2, i2) {
      return e2 ? i2 ? v(e2, t2) : f(v(e2, t2)) : i2 ? g(t2) : f(g(t2));
    }
    (n = function() {
      return _;
    }.call(e, i, e, t)) === void 0 || (t.exports = n);
  }();
}, function(t, e) {
  t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
}, function(t, e, i) {
  var n = i(24), r = i(137), o = i(138), s = n ? n.toStringTag : void 0;
  t.exports = function(t2) {
    return t2 == null ? t2 === void 0 ? "[object Undefined]" : "[object Null]" : s && s in Object(t2) ? r(t2) : o(t2);
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = typeof t2;
    return t2 != null && (e2 == "object" || e2 == "function");
  };
}, function(t, e, i) {
  var n = i(162), r = i(165);
  t.exports = function(t2, e2) {
    var i2 = r(t2, e2);
    return n(i2) ? i2 : void 0;
  };
}, function(t, e, i) {
  (function(e2) {
    t.exports = function t2(e3, i2, n) {
      function r(s2, a) {
        if (!i2[s2]) {
          if (!e3[s2]) {
            if (o)
              return o(s2, true);
            var l = new Error("Cannot find module '" + s2 + "'");
            throw l.code = "MODULE_NOT_FOUND", l;
          }
          var h = i2[s2] = { exports: {} };
          e3[s2][0].call(h.exports, function(t3) {
            var i3 = e3[s2][1][t3];
            return r(i3 || t3);
          }, h, h.exports, t2, e3, i2, n);
        }
        return i2[s2].exports;
      }
      for (var o = false, s = 0; s < n.length; s++)
        r(n[s]);
      return r;
    }({ 1: [function(t2, i2, n) {
      (function(t3) {
        var e3, n2, r = t3.MutationObserver || t3.WebKitMutationObserver;
        if (r) {
          var o = 0, s = new r(u), a = t3.document.createTextNode("");
          s.observe(a, { characterData: true }), e3 = function() {
            a.data = o = ++o % 2;
          };
        } else if (t3.setImmediate || t3.MessageChannel === void 0)
          e3 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
            var e4 = t3.document.createElement("script");
            e4.onreadystatechange = function() {
              u(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t3.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var l = new t3.MessageChannel();
          l.port1.onmessage = u, e3 = function() {
            l.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var t4, e4;
          n2 = true;
          for (var i3 = h.length; i3; ) {
            for (e4 = h, h = [], t4 = -1; ++t4 < i3; )
              e4[t4]();
            i3 = h.length;
          }
          n2 = false;
        }
        i2.exports = function(t4) {
          h.push(t4) !== 1 || n2 || e3();
        };
      }).call(this, e2 !== void 0 ? e2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 2: [function(t2, e3, i2) {
      var n = t2(1);
      function r() {
      }
      var o = {}, s = ["REJECTED"], a = ["FULFILLED"], l = ["PENDING"];
      function h(t3) {
        if (typeof t3 != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, t3 !== r && p(this, t3);
      }
      function u(t3, e4, i3) {
        this.promise = t3, typeof e4 == "function" && (this.onFulfilled = e4, this.callFulfilled = this.otherCallFulfilled), typeof i3 == "function" && (this.onRejected = i3, this.callRejected = this.otherCallRejected);
      }
      function c(t3, e4, i3) {
        n(function() {
          var n2;
          try {
            n2 = e4(i3);
          } catch (e5) {
            return o.reject(t3, e5);
          }
          n2 === t3 ? o.reject(t3, new TypeError("Cannot resolve promise with itself")) : o.resolve(t3, n2);
        });
      }
      function d(t3) {
        var e4 = t3 && t3.then;
        if (t3 && (typeof t3 == "object" || typeof t3 == "function") && typeof e4 == "function")
          return function() {
            e4.apply(t3, arguments);
          };
      }
      function p(t3, e4) {
        var i3 = false;
        function n2(e5) {
          i3 || (i3 = true, o.reject(t3, e5));
        }
        function r2(e5) {
          i3 || (i3 = true, o.resolve(t3, e5));
        }
        var s2 = f(function() {
          e4(r2, n2);
        });
        s2.status === "error" && n2(s2.value);
      }
      function f(t3, e4) {
        var i3 = {};
        try {
          i3.value = t3(e4), i3.status = "success";
        } catch (t4) {
          i3.status = "error", i3.value = t4;
        }
        return i3;
      }
      e3.exports = h, h.prototype.catch = function(t3) {
        return this.then(null, t3);
      }, h.prototype.then = function(t3, e4) {
        if (typeof t3 != "function" && this.state === a || typeof e4 != "function" && this.state === s)
          return this;
        var i3 = new this.constructor(r);
        return this.state !== l ? c(i3, this.state === a ? t3 : e4, this.outcome) : this.queue.push(new u(i3, t3, e4)), i3;
      }, u.prototype.callFulfilled = function(t3) {
        o.resolve(this.promise, t3);
      }, u.prototype.otherCallFulfilled = function(t3) {
        c(this.promise, this.onFulfilled, t3);
      }, u.prototype.callRejected = function(t3) {
        o.reject(this.promise, t3);
      }, u.prototype.otherCallRejected = function(t3) {
        c(this.promise, this.onRejected, t3);
      }, o.resolve = function(t3, e4) {
        var i3 = f(d, e4);
        if (i3.status === "error")
          return o.reject(t3, i3.value);
        var n2 = i3.value;
        if (n2)
          p(t3, n2);
        else {
          t3.state = a, t3.outcome = e4;
          for (var r2 = -1, s2 = t3.queue.length; ++r2 < s2; )
            t3.queue[r2].callFulfilled(e4);
        }
        return t3;
      }, o.reject = function(t3, e4) {
        t3.state = s, t3.outcome = e4;
        for (var i3 = -1, n2 = t3.queue.length; ++i3 < n2; )
          t3.queue[i3].callRejected(e4);
        return t3;
      }, h.resolve = function(t3) {
        return t3 instanceof this ? t3 : o.resolve(new this(r), t3);
      }, h.reject = function(t3) {
        var e4 = new this(r);
        return o.reject(e4, t3);
      }, h.all = function(t3) {
        var e4 = this;
        if (Object.prototype.toString.call(t3) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var i3 = t3.length, n2 = false;
        if (!i3)
          return this.resolve([]);
        for (var s2 = new Array(i3), a2 = 0, l2 = -1, h2 = new this(r); ++l2 < i3; )
          u2(t3[l2], l2);
        return h2;
        function u2(t4, r2) {
          e4.resolve(t4).then(function(t5) {
            s2[r2] = t5, ++a2 !== i3 || n2 || (n2 = true, o.resolve(h2, s2));
          }, function(t5) {
            n2 || (n2 = true, o.reject(h2, t5));
          });
        }
      }, h.race = function(t3) {
        var e4 = this;
        if (Object.prototype.toString.call(t3) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var i3 = t3.length, n2 = false;
        if (!i3)
          return this.resolve([]);
        for (var s2, a2 = -1, l2 = new this(r); ++a2 < i3; )
          s2 = t3[a2], e4.resolve(s2).then(function(t4) {
            n2 || (n2 = true, o.resolve(l2, t4));
          }, function(t4) {
            n2 || (n2 = true, o.reject(l2, t4));
          });
        return l2;
      };
    }, { 1: 1 }], 3: [function(t2, i2, n) {
      (function(e3) {
        typeof e3.Promise != "function" && (e3.Promise = t2(2));
      }).call(this, e2 !== void 0 ? e2 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { 2: 2 }], 4: [function(t2, e3, i2) {
      var n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, r = function() {
        try {
          if (typeof indexedDB != "undefined")
            return indexedDB;
          if (typeof webkitIndexedDB != "undefined")
            return webkitIndexedDB;
          if (typeof mozIndexedDB != "undefined")
            return mozIndexedDB;
          if (typeof OIndexedDB != "undefined")
            return OIndexedDB;
          if (typeof msIndexedDB != "undefined")
            return msIndexedDB;
        } catch (t3) {
          return;
        }
      }();
      function o(t3, e4) {
        t3 = t3 || [], e4 = e4 || {};
        try {
          return new Blob(t3, e4);
        } catch (r2) {
          if (r2.name !== "TypeError")
            throw r2;
          for (var i3 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), n2 = 0; n2 < t3.length; n2 += 1)
            i3.append(t3[n2]);
          return i3.getBlob(e4.type);
        }
      }
      typeof Promise == "undefined" && t2(3);
      var s = Promise;
      function a(t3, e4) {
        e4 && t3.then(function(t4) {
          e4(null, t4);
        }, function(t4) {
          e4(t4);
        });
      }
      function l(t3, e4, i3) {
        typeof e4 == "function" && t3.then(e4), typeof i3 == "function" && t3.catch(i3);
      }
      function h(t3) {
        return typeof t3 != "string" && (console.warn(t3 + " used as a key, but it is not a string."), t3 = String(t3)), t3;
      }
      function u() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var c = void 0, d = {}, p = Object.prototype.toString;
      function f(t3) {
        return typeof c == "boolean" ? s.resolve(c) : function(t4) {
          return new s(function(e4) {
            var i3 = t4.transaction("local-forage-detect-blob-support", "readwrite"), n2 = o([""]);
            i3.objectStore("local-forage-detect-blob-support").put(n2, "key"), i3.onabort = function(t5) {
              t5.preventDefault(), t5.stopPropagation(), e4(false);
            }, i3.oncomplete = function() {
              var t5 = navigator.userAgent.match(/Chrome\/(\d+)/), i4 = navigator.userAgent.match(/Edge\//);
              e4(i4 || !t5 || parseInt(t5[1], 10) >= 43);
            };
          }).catch(function() {
            return false;
          });
        }(t3).then(function(t4) {
          return c = t4;
        });
      }
      function m(t3) {
        var e4 = d[t3.name], i3 = {};
        i3.promise = new s(function(t4, e5) {
          i3.resolve = t4, i3.reject = e5;
        }), e4.deferredOperations.push(i3), e4.dbReady ? e4.dbReady = e4.dbReady.then(function() {
          return i3.promise;
        }) : e4.dbReady = i3.promise;
      }
      function g(t3) {
        var e4 = d[t3.name].deferredOperations.pop();
        if (e4)
          return e4.resolve(), e4.promise;
      }
      function v(t3, e4) {
        var i3 = d[t3.name].deferredOperations.pop();
        if (i3)
          return i3.reject(e4), i3.promise;
      }
      function _(t3, e4) {
        return new s(function(i3, n2) {
          if (d[t3.name] = d[t3.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, t3.db) {
            if (!e4)
              return i3(t3.db);
            m(t3), t3.db.close();
          }
          var o2 = [t3.name];
          e4 && o2.push(t3.version);
          var s2 = r.open.apply(r, o2);
          e4 && (s2.onupgradeneeded = function(e5) {
            var i4 = s2.result;
            try {
              i4.createObjectStore(t3.storeName), e5.oldVersion <= 1 && i4.createObjectStore("local-forage-detect-blob-support");
            } catch (i5) {
              if (i5.name !== "ConstraintError")
                throw i5;
              console.warn('The database "' + t3.name + '" has been upgraded from version ' + e5.oldVersion + " to version " + e5.newVersion + ', but the storage "' + t3.storeName + '" already exists.');
            }
          }), s2.onerror = function(t4) {
            t4.preventDefault(), n2(s2.error);
          }, s2.onsuccess = function() {
            var e5 = s2.result;
            e5.onversionchange = function(t4) {
              t4.target.close();
            }, i3(e5), g(t3);
          };
        });
      }
      function y(t3) {
        return _(t3, false);
      }
      function x(t3) {
        return _(t3, true);
      }
      function b(t3, e4) {
        if (!t3.db)
          return true;
        var i3 = !t3.db.objectStoreNames.contains(t3.storeName), n2 = t3.version < t3.db.version, r2 = t3.version > t3.db.version;
        if (n2 && (t3.version !== e4 && console.warn('The database "' + t3.name + `" can't be downgraded from version ` + t3.db.version + " to version " + t3.version + "."), t3.version = t3.db.version), r2 || i3) {
          if (i3) {
            var o2 = t3.db.version + 1;
            o2 > t3.version && (t3.version = o2);
          }
          return true;
        }
        return false;
      }
      function T(t3) {
        return o([function(t4) {
          for (var e4 = t4.length, i3 = new ArrayBuffer(e4), n2 = new Uint8Array(i3), r2 = 0; r2 < e4; r2++)
            n2[r2] = t4.charCodeAt(r2);
          return i3;
        }(atob(t3.data))], { type: t3.type });
      }
      function E(t3) {
        return t3 && t3.__local_forage_encoded_blob;
      }
      function S(t3) {
        var e4 = this, i3 = e4._initReady().then(function() {
          var t4 = d[e4._dbInfo.name];
          if (t4 && t4.dbReady)
            return t4.dbReady;
        });
        return l(i3, t3, t3), i3;
      }
      function w(t3, e4, i3, n2) {
        n2 === void 0 && (n2 = 1);
        try {
          var r2 = t3.db.transaction(t3.storeName, e4);
          i3(null, r2);
        } catch (r3) {
          if (n2 > 0 && (!t3.db || r3.name === "InvalidStateError" || r3.name === "NotFoundError"))
            return s.resolve().then(function() {
              if (!t3.db || r3.name === "NotFoundError" && !t3.db.objectStoreNames.contains(t3.storeName) && t3.version <= t3.db.version)
                return t3.db && (t3.version = t3.db.version + 1), x(t3);
            }).then(function() {
              return function(t4) {
                m(t4);
                for (var e5 = d[t4.name], i4 = e5.forages, n3 = 0; n3 < i4.length; n3++) {
                  var r4 = i4[n3];
                  r4._dbInfo.db && (r4._dbInfo.db.close(), r4._dbInfo.db = null);
                }
                return t4.db = null, y(t4).then(function(e6) {
                  return t4.db = e6, b(t4) ? x(t4) : e6;
                }).then(function(n4) {
                  t4.db = e5.db = n4;
                  for (var r5 = 0; r5 < i4.length; r5++)
                    i4[r5]._dbInfo.db = n4;
                }).catch(function(e6) {
                  throw v(t4, e6), e6;
                });
              }(t3).then(function() {
                w(t3, e4, i3, n2 - 1);
              });
            }).catch(i3);
          i3(r3);
        }
      }
      var A = { _driver: "asyncStorage", _initStorage: function(t3) {
        var e4 = this, i3 = { db: null };
        if (t3)
          for (var n2 in t3)
            i3[n2] = t3[n2];
        var r2 = d[i3.name];
        r2 || (r2 = { forages: [], db: null, dbReady: null, deferredOperations: [] }, d[i3.name] = r2), r2.forages.push(e4), e4._initReady || (e4._initReady = e4.ready, e4.ready = S);
        var o2 = [];
        function a2() {
          return s.resolve();
        }
        for (var l2 = 0; l2 < r2.forages.length; l2++) {
          var h2 = r2.forages[l2];
          h2 !== e4 && o2.push(h2._initReady().catch(a2));
        }
        var u2 = r2.forages.slice(0);
        return s.all(o2).then(function() {
          return i3.db = r2.db, y(i3);
        }).then(function(t4) {
          return i3.db = t4, b(i3, e4._defaultConfig.version) ? x(i3) : t4;
        }).then(function(t4) {
          i3.db = r2.db = t4, e4._dbInfo = i3;
          for (var n3 = 0; n3 < u2.length; n3++) {
            var o3 = u2[n3];
            o3 !== e4 && (o3._dbInfo.db = i3.db, o3._dbInfo.version = i3.version);
          }
        });
      }, _support: function() {
        try {
          if (!r || !r.open)
            return false;
          var t3 = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), e4 = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!t3 || e4) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
        } catch (t4) {
          return false;
        }
      }(), iterate: function(t3, e4) {
        var i3 = this, n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            w(i3._dbInfo, "readonly", function(r2, o2) {
              if (r2)
                return n3(r2);
              try {
                var s2 = o2.objectStore(i3._dbInfo.storeName).openCursor(), a2 = 1;
                s2.onsuccess = function() {
                  var i4 = s2.result;
                  if (i4) {
                    var n4 = i4.value;
                    E(n4) && (n4 = T(n4));
                    var r3 = t3(n4, i4.key, a2++);
                    r3 !== void 0 ? e5(r3) : i4.continue();
                  } else
                    e5();
                }, s2.onerror = function() {
                  n3(s2.error);
                };
              } catch (t4) {
                n3(t4);
              }
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, getItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            w(i3._dbInfo, "readonly", function(r2, o2) {
              if (r2)
                return n3(r2);
              try {
                var s2 = o2.objectStore(i3._dbInfo.storeName).get(t3);
                s2.onsuccess = function() {
                  var t4 = s2.result;
                  t4 === void 0 && (t4 = null), E(t4) && (t4 = T(t4)), e5(t4);
                }, s2.onerror = function() {
                  n3(s2.error);
                };
              } catch (t4) {
                n3(t4);
              }
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, setItem: function(t3, e4, i3) {
        var n2 = this;
        t3 = h(t3);
        var r2 = new s(function(i4, r3) {
          var o2;
          n2.ready().then(function() {
            return o2 = n2._dbInfo, p.call(e4) === "[object Blob]" ? f(o2.db).then(function(t4) {
              return t4 ? e4 : (i5 = e4, new s(function(t5, e5) {
                var n3 = new FileReader();
                n3.onerror = e5, n3.onloadend = function(e6) {
                  var n4 = btoa(e6.target.result || "");
                  t5({ __local_forage_encoded_blob: true, data: n4, type: i5.type });
                }, n3.readAsBinaryString(i5);
              }));
              var i5;
            }) : e4;
          }).then(function(e5) {
            w(n2._dbInfo, "readwrite", function(o3, s2) {
              if (o3)
                return r3(o3);
              try {
                var a2 = s2.objectStore(n2._dbInfo.storeName);
                e5 === null && (e5 = void 0);
                var l2 = a2.put(e5, t3);
                s2.oncomplete = function() {
                  e5 === void 0 && (e5 = null), i4(e5);
                }, s2.onabort = s2.onerror = function() {
                  var t4 = l2.error ? l2.error : l2.transaction.error;
                  r3(t4);
                };
              } catch (t4) {
                r3(t4);
              }
            });
          }).catch(r3);
        });
        return a(r2, i3), r2;
      }, removeItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            w(i3._dbInfo, "readwrite", function(r2, o2) {
              if (r2)
                return n3(r2);
              try {
                var s2 = o2.objectStore(i3._dbInfo.storeName).delete(t3);
                o2.oncomplete = function() {
                  e5();
                }, o2.onerror = function() {
                  n3(s2.error);
                }, o2.onabort = function() {
                  var t4 = s2.error ? s2.error : s2.transaction.error;
                  n3(t4);
                };
              } catch (t4) {
                n3(t4);
              }
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, clear: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            w(e4._dbInfo, "readwrite", function(n2, r2) {
              if (n2)
                return i4(n2);
              try {
                var o2 = r2.objectStore(e4._dbInfo.storeName).clear();
                r2.oncomplete = function() {
                  t4();
                }, r2.onabort = r2.onerror = function() {
                  var t5 = o2.error ? o2.error : o2.transaction.error;
                  i4(t5);
                };
              } catch (t5) {
                i4(t5);
              }
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, length: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            w(e4._dbInfo, "readonly", function(n2, r2) {
              if (n2)
                return i4(n2);
              try {
                var o2 = r2.objectStore(e4._dbInfo.storeName).count();
                o2.onsuccess = function() {
                  t4(o2.result);
                }, o2.onerror = function() {
                  i4(o2.error);
                };
              } catch (t5) {
                i4(t5);
              }
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, key: function(t3, e4) {
        var i3 = this, n2 = new s(function(e5, n3) {
          t3 < 0 ? e5(null) : i3.ready().then(function() {
            w(i3._dbInfo, "readonly", function(r2, o2) {
              if (r2)
                return n3(r2);
              try {
                var s2 = o2.objectStore(i3._dbInfo.storeName), a2 = false, l2 = s2.openKeyCursor();
                l2.onsuccess = function() {
                  var i4 = l2.result;
                  i4 ? t3 === 0 || a2 ? e5(i4.key) : (a2 = true, i4.advance(t3)) : e5(null);
                }, l2.onerror = function() {
                  n3(l2.error);
                };
              } catch (t4) {
                n3(t4);
              }
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, keys: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            w(e4._dbInfo, "readonly", function(n2, r2) {
              if (n2)
                return i4(n2);
              try {
                var o2 = r2.objectStore(e4._dbInfo.storeName).openKeyCursor(), s2 = [];
                o2.onsuccess = function() {
                  var e5 = o2.result;
                  e5 ? (s2.push(e5.key), e5.continue()) : t4(s2);
                }, o2.onerror = function() {
                  i4(o2.error);
                };
              } catch (t5) {
                i4(t5);
              }
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, dropInstance: function(t3, e4) {
        e4 = u.apply(this, arguments);
        var i3 = this.config();
        (t3 = typeof t3 != "function" && t3 || {}).name || (t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName);
        var n2, o2 = this;
        if (t3.name) {
          var l2 = t3.name === i3.name && o2._dbInfo.db, h2 = l2 ? s.resolve(o2._dbInfo.db) : y(t3).then(function(e5) {
            var i4 = d[t3.name], n3 = i4.forages;
            i4.db = e5;
            for (var r2 = 0; r2 < n3.length; r2++)
              n3[r2]._dbInfo.db = e5;
            return e5;
          });
          n2 = t3.storeName ? h2.then(function(e5) {
            if (e5.objectStoreNames.contains(t3.storeName)) {
              var i4 = e5.version + 1;
              m(t3);
              var n3 = d[t3.name], o3 = n3.forages;
              e5.close();
              for (var a2 = 0; a2 < o3.length; a2++) {
                var l3 = o3[a2];
                l3._dbInfo.db = null, l3._dbInfo.version = i4;
              }
              return new s(function(e6, n4) {
                var o4 = r.open(t3.name, i4);
                o4.onerror = function(t4) {
                  o4.result.close(), n4(t4);
                }, o4.onupgradeneeded = function() {
                  o4.result.deleteObjectStore(t3.storeName);
                }, o4.onsuccess = function() {
                  var t4 = o4.result;
                  t4.close(), e6(t4);
                };
              }).then(function(t4) {
                n3.db = t4;
                for (var e6 = 0; e6 < o3.length; e6++) {
                  var i5 = o3[e6];
                  i5._dbInfo.db = t4, g(i5._dbInfo);
                }
              }).catch(function(e6) {
                throw (v(t3, e6) || s.resolve()).catch(function() {
                }), e6;
              });
            }
          }) : h2.then(function(e5) {
            m(t3);
            var i4 = d[t3.name], n3 = i4.forages;
            e5.close();
            for (var o3 = 0; o3 < n3.length; o3++)
              n3[o3]._dbInfo.db = null;
            return new s(function(e6, i5) {
              var n4 = r.deleteDatabase(t3.name);
              n4.onerror = function() {
                var t4 = n4.result;
                t4 && t4.close(), i5(n4.error);
              }, n4.onblocked = function() {
                console.warn('dropInstance blocked for database "' + t3.name + '" until all open connections are closed');
              }, n4.onsuccess = function() {
                var t4 = n4.result;
                t4 && t4.close(), e6(t4);
              };
            }).then(function(t4) {
              i4.db = t4;
              for (var e6 = 0; e6 < n3.length; e6++)
                g(n3[e6]._dbInfo);
            }).catch(function(e6) {
              throw (v(t3, e6) || s.resolve()).catch(function() {
              }), e6;
            });
          });
        } else
          n2 = s.reject("Invalid arguments");
        return a(n2, e4), n2;
      } }, M = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", R = /^~~local_forage_type~([^~]+)~/, C = "__lfsc__:".length, I = C + "arbf".length, P = Object.prototype.toString;
      function O(t3) {
        var e4, i3, n2, r2, o2, s2 = 0.75 * t3.length, a2 = t3.length, l2 = 0;
        t3[t3.length - 1] === "=" && (s2--, t3[t3.length - 2] === "=" && s2--);
        var h2 = new ArrayBuffer(s2), u2 = new Uint8Array(h2);
        for (e4 = 0; e4 < a2; e4 += 4)
          i3 = M.indexOf(t3[e4]), n2 = M.indexOf(t3[e4 + 1]), r2 = M.indexOf(t3[e4 + 2]), o2 = M.indexOf(t3[e4 + 3]), u2[l2++] = i3 << 2 | n2 >> 4, u2[l2++] = (15 & n2) << 4 | r2 >> 2, u2[l2++] = (3 & r2) << 6 | 63 & o2;
        return h2;
      }
      function N(t3) {
        var e4, i3 = new Uint8Array(t3), n2 = "";
        for (e4 = 0; e4 < i3.length; e4 += 3)
          n2 += M[i3[e4] >> 2], n2 += M[(3 & i3[e4]) << 4 | i3[e4 + 1] >> 4], n2 += M[(15 & i3[e4 + 1]) << 2 | i3[e4 + 2] >> 6], n2 += M[63 & i3[e4 + 2]];
        return i3.length % 3 == 2 ? n2 = n2.substring(0, n2.length - 1) + "=" : i3.length % 3 == 1 && (n2 = n2.substring(0, n2.length - 2) + "=="), n2;
      }
      var L = { serialize: function(t3, e4) {
        var i3 = "";
        if (t3 && (i3 = P.call(t3)), t3 && (i3 === "[object ArrayBuffer]" || t3.buffer && P.call(t3.buffer) === "[object ArrayBuffer]")) {
          var n2, r2 = "__lfsc__:";
          t3 instanceof ArrayBuffer ? (n2 = t3, r2 += "arbf") : (n2 = t3.buffer, i3 === "[object Int8Array]" ? r2 += "si08" : i3 === "[object Uint8Array]" ? r2 += "ui08" : i3 === "[object Uint8ClampedArray]" ? r2 += "uic8" : i3 === "[object Int16Array]" ? r2 += "si16" : i3 === "[object Uint16Array]" ? r2 += "ur16" : i3 === "[object Int32Array]" ? r2 += "si32" : i3 === "[object Uint32Array]" ? r2 += "ui32" : i3 === "[object Float32Array]" ? r2 += "fl32" : i3 === "[object Float64Array]" ? r2 += "fl64" : e4(new Error("Failed to get type for BinaryArray"))), e4(r2 + N(n2));
        } else if (i3 === "[object Blob]") {
          var o2 = new FileReader();
          o2.onload = function() {
            var i4 = "~~local_forage_type~" + t3.type + "~" + N(this.result);
            e4("__lfsc__:blob" + i4);
          }, o2.readAsArrayBuffer(t3);
        } else
          try {
            e4(JSON.stringify(t3));
          } catch (i4) {
            console.error("Couldn't convert value into a JSON string: ", t3), e4(null, i4);
          }
      }, deserialize: function(t3) {
        if (t3.substring(0, C) !== "__lfsc__:")
          return JSON.parse(t3);
        var e4, i3 = t3.substring(I), n2 = t3.substring(C, I);
        if (n2 === "blob" && R.test(i3)) {
          var r2 = i3.match(R);
          e4 = r2[1], i3 = i3.substring(r2[0].length);
        }
        var s2 = O(i3);
        switch (n2) {
          case "arbf":
            return s2;
          case "blob":
            return o([s2], { type: e4 });
          case "si08":
            return new Int8Array(s2);
          case "ui08":
            return new Uint8Array(s2);
          case "uic8":
            return new Uint8ClampedArray(s2);
          case "si16":
            return new Int16Array(s2);
          case "ur16":
            return new Uint16Array(s2);
          case "si32":
            return new Int32Array(s2);
          case "ui32":
            return new Uint32Array(s2);
          case "fl32":
            return new Float32Array(s2);
          case "fl64":
            return new Float64Array(s2);
          default:
            throw new Error("Unkown type: " + n2);
        }
      }, stringToBuffer: O, bufferToString: N };
      function D(t3, e4, i3, n2) {
        t3.executeSql("CREATE TABLE IF NOT EXISTS " + e4.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], i3, n2);
      }
      function F(t3, e4, i3, n2, r2, o2) {
        t3.executeSql(i3, n2, r2, function(t4, s2) {
          s2.code === s2.SYNTAX_ERR ? t4.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [e4.storeName], function(t5, a2) {
            a2.rows.length ? o2(t5, s2) : D(t5, e4, function() {
              t5.executeSql(i3, n2, r2, o2);
            }, o2);
          }, o2) : o2(t4, s2);
        }, o2);
      }
      function B(t3, e4, i3, n2) {
        var r2 = this;
        t3 = h(t3);
        var o2 = new s(function(o3, s2) {
          r2.ready().then(function() {
            e4 === void 0 && (e4 = null);
            var a2 = e4, l2 = r2._dbInfo;
            l2.serializer.serialize(e4, function(e5, h2) {
              h2 ? s2(h2) : l2.db.transaction(function(i4) {
                F(i4, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [t3, e5], function() {
                  o3(a2);
                }, function(t4, e6) {
                  s2(e6);
                });
              }, function(e6) {
                if (e6.code === e6.QUOTA_ERR) {
                  if (n2 > 0)
                    return void o3(B.apply(r2, [t3, a2, i3, n2 - 1]));
                  s2(e6);
                }
              });
            });
          }).catch(s2);
        });
        return a(o2, i3), o2;
      }
      function U(t3) {
        return new s(function(e4, i3) {
          t3.transaction(function(n2) {
            n2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(i4, n3) {
              for (var r2 = [], o2 = 0; o2 < n3.rows.length; o2++)
                r2.push(n3.rows.item(o2).name);
              e4({ db: t3, storeNames: r2 });
            }, function(t4, e5) {
              i3(e5);
            });
          }, function(t4) {
            i3(t4);
          });
        });
      }
      var k = { _driver: "webSQLStorage", _initStorage: function(t3) {
        var e4 = this, i3 = { db: null };
        if (t3)
          for (var n2 in t3)
            i3[n2] = typeof t3[n2] != "string" ? t3[n2].toString() : t3[n2];
        var r2 = new s(function(t4, n3) {
          try {
            i3.db = openDatabase(i3.name, String(i3.version), i3.description, i3.size);
          } catch (t5) {
            return n3(t5);
          }
          i3.db.transaction(function(r3) {
            D(r3, i3, function() {
              e4._dbInfo = i3, t4();
            }, function(t5, e5) {
              n3(e5);
            });
          }, n3);
        });
        return i3.serializer = L, r2;
      }, _support: typeof openDatabase == "function", iterate: function(t3, e4) {
        var i3 = this, n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            var r2 = i3._dbInfo;
            r2.db.transaction(function(i4) {
              F(i4, r2, "SELECT * FROM " + r2.storeName, [], function(i5, n4) {
                for (var o2 = n4.rows, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
                  var l2 = o2.item(a2), h2 = l2.value;
                  if (h2 && (h2 = r2.serializer.deserialize(h2)), (h2 = t3(h2, l2.key, a2 + 1)) !== void 0)
                    return void e5(h2);
                }
                e5();
              }, function(t4, e6) {
                n3(e6);
              });
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, getItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            var r2 = i3._dbInfo;
            r2.db.transaction(function(i4) {
              F(i4, r2, "SELECT * FROM " + r2.storeName + " WHERE key = ? LIMIT 1", [t3], function(t4, i5) {
                var n4 = i5.rows.length ? i5.rows.item(0).value : null;
                n4 && (n4 = r2.serializer.deserialize(n4)), e5(n4);
              }, function(t4, e6) {
                n3(e6);
              });
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, setItem: function(t3, e4, i3) {
        return B.apply(this, [t3, e4, i3, 1]);
      }, removeItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            var r2 = i3._dbInfo;
            r2.db.transaction(function(i4) {
              F(i4, r2, "DELETE FROM " + r2.storeName + " WHERE key = ?", [t3], function() {
                e5();
              }, function(t4, e6) {
                n3(e6);
              });
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, clear: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            var n2 = e4._dbInfo;
            n2.db.transaction(function(e5) {
              F(e5, n2, "DELETE FROM " + n2.storeName, [], function() {
                t4();
              }, function(t5, e6) {
                i4(e6);
              });
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, length: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            var n2 = e4._dbInfo;
            n2.db.transaction(function(e5) {
              F(e5, n2, "SELECT COUNT(key) as c FROM " + n2.storeName, [], function(e6, i5) {
                var n3 = i5.rows.item(0).c;
                t4(n3);
              }, function(t5, e6) {
                i4(e6);
              });
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, key: function(t3, e4) {
        var i3 = this, n2 = new s(function(e5, n3) {
          i3.ready().then(function() {
            var r2 = i3._dbInfo;
            r2.db.transaction(function(i4) {
              F(i4, r2, "SELECT key FROM " + r2.storeName + " WHERE id = ? LIMIT 1", [t3 + 1], function(t4, i5) {
                var n4 = i5.rows.length ? i5.rows.item(0).key : null;
                e5(n4);
              }, function(t4, e6) {
                n3(e6);
              });
            });
          }).catch(n3);
        });
        return a(n2, e4), n2;
      }, keys: function(t3) {
        var e4 = this, i3 = new s(function(t4, i4) {
          e4.ready().then(function() {
            var n2 = e4._dbInfo;
            n2.db.transaction(function(e5) {
              F(e5, n2, "SELECT key FROM " + n2.storeName, [], function(e6, i5) {
                for (var n3 = [], r2 = 0; r2 < i5.rows.length; r2++)
                  n3.push(i5.rows.item(r2).key);
                t4(n3);
              }, function(t5, e6) {
                i4(e6);
              });
            });
          }).catch(i4);
        });
        return a(i3, t3), i3;
      }, dropInstance: function(t3, e4) {
        e4 = u.apply(this, arguments);
        var i3 = this.config();
        (t3 = typeof t3 != "function" && t3 || {}).name || (t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName);
        var n2, r2 = this;
        return a(n2 = t3.name ? new s(function(e5) {
          var n3;
          n3 = t3.name === i3.name ? r2._dbInfo.db : openDatabase(t3.name, "", "", 0), t3.storeName ? e5({ db: n3, storeNames: [t3.storeName] }) : e5(U(n3));
        }).then(function(t4) {
          return new s(function(e5, i4) {
            t4.db.transaction(function(n3) {
              function r3(t5) {
                return new s(function(e6, i5) {
                  n3.executeSql("DROP TABLE IF EXISTS " + t5, [], function() {
                    e6();
                  }, function(t6, e7) {
                    i5(e7);
                  });
                });
              }
              for (var o2 = [], a2 = 0, l2 = t4.storeNames.length; a2 < l2; a2++)
                o2.push(r3(t4.storeNames[a2]));
              s.all(o2).then(function() {
                e5();
              }).catch(function(t5) {
                i4(t5);
              });
            }, function(t5) {
              i4(t5);
            });
          });
        }) : s.reject("Invalid arguments"), e4), n2;
      } };
      function G(t3, e4) {
        var i3 = t3.name + "/";
        return t3.storeName !== e4.storeName && (i3 += t3.storeName + "/"), i3;
      }
      function H() {
        return !function() {
          try {
            return localStorage.setItem("_localforage_support_test", true), localStorage.removeItem("_localforage_support_test"), false;
          } catch (t3) {
            return true;
          }
        }() || localStorage.length > 0;
      }
      var j = { _driver: "localStorageWrapper", _initStorage: function(t3) {
        var e4 = {};
        if (t3)
          for (var i3 in t3)
            e4[i3] = t3[i3];
        return e4.keyPrefix = G(t3, this._defaultConfig), H() ? (this._dbInfo = e4, e4.serializer = L, s.resolve()) : s.reject();
      }, _support: function() {
        try {
          return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
        } catch (t3) {
          return false;
        }
      }(), iterate: function(t3, e4) {
        var i3 = this, n2 = i3.ready().then(function() {
          for (var e5 = i3._dbInfo, n3 = e5.keyPrefix, r2 = n3.length, o2 = localStorage.length, s2 = 1, a2 = 0; a2 < o2; a2++) {
            var l2 = localStorage.key(a2);
            if (l2.indexOf(n3) === 0) {
              var h2 = localStorage.getItem(l2);
              if (h2 && (h2 = e5.serializer.deserialize(h2)), (h2 = t3(h2, l2.substring(r2), s2++)) !== void 0)
                return h2;
            }
          }
        });
        return a(n2, e4), n2;
      }, getItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = i3.ready().then(function() {
          var e5 = i3._dbInfo, n3 = localStorage.getItem(e5.keyPrefix + t3);
          return n3 && (n3 = e5.serializer.deserialize(n3)), n3;
        });
        return a(n2, e4), n2;
      }, setItem: function(t3, e4, i3) {
        var n2 = this;
        t3 = h(t3);
        var r2 = n2.ready().then(function() {
          e4 === void 0 && (e4 = null);
          var i4 = e4;
          return new s(function(r3, o2) {
            var s2 = n2._dbInfo;
            s2.serializer.serialize(e4, function(e5, n3) {
              if (n3)
                o2(n3);
              else
                try {
                  localStorage.setItem(s2.keyPrefix + t3, e5), r3(i4);
                } catch (t4) {
                  t4.name !== "QuotaExceededError" && t4.name !== "NS_ERROR_DOM_QUOTA_REACHED" || o2(t4), o2(t4);
                }
            });
          });
        });
        return a(r2, i3), r2;
      }, removeItem: function(t3, e4) {
        var i3 = this;
        t3 = h(t3);
        var n2 = i3.ready().then(function() {
          var e5 = i3._dbInfo;
          localStorage.removeItem(e5.keyPrefix + t3);
        });
        return a(n2, e4), n2;
      }, clear: function(t3) {
        var e4 = this, i3 = e4.ready().then(function() {
          for (var t4 = e4._dbInfo.keyPrefix, i4 = localStorage.length - 1; i4 >= 0; i4--) {
            var n2 = localStorage.key(i4);
            n2.indexOf(t4) === 0 && localStorage.removeItem(n2);
          }
        });
        return a(i3, t3), i3;
      }, length: function(t3) {
        var e4 = this.keys().then(function(t4) {
          return t4.length;
        });
        return a(e4, t3), e4;
      }, key: function(t3, e4) {
        var i3 = this, n2 = i3.ready().then(function() {
          var e5, n3 = i3._dbInfo;
          try {
            e5 = localStorage.key(t3);
          } catch (t4) {
            e5 = null;
          }
          return e5 && (e5 = e5.substring(n3.keyPrefix.length)), e5;
        });
        return a(n2, e4), n2;
      }, keys: function(t3) {
        var e4 = this, i3 = e4.ready().then(function() {
          for (var t4 = e4._dbInfo, i4 = localStorage.length, n2 = [], r2 = 0; r2 < i4; r2++) {
            var o2 = localStorage.key(r2);
            o2.indexOf(t4.keyPrefix) === 0 && n2.push(o2.substring(t4.keyPrefix.length));
          }
          return n2;
        });
        return a(i3, t3), i3;
      }, dropInstance: function(t3, e4) {
        if (e4 = u.apply(this, arguments), !(t3 = typeof t3 != "function" && t3 || {}).name) {
          var i3 = this.config();
          t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName;
        }
        var n2, r2 = this;
        return a(n2 = t3.name ? new s(function(e5) {
          t3.storeName ? e5(G(t3, r2._defaultConfig)) : e5(t3.name + "/");
        }).then(function(t4) {
          for (var e5 = localStorage.length - 1; e5 >= 0; e5--) {
            var i4 = localStorage.key(e5);
            i4.indexOf(t4) === 0 && localStorage.removeItem(i4);
          }
        }) : s.reject("Invalid arguments"), e4), n2;
      } }, z = function(t3, e4) {
        for (var i3, n2, r2 = t3.length, o2 = 0; o2 < r2; ) {
          if ((i3 = t3[o2]) === (n2 = e4) || typeof i3 == "number" && typeof n2 == "number" && isNaN(i3) && isNaN(n2))
            return true;
          o2++;
        }
        return false;
      }, V = Array.isArray || function(t3) {
        return Object.prototype.toString.call(t3) === "[object Array]";
      }, X = {}, W = {}, Y = { INDEXEDDB: A, WEBSQL: k, LOCALSTORAGE: j }, q = [Y.INDEXEDDB._driver, Y.WEBSQL._driver, Y.LOCALSTORAGE._driver], Z = ["dropInstance"], J = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Z), K = { description: "", driver: q.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
      function Q(t3, e4) {
        t3[e4] = function() {
          var i3 = arguments;
          return t3.ready().then(function() {
            return t3[e4].apply(t3, i3);
          });
        };
      }
      function $() {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var e4 = arguments[t3];
          if (e4)
            for (var i3 in e4)
              e4.hasOwnProperty(i3) && (V(e4[i3]) ? arguments[0][i3] = e4[i3].slice() : arguments[0][i3] = e4[i3]);
        }
        return arguments[0];
      }
      var tt = new (function() {
        function t3(e4) {
          for (var i3 in function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), Y)
            if (Y.hasOwnProperty(i3)) {
              var n2 = Y[i3], r2 = n2._driver;
              this[i3] = r2, X[r2] || this.defineDriver(n2);
            }
          this._defaultConfig = $({}, K), this._config = $({}, this._defaultConfig, e4), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return t3.prototype.config = function(t4) {
          if ((t4 === void 0 ? "undefined" : n(t4)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var e4 in t4) {
              if (e4 === "storeName" && (t4[e4] = t4[e4].replace(/\W/g, "_")), e4 === "version" && typeof t4[e4] != "number")
                return new Error("Database version must be a number.");
              this._config[e4] = t4[e4];
            }
            return !("driver" in t4) || !t4.driver || this.setDriver(this._config.driver);
          }
          return typeof t4 == "string" ? this._config[t4] : this._config;
        }, t3.prototype.defineDriver = function(t4, e4, i3) {
          var n2 = new s(function(e5, i4) {
            try {
              var n3 = t4._driver, r2 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!t4._driver)
                return void i4(r2);
              for (var o2 = J.concat("_initStorage"), l2 = 0, h2 = o2.length; l2 < h2; l2++) {
                var u2 = o2[l2];
                if ((!z(Z, u2) || t4[u2]) && typeof t4[u2] != "function")
                  return void i4(r2);
              }
              !function() {
                for (var e6 = function(t5) {
                  return function() {
                    var e7 = new Error("Method " + t5 + " is not implemented by the current driver"), i6 = s.reject(e7);
                    return a(i6, arguments[arguments.length - 1]), i6;
                  };
                }, i5 = 0, n4 = Z.length; i5 < n4; i5++) {
                  var r3 = Z[i5];
                  t4[r3] || (t4[r3] = e6(r3));
                }
              }();
              var c2 = function(i5) {
                X[n3] && console.info("Redefining LocalForage driver: " + n3), X[n3] = t4, W[n3] = i5, e5();
              };
              "_support" in t4 ? t4._support && typeof t4._support == "function" ? t4._support().then(c2, i4) : c2(!!t4._support) : c2(true);
            } catch (t5) {
              i4(t5);
            }
          });
          return l(n2, e4, i3), n2;
        }, t3.prototype.driver = function() {
          return this._driver || null;
        }, t3.prototype.getDriver = function(t4, e4, i3) {
          var n2 = X[t4] ? s.resolve(X[t4]) : s.reject(new Error("Driver not found."));
          return l(n2, e4, i3), n2;
        }, t3.prototype.getSerializer = function(t4) {
          var e4 = s.resolve(L);
          return l(e4, t4), e4;
        }, t3.prototype.ready = function(t4) {
          var e4 = this, i3 = e4._driverSet.then(function() {
            return e4._ready === null && (e4._ready = e4._initDriver()), e4._ready;
          });
          return l(i3, t4, t4), i3;
        }, t3.prototype.setDriver = function(t4, e4, i3) {
          var n2 = this;
          V(t4) || (t4 = [t4]);
          var r2 = this._getSupportedDrivers(t4);
          function o2() {
            n2._config.driver = n2.driver();
          }
          function a2(t5) {
            return n2._extend(t5), o2(), n2._ready = n2._initStorage(n2._config), n2._ready;
          }
          var h2 = this._driverSet !== null ? this._driverSet.catch(function() {
            return s.resolve();
          }) : s.resolve();
          return this._driverSet = h2.then(function() {
            var t5 = r2[0];
            return n2._dbInfo = null, n2._ready = null, n2.getDriver(t5).then(function(t6) {
              n2._driver = t6._driver, o2(), n2._wrapLibraryMethodsWithReady(), n2._initDriver = function(t7) {
                return function() {
                  var e5 = 0;
                  return function i4() {
                    for (; e5 < t7.length; ) {
                      var r3 = t7[e5];
                      return e5++, n2._dbInfo = null, n2._ready = null, n2.getDriver(r3).then(a2).catch(i4);
                    }
                    o2();
                    var l2 = new Error("No available storage method found.");
                    return n2._driverSet = s.reject(l2), n2._driverSet;
                  }();
                };
              }(r2);
            });
          }).catch(function() {
            o2();
            var t5 = new Error("No available storage method found.");
            return n2._driverSet = s.reject(t5), n2._driverSet;
          }), l(this._driverSet, e4, i3), this._driverSet;
        }, t3.prototype.supports = function(t4) {
          return !!W[t4];
        }, t3.prototype._extend = function(t4) {
          $(this, t4);
        }, t3.prototype._getSupportedDrivers = function(t4) {
          for (var e4 = [], i3 = 0, n2 = t4.length; i3 < n2; i3++) {
            var r2 = t4[i3];
            this.supports(r2) && e4.push(r2);
          }
          return e4;
        }, t3.prototype._wrapLibraryMethodsWithReady = function() {
          for (var t4 = 0, e4 = J.length; t4 < e4; t4++)
            Q(this, J[t4]);
        }, t3.prototype.createInstance = function(e4) {
          return new t3(e4);
        }, t3;
      }())();
      e3.exports = tt;
    }, { 3: 3 }] }, {}, [4])(4);
  }).call(this, i(17));
}, function(t, e, i) {
  var n = i(14).Symbol;
  t.exports = n;
}, function(t, e) {
  t.exports = function(t2) {
    return t2.webpackPolyfill || (t2.deprecate = function() {
    }, t2.paths = [], t2.children || (t2.children = []), Object.defineProperty(t2, "loaded", { enumerable: true, get: function() {
      return t2.l;
    } }), Object.defineProperty(t2, "id", { enumerable: true, get: function() {
      return t2.i;
    } }), t2.webpackPolyfill = 1), t2;
  };
}, function(t, e, i) {
  var n = i(152), r = i(153), o = i(154), s = i(155), a = i(156);
  function l(t2) {
    var e2 = -1, i2 = t2 == null ? 0 : t2.length;
    for (this.clear(); ++e2 < i2; ) {
      var n2 = t2[e2];
      this.set(n2[0], n2[1]);
    }
  }
  l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
}, function(t, e, i) {
  var n = i(36);
  t.exports = function(t2, e2) {
    for (var i2 = t2.length; i2--; )
      if (n(t2[i2][0], e2))
        return i2;
    return -1;
  };
}, function(t, e, i) {
  var n = i(22)(Object, "create");
  t.exports = n;
}, function(t, e, i) {
  var n = i(174);
  t.exports = function(t2, e2) {
    var i2 = t2.__data__;
    return n(e2) ? i2[typeof e2 == "string" ? "string" : "hash"] : i2.map;
  };
}, function(t, e) {
  var i = Array.isArray;
  t.exports = i;
}, function(t, e, i) {
  var n = i(196), r = i(37), o = i(197), s = i(198), a = i(199), l = i(20), h = i(55), u = h(n), c = h(r), d = h(o), p = h(s), f = h(a), m = l;
  (n && m(new n(new ArrayBuffer(1))) != "[object DataView]" || r && m(new r()) != "[object Map]" || o && m(o.resolve()) != "[object Promise]" || s && m(new s()) != "[object Set]" || a && m(new a()) != "[object WeakMap]") && (m = function(t2) {
    var e2 = l(t2), i2 = e2 == "[object Object]" ? t2.constructor : void 0, n2 = i2 ? h(i2) : "";
    if (n2)
      switch (n2) {
        case u:
          return "[object DataView]";
        case c:
          return "[object Map]";
        case d:
          return "[object Promise]";
        case p:
          return "[object Set]";
        case f:
          return "[object WeakMap]";
      }
    return e2;
  }), t.exports = m;
}, function(t, e, i) {
  var n = i(68), r = i(69);
  t.exports = function(t2, e2, i2, o) {
    var s = !i2;
    i2 || (i2 = {});
    for (var a = -1, l = e2.length; ++a < l; ) {
      var h = e2[a], u = o ? o(i2[h], t2[h], h, i2, t2) : void 0;
      u === void 0 && (u = t2[h]), s ? r(i2, h, u) : n(i2, h, u);
    }
    return i2;
  };
}, function(t, e, i) {
  var n = i(20), r = i(21);
  t.exports = function(t2) {
    if (!r(t2))
      return false;
    var e2 = n(t2);
    return e2 == "[object Function]" || e2 == "[object GeneratorFunction]" || e2 == "[object AsyncFunction]" || e2 == "[object Proxy]";
  };
}, function(t, e, i) {
  (function(t2) {
    i.d(e, "a", function() {
      return Fi;
    });
    var n = i(4), r = i(0), o = i(10), s = i(8), a = i(16), l = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : t2 !== void 0 ? t2 : typeof self != "undefined" ? self : {};
    function h(t3, e2, i2) {
      return t3(i2 = { path: e2, exports: {}, require: function(t4, e3) {
        return function() {
          throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
        }(e3 == null && i2.path);
      } }, i2.exports), i2.exports;
    }
    var u = h(function(t3) {
      var e2 = Object.prototype.hasOwnProperty, i2 = "~";
      function n2() {
      }
      function r2(t4, e3, i3) {
        this.fn = t4, this.context = e3, this.once = i3 || false;
      }
      function o2(t4, e3, n3, o3, s3) {
        if (typeof n3 != "function")
          throw new TypeError("The listener must be a function");
        var a3 = new r2(n3, o3 || t4, s3), l2 = i2 ? i2 + e3 : e3;
        return t4._events[l2] ? t4._events[l2].fn ? t4._events[l2] = [t4._events[l2], a3] : t4._events[l2].push(a3) : (t4._events[l2] = a3, t4._eventsCount++), t4;
      }
      function s2(t4, e3) {
        --t4._eventsCount == 0 ? t4._events = new n2() : delete t4._events[e3];
      }
      function a2() {
        this._events = new n2(), this._eventsCount = 0;
      }
      Object.create && (n2.prototype = /* @__PURE__ */ Object.create(null), new n2().__proto__ || (i2 = false)), a2.prototype.eventNames = function() {
        var t4, n3, r3 = [];
        if (this._eventsCount === 0)
          return r3;
        for (n3 in t4 = this._events)
          e2.call(t4, n3) && r3.push(i2 ? n3.slice(1) : n3);
        return Object.getOwnPropertySymbols ? r3.concat(Object.getOwnPropertySymbols(t4)) : r3;
      }, a2.prototype.listeners = function(t4) {
        var e3 = i2 ? i2 + t4 : t4, n3 = this._events[e3];
        if (!n3)
          return [];
        if (n3.fn)
          return [n3.fn];
        for (var r3 = 0, o3 = n3.length, s3 = new Array(o3); r3 < o3; r3++)
          s3[r3] = n3[r3].fn;
        return s3;
      }, a2.prototype.listenerCount = function(t4) {
        var e3 = i2 ? i2 + t4 : t4, n3 = this._events[e3];
        return n3 ? n3.fn ? 1 : n3.length : 0;
      }, a2.prototype.emit = function(t4, e3, n3, r3, o3, s3) {
        var a3 = arguments, l2 = i2 ? i2 + t4 : t4;
        if (!this._events[l2])
          return false;
        var h2, u2, c2 = this._events[l2], d2 = arguments.length;
        if (c2.fn) {
          switch (c2.once && this.removeListener(t4, c2.fn, void 0, true), d2) {
            case 1:
              return c2.fn.call(c2.context), true;
            case 2:
              return c2.fn.call(c2.context, e3), true;
            case 3:
              return c2.fn.call(c2.context, e3, n3), true;
            case 4:
              return c2.fn.call(c2.context, e3, n3, r3), true;
            case 5:
              return c2.fn.call(c2.context, e3, n3, r3, o3), true;
            case 6:
              return c2.fn.call(c2.context, e3, n3, r3, o3, s3), true;
          }
          for (u2 = 1, h2 = new Array(d2 - 1); u2 < d2; u2++)
            h2[u2 - 1] = a3[u2];
          c2.fn.apply(c2.context, h2);
        } else {
          var p2, f2 = c2.length;
          for (u2 = 0; u2 < f2; u2++)
            switch (c2[u2].once && this.removeListener(t4, c2[u2].fn, void 0, true), d2) {
              case 1:
                c2[u2].fn.call(c2[u2].context);
                break;
              case 2:
                c2[u2].fn.call(c2[u2].context, e3);
                break;
              case 3:
                c2[u2].fn.call(c2[u2].context, e3, n3);
                break;
              case 4:
                c2[u2].fn.call(c2[u2].context, e3, n3, r3);
                break;
              default:
                if (!h2)
                  for (p2 = 1, h2 = new Array(d2 - 1); p2 < d2; p2++)
                    h2[p2 - 1] = a3[p2];
                c2[u2].fn.apply(c2[u2].context, h2);
            }
        }
        return true;
      }, a2.prototype.on = function(t4, e3, i3) {
        return o2(this, t4, e3, i3, false);
      }, a2.prototype.once = function(t4, e3, i3) {
        return o2(this, t4, e3, i3, true);
      }, a2.prototype.removeListener = function(t4, e3, n3, r3) {
        var o3 = i2 ? i2 + t4 : t4;
        if (!this._events[o3])
          return this;
        if (!e3)
          return s2(this, o3), this;
        var a3 = this._events[o3];
        if (a3.fn)
          a3.fn !== e3 || r3 && !a3.once || n3 && a3.context !== n3 || s2(this, o3);
        else {
          for (var l2 = 0, h2 = [], u2 = a3.length; l2 < u2; l2++)
            (a3[l2].fn !== e3 || r3 && !a3[l2].once || n3 && a3[l2].context !== n3) && h2.push(a3[l2]);
          h2.length ? this._events[o3] = h2.length === 1 ? h2[0] : h2 : s2(this, o3);
        }
        return this;
      }, a2.prototype.removeAllListeners = function(t4) {
        var e3;
        return t4 ? (e3 = i2 ? i2 + t4 : t4, this._events[e3] && s2(this, e3)) : (this._events = new n2(), this._eventsCount = 0), this;
      }, a2.prototype.off = a2.prototype.removeListener, a2.prototype.addListener = a2.prototype.on, a2.prefixed = i2, a2.EventEmitter = a2, t3.exports = a2;
    }), c = h(function(t3, e2) {
      !function(i2) {
        var n2 = e2 && !e2.nodeType && e2, r2 = t3 && !t3.nodeType && t3, o2 = typeof l == "object" && l;
        o2.global !== o2 && o2.window !== o2 && o2.self !== o2 || (i2 = o2);
        var s2, a2, h2 = 2147483647, u2 = /^xn--/, c2 = /[^\x20-\x7E]/, d2 = /[\x2E\u3002\uFF0E\uFF61]/g, p2 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f2 = Math.floor, m2 = String.fromCharCode;
        function g2(t4) {
          throw RangeError(p2[t4]);
        }
        function v2(t4, e3) {
          for (var i3 = t4.length, n3 = []; i3--; )
            n3[i3] = e3(t4[i3]);
          return n3;
        }
        function _2(t4, e3) {
          var i3 = t4.split("@"), n3 = "";
          return i3.length > 1 && (n3 = i3[0] + "@", t4 = i3[1]), n3 + v2((t4 = t4.replace(d2, ".")).split("."), e3).join(".");
        }
        function y2(t4) {
          for (var e3, i3, n3 = [], r3 = 0, o3 = t4.length; r3 < o3; )
            (e3 = t4.charCodeAt(r3++)) >= 55296 && e3 <= 56319 && r3 < o3 ? (64512 & (i3 = t4.charCodeAt(r3++))) == 56320 ? n3.push(((1023 & e3) << 10) + (1023 & i3) + 65536) : (n3.push(e3), r3--) : n3.push(e3);
          return n3;
        }
        function x2(t4) {
          return v2(t4, function(t5) {
            var e3 = "";
            return t5 > 65535 && (e3 += m2((t5 -= 65536) >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), e3 += m2(t5);
          }).join("");
        }
        function b2(t4, e3) {
          return t4 + 22 + 75 * (t4 < 26) - ((e3 != 0) << 5);
        }
        function T2(t4, e3, i3) {
          var n3 = 0;
          for (t4 = i3 ? f2(t4 / 700) : t4 >> 1, t4 += f2(t4 / e3); t4 > 455; n3 += 36)
            t4 = f2(t4 / 35);
          return f2(n3 + 36 * t4 / (t4 + 38));
        }
        function E2(t4) {
          var e3, i3, n3, r3, o3, s3, a3, l2, u3, c3, d3, p3 = [], m3 = t4.length, v3 = 0, _3 = 128, y3 = 72;
          for ((i3 = t4.lastIndexOf("-")) < 0 && (i3 = 0), n3 = 0; n3 < i3; ++n3)
            t4.charCodeAt(n3) >= 128 && g2("not-basic"), p3.push(t4.charCodeAt(n3));
          for (r3 = i3 > 0 ? i3 + 1 : 0; r3 < m3; ) {
            for (o3 = v3, s3 = 1, a3 = 36; r3 >= m3 && g2("invalid-input"), ((l2 = (d3 = t4.charCodeAt(r3++)) - 48 < 10 ? d3 - 22 : d3 - 65 < 26 ? d3 - 65 : d3 - 97 < 26 ? d3 - 97 : 36) >= 36 || l2 > f2((h2 - v3) / s3)) && g2("overflow"), v3 += l2 * s3, !(l2 < (u3 = a3 <= y3 ? 1 : a3 >= y3 + 26 ? 26 : a3 - y3)); a3 += 36)
              s3 > f2(h2 / (c3 = 36 - u3)) && g2("overflow"), s3 *= c3;
            y3 = T2(v3 - o3, e3 = p3.length + 1, o3 == 0), f2(v3 / e3) > h2 - _3 && g2("overflow"), _3 += f2(v3 / e3), v3 %= e3, p3.splice(v3++, 0, _3);
          }
          return x2(p3);
        }
        function S2(t4) {
          var e3, i3, n3, r3, o3, s3, a3, l2, u3, c3, d3, p3, v3, _3, x3, E3 = [];
          for (p3 = (t4 = y2(t4)).length, e3 = 128, i3 = 0, o3 = 72, s3 = 0; s3 < p3; ++s3)
            (d3 = t4[s3]) < 128 && E3.push(m2(d3));
          for (n3 = r3 = E3.length, r3 && E3.push("-"); n3 < p3; ) {
            for (a3 = h2, s3 = 0; s3 < p3; ++s3)
              (d3 = t4[s3]) >= e3 && d3 < a3 && (a3 = d3);
            for (a3 - e3 > f2((h2 - i3) / (v3 = n3 + 1)) && g2("overflow"), i3 += (a3 - e3) * v3, e3 = a3, s3 = 0; s3 < p3; ++s3)
              if ((d3 = t4[s3]) < e3 && ++i3 > h2 && g2("overflow"), d3 == e3) {
                for (l2 = i3, u3 = 36; !(l2 < (c3 = u3 <= o3 ? 1 : u3 >= o3 + 26 ? 26 : u3 - o3)); u3 += 36)
                  x3 = l2 - c3, _3 = 36 - c3, E3.push(m2(b2(c3 + x3 % _3, 0))), l2 = f2(x3 / _3);
                E3.push(m2(b2(l2, 0))), o3 = T2(i3, v3, n3 == r3), i3 = 0, ++n3;
              }
            ++i3, ++e3;
          }
          return E3.join("");
        }
        if (s2 = { version: "1.3.2", ucs2: { decode: y2, encode: x2 }, decode: E2, encode: S2, toASCII: function(t4) {
          return _2(t4, function(t5) {
            return c2.test(t5) ? "xn--" + S2(t5) : t5;
          });
        }, toUnicode: function(t4) {
          return _2(t4, function(t5) {
            return u2.test(t5) ? E2(t5.slice(4).toLowerCase()) : t5;
          });
        } }, n2 && r2)
          if (t3.exports == n2)
            r2.exports = s2;
          else
            for (a2 in s2)
              s2.hasOwnProperty(a2) && (n2[a2] = s2[a2]);
        else
          i2.punycode = s2;
      }(l);
    }), d = function(t3) {
      return typeof t3 == "string";
    }, p = function(t3) {
      return typeof t3 == "object" && t3 !== null;
    }, f = function(t3) {
      return t3 === null;
    }, m = function(t3) {
      return t3 == null;
    };
    function g(t3, e2) {
      return Object.prototype.hasOwnProperty.call(t3, e2);
    }
    var v = function(t3, e2, i2, n2) {
      e2 = e2 || "&", i2 = i2 || "=";
      var r2 = {};
      if (typeof t3 != "string" || t3.length === 0)
        return r2;
      var o2 = /\+/g;
      t3 = t3.split(e2);
      var s2 = 1e3;
      n2 && typeof n2.maxKeys == "number" && (s2 = n2.maxKeys);
      var a2 = t3.length;
      s2 > 0 && a2 > s2 && (a2 = s2);
      for (var l2 = 0; l2 < a2; ++l2) {
        var h2, u2, c2, d2, p2 = t3[l2].replace(o2, "%20"), f2 = p2.indexOf(i2);
        f2 >= 0 ? (h2 = p2.substr(0, f2), u2 = p2.substr(f2 + 1)) : (h2 = p2, u2 = ""), c2 = decodeURIComponent(h2), d2 = decodeURIComponent(u2), g(r2, c2) ? Array.isArray(r2[c2]) ? r2[c2].push(d2) : r2[c2] = [r2[c2], d2] : r2[c2] = d2;
      }
      return r2;
    }, _ = function(t3) {
      switch (typeof t3) {
        case "string":
          return t3;
        case "boolean":
          return t3 ? "true" : "false";
        case "number":
          return isFinite(t3) ? t3 : "";
        default:
          return "";
      }
    }, y = function(t3, e2, i2, n2) {
      return e2 = e2 || "&", i2 = i2 || "=", t3 === null && (t3 = void 0), typeof t3 == "object" ? Object.keys(t3).map(function(n3) {
        var r2 = encodeURIComponent(_(n3)) + i2;
        return Array.isArray(t3[n3]) ? t3[n3].map(function(t4) {
          return r2 + encodeURIComponent(_(t4));
        }).join(e2) : r2 + encodeURIComponent(_(t3[n3]));
      }).join(e2) : n2 ? encodeURIComponent(_(n2)) + i2 + encodeURIComponent(_(t3)) : "";
    }, x = h(function(t3, e2) {
      e2.decode = e2.parse = v, e2.encode = e2.stringify = y;
    }), b = B, T = function(t3, e2) {
      return B(t3, false, true).resolve(e2);
    }, E = function(t3) {
      d(t3) && (t3 = B(t3));
      if (!(t3 instanceof S))
        return S.prototype.format.call(t3);
      return t3.format();
    };
    function S() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var w = /^([a-z0-9.+-]+:)/i, A = /:[0-9]*$/, M = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, R = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), C = ["'"].concat(R), I = ["%", "/", "?", ";", "#"].concat(C), P = ["/", "?", "#"], O = /^[+a-z0-9A-Z_-]{0,63}$/, N = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, L = { javascript: true, "javascript:": true }, D = { javascript: true, "javascript:": true }, F = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    function B(t3, e2, i2) {
      if (t3 && p(t3) && t3 instanceof S)
        return t3;
      var n2 = new S();
      return n2.parse(t3, e2, i2), n2;
    }
    S.prototype.parse = function(t3, e2, i2) {
      if (!d(t3))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t3);
      var n2 = t3.indexOf("?"), r2 = n2 !== -1 && n2 < t3.indexOf("#") ? "?" : "#", o2 = t3.split(r2);
      o2[0] = o2[0].replace(/\\/g, "/");
      var s2 = t3 = o2.join(r2);
      if (s2 = s2.trim(), !i2 && t3.split("#").length === 1) {
        var a2 = M.exec(s2);
        if (a2)
          return this.path = s2, this.href = s2, this.pathname = a2[1], a2[2] ? (this.search = a2[2], this.query = e2 ? x.parse(this.search.substr(1)) : this.search.substr(1)) : e2 && (this.search = "", this.query = {}), this;
      }
      var l2 = w.exec(s2);
      if (l2) {
        var h2 = (l2 = l2[0]).toLowerCase();
        this.protocol = h2, s2 = s2.substr(l2.length);
      }
      if (i2 || l2 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var u2 = s2.substr(0, 2) === "//";
        !u2 || l2 && D[l2] || (s2 = s2.substr(2), this.slashes = true);
      }
      if (!D[l2] && (u2 || l2 && !F[l2])) {
        for (var p2, f2, m2 = -1, g2 = 0; g2 < P.length; g2++) {
          (v2 = s2.indexOf(P[g2])) !== -1 && (m2 === -1 || v2 < m2) && (m2 = v2);
        }
        (f2 = m2 === -1 ? s2.lastIndexOf("@") : s2.lastIndexOf("@", m2)) !== -1 && (p2 = s2.slice(0, f2), s2 = s2.slice(f2 + 1), this.auth = decodeURIComponent(p2)), m2 = -1;
        for (g2 = 0; g2 < I.length; g2++) {
          var v2;
          (v2 = s2.indexOf(I[g2])) !== -1 && (m2 === -1 || v2 < m2) && (m2 = v2);
        }
        m2 === -1 && (m2 = s2.length), this.host = s2.slice(0, m2), s2 = s2.slice(m2), this.parseHost(), this.hostname = this.hostname || "";
        var _2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!_2)
          for (var y2 = this.hostname.split(/\./), b2 = (g2 = 0, y2.length); g2 < b2; g2++) {
            var T2 = y2[g2];
            if (T2 && !T2.match(O)) {
              for (var E2 = "", S2 = 0, A2 = T2.length; S2 < A2; S2++)
                T2.charCodeAt(S2) > 127 ? E2 += "x" : E2 += T2[S2];
              if (!E2.match(O)) {
                var R2 = y2.slice(0, g2), B2 = y2.slice(g2 + 1), U2 = T2.match(N);
                U2 && (R2.push(U2[1]), B2.unshift(U2[2])), B2.length && (s2 = "/" + B2.join(".") + s2), this.hostname = R2.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), _2 || (this.hostname = c.toASCII(this.hostname));
        var k2 = this.port ? ":" + this.port : "", G2 = this.hostname || "";
        this.host = G2 + k2, this.href += this.host, _2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s2[0] !== "/" && (s2 = "/" + s2));
      }
      if (!L[h2])
        for (g2 = 0, b2 = C.length; g2 < b2; g2++) {
          var H2 = C[g2];
          if (s2.indexOf(H2) !== -1) {
            var j2 = encodeURIComponent(H2);
            j2 === H2 && (j2 = escape(H2)), s2 = s2.split(H2).join(j2);
          }
        }
      var z2 = s2.indexOf("#");
      z2 !== -1 && (this.hash = s2.substr(z2), s2 = s2.slice(0, z2));
      var V2 = s2.indexOf("?");
      if (V2 !== -1 ? (this.search = s2.substr(V2), this.query = s2.substr(V2 + 1), e2 && (this.query = x.parse(this.query)), s2 = s2.slice(0, V2)) : e2 && (this.search = "", this.query = {}), s2 && (this.pathname = s2), F[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        k2 = this.pathname || "";
        var X2 = this.search || "";
        this.path = k2 + X2;
      }
      return this.href = this.format(), this;
    }, S.prototype.format = function() {
      var t3 = this.auth || "";
      t3 && (t3 = (t3 = encodeURIComponent(t3)).replace(/%3A/i, ":"), t3 += "@");
      var e2 = this.protocol || "", i2 = this.pathname || "", n2 = this.hash || "", r2 = false, o2 = "";
      this.host ? r2 = t3 + this.host : this.hostname && (r2 = t3 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (r2 += ":" + this.port)), this.query && p(this.query) && Object.keys(this.query).length && (o2 = x.stringify(this.query));
      var s2 = this.search || o2 && "?" + o2 || "";
      return e2 && e2.substr(-1) !== ":" && (e2 += ":"), this.slashes || (!e2 || F[e2]) && r2 !== false ? (r2 = "//" + (r2 || ""), i2 && i2.charAt(0) !== "/" && (i2 = "/" + i2)) : r2 || (r2 = ""), n2 && n2.charAt(0) !== "#" && (n2 = "#" + n2), s2 && s2.charAt(0) !== "?" && (s2 = "?" + s2), e2 + r2 + (i2 = i2.replace(/[?#]/g, function(t4) {
        return encodeURIComponent(t4);
      })) + (s2 = s2.replace("#", "%23")) + n2;
    }, S.prototype.resolve = function(t3) {
      return this.resolveObject(B(t3, false, true)).format();
    }, S.prototype.resolveObject = function(t3) {
      if (d(t3)) {
        var e2 = new S();
        e2.parse(t3, false, true), t3 = e2;
      }
      for (var i2 = new S(), n2 = Object.keys(this), r2 = 0; r2 < n2.length; r2++) {
        var o2 = n2[r2];
        i2[o2] = this[o2];
      }
      if (i2.hash = t3.hash, t3.href === "")
        return i2.href = i2.format(), i2;
      if (t3.slashes && !t3.protocol) {
        for (var s2 = Object.keys(t3), a2 = 0; a2 < s2.length; a2++) {
          var l2 = s2[a2];
          l2 !== "protocol" && (i2[l2] = t3[l2]);
        }
        return F[i2.protocol] && i2.hostname && !i2.pathname && (i2.path = i2.pathname = "/"), i2.href = i2.format(), i2;
      }
      if (t3.protocol && t3.protocol !== i2.protocol) {
        if (!F[t3.protocol]) {
          for (var h2 = Object.keys(t3), u2 = 0; u2 < h2.length; u2++) {
            var c2 = h2[u2];
            i2[c2] = t3[c2];
          }
          return i2.href = i2.format(), i2;
        }
        if (i2.protocol = t3.protocol, t3.host || D[t3.protocol])
          i2.pathname = t3.pathname;
        else {
          for (var p2 = (t3.pathname || "").split("/"); p2.length && !(t3.host = p2.shift()); )
            ;
          t3.host || (t3.host = ""), t3.hostname || (t3.hostname = ""), p2[0] !== "" && p2.unshift(""), p2.length < 2 && p2.unshift(""), i2.pathname = p2.join("/");
        }
        if (i2.search = t3.search, i2.query = t3.query, i2.host = t3.host || "", i2.auth = t3.auth, i2.hostname = t3.hostname || t3.host, i2.port = t3.port, i2.pathname || i2.search) {
          var g2 = i2.pathname || "", v2 = i2.search || "";
          i2.path = g2 + v2;
        }
        return i2.slashes = i2.slashes || t3.slashes, i2.href = i2.format(), i2;
      }
      var _2 = i2.pathname && i2.pathname.charAt(0) === "/", y2 = t3.host || t3.pathname && t3.pathname.charAt(0) === "/", x2 = y2 || _2 || i2.host && t3.pathname, b2 = x2, T2 = i2.pathname && i2.pathname.split("/") || [], E2 = (p2 = t3.pathname && t3.pathname.split("/") || [], i2.protocol && !F[i2.protocol]);
      if (E2 && (i2.hostname = "", i2.port = null, i2.host && (T2[0] === "" ? T2[0] = i2.host : T2.unshift(i2.host)), i2.host = "", t3.protocol && (t3.hostname = null, t3.port = null, t3.host && (p2[0] === "" ? p2[0] = t3.host : p2.unshift(t3.host)), t3.host = null), x2 = x2 && (p2[0] === "" || T2[0] === "")), y2)
        i2.host = t3.host || t3.host === "" ? t3.host : i2.host, i2.hostname = t3.hostname || t3.hostname === "" ? t3.hostname : i2.hostname, i2.search = t3.search, i2.query = t3.query, T2 = p2;
      else if (p2.length)
        T2 || (T2 = []), T2.pop(), T2 = T2.concat(p2), i2.search = t3.search, i2.query = t3.query;
      else if (!m(t3.search)) {
        if (E2)
          i2.hostname = i2.host = T2.shift(), (C2 = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = C2.shift(), i2.host = i2.hostname = C2.shift());
        return i2.search = t3.search, i2.query = t3.query, f(i2.pathname) && f(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.href = i2.format(), i2;
      }
      if (!T2.length)
        return i2.pathname = null, i2.search ? i2.path = "/" + i2.search : i2.path = null, i2.href = i2.format(), i2;
      for (var w2 = T2.slice(-1)[0], A2 = (i2.host || t3.host || T2.length > 1) && (w2 === "." || w2 === "..") || w2 === "", M2 = 0, R2 = T2.length; R2 >= 0; R2--)
        (w2 = T2[R2]) === "." ? T2.splice(R2, 1) : w2 === ".." ? (T2.splice(R2, 1), M2++) : M2 && (T2.splice(R2, 1), M2--);
      if (!x2 && !b2)
        for (; M2--; M2)
          T2.unshift("..");
      !x2 || T2[0] === "" || T2[0] && T2[0].charAt(0) === "/" || T2.unshift(""), A2 && T2.join("/").substr(-1) !== "/" && T2.push("");
      var C2, I2 = T2[0] === "" || T2[0] && T2[0].charAt(0) === "/";
      E2 && (i2.hostname = i2.host = I2 ? "" : T2.length ? T2.shift() : "", (C2 = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = C2.shift(), i2.host = i2.hostname = C2.shift()));
      return (x2 = x2 || i2.host && T2.length) && !I2 && T2.unshift(""), T2.length ? i2.pathname = T2.join("/") : (i2.pathname = null, i2.path = null), f(i2.pathname) && f(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.auth = t3.auth || i2.auth, i2.slashes = i2.slashes || t3.slashes, i2.href = i2.format(), i2;
    }, S.prototype.parseHost = function() {
      var t3 = this.host, e2 = A.exec(t3);
      e2 && ((e2 = e2[0]) !== ":" && (this.port = e2.substr(1)), t3 = t3.substr(0, t3.length - e2.length)), t3 && (this.hostname = t3);
    };
    /*!
     * @pixi/utils - v6.4.2
     * Compiled Thu, 02 Jun 2022 15:39:26 UTC
     *
     * @pixi/utils is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var U = { parse: b, format: E, resolve: T };
    n.b.RETINA_PREFIX = /@([0-9\.]+)x/, n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
    var k, G = false;
    var H = function() {
      for (var t3 = [], e2 = [], i2 = 0; i2 < 32; i2++)
        t3[i2] = i2, e2[i2] = i2;
      t3[r.b.NORMAL_NPM] = r.b.NORMAL, t3[r.b.ADD_NPM] = r.b.ADD, t3[r.b.SCREEN_NPM] = r.b.SCREEN, e2[r.b.NORMAL] = r.b.NORMAL_NPM, e2[r.b.ADD] = r.b.ADD_NPM, e2[r.b.SCREEN] = r.b.SCREEN_NPM;
      var n2 = [];
      return n2.push(e2), n2.push(t3), n2;
    }();
    function j(t3) {
      if (t3.BYTES_PER_ELEMENT === 4)
        return t3 instanceof Float32Array ? "Float32Array" : t3 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
      if (t3.BYTES_PER_ELEMENT === 2) {
        if (t3 instanceof Uint16Array)
          return "Uint16Array";
      } else if (t3.BYTES_PER_ELEMENT === 1 && t3 instanceof Uint8Array)
        return "Uint8Array";
      return null;
    }
    function z(t3) {
      return t3 += t3 === 0 ? 1 : 0, --t3, t3 |= t3 >>> 1, t3 |= t3 >>> 2, t3 |= t3 >>> 4, t3 |= t3 >>> 8, (t3 |= t3 >>> 16) + 1;
    }
    function V(t3) {
      return !(t3 & t3 - 1 || !t3);
    }
    function X(t3) {
      var e2 = (t3 > 65535 ? 1 : 0) << 4, i2 = ((t3 >>>= e2) > 255 ? 1 : 0) << 3;
      return e2 |= i2, e2 |= i2 = ((t3 >>>= i2) > 15 ? 1 : 0) << 2, (e2 |= i2 = ((t3 >>>= i2) > 3 ? 1 : 0) << 1) | (t3 >>>= i2) >> 1;
    }
    var W = 0;
    function Y() {
      return ++W;
    }
    var q = {};
    function Z(t3, e2, i2) {
      if (i2 === void 0 && (i2 = 3), !q[e2]) {
        var n2 = new Error().stack;
        n2 === void 0 ? console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t3) : (n2 = n2.split("\n").splice(i2).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e2 + "\nDeprecated since v" + t3), console.warn(n2), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t3), console.warn(n2))), q[e2] = true;
      }
    }
    var J, K = {}, Q = /* @__PURE__ */ Object.create(null), $ = /* @__PURE__ */ Object.create(null);
    function tt(t3, e2) {
      if (e2 === void 0 && (e2 = globalThis.location), t3.indexOf("data:") === 0)
        return "";
      e2 = e2 || globalThis.location, J || (J = document.createElement("a")), J.href = t3;
      var i2 = U.parse(J.href), n2 = !i2.port && e2.port === "" || i2.port === e2.port;
      return i2.hostname === e2.hostname && n2 && i2.protocol === e2.protocol ? "" : "anonymous";
    }
    function et(t3, e2) {
      var i2 = n.b.RETINA_PREFIX.exec(t3);
      return i2 ? parseFloat(i2[1]) : e2 !== void 0 ? e2 : 1;
    }
    /*!
     * @pixi/runner - v6.4.2
     * Compiled Thu, 02 Jun 2022 15:39:26 UTC
     *
     * @pixi/runner is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    !function() {
      function t3(t4, e2, i2) {
        this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i2 || n.b.RESOLUTION, this.resize(t4, e2);
      }
      t3.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }, t3.prototype.resize = function(t4, e2) {
        this.canvas.width = Math.round(t4 * this.resolution), this.canvas.height = Math.round(e2 * this.resolution);
      }, t3.prototype.destroy = function() {
        this.context = null, this.canvas = null;
      }, Object.defineProperty(t3.prototype, "width", { get: function() {
        return this.canvas.width;
      }, set: function(t4) {
        this.canvas.width = Math.round(t4);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
        return this.canvas.height;
      }, set: function(t4) {
        this.canvas.height = Math.round(t4);
      }, enumerable: false, configurable: true });
    }();
    var it, nt = function() {
      function t3(t4) {
        this.items = [], this._name = t4, this._aliasCount = 0;
      }
      return t3.prototype.emit = function(t4, e2, i2, n2, r2, o2, s2, a2) {
        if (arguments.length > 8)
          throw new Error("max arguments reached");
        var l2 = this, h2 = l2.name, u2 = l2.items;
        this._aliasCount++;
        for (var c2 = 0, d2 = u2.length; c2 < d2; c2++)
          u2[c2][h2](t4, e2, i2, n2, r2, o2, s2, a2);
        return u2 === this.items && this._aliasCount--, this;
      }, t3.prototype.ensureNonAliasedItems = function() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
      }, t3.prototype.add = function(t4) {
        return t4[this._name] && (this.ensureNonAliasedItems(), this.remove(t4), this.items.push(t4)), this;
      }, t3.prototype.remove = function(t4) {
        var e2 = this.items.indexOf(t4);
        return e2 !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e2, 1)), this;
      }, t3.prototype.contains = function(t4) {
        return this.items.indexOf(t4) !== -1;
      }, t3.prototype.removeAll = function() {
        return this.ensureNonAliasedItems(), this.items.length = 0, this;
      }, t3.prototype.destroy = function() {
        this.removeAll(), this.items = null, this._name = null;
      }, Object.defineProperty(t3.prototype, "empty", { get: function() {
        return this.items.length === 0;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "name", { get: function() {
        return this._name;
      }, enumerable: false, configurable: true }), t3;
    }();
    Object.defineProperties(nt.prototype, { dispatch: { value: nt.prototype.emit }, run: { value: nt.prototype.emit } }), n.b.TARGET_FPMS = 0.06, function(t3) {
      t3[t3.INTERACTION = 50] = "INTERACTION", t3[t3.HIGH = 25] = "HIGH", t3[t3.NORMAL = 0] = "NORMAL", t3[t3.LOW = -25] = "LOW", t3[t3.UTILITY = -50] = "UTILITY";
    }(it || (it = {}));
    var rt, ot = function() {
      function t3(t4, e2, i2, n2) {
        e2 === void 0 && (e2 = null), i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = t4, this.context = e2, this.priority = i2, this.once = n2;
      }
      return t3.prototype.match = function(t4, e2) {
        return e2 === void 0 && (e2 = null), this.fn === t4 && this.context === e2;
      }, t3.prototype.emit = function(t4) {
        this.fn && (this.context ? this.fn.call(this.context, t4) : this.fn(t4));
        var e2 = this.next;
        return this.once && this.destroy(true), this._destroyed && (this.next = null), e2;
      }, t3.prototype.connect = function(t4) {
        this.previous = t4, t4.next && (t4.next.previous = this), this.next = t4.next, t4.next = this;
      }, t3.prototype.destroy = function(t4) {
        t4 === void 0 && (t4 = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        var e2 = this.next;
        return this.next = t4 ? null : e2, this.previous = null, e2;
      }, t3;
    }(), st = function() {
      function t3() {
        var t4 = this;
        this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new ot(null, null, 1 / 0), this.deltaMS = 1 / n.b.TARGET_FPMS, this.elapsedMS = 1 / n.b.TARGET_FPMS, this._tick = function(e2) {
          t4._requestId = null, t4.started && (t4.update(e2), t4.started && t4._requestId === null && t4._head.next && (t4._requestId = requestAnimationFrame(t4._tick)));
        };
      }
      return t3.prototype._requestIfNeeded = function() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
      }, t3.prototype._cancelIfNeeded = function() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
      }, t3.prototype._startIfPossible = function() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start();
      }, t3.prototype.add = function(t4, e2, i2) {
        return i2 === void 0 && (i2 = it.NORMAL), this._addListener(new ot(t4, e2, i2));
      }, t3.prototype.addOnce = function(t4, e2, i2) {
        return i2 === void 0 && (i2 = it.NORMAL), this._addListener(new ot(t4, e2, i2, true));
      }, t3.prototype._addListener = function(t4) {
        var e2 = this._head.next, i2 = this._head;
        if (e2) {
          for (; e2; ) {
            if (t4.priority > e2.priority) {
              t4.connect(i2);
              break;
            }
            i2 = e2, e2 = e2.next;
          }
          t4.previous || t4.connect(i2);
        } else
          t4.connect(i2);
        return this._startIfPossible(), this;
      }, t3.prototype.remove = function(t4, e2) {
        for (var i2 = this._head.next; i2; )
          i2 = i2.match(t4, e2) ? i2.destroy() : i2.next;
        return this._head.next || this._cancelIfNeeded(), this;
      }, Object.defineProperty(t3.prototype, "count", { get: function() {
        if (!this._head)
          return 0;
        for (var t4 = 0, e2 = this._head; e2 = e2.next; )
          t4++;
        return t4;
      }, enumerable: false, configurable: true }), t3.prototype.start = function() {
        this.started || (this.started = true, this._requestIfNeeded());
      }, t3.prototype.stop = function() {
        this.started && (this.started = false, this._cancelIfNeeded());
      }, t3.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          for (var t4 = this._head.next; t4; )
            t4 = t4.destroy(true);
          this._head.destroy(), this._head = null;
        }
      }, t3.prototype.update = function(t4) {
        var e2;
        if (t4 === void 0 && (t4 = performance.now()), t4 > this.lastTime) {
          if ((e2 = this.elapsedMS = t4 - this.lastTime) > this._maxElapsedMS && (e2 = this._maxElapsedMS), e2 *= this.speed, this._minElapsedMS) {
            var i2 = t4 - this._lastFrame | 0;
            if (i2 < this._minElapsedMS)
              return;
            this._lastFrame = t4 - i2 % this._minElapsedMS;
          }
          this.deltaMS = e2, this.deltaTime = this.deltaMS * n.b.TARGET_FPMS;
          for (var r2 = this._head, o2 = r2.next; o2; )
            o2 = o2.emit(this.deltaTime);
          r2.next || this._cancelIfNeeded();
        } else
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = t4;
      }, Object.defineProperty(t3.prototype, "FPS", { get: function() {
        return 1e3 / this.elapsedMS;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "minFPS", { get: function() {
        return 1e3 / this._maxElapsedMS;
      }, set: function(t4) {
        var e2 = Math.min(this.maxFPS, t4), i2 = Math.min(Math.max(0, e2) / 1e3, n.b.TARGET_FPMS);
        this._maxElapsedMS = 1 / i2;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "maxFPS", { get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      }, set: function(t4) {
        if (t4 === 0)
          this._minElapsedMS = 0;
        else {
          var e2 = Math.max(this.minFPS, t4);
          this._minElapsedMS = 1 / (e2 / 1e3);
        }
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "shared", { get: function() {
        if (!t3._shared) {
          var e2 = t3._shared = new t3();
          e2.autoStart = true, e2._protected = true;
        }
        return t3._shared;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "system", { get: function() {
        if (!t3._system) {
          var e2 = t3._system = new t3();
          e2.autoStart = true, e2._protected = true;
        }
        return t3._system;
      }, enumerable: false, configurable: true }), t3;
    }(), at = 2 * Math.PI;
    !function(t3) {
      t3[t3.POLY = 0] = "POLY", t3[t3.RECT = 1] = "RECT", t3[t3.CIRC = 2] = "CIRC", t3[t3.ELIP = 3] = "ELIP", t3[t3.RREC = 4] = "RREC";
    }(rt || (rt = {}));
    var lt = function() {
      function t3(t4, e2) {
        t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = 0), this.x = 0, this.y = 0, this.x = t4, this.y = e2;
      }
      return t3.prototype.clone = function() {
        return new t3(this.x, this.y);
      }, t3.prototype.copyFrom = function(t4) {
        return this.set(t4.x, t4.y), this;
      }, t3.prototype.copyTo = function(t4) {
        return t4.set(this.x, this.y), t4;
      }, t3.prototype.equals = function(t4) {
        return t4.x === this.x && t4.y === this.y;
      }, t3.prototype.set = function(t4, e2) {
        return t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = t4), this.x = t4, this.y = e2, this;
      }, t3.prototype.toString = function() {
        return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
      }, t3;
    }(), ht = [new lt(), new lt(), new lt(), new lt()], ut = function() {
      function t3(t4, e2, i2, n2) {
        t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 0), this.x = Number(t4), this.y = Number(e2), this.width = Number(i2), this.height = Number(n2), this.type = rt.RECT;
      }
      return Object.defineProperty(t3.prototype, "left", { get: function() {
        return this.x;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "right", { get: function() {
        return this.x + this.width;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "top", { get: function() {
        return this.y;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "bottom", { get: function() {
        return this.y + this.height;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "EMPTY", { get: function() {
        return new t3(0, 0, 0, 0);
      }, enumerable: false, configurable: true }), t3.prototype.clone = function() {
        return new t3(this.x, this.y, this.width, this.height);
      }, t3.prototype.copyFrom = function(t4) {
        return this.x = t4.x, this.y = t4.y, this.width = t4.width, this.height = t4.height, this;
      }, t3.prototype.copyTo = function(t4) {
        return t4.x = this.x, t4.y = this.y, t4.width = this.width, t4.height = this.height, t4;
      }, t3.prototype.contains = function(t4, e2) {
        return !(this.width <= 0 || this.height <= 0) && (t4 >= this.x && t4 < this.x + this.width && e2 >= this.y && e2 < this.y + this.height);
      }, t3.prototype.intersects = function(t4, e2) {
        if (!e2) {
          var i2 = this.x < t4.x ? t4.x : this.x;
          if ((this.right > t4.right ? t4.right : this.right) <= i2)
            return false;
          var n2 = this.y < t4.y ? t4.y : this.y;
          return (this.bottom > t4.bottom ? t4.bottom : this.bottom) > n2;
        }
        var r2 = this.left, o2 = this.right, s2 = this.top, a2 = this.bottom;
        if (o2 <= r2 || a2 <= s2)
          return false;
        var l2 = ht[0].set(t4.left, t4.top), h2 = ht[1].set(t4.left, t4.bottom), u2 = ht[2].set(t4.right, t4.top), c2 = ht[3].set(t4.right, t4.bottom);
        if (u2.x <= l2.x || h2.y <= l2.y)
          return false;
        var d2 = Math.sign(e2.a * e2.d - e2.b * e2.c);
        if (d2 === 0)
          return false;
        if (e2.apply(l2, l2), e2.apply(h2, h2), e2.apply(u2, u2), e2.apply(c2, c2), Math.max(l2.x, h2.x, u2.x, c2.x) <= r2 || Math.min(l2.x, h2.x, u2.x, c2.x) >= o2 || Math.max(l2.y, h2.y, u2.y, c2.y) <= s2 || Math.min(l2.y, h2.y, u2.y, c2.y) >= a2)
          return false;
        var p2 = d2 * (h2.y - l2.y), f2 = d2 * (l2.x - h2.x), m2 = p2 * r2 + f2 * s2, g2 = p2 * o2 + f2 * s2, v2 = p2 * r2 + f2 * a2, _2 = p2 * o2 + f2 * a2;
        if (Math.max(m2, g2, v2, _2) <= p2 * l2.x + f2 * l2.y || Math.min(m2, g2, v2, _2) >= p2 * c2.x + f2 * c2.y)
          return false;
        var y2 = d2 * (l2.y - u2.y), x2 = d2 * (u2.x - l2.x), b2 = y2 * r2 + x2 * s2, T2 = y2 * o2 + x2 * s2, E2 = y2 * r2 + x2 * a2, S2 = y2 * o2 + x2 * a2;
        return !(Math.max(b2, T2, E2, S2) <= y2 * l2.x + x2 * l2.y || Math.min(b2, T2, E2, S2) >= y2 * c2.x + x2 * c2.y);
      }, t3.prototype.pad = function(t4, e2) {
        return t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = t4), this.x -= t4, this.y -= e2, this.width += 2 * t4, this.height += 2 * e2, this;
      }, t3.prototype.fit = function(t4) {
        var e2 = Math.max(this.x, t4.x), i2 = Math.min(this.x + this.width, t4.x + t4.width), n2 = Math.max(this.y, t4.y), r2 = Math.min(this.y + this.height, t4.y + t4.height);
        return this.x = e2, this.width = Math.max(i2 - e2, 0), this.y = n2, this.height = Math.max(r2 - n2, 0), this;
      }, t3.prototype.ceil = function(t4, e2) {
        t4 === void 0 && (t4 = 1), e2 === void 0 && (e2 = 1e-3);
        var i2 = Math.ceil((this.x + this.width - e2) * t4) / t4, n2 = Math.ceil((this.y + this.height - e2) * t4) / t4;
        return this.x = Math.floor((this.x + e2) * t4) / t4, this.y = Math.floor((this.y + e2) * t4) / t4, this.width = i2 - this.x, this.height = n2 - this.y, this;
      }, t3.prototype.enlarge = function(t4) {
        var e2 = Math.min(this.x, t4.x), i2 = Math.max(this.x + this.width, t4.x + t4.width), n2 = Math.min(this.y, t4.y), r2 = Math.max(this.y + this.height, t4.y + t4.height);
        return this.x = e2, this.width = i2 - e2, this.y = n2, this.height = r2 - n2, this;
      }, t3.prototype.toString = function() {
        return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      }, t3;
    }(), ct = function() {
      function t3(t4, e2, i2, n2) {
        i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 0), this._x = i2, this._y = n2, this.cb = t4, this.scope = e2;
      }
      return t3.prototype.clone = function(e2, i2) {
        return e2 === void 0 && (e2 = this.cb), i2 === void 0 && (i2 = this.scope), new t3(e2, i2, this._x, this._y);
      }, t3.prototype.set = function(t4, e2) {
        return t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = t4), this._x === t4 && this._y === e2 || (this._x = t4, this._y = e2, this.cb.call(this.scope)), this;
      }, t3.prototype.copyFrom = function(t4) {
        return this._x === t4.x && this._y === t4.y || (this._x = t4.x, this._y = t4.y, this.cb.call(this.scope)), this;
      }, t3.prototype.copyTo = function(t4) {
        return t4.set(this._x, this._y), t4;
      }, t3.prototype.equals = function(t4) {
        return t4.x === this._x && t4.y === this._y;
      }, t3.prototype.toString = function() {
        return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
      }, Object.defineProperty(t3.prototype, "x", { get: function() {
        return this._x;
      }, set: function(t4) {
        this._x !== t4 && (this._x = t4, this.cb.call(this.scope));
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "y", { get: function() {
        return this._y;
      }, set: function(t4) {
        this._y !== t4 && (this._y = t4, this.cb.call(this.scope));
      }, enumerable: false, configurable: true }), t3;
    }(), dt = function() {
      function t3(t4, e2, i2, n2, r2, o2) {
        t4 === void 0 && (t4 = 1), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 1), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = 0), this.array = null, this.a = t4, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2;
      }
      return t3.prototype.fromArray = function(t4) {
        this.a = t4[0], this.b = t4[1], this.c = t4[3], this.d = t4[4], this.tx = t4[2], this.ty = t4[5];
      }, t3.prototype.set = function(t4, e2, i2, n2, r2, o2) {
        return this.a = t4, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2, this;
      }, t3.prototype.toArray = function(t4, e2) {
        this.array || (this.array = new Float32Array(9));
        var i2 = e2 || this.array;
        return t4 ? (i2[0] = this.a, i2[1] = this.b, i2[2] = 0, i2[3] = this.c, i2[4] = this.d, i2[5] = 0, i2[6] = this.tx, i2[7] = this.ty, i2[8] = 1) : (i2[0] = this.a, i2[1] = this.c, i2[2] = this.tx, i2[3] = this.b, i2[4] = this.d, i2[5] = this.ty, i2[6] = 0, i2[7] = 0, i2[8] = 1), i2;
      }, t3.prototype.apply = function(t4, e2) {
        e2 = e2 || new lt();
        var i2 = t4.x, n2 = t4.y;
        return e2.x = this.a * i2 + this.c * n2 + this.tx, e2.y = this.b * i2 + this.d * n2 + this.ty, e2;
      }, t3.prototype.applyInverse = function(t4, e2) {
        e2 = e2 || new lt();
        var i2 = 1 / (this.a * this.d + this.c * -this.b), n2 = t4.x, r2 = t4.y;
        return e2.x = this.d * i2 * n2 + -this.c * i2 * r2 + (this.ty * this.c - this.tx * this.d) * i2, e2.y = this.a * i2 * r2 + -this.b * i2 * n2 + (-this.ty * this.a + this.tx * this.b) * i2, e2;
      }, t3.prototype.translate = function(t4, e2) {
        return this.tx += t4, this.ty += e2, this;
      }, t3.prototype.scale = function(t4, e2) {
        return this.a *= t4, this.d *= e2, this.c *= t4, this.b *= e2, this.tx *= t4, this.ty *= e2, this;
      }, t3.prototype.rotate = function(t4) {
        var e2 = Math.cos(t4), i2 = Math.sin(t4), n2 = this.a, r2 = this.c, o2 = this.tx;
        return this.a = n2 * e2 - this.b * i2, this.b = n2 * i2 + this.b * e2, this.c = r2 * e2 - this.d * i2, this.d = r2 * i2 + this.d * e2, this.tx = o2 * e2 - this.ty * i2, this.ty = o2 * i2 + this.ty * e2, this;
      }, t3.prototype.append = function(t4) {
        var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d;
        return this.a = t4.a * e2 + t4.b * n2, this.b = t4.a * i2 + t4.b * r2, this.c = t4.c * e2 + t4.d * n2, this.d = t4.c * i2 + t4.d * r2, this.tx = t4.tx * e2 + t4.ty * n2 + this.tx, this.ty = t4.tx * i2 + t4.ty * r2 + this.ty, this;
      }, t3.prototype.setTransform = function(t4, e2, i2, n2, r2, o2, s2, a2, l2) {
        return this.a = Math.cos(s2 + l2) * r2, this.b = Math.sin(s2 + l2) * r2, this.c = -Math.sin(s2 - a2) * o2, this.d = Math.cos(s2 - a2) * o2, this.tx = t4 - (i2 * this.a + n2 * this.c), this.ty = e2 - (i2 * this.b + n2 * this.d), this;
      }, t3.prototype.prepend = function(t4) {
        var e2 = this.tx;
        if (t4.a !== 1 || t4.b !== 0 || t4.c !== 0 || t4.d !== 1) {
          var i2 = this.a, n2 = this.c;
          this.a = i2 * t4.a + this.b * t4.c, this.b = i2 * t4.b + this.b * t4.d, this.c = n2 * t4.a + this.d * t4.c, this.d = n2 * t4.b + this.d * t4.d;
        }
        return this.tx = e2 * t4.a + this.ty * t4.c + t4.tx, this.ty = e2 * t4.b + this.ty * t4.d + t4.ty, this;
      }, t3.prototype.decompose = function(t4) {
        var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d, o2 = t4.pivot, s2 = -Math.atan2(-n2, r2), a2 = Math.atan2(i2, e2), l2 = Math.abs(s2 + a2);
        return l2 < 1e-5 || Math.abs(at - l2) < 1e-5 ? (t4.rotation = a2, t4.skew.x = t4.skew.y = 0) : (t4.rotation = 0, t4.skew.x = s2, t4.skew.y = a2), t4.scale.x = Math.sqrt(e2 * e2 + i2 * i2), t4.scale.y = Math.sqrt(n2 * n2 + r2 * r2), t4.position.x = this.tx + (o2.x * e2 + o2.y * n2), t4.position.y = this.ty + (o2.x * i2 + o2.y * r2), t4;
      }, t3.prototype.invert = function() {
        var t4 = this.a, e2 = this.b, i2 = this.c, n2 = this.d, r2 = this.tx, o2 = t4 * n2 - e2 * i2;
        return this.a = n2 / o2, this.b = -e2 / o2, this.c = -i2 / o2, this.d = t4 / o2, this.tx = (i2 * this.ty - n2 * r2) / o2, this.ty = -(t4 * this.ty - e2 * r2) / o2, this;
      }, t3.prototype.identity = function() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
      }, t3.prototype.clone = function() {
        var e2 = new t3();
        return e2.a = this.a, e2.b = this.b, e2.c = this.c, e2.d = this.d, e2.tx = this.tx, e2.ty = this.ty, e2;
      }, t3.prototype.copyTo = function(t4) {
        return t4.a = this.a, t4.b = this.b, t4.c = this.c, t4.d = this.d, t4.tx = this.tx, t4.ty = this.ty, t4;
      }, t3.prototype.copyFrom = function(t4) {
        return this.a = t4.a, this.b = t4.b, this.c = t4.c, this.d = t4.d, this.tx = t4.tx, this.ty = t4.ty, this;
      }, t3.prototype.toString = function() {
        return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
      }, Object.defineProperty(t3, "IDENTITY", { get: function() {
        return new t3();
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "TEMP_MATRIX", { get: function() {
        return new t3();
      }, enumerable: false, configurable: true }), t3;
    }(), pt = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], ft = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], mt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], gt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], vt = [], _t = [], yt = Math.sign;
    !function() {
      for (var t3 = 0; t3 < 16; t3++) {
        var e2 = [];
        vt.push(e2);
        for (var i2 = 0; i2 < 16; i2++)
          for (var n2 = yt(pt[t3] * pt[i2] + mt[t3] * ft[i2]), r2 = yt(ft[t3] * pt[i2] + gt[t3] * ft[i2]), o2 = yt(pt[t3] * mt[i2] + mt[t3] * gt[i2]), s2 = yt(ft[t3] * mt[i2] + gt[t3] * gt[i2]), a2 = 0; a2 < 16; a2++)
            if (pt[a2] === n2 && ft[a2] === r2 && mt[a2] === o2 && gt[a2] === s2) {
              e2.push(a2);
              break;
            }
      }
      for (t3 = 0; t3 < 16; t3++) {
        var l2 = new dt();
        l2.set(pt[t3], ft[t3], mt[t3], gt[t3], 0, 0), _t.push(l2);
      }
    }();
    var xt = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function(t3) {
      return pt[t3];
    }, uY: function(t3) {
      return ft[t3];
    }, vX: function(t3) {
      return mt[t3];
    }, vY: function(t3) {
      return gt[t3];
    }, inv: function(t3) {
      return 8 & t3 ? 15 & t3 : 7 & -t3;
    }, add: function(t3, e2) {
      return vt[t3][e2];
    }, sub: function(t3, e2) {
      return vt[t3][xt.inv(e2)];
    }, rotate180: function(t3) {
      return 4 ^ t3;
    }, isVertical: function(t3) {
      return (3 & t3) == 2;
    }, byDirection: function(t3, e2) {
      return 2 * Math.abs(t3) <= Math.abs(e2) ? e2 >= 0 ? xt.S : xt.N : 2 * Math.abs(e2) <= Math.abs(t3) ? t3 > 0 ? xt.E : xt.W : e2 > 0 ? t3 > 0 ? xt.SE : xt.SW : t3 > 0 ? xt.NE : xt.NW;
    }, matrixAppendRotationInv: function(t3, e2, i2, n2) {
      i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = 0);
      var r2 = _t[xt.inv(e2)];
      r2.tx = i2, r2.ty = n2, t3.append(r2);
    } };
    !function() {
      function t3() {
        this.worldTransform = new dt(), this.localTransform = new dt(), this.position = new ct(this.onChange, this, 0, 0), this.scale = new ct(this.onChange, this, 1, 1), this.pivot = new ct(this.onChange, this, 0, 0), this.skew = new ct(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
      }
      t3.prototype.onChange = function() {
        this._localID++;
      }, t3.prototype.updateSkew = function() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
      }, t3.prototype.toString = function() {
        return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
      }, t3.prototype.updateLocalTransform = function() {
        var t4 = this.localTransform;
        this._localID !== this._currentLocalID && (t4.a = this._cx * this.scale.x, t4.b = this._sx * this.scale.x, t4.c = this._cy * this.scale.y, t4.d = this._sy * this.scale.y, t4.tx = this.position.x - (this.pivot.x * t4.a + this.pivot.y * t4.c), t4.ty = this.position.y - (this.pivot.x * t4.b + this.pivot.y * t4.d), this._currentLocalID = this._localID, this._parentID = -1);
      }, t3.prototype.updateTransform = function(t4) {
        var e2 = this.localTransform;
        if (this._localID !== this._currentLocalID && (e2.a = this._cx * this.scale.x, e2.b = this._sx * this.scale.x, e2.c = this._cy * this.scale.y, e2.d = this._sy * this.scale.y, e2.tx = this.position.x - (this.pivot.x * e2.a + this.pivot.y * e2.c), e2.ty = this.position.y - (this.pivot.x * e2.b + this.pivot.y * e2.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t4._worldID) {
          var i2 = t4.worldTransform, n2 = this.worldTransform;
          n2.a = e2.a * i2.a + e2.b * i2.c, n2.b = e2.a * i2.b + e2.b * i2.d, n2.c = e2.c * i2.a + e2.d * i2.c, n2.d = e2.c * i2.b + e2.d * i2.d, n2.tx = e2.tx * i2.a + e2.ty * i2.c + i2.tx, n2.ty = e2.tx * i2.b + e2.ty * i2.d + i2.ty, this._parentID = t4._worldID, this._worldID++;
        }
      }, t3.prototype.setFromMatrix = function(t4) {
        t4.decompose(this), this._localID++;
      }, Object.defineProperty(t3.prototype, "rotation", { get: function() {
        return this._rotation;
      }, set: function(t4) {
        this._rotation !== t4 && (this._rotation = t4, this.updateSkew());
      }, enumerable: false, configurable: true }), t3.IDENTITY = new t3();
    }(), n.b.PREFER_ENV = n.a.any ? r.g.WEBGL : r.g.WEBGL2, n.b.STRICT_TEXTURE_CACHE = false;
    var bt = [];
    function Tt(t3, e2) {
      if (!t3)
        return null;
      var i2 = "";
      if (typeof t3 == "string") {
        var n2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(t3);
        n2 && (i2 = n2[1].toLowerCase());
      }
      for (var r2 = bt.length - 1; r2 >= 0; --r2) {
        var o2 = bt[r2];
        if (o2.test && o2.test(t3, i2))
          return new o2(t3, e2);
      }
      throw new Error("Unrecognized source type to auto-detect Resource");
    }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var Et = function(t3, e2) {
      return (Et = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var i2 in e3)
          e3.hasOwnProperty(i2) && (t4[i2] = e3[i2]);
      })(t3, e2);
    };
    function St(t3, e2) {
      function i2() {
        this.constructor = t3;
      }
      Et(t3, e2), t3.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
    }
    var wt = function() {
      return (wt = Object.assign || function(t3) {
        for (var e2, i2 = arguments, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
          for (var o2 in e2 = i2[n2])
            Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
        return t3;
      }).apply(this, arguments);
    };
    var At = function() {
      function t3(t4, e2) {
        t4 === void 0 && (t4 = 0), e2 === void 0 && (e2 = 0), this._width = t4, this._height = e2, this.destroyed = false, this.internal = false, this.onResize = new nt("setRealSize"), this.onUpdate = new nt("update"), this.onError = new nt("onError");
      }
      return t3.prototype.bind = function(t4) {
        this.onResize.add(t4), this.onUpdate.add(t4), this.onError.add(t4), (this._width || this._height) && this.onResize.emit(this._width, this._height);
      }, t3.prototype.unbind = function(t4) {
        this.onResize.remove(t4), this.onUpdate.remove(t4), this.onError.remove(t4);
      }, t3.prototype.resize = function(t4, e2) {
        t4 === this._width && e2 === this._height || (this._width = t4, this._height = e2, this.onResize.emit(t4, e2));
      }, Object.defineProperty(t3.prototype, "valid", { get: function() {
        return !!this._width && !!this._height;
      }, enumerable: false, configurable: true }), t3.prototype.update = function() {
        this.destroyed || this.onUpdate.emit();
      }, t3.prototype.load = function() {
        return Promise.resolve(this);
      }, Object.defineProperty(t3.prototype, "width", { get: function() {
        return this._width;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
        return this._height;
      }, enumerable: false, configurable: true }), t3.prototype.style = function(t4, e2, i2) {
        return false;
      }, t3.prototype.dispose = function() {
      }, t3.prototype.destroy = function() {
        this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
      }, t3.test = function(t4, e2) {
        return false;
      }, t3;
    }(), Mt = function(t3) {
      function e2(e3, i2) {
        var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
        if (!o2 || !s2)
          throw new Error("BufferResource width or height invalid");
        return (n2 = t3.call(this, o2, s2) || this).data = e3, n2;
      }
      return St(e2, t3), e2.prototype.upload = function(t4, e3, i2) {
        var n2 = t4.gl;
        n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
        var o2 = e3.realWidth, s2 = e3.realHeight;
        return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
      }, e2.prototype.dispose = function() {
        this.data = null;
      }, e2.test = function(t4) {
        return t4 instanceof Float32Array || t4 instanceof Uint8Array || t4 instanceof Uint32Array;
      }, e2;
    }(At), Rt = { scaleMode: r.p.NEAREST, format: r.h.RGBA, alphaMode: r.a.NPM }, Ct = function(t3) {
      function e2(e3, i2) {
        e3 === void 0 && (e3 = null), i2 === void 0 && (i2 = null);
        var o2 = t3.call(this) || this, s2 = (i2 = i2 || {}).alphaMode, a2 = i2.mipmap, l2 = i2.anisotropicLevel, h2 = i2.scaleMode, u2 = i2.width, c2 = i2.height, d2 = i2.wrapMode, p2 = i2.format, f2 = i2.type, m2 = i2.target, g2 = i2.resolution, v2 = i2.resourceOptions;
        return !e3 || e3 instanceof At || ((e3 = Tt(e3, v2)).internal = true), o2.resolution = g2 || n.b.RESOLUTION, o2.width = Math.round((u2 || 0) * o2.resolution) / o2.resolution, o2.height = Math.round((c2 || 0) * o2.resolution) / o2.resolution, o2._mipmap = a2 !== void 0 ? a2 : n.b.MIPMAP_TEXTURES, o2.anisotropicLevel = l2 !== void 0 ? l2 : n.b.ANISOTROPIC_LEVEL, o2._wrapMode = d2 || n.b.WRAP_MODE, o2._scaleMode = h2 !== void 0 ? h2 : n.b.SCALE_MODE, o2.format = p2 || r.h.RGBA, o2.type = f2 || r.r.UNSIGNED_BYTE, o2.target = m2 || r.q.TEXTURE_2D, o2.alphaMode = s2 !== void 0 ? s2 : r.a.UNPACK, o2.uid = Y(), o2.touched = 0, o2.isPowerOfTwo = false, o2._refreshPOT(), o2._glTextures = {}, o2.dirtyId = 0, o2.dirtyStyleId = 0, o2.cacheId = null, o2.valid = u2 > 0 && c2 > 0, o2.textureCacheIds = [], o2.destroyed = false, o2.resource = null, o2._batchEnabled = 0, o2._batchLocation = 0, o2.parentTextureArray = null, o2.setResource(e3), o2;
      }
      return St(e2, t3), Object.defineProperty(e2.prototype, "realWidth", { get: function() {
        return Math.round(this.width * this.resolution);
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "realHeight", { get: function() {
        return Math.round(this.height * this.resolution);
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mipmap", { get: function() {
        return this._mipmap;
      }, set: function(t4) {
        this._mipmap !== t4 && (this._mipmap = t4, this.dirtyStyleId++);
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scaleMode", { get: function() {
        return this._scaleMode;
      }, set: function(t4) {
        this._scaleMode !== t4 && (this._scaleMode = t4, this.dirtyStyleId++);
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "wrapMode", { get: function() {
        return this._wrapMode;
      }, set: function(t4) {
        this._wrapMode !== t4 && (this._wrapMode = t4, this.dirtyStyleId++);
      }, enumerable: false, configurable: true }), e2.prototype.setStyle = function(t4, e3) {
        var i2;
        return t4 !== void 0 && t4 !== this.scaleMode && (this.scaleMode = t4, i2 = true), e3 !== void 0 && e3 !== this.mipmap && (this.mipmap = e3, i2 = true), i2 && this.dirtyStyleId++, this;
      }, e2.prototype.setSize = function(t4, e3, i2) {
        return i2 = i2 || this.resolution, this.setRealSize(t4 * i2, e3 * i2, i2);
      }, e2.prototype.setRealSize = function(t4, e3, i2) {
        return this.resolution = i2 || this.resolution, this.width = Math.round(t4) / this.resolution, this.height = Math.round(e3) / this.resolution, this._refreshPOT(), this.update(), this;
      }, e2.prototype._refreshPOT = function() {
        this.isPowerOfTwo = V(this.realWidth) && V(this.realHeight);
      }, e2.prototype.setResolution = function(t4) {
        var e3 = this.resolution;
        return e3 === t4 || (this.resolution = t4, this.valid && (this.width = Math.round(this.width * e3) / t4, this.height = Math.round(this.height * e3) / t4, this.emit("update", this)), this._refreshPOT()), this;
      }, e2.prototype.setResource = function(t4) {
        if (this.resource === t4)
          return this;
        if (this.resource)
          throw new Error("Resource can be set only once");
        return t4.bind(this), this.resource = t4, this;
      }, e2.prototype.update = function() {
        this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
      }, e2.prototype.onError = function(t4) {
        this.emit("error", this, t4);
      }, e2.prototype.destroy = function() {
        this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete $[this.cacheId], delete Q[this.cacheId], this.cacheId = null), this.dispose(), e2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
      }, e2.prototype.dispose = function() {
        this.emit("dispose", this);
      }, e2.prototype.castToBaseTexture = function() {
        return this;
      }, e2.from = function(t4, i2, r2) {
        r2 === void 0 && (r2 = n.b.STRICT_TEXTURE_CACHE);
        var o2 = typeof t4 == "string", s2 = null;
        if (o2)
          s2 = t4;
        else {
          if (!t4._pixiId) {
            var a2 = i2 && i2.pixiIdPrefix || "pixiid";
            t4._pixiId = a2 + "_" + Y();
          }
          s2 = t4._pixiId;
        }
        var l2 = $[s2];
        if (o2 && r2 && !l2)
          throw new Error('The cacheId "' + s2 + '" does not exist in BaseTextureCache.');
        return l2 || ((l2 = new e2(t4, i2)).cacheId = s2, e2.addToCache(l2, s2)), l2;
      }, e2.fromBuffer = function(t4, i2, n2, o2) {
        t4 = t4 || new Float32Array(i2 * n2 * 4);
        var s2 = new Mt(t4, { width: i2, height: n2 }), a2 = t4 instanceof Float32Array ? r.r.FLOAT : r.r.UNSIGNED_BYTE;
        return new e2(s2, Object.assign(Rt, o2 || { width: i2, height: n2, type: a2 }));
      }, e2.addToCache = function(t4, e3) {
        e3 && (t4.textureCacheIds.indexOf(e3) === -1 && t4.textureCacheIds.push(e3), $[e3] && console.warn("BaseTexture added to the cache with an id [" + e3 + "] that already had an entry"), $[e3] = t4);
      }, e2.removeFromCache = function(t4) {
        if (typeof t4 == "string") {
          var e3 = $[t4];
          if (e3) {
            var i2 = e3.textureCacheIds.indexOf(t4);
            return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete $[t4], e3;
          }
        } else if (t4 && t4.textureCacheIds) {
          for (var n2 = 0; n2 < t4.textureCacheIds.length; ++n2)
            delete $[t4.textureCacheIds[n2]];
          return t4.textureCacheIds.length = 0, t4;
        }
        return null;
      }, e2._globalBatch = 0, e2;
    }(u), It = function(t3) {
      function e2(e3, i2) {
        var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
        (n2 = t3.call(this, o2, s2) || this).items = [], n2.itemDirtyIds = [];
        for (var a2 = 0; a2 < e3; a2++) {
          var l2 = new Ct();
          n2.items.push(l2), n2.itemDirtyIds.push(-2);
        }
        return n2.length = e3, n2._load = null, n2.baseTexture = null, n2;
      }
      return St(e2, t3), e2.prototype.initFromArray = function(t4, e3) {
        for (var i2 = 0; i2 < this.length; i2++)
          t4[i2] && (t4[i2].castToBaseTexture ? this.addBaseTextureAt(t4[i2].castToBaseTexture(), i2) : t4[i2] instanceof At ? this.addResourceAt(t4[i2], i2) : this.addResourceAt(Tt(t4[i2], e3), i2));
      }, e2.prototype.dispose = function() {
        for (var t4 = 0, e3 = this.length; t4 < e3; t4++)
          this.items[t4].destroy();
        this.items = null, this.itemDirtyIds = null, this._load = null;
      }, e2.prototype.addResourceAt = function(t4, e3) {
        if (!this.items[e3])
          throw new Error("Index " + e3 + " is out of bounds");
        return t4.valid && !this.valid && this.resize(t4.width, t4.height), this.items[e3].setResource(t4), this;
      }, e2.prototype.bind = function(e3) {
        if (this.baseTexture !== null)
          throw new Error("Only one base texture per TextureArray is allowed");
        t3.prototype.bind.call(this, e3);
        for (var i2 = 0; i2 < this.length; i2++)
          this.items[i2].parentTextureArray = e3, this.items[i2].on("update", e3.update, e3);
      }, e2.prototype.unbind = function(e3) {
        t3.prototype.unbind.call(this, e3);
        for (var i2 = 0; i2 < this.length; i2++)
          this.items[i2].parentTextureArray = null, this.items[i2].off("update", e3.update, e3);
      }, e2.prototype.load = function() {
        var t4 = this;
        if (this._load)
          return this._load;
        var e3 = this.items.map(function(t5) {
          return t5.resource;
        }).filter(function(t5) {
          return t5;
        }).map(function(t5) {
          return t5.load();
        });
        return this._load = Promise.all(e3).then(function() {
          var e4 = t4.items[0], i2 = e4.realWidth, n2 = e4.realHeight;
          return t4.resize(i2, n2), Promise.resolve(t4);
        }), this._load;
      }, e2;
    }(At), Pt = function(t3) {
      function e2(e3, i2) {
        var n2, r2, o2 = this, s2 = i2 || {}, a2 = s2.width, l2 = s2.height;
        return Array.isArray(e3) ? (n2 = e3, r2 = e3.length) : r2 = e3, o2 = t3.call(this, r2, { width: a2, height: l2 }) || this, n2 && o2.initFromArray(n2, i2), o2;
      }
      return St(e2, t3), e2.prototype.addBaseTextureAt = function(t4, e3) {
        if (!t4.resource)
          throw new Error("ArrayResource does not support RenderTexture");
        return this.addResourceAt(t4.resource, e3), this;
      }, e2.prototype.bind = function(e3) {
        t3.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_2D_ARRAY;
      }, e2.prototype.upload = function(t4, e3, i2) {
        var n2 = this.length, r2 = this.itemDirtyIds, o2 = this.items, s2 = t4.gl;
        i2.dirtyId < 0 && s2.texImage3D(s2.TEXTURE_2D_ARRAY, 0, i2.internalFormat, this._width, this._height, n2, 0, e3.format, i2.type, null);
        for (var a2 = 0; a2 < n2; a2++) {
          var l2 = o2[a2];
          r2[a2] < l2.dirtyId && (r2[a2] = l2.dirtyId, l2.valid && s2.texSubImage3D(s2.TEXTURE_2D_ARRAY, 0, 0, 0, a2, l2.resource.width, l2.resource.height, 1, e3.format, i2.type, l2.resource.source));
        }
        return true;
      }, e2;
    }(It), Ot = function(t3) {
      function e2(e3) {
        var i2 = this, n2 = e3, r2 = n2.naturalWidth || n2.videoWidth || n2.width, o2 = n2.naturalHeight || n2.videoHeight || n2.height;
        return (i2 = t3.call(this, r2, o2) || this).source = e3, i2.noSubImage = false, i2;
      }
      return St(e2, t3), e2.crossOrigin = function(t4, e3, i2) {
        i2 === void 0 && e3.indexOf("data:") !== 0 ? t4.crossOrigin = tt(e3) : i2 !== false && (t4.crossOrigin = typeof i2 == "string" ? i2 : "anonymous");
      }, e2.prototype.upload = function(t4, e3, i2, n2) {
        var o2 = t4.gl, s2 = e3.realWidth, a2 = e3.realHeight;
        if ((n2 = n2 || this.source) instanceof HTMLImageElement) {
          if (!n2.complete || n2.naturalWidth === 0)
            return false;
        } else if (n2 instanceof HTMLVideoElement && n2.readyState <= 1)
          return false;
        return o2.pixelStorei(o2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK), this.noSubImage || e3.target !== o2.TEXTURE_2D || i2.width !== s2 || i2.height !== a2 ? (i2.width = s2, i2.height = a2, o2.texImage2D(e3.target, 0, i2.internalFormat, e3.format, i2.type, n2)) : o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e3.format, i2.type, n2), true;
      }, e2.prototype.update = function() {
        if (!this.destroyed) {
          var e3 = this.source, i2 = e3.naturalWidth || e3.videoWidth || e3.width, n2 = e3.naturalHeight || e3.videoHeight || e3.height;
          this.resize(i2, n2), t3.prototype.update.call(this);
        }
      }, e2.prototype.dispose = function() {
        this.source = null;
      }, e2;
    }(At), Nt = function(t3) {
      function e2(e3) {
        return t3.call(this, e3) || this;
      }
      return St(e2, t3), e2.test = function(t4) {
        var e3 = globalThis.OffscreenCanvas;
        return !!(e3 && t4 instanceof e3) || globalThis.HTMLCanvasElement && t4 instanceof HTMLCanvasElement;
      }, e2;
    }(Ot), Lt = function(t3) {
      function e2(i2, n2) {
        var o2 = this, s2 = n2 || {}, a2 = s2.width, l2 = s2.height, h2 = s2.autoLoad, u2 = s2.linkBaseTexture;
        if (i2 && i2.length !== e2.SIDES)
          throw new Error("Invalid length. Got " + i2.length + ", expected 6");
        o2 = t3.call(this, 6, { width: a2, height: l2 }) || this;
        for (var c2 = 0; c2 < e2.SIDES; c2++)
          o2.items[c2].target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + c2;
        return o2.linkBaseTexture = u2 !== false, i2 && o2.initFromArray(i2, n2), h2 !== false && o2.load(), o2;
      }
      return St(e2, t3), e2.prototype.bind = function(e3) {
        t3.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_CUBE_MAP;
      }, e2.prototype.addBaseTextureAt = function(t4, e3, i2) {
        if (!this.items[e3])
          throw new Error("Index " + e3 + " is out of bounds");
        if (!this.linkBaseTexture || t4.parentTextureArray || Object.keys(t4._glTextures).length > 0) {
          if (!t4.resource)
            throw new Error("CubeResource does not support copying of renderTexture.");
          this.addResourceAt(t4.resource, e3);
        } else
          t4.target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + e3, t4.parentTextureArray = this.baseTexture, this.items[e3] = t4;
        return t4.valid && !this.valid && this.resize(t4.realWidth, t4.realHeight), this.items[e3] = t4, this;
      }, e2.prototype.upload = function(t4, i2, n2) {
        for (var r2 = this.itemDirtyIds, o2 = 0; o2 < e2.SIDES; o2++) {
          var s2 = this.items[o2];
          r2[o2] < s2.dirtyId && (s2.valid && s2.resource ? (s2.resource.upload(t4, s2, n2), r2[o2] = s2.dirtyId) : r2[o2] < -1 && (t4.gl.texImage2D(s2.target, 0, n2.internalFormat, i2.realWidth, i2.realHeight, 0, i2.format, n2.type, null), r2[o2] = -1));
        }
        return true;
      }, e2.test = function(t4) {
        return Array.isArray(t4) && t4.length === e2.SIDES;
      }, e2.SIDES = 6, e2;
    }(It), Dt = function(t3) {
      function e2(e3, i2) {
        var r2 = this;
        if (i2 = i2 || {}, !(e3 instanceof HTMLImageElement)) {
          var o2 = new Image();
          Ot.crossOrigin(o2, e3, i2.crossorigin), o2.src = e3, e3 = o2;
        }
        return r2 = t3.call(this, e3) || this, !e3.complete && r2._width && r2._height && (r2._width = 0, r2._height = 0), r2.url = e3.src, r2._process = null, r2.preserveBitmap = false, r2.createBitmap = (i2.createBitmap !== void 0 ? i2.createBitmap : n.b.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, r2.alphaMode = typeof i2.alphaMode == "number" ? i2.alphaMode : null, r2.bitmap = null, r2._load = null, i2.autoLoad !== false && r2.load(), r2;
      }
      return St(e2, t3), e2.prototype.load = function(t4) {
        var e3 = this;
        return this._load || (t4 !== void 0 && (this.createBitmap = t4), this._load = new Promise(function(t5, i2) {
          var n2 = e3.source;
          e3.url = n2.src;
          var r2 = function() {
            e3.destroyed || (n2.onload = null, n2.onerror = null, e3.resize(n2.width, n2.height), e3._load = null, e3.createBitmap ? t5(e3.process()) : t5(e3));
          };
          n2.complete && n2.src ? r2() : (n2.onload = r2, n2.onerror = function(t6) {
            i2(t6), e3.onError.emit(t6);
          });
        })), this._load;
      }, e2.prototype.process = function() {
        var t4 = this, e3 = this.source;
        if (this._process !== null)
          return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap)
          return Promise.resolve(this);
        var i2 = globalThis.createImageBitmap, n2 = !e3.crossOrigin || e3.crossOrigin === "anonymous";
        return this._process = fetch(e3.src, { mode: n2 ? "cors" : "no-cors" }).then(function(t5) {
          return t5.blob();
        }).then(function(n3) {
          return i2(n3, 0, 0, e3.width, e3.height, { premultiplyAlpha: t4.alphaMode === r.a.UNPACK ? "premultiply" : "none" });
        }).then(function(e4) {
          return t4.destroyed ? Promise.reject() : (t4.bitmap = e4, t4.update(), t4._process = null, Promise.resolve(t4));
        }), this._process;
      }, e2.prototype.upload = function(e3, i2, n2) {
        if (typeof this.alphaMode == "number" && (i2.alphaMode = this.alphaMode), !this.createBitmap)
          return t3.prototype.upload.call(this, e3, i2, n2);
        if (!this.bitmap && (this.process(), !this.bitmap))
          return false;
        if (t3.prototype.upload.call(this, e3, i2, n2, this.bitmap), !this.preserveBitmap) {
          var r2 = true, o2 = i2._glTextures;
          for (var s2 in o2) {
            var a2 = o2[s2];
            if (a2 !== n2 && a2.dirtyId !== i2.dirtyId) {
              r2 = false;
              break;
            }
          }
          r2 && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
        }
        return true;
      }, e2.prototype.dispose = function() {
        this.source.onload = null, this.source.onerror = null, t3.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
      }, e2.test = function(t4) {
        return typeof t4 == "string" || t4 instanceof HTMLImageElement;
      }, e2;
    }(Ot), Ft = function(t3) {
      function e2(e3, i2) {
        var n2 = this;
        return i2 = i2 || {}, (n2 = t3.call(this, document.createElement("canvas")) || this)._width = 0, n2._height = 0, n2.svg = e3, n2.scale = i2.scale || 1, n2._overrideWidth = i2.width, n2._overrideHeight = i2.height, n2._resolve = null, n2._crossorigin = i2.crossorigin, n2._load = null, i2.autoLoad !== false && n2.load(), n2;
      }
      return St(e2, t3), e2.prototype.load = function() {
        var t4 = this;
        return this._load || (this._load = new Promise(function(i2) {
          if (t4._resolve = function() {
            t4.resize(t4.source.width, t4.source.height), i2(t4);
          }, e2.SVG_XML.test(t4.svg.trim())) {
            if (!btoa)
              throw new Error("Your browser doesn't support base64 conversions.");
            t4.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t4.svg)));
          }
          t4._loadSvg();
        })), this._load;
      }, e2.prototype._loadSvg = function() {
        var t4 = this, e3 = new Image();
        Ot.crossOrigin(e3, this.svg, this._crossorigin), e3.src = this.svg, e3.onerror = function(i2) {
          t4._resolve && (e3.onerror = null, t4.onError.emit(i2));
        }, e3.onload = function() {
          if (t4._resolve) {
            var i2 = e3.width, n2 = e3.height;
            if (!i2 || !n2)
              throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            var r2 = i2 * t4.scale, o2 = n2 * t4.scale;
            (t4._overrideWidth || t4._overrideHeight) && (r2 = t4._overrideWidth || t4._overrideHeight / n2 * i2, o2 = t4._overrideHeight || t4._overrideWidth / i2 * n2), r2 = Math.round(r2), o2 = Math.round(o2);
            var s2 = t4.source;
            s2.width = r2, s2.height = o2, s2._pixiId = "canvas_" + Y(), s2.getContext("2d").drawImage(e3, 0, 0, i2, n2, 0, 0, r2, o2), t4._resolve(), t4._resolve = null;
          }
        };
      }, e2.getSize = function(t4) {
        var i2 = e2.SVG_SIZE.exec(t4), n2 = {};
        return i2 && (n2[i2[1]] = Math.round(parseFloat(i2[3])), n2[i2[5]] = Math.round(parseFloat(i2[7]))), n2;
      }, e2.prototype.dispose = function() {
        t3.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
      }, e2.test = function(t4, i2) {
        return i2 === "svg" || typeof t4 == "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t4) || typeof t4 == "string" && e2.SVG_XML.test(t4);
      }, e2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e2;
    }(Ot), Bt = function(t3) {
      function e2(i2, n2) {
        var r2 = this;
        if (n2 = n2 || {}, !(i2 instanceof HTMLVideoElement)) {
          var o2 = document.createElement("video");
          o2.setAttribute("preload", "auto"), o2.setAttribute("webkit-playsinline", ""), o2.setAttribute("playsinline", ""), typeof i2 == "string" && (i2 = [i2]);
          var s2 = i2[0].src || i2[0];
          Ot.crossOrigin(o2, s2, n2.crossorigin);
          for (var a2 = 0; a2 < i2.length; ++a2) {
            var l2 = document.createElement("source"), h2 = i2[a2], u2 = h2.src, c2 = h2.mime, d2 = (u2 = u2 || i2[a2]).split("?").shift().toLowerCase(), p2 = d2.slice(d2.lastIndexOf(".") + 1);
            c2 = c2 || e2.MIME_TYPES[p2] || "video/" + p2, l2.src = u2, l2.type = c2, o2.appendChild(l2);
          }
          i2 = o2;
        }
        return (r2 = t3.call(this, i2) || this).noSubImage = true, r2._autoUpdate = true, r2._isConnectedToTicker = false, r2._updateFPS = n2.updateFPS || 0, r2._msToNextUpdate = 0, r2.autoPlay = n2.autoPlay !== false, r2._load = null, r2._resolve = null, r2._onCanPlay = r2._onCanPlay.bind(r2), r2._onError = r2._onError.bind(r2), n2.autoLoad !== false && r2.load(), r2;
      }
      return St(e2, t3), e2.prototype.update = function(e3) {
        if (!this.destroyed) {
          var i2 = st.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - i2), (!this._updateFPS || this._msToNextUpdate <= 0) && (t3.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
        }
      }, e2.prototype.load = function() {
        var t4 = this;
        if (this._load)
          return this._load;
        var e3 = this.source;
        return (e3.readyState === e3.HAVE_ENOUGH_DATA || e3.readyState === e3.HAVE_FUTURE_DATA) && e3.width && e3.height && (e3.complete = true), e3.addEventListener("play", this._onPlayStart.bind(this)), e3.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e3.addEventListener("canplay", this._onCanPlay), e3.addEventListener("canplaythrough", this._onCanPlay), e3.addEventListener("error", this._onError, true)), this._load = new Promise(function(i2) {
          t4.valid ? i2(t4) : (t4._resolve = i2, e3.load());
        }), this._load;
      }, e2.prototype._onError = function(t4) {
        this.source.removeEventListener("error", this._onError, true), this.onError.emit(t4);
      }, e2.prototype._isSourcePlaying = function() {
        var t4 = this.source;
        return t4.currentTime > 0 && t4.paused === false && t4.ended === false && t4.readyState > 2;
      }, e2.prototype._isSourceReady = function() {
        var t4 = this.source;
        return t4.readyState === 3 || t4.readyState === 4;
      }, e2.prototype._onPlayStart = function() {
        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (st.shared.add(this.update, this), this._isConnectedToTicker = true);
      }, e2.prototype._onPlayStop = function() {
        this._isConnectedToTicker && (st.shared.remove(this.update, this), this._isConnectedToTicker = false);
      }, e2.prototype._onCanPlay = function() {
        var t4 = this.source;
        t4.removeEventListener("canplay", this._onCanPlay), t4.removeEventListener("canplaythrough", this._onCanPlay);
        var e3 = this.valid;
        this.resize(t4.videoWidth, t4.videoHeight), !e3 && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t4.play();
      }, e2.prototype.dispose = function() {
        this._isConnectedToTicker && (st.shared.remove(this.update, this), this._isConnectedToTicker = false);
        var e3 = this.source;
        e3 && (e3.removeEventListener("error", this._onError, true), e3.pause(), e3.src = "", e3.load()), t3.prototype.dispose.call(this);
      }, Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
        return this._autoUpdate;
      }, set: function(t4) {
        t4 !== this._autoUpdate && (this._autoUpdate = t4, !this._autoUpdate && this._isConnectedToTicker ? (st.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (st.shared.add(this.update, this), this._isConnectedToTicker = true));
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "updateFPS", { get: function() {
        return this._updateFPS;
      }, set: function(t4) {
        t4 !== this._updateFPS && (this._updateFPS = t4);
      }, enumerable: false, configurable: true }), e2.test = function(t4, i2) {
        return globalThis.HTMLVideoElement && t4 instanceof HTMLVideoElement || e2.TYPES.indexOf(i2) > -1;
      }, e2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e2.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e2;
    }(Ot), Ut = function(t3) {
      function e2(e3) {
        return t3.call(this, e3) || this;
      }
      return St(e2, t3), e2.test = function(t4) {
        return !!globalThis.createImageBitmap && t4 instanceof ImageBitmap;
      }, e2;
    }(Ot);
    bt.push(Dt, Ut, Nt, Bt, Ft, Mt, Lt, Pt);
    var Gt = function(t3) {
      function e2() {
        return t3 !== null && t3.apply(this, arguments) || this;
      }
      return St(e2, t3), e2.prototype.upload = function(t4, e3, i2) {
        var n2 = t4.gl;
        n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
        var o2 = e3.realWidth, s2 = e3.realHeight;
        return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
      }, e2;
    }(Mt), Ht = function() {
      function t3(t4, e2) {
        this.width = Math.round(t4 || 100), this.height = Math.round(e2 || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new nt("disposeFramebuffer"), this.multisample = r.l.NONE;
      }
      return Object.defineProperty(t3.prototype, "colorTexture", { get: function() {
        return this.colorTextures[0];
      }, enumerable: false, configurable: true }), t3.prototype.addColorTexture = function(t4, e2) {
        return t4 === void 0 && (t4 = 0), this.colorTextures[t4] = e2 || new Ct(null, { scaleMode: r.p.NEAREST, resolution: 1, mipmap: r.k.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this;
      }, t3.prototype.addDepthTexture = function(t4) {
        return this.depthTexture = t4 || new Ct(new Gt(null, { width: this.width, height: this.height }), { scaleMode: r.p.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: r.k.OFF, format: r.h.DEPTH_COMPONENT, type: r.r.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this;
      }, t3.prototype.enableDepth = function() {
        return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
      }, t3.prototype.enableStencil = function() {
        return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
      }, t3.prototype.resize = function(t4, e2) {
        if (t4 = Math.round(t4), e2 = Math.round(e2), t4 !== this.width || e2 !== this.height) {
          this.width = t4, this.height = e2, this.dirtyId++, this.dirtySize++;
          for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
            var n2 = this.colorTextures[i2], r2 = n2.resolution;
            n2.setSize(t4 / r2, e2 / r2);
          }
          if (this.depthTexture) {
            r2 = this.depthTexture.resolution;
            this.depthTexture.setSize(t4 / r2, e2 / r2);
          }
        }
      }, t3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      }, t3.prototype.destroyDepthTexture = function() {
        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
      }, t3;
    }(), jt = function(t3) {
      function e2(e3) {
        e3 === void 0 && (e3 = {});
        var i2 = this;
        if (typeof e3 == "number") {
          var n2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
          e3 = { width: n2, height: o2, scaleMode: s2, resolution: a2 };
        }
        return e3.width = e3.width || 100, e3.height = e3.height || 100, e3.multisample = e3.multisample !== void 0 ? e3.multisample : r.l.NONE, (i2 = t3.call(this, null, e3) || this).mipmap = r.k.OFF, i2.valid = true, i2.clearColor = [0, 0, 0, 0], i2.framebuffer = new Ht(i2.realWidth, i2.realHeight).addColorTexture(0, i2), i2.framebuffer.multisample = e3.multisample, i2.maskStack = [], i2.filterStack = [{}], i2;
      }
      return St(e2, t3), e2.prototype.resize = function(t4, e3) {
        this.framebuffer.resize(t4 * this.resolution, e3 * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
      }, e2.prototype.dispose = function() {
        this.framebuffer.dispose(), t3.prototype.dispose.call(this);
      }, e2.prototype.destroy = function() {
        t3.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
      }, e2;
    }(Ct), zt = function() {
      function t3() {
        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
      }
      return t3.prototype.set = function(t4, e2, i2) {
        var n2 = e2.width, r2 = e2.height;
        if (i2) {
          var o2 = t4.width / 2 / n2, s2 = t4.height / 2 / r2, a2 = t4.x / n2 + o2, l2 = t4.y / r2 + s2;
          i2 = xt.add(i2, xt.NW), this.x0 = a2 + o2 * xt.uX(i2), this.y0 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x1 = a2 + o2 * xt.uX(i2), this.y1 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x2 = a2 + o2 * xt.uX(i2), this.y2 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x3 = a2 + o2 * xt.uX(i2), this.y3 = l2 + s2 * xt.uY(i2);
        } else
          this.x0 = t4.x / n2, this.y0 = t4.y / r2, this.x1 = (t4.x + t4.width) / n2, this.y1 = t4.y / r2, this.x2 = (t4.x + t4.width) / n2, this.y2 = (t4.y + t4.height) / r2, this.x3 = t4.x / n2, this.y3 = (t4.y + t4.height) / r2;
        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
      }, t3.prototype.toString = function() {
        return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]";
      }, t3;
    }(), Vt = new zt();
    function Xt(t3) {
      t3.destroy = function() {
      }, t3.on = function() {
      }, t3.once = function() {
      }, t3.emit = function() {
      };
    }
    var Wt = function(t3) {
      function e2(i2, n2, r2, o2, s2, a2) {
        var l2 = t3.call(this) || this;
        if (l2.noFrame = false, n2 || (l2.noFrame = true, n2 = new ut(0, 0, 1, 1)), i2 instanceof e2 && (i2 = i2.baseTexture), l2.baseTexture = i2, l2._frame = n2, l2.trim = o2, l2.valid = false, l2._uvs = Vt, l2.uvMatrix = null, l2.orig = r2 || n2, l2._rotate = Number(s2 || 0), s2 === true)
          l2._rotate = 2;
        else if (l2._rotate % 2 != 0)
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        return l2.defaultAnchor = a2 ? new lt(a2.x, a2.y) : new lt(0, 0), l2._updateID = 0, l2.textureCacheIds = [], i2.valid ? l2.noFrame ? i2.valid && l2.onBaseTextureUpdated(i2) : l2.frame = n2 : i2.once("loaded", l2.onBaseTextureUpdated, l2), l2.noFrame && i2.on("update", l2.onBaseTextureUpdated, l2), l2;
      }
      return St(e2, t3), e2.prototype.update = function() {
        this.baseTexture.resource && this.baseTexture.resource.update();
      }, e2.prototype.onBaseTextureUpdated = function(t4) {
        if (this.noFrame) {
          if (!this.baseTexture.valid)
            return;
          this._frame.width = t4.width, this._frame.height = t4.height, this.valid = true, this.updateUvs();
        } else
          this.frame = this._frame;
        this.emit("update", this);
      }, e2.prototype.destroy = function(t4) {
        if (this.baseTexture) {
          if (t4) {
            var i2 = this.baseTexture.resource;
            i2 && i2.url && Q[i2.url] && e2.removeFromCache(i2.url), this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
        }
        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e2.removeFromCache(this), this.textureCacheIds = null;
      }, e2.prototype.clone = function() {
        var t4 = this._frame.clone(), i2 = this._frame === this.orig ? t4 : this.orig.clone(), n2 = new e2(this.baseTexture, !this.noFrame && t4, i2, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
        return this.noFrame && (n2._frame = t4), n2;
      }, e2.prototype.updateUvs = function() {
        this._uvs === Vt && (this._uvs = new zt()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
      }, e2.from = function(t4, i2, r2) {
        i2 === void 0 && (i2 = {}), r2 === void 0 && (r2 = n.b.STRICT_TEXTURE_CACHE);
        var o2 = typeof t4 == "string", s2 = null;
        if (o2)
          s2 = t4;
        else if (t4 instanceof Ct) {
          if (!t4.cacheId) {
            var a2 = i2 && i2.pixiIdPrefix || "pixiid";
            t4.cacheId = a2 + "-" + Y(), Ct.addToCache(t4, t4.cacheId);
          }
          s2 = t4.cacheId;
        } else {
          if (!t4._pixiId) {
            a2 = i2 && i2.pixiIdPrefix || "pixiid";
            t4._pixiId = a2 + "_" + Y();
          }
          s2 = t4._pixiId;
        }
        var l2 = Q[s2];
        if (o2 && r2 && !l2)
          throw new Error('The cacheId "' + s2 + '" does not exist in TextureCache.');
        return l2 || t4 instanceof Ct ? !l2 && t4 instanceof Ct && (l2 = new e2(t4), e2.addToCache(l2, s2)) : (i2.resolution || (i2.resolution = et(t4)), (l2 = new e2(new Ct(t4, i2))).baseTexture.cacheId = s2, Ct.addToCache(l2.baseTexture, s2), e2.addToCache(l2, s2)), l2;
      }, e2.fromURL = function(t4, i2) {
        var n2 = Object.assign({ autoLoad: false }, i2 == null ? void 0 : i2.resourceOptions), r2 = e2.from(t4, Object.assign({ resourceOptions: n2 }, i2), false), o2 = r2.baseTexture.resource;
        return r2.baseTexture.valid ? Promise.resolve(r2) : o2.load().then(function() {
          return Promise.resolve(r2);
        });
      }, e2.fromBuffer = function(t4, i2, n2, r2) {
        return new e2(Ct.fromBuffer(t4, i2, n2, r2));
      }, e2.fromLoader = function(t4, i2, r2, o2) {
        var s2 = new Ct(t4, Object.assign({ scaleMode: n.b.SCALE_MODE, resolution: et(i2) }, o2)), a2 = s2.resource;
        a2 instanceof Dt && (a2.url = i2);
        var l2 = new e2(s2);
        return r2 || (r2 = i2), Ct.addToCache(l2.baseTexture, r2), e2.addToCache(l2, r2), r2 !== i2 && (Ct.addToCache(l2.baseTexture, i2), e2.addToCache(l2, i2)), l2.baseTexture.valid ? Promise.resolve(l2) : new Promise(function(t5) {
          l2.baseTexture.once("loaded", function() {
            return t5(l2);
          });
        });
      }, e2.addToCache = function(t4, e3) {
        e3 && (t4.textureCacheIds.indexOf(e3) === -1 && t4.textureCacheIds.push(e3), Q[e3] && console.warn("Texture added to the cache with an id [" + e3 + "] that already had an entry"), Q[e3] = t4);
      }, e2.removeFromCache = function(t4) {
        if (typeof t4 == "string") {
          var e3 = Q[t4];
          if (e3) {
            var i2 = e3.textureCacheIds.indexOf(t4);
            return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete Q[t4], e3;
          }
        } else if (t4 && t4.textureCacheIds) {
          for (var n2 = 0; n2 < t4.textureCacheIds.length; ++n2)
            Q[t4.textureCacheIds[n2]] === t4 && delete Q[t4.textureCacheIds[n2]];
          return t4.textureCacheIds.length = 0, t4;
        }
        return null;
      }, Object.defineProperty(e2.prototype, "resolution", { get: function() {
        return this.baseTexture.resolution;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "frame", { get: function() {
        return this._frame;
      }, set: function(t4) {
        this._frame = t4, this.noFrame = false;
        var e3 = t4.x, i2 = t4.y, n2 = t4.width, r2 = t4.height, o2 = e3 + n2 > this.baseTexture.width, s2 = i2 + r2 > this.baseTexture.height;
        if (o2 || s2) {
          var a2 = o2 && s2 ? "and" : "or", l2 = "X: " + e3 + " + " + n2 + " = " + (e3 + n2) + " > " + this.baseTexture.width, h2 = "Y: " + i2 + " + " + r2 + " = " + (i2 + r2) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l2 + " " + a2 + " " + h2);
        }
        this.valid = n2 && r2 && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t4), this.valid && this.updateUvs();
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotate", { get: function() {
        return this._rotate;
      }, set: function(t4) {
        this._rotate = t4, this.valid && this.updateUvs();
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
        return this.orig.width;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
        return this.orig.height;
      }, enumerable: false, configurable: true }), e2.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      }, Object.defineProperty(e2, "EMPTY", { get: function() {
        return e2._EMPTY || (e2._EMPTY = new e2(new Ct()), Xt(e2._EMPTY), Xt(e2._EMPTY.baseTexture)), e2._EMPTY;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2, "WHITE", { get: function() {
        if (!e2._WHITE) {
          var t4 = document.createElement("canvas"), i2 = t4.getContext("2d");
          t4.width = 16, t4.height = 16, i2.fillStyle = "white", i2.fillRect(0, 0, 16, 16), e2._WHITE = new e2(new Ct(new Nt(t4))), Xt(e2._WHITE), Xt(e2._WHITE.baseTexture);
        }
        return e2._WHITE;
      }, enumerable: false, configurable: true }), e2;
    }(u), Yt = function(t3) {
      function e2(e3, i2) {
        var n2 = t3.call(this, e3, i2) || this;
        return n2.valid = true, n2.filterFrame = null, n2.filterPoolKey = null, n2.updateUvs(), n2;
      }
      return St(e2, t3), Object.defineProperty(e2.prototype, "framebuffer", { get: function() {
        return this.baseTexture.framebuffer;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "multisample", { get: function() {
        return this.framebuffer.multisample;
      }, set: function(t4) {
        this.framebuffer.multisample = t4;
      }, enumerable: false, configurable: true }), e2.prototype.resize = function(t4, e3, i2) {
        i2 === void 0 && (i2 = true);
        var n2 = this.baseTexture.resolution, r2 = Math.round(t4 * n2) / n2, o2 = Math.round(e3 * n2) / n2;
        this.valid = r2 > 0 && o2 > 0, this._frame.width = this.orig.width = r2, this._frame.height = this.orig.height = o2, i2 && this.baseTexture.resize(r2, o2), this.updateUvs();
      }, e2.prototype.setResolution = function(t4) {
        var e3 = this.baseTexture;
        e3.resolution !== t4 && (e3.setResolution(t4), this.resize(e3.width, e3.height, false));
      }, e2.create = function(t4) {
        for (var i2 = arguments, n2 = [], r2 = 1; r2 < arguments.length; r2++)
          n2[r2 - 1] = i2[r2];
        return typeof t4 == "number" && (Z("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t4 = { width: t4, height: n2[0], scaleMode: n2[1], resolution: n2[2] }), new e2(new jt(t4));
      }, e2;
    }(Wt), qt = function() {
      function t3(t4) {
        this.texturePool = {}, this.textureOptions = t4 || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
      }
      return t3.prototype.createTexture = function(t4, e2, i2) {
        i2 === void 0 && (i2 = r.l.NONE);
        var n2 = new jt(Object.assign({ width: t4, height: e2, resolution: 1, multisample: i2 }, this.textureOptions));
        return new Yt(n2);
      }, t3.prototype.getOptimalTexture = function(t4, e2, i2, n2) {
        var o2;
        i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = r.l.NONE), t4 = Math.ceil(t4 * i2 - 1e-6), e2 = Math.ceil(e2 * i2 - 1e-6), this.enableFullScreen && t4 === this._pixelsWidth && e2 === this._pixelsHeight ? o2 = n2 > 1 ? -n2 : -1 : (o2 = ((65535 & (t4 = z(t4))) << 16 | 65535 & (e2 = z(e2))) >>> 0, n2 > 1 && (o2 += 4294967296 * n2)), this.texturePool[o2] || (this.texturePool[o2] = []);
        var s2 = this.texturePool[o2].pop();
        return s2 || (s2 = this.createTexture(t4, e2, n2)), s2.filterPoolKey = o2, s2.setResolution(i2), s2;
      }, t3.prototype.getFilterTexture = function(t4, e2, i2) {
        var n2 = this.getOptimalTexture(t4.width, t4.height, e2 || t4.resolution, i2 || r.l.NONE);
        return n2.filterFrame = t4.filterFrame, n2;
      }, t3.prototype.returnTexture = function(t4) {
        var e2 = t4.filterPoolKey;
        t4.filterFrame = null, this.texturePool[e2].push(t4);
      }, t3.prototype.returnFilterTexture = function(t4) {
        this.returnTexture(t4);
      }, t3.prototype.clear = function(t4) {
        if (t4 = t4 !== false)
          for (var e2 in this.texturePool) {
            var i2 = this.texturePool[e2];
            if (i2)
              for (var n2 = 0; n2 < i2.length; n2++)
                i2[n2].destroy(true);
          }
        this.texturePool = {};
      }, t3.prototype.setScreenSize = function(t4) {
        if (t4.width !== this._pixelsWidth || t4.height !== this._pixelsHeight) {
          for (var e2 in this.enableFullScreen = t4.width > 0 && t4.height > 0, this.texturePool)
            if (Number(e2) < 0) {
              var i2 = this.texturePool[e2];
              if (i2)
                for (var n2 = 0; n2 < i2.length; n2++)
                  i2[n2].destroy(true);
              this.texturePool[e2] = [];
            }
          this._pixelsWidth = t4.width, this._pixelsHeight = t4.height;
        }
      }, t3.SCREEN_KEY = -1, t3;
    }(), Zt = function() {
      function t3(t4, e2, i2, n2, o2, s2, a2) {
        e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = false), n2 === void 0 && (n2 = r.r.FLOAT), this.buffer = t4, this.size = e2, this.normalized = i2, this.type = n2, this.stride = o2, this.start = s2, this.instance = a2;
      }
      return t3.prototype.destroy = function() {
        this.buffer = null;
      }, t3.from = function(e2, i2, n2, r2, o2) {
        return new t3(e2, i2, n2, r2, o2);
      }, t3;
    }(), Jt = 0, Kt = function() {
      function t3(t4, e2, i2) {
        e2 === void 0 && (e2 = true), i2 === void 0 && (i2 = false), this.data = t4 || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i2, this.static = e2, this.id = Jt++, this.disposeRunner = new nt("disposeBuffer");
      }
      return t3.prototype.update = function(t4) {
        t4 instanceof Array && (t4 = new Float32Array(t4)), this.data = t4 || this.data, this._updateID++;
      }, t3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      }, t3.prototype.destroy = function() {
        this.dispose(), this.data = null;
      }, Object.defineProperty(t3.prototype, "index", { get: function() {
        return this.type === r.d.ELEMENT_ARRAY_BUFFER;
      }, set: function(t4) {
        this.type = t4 ? r.d.ELEMENT_ARRAY_BUFFER : r.d.ARRAY_BUFFER;
      }, enumerable: false, configurable: true }), t3.from = function(e2) {
        return e2 instanceof Array && (e2 = new Float32Array(e2)), new t3(e2);
      }, t3;
    }(), Qt = { Float32Array, Uint32Array, Int32Array, Uint8Array };
    var $t = { 5126: 4, 5123: 2, 5121: 1 }, te = 0, ee = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }, ie = function() {
      function t3(t4, e2) {
        t4 === void 0 && (t4 = []), e2 === void 0 && (e2 = {}), this.buffers = t4, this.indexBuffer = null, this.attributes = e2, this.glVertexArrayObjects = {}, this.id = te++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new nt("disposeGeometry"), this.refCount = 0;
      }
      return t3.prototype.addAttribute = function(t4, e2, i2, n2, r2, o2, s2, a2) {
        if (i2 === void 0 && (i2 = 0), n2 === void 0 && (n2 = false), a2 === void 0 && (a2 = false), !e2)
          throw new Error("You must pass a buffer when creating an attribute");
        e2 instanceof Kt || (e2 instanceof Array && (e2 = new Float32Array(e2)), e2 = new Kt(e2));
        var l2 = t4.split("|");
        if (l2.length > 1) {
          for (var h2 = 0; h2 < l2.length; h2++)
            this.addAttribute(l2[h2], e2, i2, n2, r2);
          return this;
        }
        var u2 = this.buffers.indexOf(e2);
        return u2 === -1 && (this.buffers.push(e2), u2 = this.buffers.length - 1), this.attributes[t4] = new Zt(u2, i2, n2, r2, o2, s2, a2), this.instanced = this.instanced || a2, this;
      }, t3.prototype.getAttribute = function(t4) {
        return this.attributes[t4];
      }, t3.prototype.getBuffer = function(t4) {
        return this.buffers[this.getAttribute(t4).buffer];
      }, t3.prototype.addIndex = function(t4) {
        return t4 instanceof Kt || (t4 instanceof Array && (t4 = new Uint16Array(t4)), t4 = new Kt(t4)), t4.type = r.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t4, this.buffers.indexOf(t4) === -1 && this.buffers.push(t4), this;
      }, t3.prototype.getIndex = function() {
        return this.indexBuffer;
      }, t3.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
          return this;
        var t4, e2 = [], i2 = [], n2 = new Kt();
        for (t4 in this.attributes) {
          var r2 = this.attributes[t4], o2 = this.buffers[r2.buffer];
          e2.push(o2.data), i2.push(r2.size * $t[r2.type] / 4), r2.buffer = 0;
        }
        for (n2.data = function(t5, e3) {
          for (var i3 = 0, n3 = 0, r3 = {}, o3 = 0; o3 < t5.length; o3++)
            n3 += e3[o3], i3 += t5[o3].length;
          var s2 = new ArrayBuffer(4 * i3), a2 = null, l2 = 0;
          for (o3 = 0; o3 < t5.length; o3++) {
            var h2 = e3[o3], u2 = t5[o3], c2 = j(u2);
            r3[c2] || (r3[c2] = new Qt[c2](s2)), a2 = r3[c2];
            for (var d2 = 0; d2 < u2.length; d2++) {
              a2[(d2 / h2 | 0) * n3 + l2 + d2 % h2] = u2[d2];
            }
            l2 += h2;
          }
          return new Float32Array(s2);
        }(e2, i2), t4 = 0; t4 < this.buffers.length; t4++)
          this.buffers[t4] !== this.indexBuffer && this.buffers[t4].destroy();
        return this.buffers = [n2], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
      }, t3.prototype.getSize = function() {
        for (var t4 in this.attributes) {
          var e2 = this.attributes[t4];
          return this.buffers[e2.buffer].data.length / (e2.stride / 4 || e2.size);
        }
        return 0;
      }, t3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      }, t3.prototype.destroy = function() {
        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
      }, t3.prototype.clone = function() {
        for (var e2 = new t3(), i2 = 0; i2 < this.buffers.length; i2++)
          e2.buffers[i2] = new Kt(this.buffers[i2].data.slice(0));
        for (var i2 in this.attributes) {
          var n2 = this.attributes[i2];
          e2.attributes[i2] = new Zt(n2.buffer, n2.size, n2.normalized, n2.type, n2.stride, n2.start, n2.instance);
        }
        return this.indexBuffer && (e2.indexBuffer = e2.buffers[this.buffers.indexOf(this.indexBuffer)], e2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER), e2;
      }, t3.merge = function(e2) {
        for (var i2, n2 = new t3(), o2 = [], s2 = [], a2 = [], l2 = 0; l2 < e2.length; l2++) {
          i2 = e2[l2];
          for (var h2 = 0; h2 < i2.buffers.length; h2++)
            s2[h2] = s2[h2] || 0, s2[h2] += i2.buffers[h2].data.length, a2[h2] = 0;
        }
        for (l2 = 0; l2 < i2.buffers.length; l2++)
          o2[l2] = new ee[j(i2.buffers[l2].data)](s2[l2]), n2.buffers[l2] = new Kt(o2[l2]);
        for (l2 = 0; l2 < e2.length; l2++) {
          i2 = e2[l2];
          for (h2 = 0; h2 < i2.buffers.length; h2++)
            o2[h2].set(i2.buffers[h2].data, a2[h2]), a2[h2] += i2.buffers[h2].data.length;
        }
        if (n2.attributes = i2.attributes, i2.indexBuffer) {
          n2.indexBuffer = n2.buffers[i2.buffers.indexOf(i2.indexBuffer)], n2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER;
          var u2 = 0, c2 = 0, d2 = 0, p2 = 0;
          for (l2 = 0; l2 < i2.buffers.length; l2++)
            if (i2.buffers[l2] !== i2.indexBuffer) {
              p2 = l2;
              break;
            }
          for (var l2 in i2.attributes) {
            var f2 = i2.attributes[l2];
            (0 | f2.buffer) === p2 && (c2 += f2.size * $t[f2.type] / 4);
          }
          for (l2 = 0; l2 < e2.length; l2++) {
            var m2 = e2[l2].indexBuffer.data;
            for (h2 = 0; h2 < m2.length; h2++)
              n2.indexBuffer.data[h2 + d2] += u2;
            u2 += e2[l2].buffers[p2].data.length / c2, d2 += m2.length;
          }
        }
        return n2;
      }, t3;
    }(), ne = function(t3) {
      function e2() {
        var e3 = t3.call(this) || this;
        return e3.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e3;
      }
      return St(e2, t3), e2;
    }(ie), re = function(t3) {
      function e2() {
        var e3 = t3.call(this) || this;
        return e3.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e3.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e3.vertexBuffer = new Kt(e3.vertices), e3.uvBuffer = new Kt(e3.uvs), e3.addAttribute("aVertexPosition", e3.vertexBuffer).addAttribute("aTextureCoord", e3.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e3;
      }
      return St(e2, t3), e2.prototype.map = function(t4, e3) {
        var i2 = 0, n2 = 0;
        return this.uvs[0] = i2, this.uvs[1] = n2, this.uvs[2] = i2 + e3.width / t4.width, this.uvs[3] = n2, this.uvs[4] = i2 + e3.width / t4.width, this.uvs[5] = n2 + e3.height / t4.height, this.uvs[6] = i2, this.uvs[7] = n2 + e3.height / t4.height, i2 = e3.x, n2 = e3.y, this.vertices[0] = i2, this.vertices[1] = n2, this.vertices[2] = i2 + e3.width, this.vertices[3] = n2, this.vertices[4] = i2 + e3.width, this.vertices[5] = n2 + e3.height, this.vertices[6] = i2, this.vertices[7] = n2 + e3.height, this.invalidate(), this;
      }, e2.prototype.invalidate = function() {
        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
      }, e2;
    }(ie), oe = 0, se = function() {
      function t3(t4, e2, i2) {
        this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = oe++, this.static = !!e2, this.ubo = !!i2, t4 instanceof Kt ? (this.buffer = t4, this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = t4, this.ubo && (this.buffer = new Kt(new Float32Array(1)), this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = true));
      }
      return t3.prototype.update = function() {
        this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
      }, t3.prototype.add = function(e2, i2, n2) {
        if (this.ubo)
          throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
        this.uniforms[e2] = new t3(i2, n2);
      }, t3.from = function(e2, i2, n2) {
        return new t3(e2, i2, n2);
      }, t3.uboFrom = function(e2, i2) {
        return new t3(e2, i2 == null || i2, true);
      }, t3;
    }(), ae = function() {
      function t3() {
        this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = r.l.NONE, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.bindingSourceFrame = new ut(), this.bindingDestinationFrame = new ut(), this.filters = [], this.transform = null;
      }
      return t3.prototype.clear = function() {
        this.target = null, this.filters = null, this.renderTexture = null;
      }, t3;
    }(), le = [new lt(), new lt(), new lt(), new lt()], he = new dt(), ue = function() {
      function t3(t4) {
        this.renderer = t4, this.defaultFilterStack = [{}], this.texturePool = new qt(), this.texturePool.setScreenSize(t4.view), this.statePool = [], this.quad = new ne(), this.quadUv = new re(), this.tempRect = new ut(), this.activeState = {}, this.globalUniforms = new se({ outputFrame: new ut(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, true), this.forceClear = false, this.useMaxPadding = false;
      }
      return t3.prototype.push = function(t4, e2) {
        for (var i2, n2, r2 = this.renderer, o2 = this.defaultFilterStack, s2 = this.statePool.pop() || new ae(), a2 = this.renderer.renderTexture, l2 = e2[0].resolution, h2 = e2[0].multisample, u2 = e2[0].padding, c2 = e2[0].autoFit, d2 = (i2 = e2[0].legacy) === null || i2 === void 0 || i2, p2 = 1; p2 < e2.length; p2++) {
          var f2 = e2[p2];
          l2 = Math.min(l2, f2.resolution), h2 = Math.min(h2, f2.multisample), u2 = this.useMaxPadding ? Math.max(u2, f2.padding) : u2 + f2.padding, c2 = c2 && f2.autoFit, d2 = d2 || (n2 = f2.legacy) === null || n2 === void 0 || n2;
        }
        o2.length === 1 && (this.defaultFilterStack[0].renderTexture = a2.current), o2.push(s2), s2.resolution = l2, s2.multisample = h2, s2.legacy = d2, s2.target = t4, s2.sourceFrame.copyFrom(t4.filterArea || t4.getBounds(true)), s2.sourceFrame.pad(u2);
        var m2 = this.tempRect.copyFrom(a2.sourceFrame);
        r2.projection.transform && this.transformAABB(he.copyFrom(r2.projection.transform).invert(), m2), c2 ? (s2.sourceFrame.fit(m2), (s2.sourceFrame.width <= 0 || s2.sourceFrame.height <= 0) && (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0)) : s2.sourceFrame.intersects(m2) || (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0), this.roundFrame(s2.sourceFrame, a2.current ? a2.current.resolution : r2.resolution, a2.sourceFrame, a2.destinationFrame, r2.projection.transform), s2.renderTexture = this.getOptimalFilterTexture(s2.sourceFrame.width, s2.sourceFrame.height, l2, h2), s2.filters = e2, s2.destinationFrame.width = s2.renderTexture.width, s2.destinationFrame.height = s2.renderTexture.height;
        var g2 = this.tempRect;
        g2.x = 0, g2.y = 0, g2.width = s2.sourceFrame.width, g2.height = s2.sourceFrame.height, s2.renderTexture.filterFrame = s2.sourceFrame, s2.bindingSourceFrame.copyFrom(a2.sourceFrame), s2.bindingDestinationFrame.copyFrom(a2.destinationFrame), s2.transform = r2.projection.transform, r2.projection.transform = null, a2.bind(s2.renderTexture, s2.sourceFrame, g2), r2.framebuffer.clear(0, 0, 0, 0);
      }, t3.prototype.pop = function() {
        var t4 = this.defaultFilterStack, e2 = t4.pop(), i2 = e2.filters;
        this.activeState = e2;
        var n2 = this.globalUniforms.uniforms;
        n2.outputFrame = e2.sourceFrame, n2.resolution = e2.resolution;
        var o2 = n2.inputSize, s2 = n2.inputPixel, a2 = n2.inputClamp;
        if (o2[0] = e2.destinationFrame.width, o2[1] = e2.destinationFrame.height, o2[2] = 1 / o2[0], o2[3] = 1 / o2[1], s2[0] = Math.round(o2[0] * e2.resolution), s2[1] = Math.round(o2[1] * e2.resolution), s2[2] = 1 / s2[0], s2[3] = 1 / s2[1], a2[0] = 0.5 * s2[2], a2[1] = 0.5 * s2[3], a2[2] = e2.sourceFrame.width * o2[2] - 0.5 * s2[2], a2[3] = e2.sourceFrame.height * o2[3] - 0.5 * s2[3], e2.legacy) {
          var l2 = n2.filterArea;
          l2[0] = e2.destinationFrame.width, l2[1] = e2.destinationFrame.height, l2[2] = e2.sourceFrame.x, l2[3] = e2.sourceFrame.y, n2.filterClamp = n2.inputClamp;
        }
        this.globalUniforms.update();
        var h2 = t4[t4.length - 1];
        if (this.renderer.framebuffer.blit(), i2.length === 1)
          i2[0].apply(this, e2.renderTexture, h2.renderTexture, r.e.BLEND, e2), this.returnFilterTexture(e2.renderTexture);
        else {
          var u2 = e2.renderTexture, c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution);
          c2.filterFrame = u2.filterFrame;
          var d2 = 0;
          for (d2 = 0; d2 < i2.length - 1; ++d2) {
            d2 === 1 && e2.multisample > 1 && ((c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution)).filterFrame = u2.filterFrame), i2[d2].apply(this, u2, c2, r.e.CLEAR, e2);
            var p2 = u2;
            u2 = c2, c2 = p2;
          }
          i2[d2].apply(this, u2, h2.renderTexture, r.e.BLEND, e2), d2 > 1 && e2.multisample > 1 && this.returnFilterTexture(e2.renderTexture), this.returnFilterTexture(u2), this.returnFilterTexture(c2);
        }
        e2.clear(), this.statePool.push(e2);
      }, t3.prototype.bindAndClear = function(t4, e2) {
        e2 === void 0 && (e2 = r.e.CLEAR);
        var i2 = this.renderer, n2 = i2.renderTexture, o2 = i2.state;
        if (t4 === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t4 && t4.filterFrame) {
          var s2 = this.tempRect;
          s2.x = 0, s2.y = 0, s2.width = t4.filterFrame.width, s2.height = t4.filterFrame.height, n2.bind(t4, t4.filterFrame, s2);
        } else
          t4 !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n2.bind(t4) : this.renderer.renderTexture.bind(t4, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        var a2 = 1 & o2.stateId || this.forceClear;
        (e2 === r.e.CLEAR || e2 === r.e.BLIT && a2) && this.renderer.framebuffer.clear(0, 0, 0, 0);
      }, t3.prototype.applyFilter = function(t4, e2, i2, n2) {
        var o2 = this.renderer;
        o2.state.set(t4.state), this.bindAndClear(i2, n2), t4.uniforms.uSampler = e2, t4.uniforms.filterGlobals = this.globalUniforms, o2.shader.bind(t4), t4.legacy = !!t4.program.attributeData.aTextureCoord, t4.legacy ? (this.quadUv.map(e2._frame, e2.filterFrame), o2.geometry.bind(this.quadUv), o2.geometry.draw(r.f.TRIANGLES)) : (o2.geometry.bind(this.quad), o2.geometry.draw(r.f.TRIANGLE_STRIP));
      }, t3.prototype.calculateSpriteMatrix = function(t4, e2) {
        var i2 = this.activeState, n2 = i2.sourceFrame, r2 = i2.destinationFrame, o2 = e2._texture.orig, s2 = t4.set(r2.width, 0, 0, r2.height, n2.x, n2.y), a2 = e2.worldTransform.copyTo(dt.TEMP_MATRIX);
        return a2.invert(), s2.prepend(a2), s2.scale(1 / o2.width, 1 / o2.height), s2.translate(e2.anchor.x, e2.anchor.y), s2;
      }, t3.prototype.destroy = function() {
        this.renderer = null, this.texturePool.clear(false);
      }, t3.prototype.getOptimalFilterTexture = function(t4, e2, i2, n2) {
        return i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = r.l.NONE), this.texturePool.getOptimalTexture(t4, e2, i2, n2);
      }, t3.prototype.getFilterTexture = function(t4, e2, i2) {
        if (typeof t4 == "number") {
          var n2 = t4;
          t4 = e2, e2 = n2;
        }
        t4 = t4 || this.activeState.renderTexture;
        var o2 = this.texturePool.getOptimalTexture(t4.width, t4.height, e2 || t4.resolution, i2 || r.l.NONE);
        return o2.filterFrame = t4.filterFrame, o2;
      }, t3.prototype.returnFilterTexture = function(t4) {
        this.texturePool.returnTexture(t4);
      }, t3.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      }, t3.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      }, t3.prototype.transformAABB = function(t4, e2) {
        var i2 = le[0], n2 = le[1], r2 = le[2], o2 = le[3];
        i2.set(e2.left, e2.top), n2.set(e2.left, e2.bottom), r2.set(e2.right, e2.top), o2.set(e2.right, e2.bottom), t4.apply(i2, i2), t4.apply(n2, n2), t4.apply(r2, r2), t4.apply(o2, o2);
        var s2 = Math.min(i2.x, n2.x, r2.x, o2.x), a2 = Math.min(i2.y, n2.y, r2.y, o2.y), l2 = Math.max(i2.x, n2.x, r2.x, o2.x), h2 = Math.max(i2.y, n2.y, r2.y, o2.y);
        e2.x = s2, e2.y = a2, e2.width = l2 - s2, e2.height = h2 - a2;
      }, t3.prototype.roundFrame = function(t4, e2, i2, n2, r2) {
        if (!(t4.width <= 0 || t4.height <= 0 || i2.width <= 0 || i2.height <= 0)) {
          if (r2) {
            var o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d;
            if ((Math.abs(s2) > 1e-4 || Math.abs(a2) > 1e-4) && (Math.abs(o2) > 1e-4 || Math.abs(l2) > 1e-4))
              return;
          }
          (r2 = r2 ? he.copyFrom(r2) : he.identity()).translate(-i2.x, -i2.y).scale(n2.width / i2.width, n2.height / i2.height).translate(n2.x, n2.y), this.transformAABB(r2, t4), t4.ceil(e2), this.transformAABB(r2.invert(), t4);
        }
      }, t3;
    }(), ce = function() {
      function t3(t4) {
        this.renderer = t4;
      }
      return t3.prototype.flush = function() {
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3.prototype.start = function() {
      }, t3.prototype.stop = function() {
        this.flush();
      }, t3.prototype.render = function(t4) {
      }, t3;
    }(), de = function() {
      function t3(t4) {
        this.renderer = t4, this.emptyRenderer = new ce(t4), this.currentRenderer = this.emptyRenderer;
      }
      return t3.prototype.setObjectRenderer = function(t4) {
        this.currentRenderer !== t4 && (this.currentRenderer.stop(), this.currentRenderer = t4, this.currentRenderer.start());
      }, t3.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      }, t3.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      }, t3.prototype.copyBoundTextures = function(t4, e2) {
        for (var i2 = this.renderer.texture.boundTextures, n2 = e2 - 1; n2 >= 0; --n2)
          t4[n2] = i2[n2] || null, t4[n2] && (t4[n2]._batchLocation = n2);
      }, t3.prototype.boundArray = function(t4, e2, i2, n2) {
        for (var r2 = t4.elements, o2 = t4.ids, s2 = t4.count, a2 = 0, l2 = 0; l2 < s2; l2++) {
          var h2 = r2[l2], u2 = h2._batchLocation;
          if (u2 >= 0 && u2 < n2 && e2[u2] === h2)
            o2[l2] = u2;
          else
            for (; a2 < n2; ) {
              var c2 = e2[a2];
              if (!c2 || c2._batchEnabled !== i2 || c2._batchLocation !== a2) {
                o2[l2] = a2, h2._batchLocation = a2, e2[a2] = h2;
                break;
              }
              a2++;
            }
        }
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), pe = 0, fe = function() {
      function t3(t4) {
        this.renderer = t4, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: false }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t4.view.addEventListener("webglcontextlost", this.handleContextLost, false), t4.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      return Object.defineProperty(t3.prototype, "isLost", { get: function() {
        return !this.gl || this.gl.isContextLost();
      }, enumerable: false, configurable: true }), t3.prototype.contextChange = function(t4) {
        this.gl = t4, this.renderer.gl = t4, this.renderer.CONTEXT_UID = pe++, t4.isContextLost() && t4.getExtension("WEBGL_lose_context") && t4.getExtension("WEBGL_lose_context").restoreContext();
      }, t3.prototype.initFromContext = function(t4) {
        this.gl = t4, this.validateContext(t4), this.renderer.gl = t4, this.renderer.CONTEXT_UID = pe++, this.renderer.runners.contextChange.emit(t4);
      }, t3.prototype.initFromOptions = function(t4) {
        var e2 = this.createContext(this.renderer.view, t4);
        this.initFromContext(e2);
      }, t3.prototype.createContext = function(t4, e2) {
        var i2;
        if (n.b.PREFER_ENV >= r.g.WEBGL2 && (i2 = t4.getContext("webgl2", e2)), i2)
          this.webGLVersion = 2;
        else if (this.webGLVersion = 1, !(i2 = t4.getContext("webgl", e2) || t4.getContext("experimental-webgl", e2)))
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = i2, this.getExtensions(), this.gl;
      }, t3.prototype.getExtensions = function() {
        var t4 = this.gl, e2 = { anisotropicFiltering: t4.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), s3tc: t4.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t4.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t4.getExtension("WEBGL_compressed_texture_etc"), etc1: t4.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t4.getExtension("WEBGL_compressed_texture_pvrtc") || t4.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t4.getExtension("WEBGL_compressed_texture_atc"), astc: t4.getExtension("WEBGL_compressed_texture_astc") };
        this.webGLVersion === 1 ? Object.assign(this.extensions, e2, { drawBuffers: t4.getExtension("WEBGL_draw_buffers"), depthTexture: t4.getExtension("WEBGL_depth_texture"), loseContext: t4.getExtension("WEBGL_lose_context"), vertexArrayObject: t4.getExtension("OES_vertex_array_object") || t4.getExtension("MOZ_OES_vertex_array_object") || t4.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t4.getExtension("OES_element_index_uint"), floatTexture: t4.getExtension("OES_texture_float"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), textureHalfFloat: t4.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t4.getExtension("OES_texture_half_float_linear") }) : this.webGLVersion === 2 && Object.assign(this.extensions, e2, { colorBufferFloat: t4.getExtension("EXT_color_buffer_float") });
      }, t3.prototype.handleContextLost = function(t4) {
        t4.preventDefault();
      }, t3.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      }, t3.prototype.destroy = function() {
        var t4 = this.renderer.view;
        this.renderer = null, t4.removeEventListener("webglcontextlost", this.handleContextLost), t4.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
      }, t3.prototype.postrender = function() {
        this.renderer.renderingToScreen && this.gl.flush();
      }, t3.prototype.validateContext = function(t4) {
        var e2 = t4.getContextAttributes(), i2 = "WebGL2RenderingContext" in globalThis && t4 instanceof globalThis.WebGL2RenderingContext;
        i2 && (this.webGLVersion = 2), e2 && !e2.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        var n2 = i2 || !!t4.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = n2, n2 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }, t3;
    }(), me = function(t3) {
      this.framebuffer = t3, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = r.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }, ge = new ut(), ve = function() {
      function t3(t4) {
        this.renderer = t4, this.managedFramebuffers = [], this.unknownFramebuffer = new Ht(10, 10), this.msaaSamples = null;
      }
      return t3.prototype.contextChange = function() {
        var t4 = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new ut(), this.hasMRT = true, this.writeDepthTexture = true, this.disposeAll(true), this.renderer.context.webGLVersion === 1) {
          var e2 = this.renderer.context.extensions.drawBuffers, i2 = this.renderer.context.extensions.depthTexture;
          n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (e2 = null, i2 = null), e2 ? t4.drawBuffers = function(t5) {
            return e2.drawBuffersWEBGL(t5);
          } : (this.hasMRT = false, t4.drawBuffers = function() {
          }), i2 || (this.writeDepthTexture = false);
        } else
          this.msaaSamples = t4.getInternalformatParameter(t4.RENDERBUFFER, t4.RGBA8, t4.SAMPLES);
      }, t3.prototype.bind = function(t4, e2, i2) {
        i2 === void 0 && (i2 = 0);
        var n2 = this.gl;
        if (t4) {
          var r2 = t4.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t4);
          this.current !== t4 && (this.current = t4, n2.bindFramebuffer(n2.FRAMEBUFFER, r2.framebuffer)), r2.mipLevel !== i2 && (t4.dirtyId++, t4.dirtyFormat++, r2.mipLevel = i2), r2.dirtyId !== t4.dirtyId && (r2.dirtyId = t4.dirtyId, r2.dirtyFormat !== t4.dirtyFormat ? (r2.dirtyFormat = t4.dirtyFormat, r2.dirtySize = t4.dirtySize, this.updateFramebuffer(t4, i2)) : r2.dirtySize !== t4.dirtySize && (r2.dirtySize = t4.dirtySize, this.resizeFramebuffer(t4)));
          for (var o2 = 0; o2 < t4.colorTextures.length; o2++) {
            var s2 = t4.colorTextures[o2];
            this.renderer.texture.unbind(s2.parentTextureArray || s2);
          }
          if (t4.depthTexture && this.renderer.texture.unbind(t4.depthTexture), e2) {
            var a2 = e2.width >> i2, l2 = e2.height >> i2, h2 = a2 / e2.width;
            this.setViewport(e2.x * h2, e2.y * h2, a2, l2);
          } else {
            a2 = t4.width >> i2, l2 = t4.height >> i2;
            this.setViewport(0, 0, a2, l2);
          }
        } else
          this.current && (this.current = null, n2.bindFramebuffer(n2.FRAMEBUFFER, null)), e2 ? this.setViewport(e2.x, e2.y, e2.width, e2.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }, t3.prototype.setViewport = function(t4, e2, i2, n2) {
        var r2 = this.viewport;
        t4 = Math.round(t4), e2 = Math.round(e2), i2 = Math.round(i2), n2 = Math.round(n2), r2.width === i2 && r2.height === n2 && r2.x === t4 && r2.y === e2 || (r2.x = t4, r2.y = e2, r2.width = i2, r2.height = n2, this.gl.viewport(t4, e2, i2, n2));
      }, Object.defineProperty(t3.prototype, "size", { get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      }, enumerable: false, configurable: true }), t3.prototype.clear = function(t4, e2, i2, n2, o2) {
        o2 === void 0 && (o2 = r.c.COLOR | r.c.DEPTH);
        var s2 = this.gl;
        s2.clearColor(t4, e2, i2, n2), s2.clear(o2);
      }, t3.prototype.initFramebuffer = function(t4) {
        var e2 = this.gl, i2 = new me(e2.createFramebuffer());
        return i2.multisample = this.detectSamples(t4.multisample), t4.glFramebuffers[this.CONTEXT_UID] = i2, this.managedFramebuffers.push(t4), t4.disposeRunner.add(this), i2;
      }, t3.prototype.resizeFramebuffer = function(t4) {
        var e2 = this.gl, i2 = t4.glFramebuffers[this.CONTEXT_UID];
        i2.msaaBuffer && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.msaaBuffer), e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.RGBA8, t4.width, t4.height)), i2.stencil && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.stencil), i2.msaaBuffer ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.DEPTH24_STENCIL8, t4.width, t4.height) : e2.renderbufferStorage(e2.RENDERBUFFER, e2.DEPTH_STENCIL, t4.width, t4.height));
        var n2 = t4.colorTextures, r2 = n2.length;
        e2.drawBuffers || (r2 = Math.min(r2, 1));
        for (var o2 = 0; o2 < r2; o2++) {
          var s2 = n2[o2], a2 = s2.parentTextureArray || s2;
          this.renderer.texture.bind(a2, 0);
        }
        t4.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t4.depthTexture, 0);
      }, t3.prototype.updateFramebuffer = function(t4, e2) {
        var i2 = this.gl, n2 = t4.glFramebuffers[this.CONTEXT_UID], r2 = t4.colorTextures, o2 = r2.length;
        i2.drawBuffers || (o2 = Math.min(o2, 1)), n2.multisample > 1 && this.canMultisampleFramebuffer(t4) ? (n2.msaaBuffer = n2.msaaBuffer || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.msaaBuffer), i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.RGBA8, t4.width, t4.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.RENDERBUFFER, n2.msaaBuffer)) : n2.msaaBuffer && (i2.deleteRenderbuffer(n2.msaaBuffer), n2.msaaBuffer = null, n2.blitFramebuffer && (n2.blitFramebuffer.dispose(), n2.blitFramebuffer = null));
        for (var s2 = [], a2 = 0; a2 < o2; a2++) {
          var l2 = r2[a2], h2 = l2.parentTextureArray || l2;
          this.renderer.texture.bind(h2, 0), a2 === 0 && n2.msaaBuffer || (i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0 + a2, l2.target, h2._glTextures[this.CONTEXT_UID].texture, e2), s2.push(i2.COLOR_ATTACHMENT0 + a2));
        }
        if ((s2.length > 1 && i2.drawBuffers(s2), t4.depthTexture) && this.writeDepthTexture) {
          var u2 = t4.depthTexture;
          this.renderer.texture.bind(u2, 0), i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.DEPTH_ATTACHMENT, i2.TEXTURE_2D, u2._glTextures[this.CONTEXT_UID].texture, e2);
        }
        !t4.stencil && !t4.depth || t4.depthTexture && this.writeDepthTexture ? n2.stencil && (i2.deleteRenderbuffer(n2.stencil), n2.stencil = null) : (n2.stencil = n2.stencil || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.stencil), n2.msaaBuffer ? i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.DEPTH24_STENCIL8, t4.width, t4.height) : i2.renderbufferStorage(i2.RENDERBUFFER, i2.DEPTH_STENCIL, t4.width, t4.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.DEPTH_STENCIL_ATTACHMENT, i2.RENDERBUFFER, n2.stencil));
      }, t3.prototype.canMultisampleFramebuffer = function(t4) {
        return this.renderer.context.webGLVersion !== 1 && t4.colorTextures.length <= 1 && !t4.depthTexture;
      }, t3.prototype.detectSamples = function(t4) {
        var e2 = this.msaaSamples, i2 = r.l.NONE;
        if (t4 <= 1 || e2 === null)
          return i2;
        for (var n2 = 0; n2 < e2.length; n2++)
          if (e2[n2] <= t4) {
            i2 = e2[n2];
            break;
          }
        return i2 === 1 && (i2 = r.l.NONE), i2;
      }, t3.prototype.blit = function(t4, e2, i2) {
        var n2 = this.current, r2 = this.renderer, o2 = this.gl, s2 = this.CONTEXT_UID;
        if (r2.context.webGLVersion === 2 && n2) {
          var a2 = n2.glFramebuffers[s2];
          if (a2) {
            if (!t4) {
              if (!a2.msaaBuffer)
                return;
              var l2 = n2.colorTextures[0];
              if (!l2)
                return;
              a2.blitFramebuffer || (a2.blitFramebuffer = new Ht(n2.width, n2.height), a2.blitFramebuffer.addColorTexture(0, l2)), (t4 = a2.blitFramebuffer).colorTextures[0] !== l2 && (t4.colorTextures[0] = l2, t4.dirtyId++, t4.dirtyFormat++), t4.width === n2.width && t4.height === n2.height || (t4.width = n2.width, t4.height = n2.height, t4.dirtyId++, t4.dirtySize++);
            }
            e2 || ((e2 = ge).width = n2.width, e2.height = n2.height), i2 || (i2 = e2);
            var h2 = e2.width === i2.width && e2.height === i2.height;
            this.bind(t4), o2.bindFramebuffer(o2.READ_FRAMEBUFFER, a2.framebuffer), o2.blitFramebuffer(e2.left, e2.top, e2.right, e2.bottom, i2.left, i2.top, i2.right, i2.bottom, o2.COLOR_BUFFER_BIT, h2 ? o2.NEAREST : o2.LINEAR);
          }
        }
      }, t3.prototype.disposeFramebuffer = function(t4, e2) {
        var i2 = t4.glFramebuffers[this.CONTEXT_UID], n2 = this.gl;
        if (i2) {
          delete t4.glFramebuffers[this.CONTEXT_UID];
          var r2 = this.managedFramebuffers.indexOf(t4);
          r2 >= 0 && this.managedFramebuffers.splice(r2, 1), t4.disposeRunner.remove(this), e2 || (n2.deleteFramebuffer(i2.framebuffer), i2.msaaBuffer && n2.deleteRenderbuffer(i2.msaaBuffer), i2.stencil && n2.deleteRenderbuffer(i2.stencil)), i2.blitFramebuffer && i2.blitFramebuffer.dispose();
        }
      }, t3.prototype.disposeAll = function(t4) {
        var e2 = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i2 = 0; i2 < e2.length; i2++)
          this.disposeFramebuffer(e2[i2], t4);
      }, t3.prototype.forceStencil = function() {
        var t4 = this.current;
        if (t4) {
          var e2 = t4.glFramebuffers[this.CONTEXT_UID];
          if (e2 && !e2.stencil) {
            t4.stencil = true;
            var i2 = t4.width, n2 = t4.height, r2 = this.gl, o2 = r2.createRenderbuffer();
            r2.bindRenderbuffer(r2.RENDERBUFFER, o2), e2.msaaBuffer ? r2.renderbufferStorageMultisample(r2.RENDERBUFFER, e2.multisample, r2.DEPTH24_STENCIL8, i2, n2) : r2.renderbufferStorage(r2.RENDERBUFFER, r2.DEPTH_STENCIL, i2, n2), e2.stencil = o2, r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, o2);
          }
        }
      }, t3.prototype.reset = function() {
        this.current = this.unknownFramebuffer, this.viewport = new ut();
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), _e = { 5126: 4, 5123: 2, 5121: 1 }, ye = function() {
      function t3(t4) {
        this.renderer = t4, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
      }
      return t3.prototype.contextChange = function() {
        this.disposeAll(true);
        var t4 = this.gl = this.renderer.gl, e2 = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e2.webGLVersion !== 2) {
          var i2 = this.renderer.context.extensions.vertexArrayObject;
          n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (i2 = null), i2 ? (t4.createVertexArray = function() {
            return i2.createVertexArrayOES();
          }, t4.bindVertexArray = function(t5) {
            return i2.bindVertexArrayOES(t5);
          }, t4.deleteVertexArray = function(t5) {
            return i2.deleteVertexArrayOES(t5);
          }) : (this.hasVao = false, t4.createVertexArray = function() {
            return null;
          }, t4.bindVertexArray = function() {
            return null;
          }, t4.deleteVertexArray = function() {
            return null;
          });
        }
        if (e2.webGLVersion !== 2) {
          var o2 = t4.getExtension("ANGLE_instanced_arrays");
          o2 ? (t4.vertexAttribDivisor = function(t5, e3) {
            return o2.vertexAttribDivisorANGLE(t5, e3);
          }, t4.drawElementsInstanced = function(t5, e3, i3, n2, r2) {
            return o2.drawElementsInstancedANGLE(t5, e3, i3, n2, r2);
          }, t4.drawArraysInstanced = function(t5, e3, i3, n2) {
            return o2.drawArraysInstancedANGLE(t5, e3, i3, n2);
          }) : this.hasInstance = false;
        }
        this.canUseUInt32ElementIndex = e2.webGLVersion === 2 || !!e2.extensions.uint32ElementIndex;
      }, t3.prototype.bind = function(t4, e2) {
        e2 = e2 || this.renderer.shader.shader;
        var i2 = this.gl, n2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r2 = false;
        n2 || (this.managedGeometries[t4.id] = t4, t4.disposeRunner.add(this), t4.glVertexArrayObjects[this.CONTEXT_UID] = n2 = {}, r2 = true);
        var o2 = n2[e2.program.id] || this.initGeometryVao(t4, e2, r2);
        this._activeGeometry = t4, this._activeVao !== o2 && (this._activeVao = o2, this.hasVao ? i2.bindVertexArray(o2) : this.activateVao(t4, e2.program)), this.updateBuffers();
      }, t3.prototype.reset = function() {
        this.unbind();
      }, t3.prototype.updateBuffers = function() {
        for (var t4 = this._activeGeometry, e2 = this.renderer.buffer, i2 = 0; i2 < t4.buffers.length; i2++) {
          var n2 = t4.buffers[i2];
          e2.update(n2);
        }
      }, t3.prototype.checkCompatibility = function(t4, e2) {
        var i2 = t4.attributes, n2 = e2.attributeData;
        for (var r2 in n2)
          if (!i2[r2])
            throw new Error('shader and geometry incompatible, geometry missing the "' + r2 + '" attribute');
      }, t3.prototype.getSignature = function(t4, e2) {
        var i2 = t4.attributes, n2 = e2.attributeData, r2 = ["g", t4.id];
        for (var o2 in i2)
          n2[o2] && r2.push(o2, n2[o2].location);
        return r2.join("-");
      }, t3.prototype.initGeometryVao = function(t4, e2, i2) {
        i2 === void 0 && (i2 = true);
        var n2 = this.gl, r2 = this.CONTEXT_UID, o2 = this.renderer.buffer, s2 = e2.program;
        s2.glPrograms[r2] || this.renderer.shader.generateProgram(e2), this.checkCompatibility(t4, s2);
        var a2 = this.getSignature(t4, s2), l2 = t4.glVertexArrayObjects[this.CONTEXT_UID], h2 = l2[a2];
        if (h2)
          return l2[s2.id] = h2, h2;
        var u2 = t4.buffers, c2 = t4.attributes, d2 = {}, p2 = {};
        for (var f2 in u2)
          d2[f2] = 0, p2[f2] = 0;
        for (var f2 in c2)
          !c2[f2].size && s2.attributeData[f2] ? c2[f2].size = s2.attributeData[f2].size : c2[f2].size || console.warn("PIXI Geometry attribute '" + f2 + "' size cannot be determined (likely the bound shader does not have the attribute)"), d2[c2[f2].buffer] += c2[f2].size * _e[c2[f2].type];
        for (var f2 in c2) {
          var m2 = c2[f2], g2 = m2.size;
          m2.stride === void 0 && (d2[m2.buffer] === g2 * _e[m2.type] ? m2.stride = 0 : m2.stride = d2[m2.buffer]), m2.start === void 0 && (m2.start = p2[m2.buffer], p2[m2.buffer] += g2 * _e[m2.type]);
        }
        h2 = n2.createVertexArray(), n2.bindVertexArray(h2);
        for (var v2 = 0; v2 < u2.length; v2++) {
          var _2 = u2[v2];
          o2.bind(_2), i2 && _2._glBuffers[r2].refCount++;
        }
        return this.activateVao(t4, s2), this._activeVao = h2, l2[s2.id] = h2, l2[a2] = h2, h2;
      }, t3.prototype.disposeGeometry = function(t4, e2) {
        var i2;
        if (this.managedGeometries[t4.id]) {
          delete this.managedGeometries[t4.id];
          var n2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r2 = this.gl, o2 = t4.buffers, s2 = (i2 = this.renderer) === null || i2 === void 0 ? void 0 : i2.buffer;
          if (t4.disposeRunner.remove(this), n2) {
            if (s2)
              for (var a2 = 0; a2 < o2.length; a2++) {
                var l2 = o2[a2]._glBuffers[this.CONTEXT_UID];
                l2 && (l2.refCount--, l2.refCount !== 0 || e2 || s2.dispose(o2[a2], e2));
              }
            if (!e2) {
              for (var h2 in n2)
                if (h2[0] === "g") {
                  var u2 = n2[h2];
                  this._activeVao === u2 && this.unbind(), r2.deleteVertexArray(u2);
                }
            }
            delete t4.glVertexArrayObjects[this.CONTEXT_UID];
          }
        }
      }, t3.prototype.disposeAll = function(t4) {
        for (var e2 = Object.keys(this.managedGeometries), i2 = 0; i2 < e2.length; i2++)
          this.disposeGeometry(this.managedGeometries[e2[i2]], t4);
      }, t3.prototype.activateVao = function(t4, e2) {
        var i2 = this.gl, n2 = this.CONTEXT_UID, r2 = this.renderer.buffer, o2 = t4.buffers, s2 = t4.attributes;
        t4.indexBuffer && r2.bind(t4.indexBuffer);
        var a2 = null;
        for (var l2 in s2) {
          var h2 = s2[l2], u2 = o2[h2.buffer], c2 = u2._glBuffers[n2];
          if (e2.attributeData[l2]) {
            a2 !== c2 && (r2.bind(u2), a2 = c2);
            var d2 = e2.attributeData[l2].location;
            if (i2.enableVertexAttribArray(d2), i2.vertexAttribPointer(d2, h2.size, h2.type || i2.FLOAT, h2.normalized, h2.stride, h2.start), h2.instance) {
              if (!this.hasInstance)
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              i2.vertexAttribDivisor(d2, 1);
            }
          }
        }
      }, t3.prototype.draw = function(t4, e2, i2, n2) {
        var r2 = this.gl, o2 = this._activeGeometry;
        if (o2.indexBuffer) {
          var s2 = o2.indexBuffer.data.BYTES_PER_ELEMENT, a2 = s2 === 2 ? r2.UNSIGNED_SHORT : r2.UNSIGNED_INT;
          s2 === 2 || s2 === 4 && this.canUseUInt32ElementIndex ? o2.instanced ? r2.drawElementsInstanced(t4, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2, n2 || 1) : r2.drawElements(t4, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2) : console.warn("unsupported index buffer type: uint32");
        } else
          o2.instanced ? r2.drawArraysInstanced(t4, i2, e2 || o2.getSize(), n2 || 1) : r2.drawArrays(t4, i2, e2 || o2.getSize());
        return this;
      }, t3.prototype.unbind = function() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), xe = function() {
      function t3(t4) {
        t4 === void 0 && (t4 = null), this.type = r.j.NONE, this.autoDetect = true, this.maskObject = t4 || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = n.b.FILTER_MULTISAMPLE, this.enabled = true, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null;
      }
      return Object.defineProperty(t3.prototype, "filter", { get: function() {
        return this._filters ? this._filters[0] : null;
      }, set: function(t4) {
        t4 ? this._filters ? this._filters[0] = t4 : this._filters = [t4] : this._filters = null;
      }, enumerable: false, configurable: true }), t3.prototype.reset = function() {
        this.pooled && (this.maskObject = null, this.type = r.j.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
      }, t3.prototype.copyCountersOrReset = function(t4) {
        t4 ? (this._stencilCounter = t4._stencilCounter, this._scissorCounter = t4._scissorCounter, this._scissorRect = t4._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
      }, t3;
    }();
    function be(t3, e2, i2) {
      var n2 = t3.createShader(e2);
      return t3.shaderSource(n2, i2), t3.compileShader(n2), n2;
    }
    function Te(t3, e2) {
      var i2 = t3.getShaderSource(e2).split("\n").map(function(t4, e3) {
        return e3 + ": " + t4;
      }), n2 = t3.getShaderInfoLog(e2), r2 = n2.split("\n"), o2 = {}, s2 = r2.map(function(t4) {
        return parseFloat(t4.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
      }).filter(function(t4) {
        return !(!t4 || o2[t4]) && (o2[t4] = true, true);
      }), a2 = [""];
      s2.forEach(function(t4) {
        i2[t4 - 1] = "%c" + i2[t4 - 1] + "%c", a2.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
      });
      var l2 = i2.join("\n");
      a2[0] = l2, console.error(n2), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a2), console.groupEnd();
    }
    function Ee(t3) {
      for (var e2 = new Array(t3), i2 = 0; i2 < e2.length; i2++)
        e2[i2] = false;
      return e2;
    }
    function Se(t3, e2) {
      switch (t3) {
        case "float":
          return 0;
        case "vec2":
          return new Float32Array(2 * e2);
        case "vec3":
          return new Float32Array(3 * e2);
        case "vec4":
          return new Float32Array(4 * e2);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
          return 0;
        case "ivec2":
          return new Int32Array(2 * e2);
        case "ivec3":
          return new Int32Array(3 * e2);
        case "ivec4":
          return new Int32Array(4 * e2);
        case "uvec2":
          return new Uint32Array(2 * e2);
        case "uvec3":
          return new Uint32Array(3 * e2);
        case "uvec4":
          return new Uint32Array(4 * e2);
        case "bool":
          return false;
        case "bvec2":
          return Ee(2 * e2);
        case "bvec3":
          return Ee(3 * e2);
        case "bvec4":
          return Ee(4 * e2);
        case "mat2":
          return new Float32Array([1, 0, 0, 1]);
        case "mat3":
          return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
          return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      return null;
    }
    var we, Ae = {}, Me = Ae;
    function Re() {
      if (!we) {
        we = r.m.MEDIUM;
        var t3 = function() {
          if (Me === Ae || Me && Me.isContextLost()) {
            var t4 = document.createElement("canvas"), e3 = void 0;
            n.b.PREFER_ENV >= r.g.WEBGL2 && (e3 = t4.getContext("webgl2", {})), e3 || ((e3 = t4.getContext("webgl", {}) || t4.getContext("experimental-webgl", {})) ? e3.getExtension("WEBGL_draw_buffers") : e3 = null), Me = e3;
          }
          return Me;
        }();
        if (t3 && t3.getShaderPrecisionFormat) {
          var e2 = t3.getShaderPrecisionFormat(t3.FRAGMENT_SHADER, t3.HIGH_FLOAT);
          we = e2.precision ? r.m.HIGH : r.m.MEDIUM;
        }
      }
      return we;
    }
    function Ce(t3, e2, i2) {
      if (t3.substring(0, 9) !== "precision") {
        var n2 = e2;
        return e2 === r.m.HIGH && i2 !== r.m.HIGH && (n2 = r.m.MEDIUM), "precision " + n2 + " float;\n" + t3;
      }
      return i2 !== r.m.HIGH && t3.substring(0, 15) === "precision highp" ? t3.replace("precision highp", "precision mediump") : t3;
    }
    var Ie = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
    function Pe(t3) {
      return Ie[t3];
    }
    var Oe = null, Ne = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" };
    function Le(t3, e2) {
      if (!Oe) {
        var i2 = Object.keys(Ne);
        Oe = {};
        for (var n2 = 0; n2 < i2.length; ++n2) {
          var r2 = i2[n2];
          Oe[t3[r2]] = Ne[r2];
        }
      }
      return Oe[e2];
    }
    var De = [{ test: function(t3) {
      return t3.type === "float" && t3.size === 1;
    }, code: function(t3) {
      return '\n            if(uv["' + t3 + '"] !== ud["' + t3 + '"].value)\n            {\n                ud["' + t3 + '"].value = uv["' + t3 + '"]\n                gl.uniform1f(ud["' + t3 + '"].location, uv["' + t3 + '"])\n            }\n            ';
    } }, { test: function(t3) {
      return (t3.type === "sampler2D" || t3.type === "samplerCube" || t3.type === "sampler2DArray") && t3.size === 1 && !t3.isArray;
    }, code: function(t3) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t3 + '"], t);\n\n            if(ud["' + t3 + '"].value !== t)\n            {\n                ud["' + t3 + '"].value = t;\n                gl.uniform1i(ud["' + t3 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    } }, { test: function(t3, e2) {
      return t3.type === "mat3" && t3.size === 1 && e2.a !== void 0;
    }, code: function(t3) {
      return '\n            gl.uniformMatrix3fv(ud["' + t3 + '"].location, false, uv["' + t3 + '"].toArray(true));\n            ';
    }, codeUbo: function(t3) {
      return "\n                var " + t3 + "_matrix = uv." + t3 + ".toArray(true);\n\n                data[offset] = " + t3 + "_matrix[0];\n                data[offset+1] = " + t3 + "_matrix[1];\n                data[offset+2] = " + t3 + "_matrix[2];\n        \n                data[offset + 4] = " + t3 + "_matrix[3];\n                data[offset + 5] = " + t3 + "_matrix[4];\n                data[offset + 6] = " + t3 + "_matrix[5];\n        \n                data[offset + 8] = " + t3 + "_matrix[6];\n                data[offset + 9] = " + t3 + "_matrix[7];\n                data[offset + 10] = " + t3 + "_matrix[8];\n            ";
    } }, { test: function(t3, e2) {
      return t3.type === "vec2" && t3.size === 1 && e2.x !== void 0;
    }, code: function(t3) {
      return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t3 + '"].location, v.x, v.y);\n                }';
    }, codeUbo: function(t3) {
      return "\n                v = uv." + t3 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    } }, { test: function(t3) {
      return t3.type === "vec2" && t3.size === 1;
    }, code: function(t3) {
      return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t3 + '"].location, v[0], v[1]);\n                }\n            ';
    } }, { test: function(t3, e2) {
      return t3.type === "vec4" && t3.size === 1 && e2.width !== void 0;
    }, code: function(t3) {
      return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t3 + '"].location, v.x, v.y, v.width, v.height)\n                }';
    }, codeUbo: function(t3) {
      return "\n                    v = uv." + t3 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    } }, { test: function(t3) {
      return t3.type === "vec4" && t3.size === 1;
    }, code: function(t3) {
      return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t3 + '"].location, v[0], v[1], v[2], v[3])\n                }';
    } }], Fe = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, Be = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" };
    var Ue, ke = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
    function Ge(t3) {
      for (var e2 = "", i2 = 0; i2 < t3; ++i2)
        i2 > 0 && (e2 += "\nelse "), i2 < t3 - 1 && (e2 += "if(test == " + i2 + ".0){}");
      return e2;
    }
    var He = 0, je = {}, ze = function() {
      function t3(e2, i2, o2) {
        o2 === void 0 && (o2 = "pixi-shader"), this.id = He++, this.vertexSrc = e2 || t3.defaultVertexSrc, this.fragmentSrc = i2 || t3.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (o2 = o2.replace(/\s+/g, "-"), je[o2] ? (je[o2]++, o2 += "-" + je[o2]) : je[o2] = 1, this.vertexSrc = "#define SHADER_NAME " + o2 + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o2 + "\n" + this.fragmentSrc, this.vertexSrc = Ce(this.vertexSrc, n.b.PRECISION_VERTEX, r.m.HIGH), this.fragmentSrc = Ce(this.fragmentSrc, n.b.PRECISION_FRAGMENT, Re())), this.glPrograms = {}, this.syncUniforms = null;
      }
      return Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
        return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentSrc", { get: function() {
        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
      }, enumerable: false, configurable: true }), t3.from = function(e2, i2, n2) {
        var r2 = e2 + i2, o2 = K[r2];
        return o2 || (K[r2] = o2 = new t3(e2, i2, n2)), o2;
      }, t3;
    }(), Ve = function() {
      function t3(t4, e2) {
        this.uniformBindCount = 0, this.program = t4, this.uniformGroup = e2 ? e2 instanceof se ? e2 : new se(e2) : new se({});
      }
      return t3.prototype.checkUniformExists = function(t4, e2) {
        if (e2.uniforms[t4])
          return true;
        for (var i2 in e2.uniforms) {
          var n2 = e2.uniforms[i2];
          if (n2.group && this.checkUniformExists(t4, n2))
            return true;
        }
        return false;
      }, t3.prototype.destroy = function() {
        this.uniformGroup = null;
      }, Object.defineProperty(t3.prototype, "uniforms", { get: function() {
        return this.uniformGroup.uniforms;
      }, enumerable: false, configurable: true }), t3.from = function(e2, i2, n2) {
        return new t3(ze.from(e2, i2), n2);
      }, t3;
    }(), Xe = function() {
      function t3() {
        this.data = 0, this.blendMode = r.b.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
      }
      return Object.defineProperty(t3.prototype, "blend", { get: function() {
        return !!(1 & this.data);
      }, set: function(t4) {
        !!(1 & this.data) !== t4 && (this.data ^= 1);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "offsets", { get: function() {
        return !!(2 & this.data);
      }, set: function(t4) {
        !!(2 & this.data) !== t4 && (this.data ^= 2);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "culling", { get: function() {
        return !!(4 & this.data);
      }, set: function(t4) {
        !!(4 & this.data) !== t4 && (this.data ^= 4);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthTest", { get: function() {
        return !!(8 & this.data);
      }, set: function(t4) {
        !!(8 & this.data) !== t4 && (this.data ^= 8);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthMask", { get: function() {
        return !!(32 & this.data);
      }, set: function(t4) {
        !!(32 & this.data) !== t4 && (this.data ^= 32);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "clockwiseFrontFace", { get: function() {
        return !!(16 & this.data);
      }, set: function(t4) {
        !!(16 & this.data) !== t4 && (this.data ^= 16);
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "blendMode", { get: function() {
        return this._blendMode;
      }, set: function(t4) {
        this.blend = t4 !== r.b.NONE, this._blendMode = t4;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "polygonOffset", { get: function() {
        return this._polygonOffset;
      }, set: function(t4) {
        this.offsets = !!t4, this._polygonOffset = t4;
      }, enumerable: false, configurable: true }), t3.prototype.toString = function() {
        return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]";
      }, t3.for2d = function() {
        var e2 = new t3();
        return e2.depthTest = false, e2.blend = true, e2;
      }, t3;
    }(), We = function(t3) {
      function e2(i2, r2, o2) {
        var s2 = this, a2 = ze.from(i2 || e2.defaultVertexSrc, r2 || e2.defaultFragmentSrc);
        return (s2 = t3.call(this, a2, o2) || this).padding = 0, s2.resolution = n.b.FILTER_RESOLUTION, s2.multisample = n.b.FILTER_MULTISAMPLE, s2.enabled = true, s2.autoFit = true, s2.state = new Xe(), s2;
      }
      return St(e2, t3), e2.prototype.apply = function(t4, e3, i2, n2, r2) {
        t4.applyFilter(this, e3, i2, n2);
      }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
        return this.state.blendMode;
      }, set: function(t4) {
        this.state.blendMode = t4;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
        return this._resolution;
      }, set: function(t4) {
        this._resolution = t4;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultVertexSrc", { get: function() {
        return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
      }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultFragmentSrc", { get: function() {
        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
      }, enumerable: false, configurable: true }), e2;
    }(Ve), Ye = new dt(), qe = function() {
      function t3(t4, e2) {
        this._texture = t4, this.mapCoord = new dt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = e2 === void 0 ? 0.5 : e2, this.isSimple = false;
      }
      return Object.defineProperty(t3.prototype, "texture", { get: function() {
        return this._texture;
      }, set: function(t4) {
        this._texture = t4, this._textureID = -1;
      }, enumerable: false, configurable: true }), t3.prototype.multiplyUvs = function(t4, e2) {
        e2 === void 0 && (e2 = t4);
        for (var i2 = this.mapCoord, n2 = 0; n2 < t4.length; n2 += 2) {
          var r2 = t4[n2], o2 = t4[n2 + 1];
          e2[n2] = r2 * i2.a + o2 * i2.c + i2.tx, e2[n2 + 1] = r2 * i2.b + o2 * i2.d + i2.ty;
        }
        return e2;
      }, t3.prototype.update = function(t4) {
        var e2 = this._texture;
        if (!e2 || !e2.valid)
          return false;
        if (!t4 && this._textureID === e2._updateID)
          return false;
        this._textureID = e2._updateID, this._updateID++;
        var i2 = e2._uvs;
        this.mapCoord.set(i2.x1 - i2.x0, i2.y1 - i2.y0, i2.x3 - i2.x0, i2.y3 - i2.y0, i2.x0, i2.y0);
        var n2 = e2.orig, r2 = e2.trim;
        r2 && (Ye.set(n2.width / r2.width, 0, 0, n2.height / r2.height, -r2.x / r2.width, -r2.y / r2.height), this.mapCoord.append(Ye));
        var o2 = e2.baseTexture, s2 = this.uClampFrame, a2 = this.clampMargin / o2.resolution, l2 = this.clampOffset;
        return s2[0] = (e2._frame.x + a2 + l2) / o2.width, s2[1] = (e2._frame.y + a2 + l2) / o2.height, s2[2] = (e2._frame.x + e2._frame.width - a2 + l2) / o2.width, s2[3] = (e2._frame.y + e2._frame.height - a2 + l2) / o2.height, this.uClampOffset[0] = l2 / o2.realWidth, this.uClampOffset[1] = l2 / o2.realHeight, this.isSimple = e2._frame.width === o2.width && e2._frame.height === o2.height && e2.rotate === 0, true;
      }, t3;
    }(), Ze = function(t3) {
      function e2(e3, i2, n2) {
        var r2 = this, o2 = null;
        return typeof e3 != "string" && i2 === void 0 && n2 === void 0 && (o2 = e3, e3 = void 0, i2 = void 0, n2 = void 0), (r2 = t3.call(this, e3 || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", i2 || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", n2) || this).maskSprite = o2, r2.maskMatrix = new dt(), r2;
      }
      return St(e2, t3), Object.defineProperty(e2.prototype, "maskSprite", { get: function() {
        return this._maskSprite;
      }, set: function(t4) {
        this._maskSprite = t4, this._maskSprite && (this._maskSprite.renderable = false);
      }, enumerable: false, configurable: true }), e2.prototype.apply = function(t4, e3, i2, n2) {
        var r2 = this._maskSprite, o2 = r2._texture;
        o2.valid && (o2.uvMatrix || (o2.uvMatrix = new qe(o2, 0)), o2.uvMatrix.update(), this.uniforms.npmAlpha = o2.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o2, this.uniforms.otherMatrix = t4.calculateSpriteMatrix(this.maskMatrix, r2).prepend(o2.uvMatrix.mapCoord), this.uniforms.alpha = r2.worldAlpha, this.uniforms.maskClamp = o2.uvMatrix.uClampFrame, t4.applyFilter(this, e3, i2, n2));
      }, e2;
    }(We), Je = function() {
      function t3(t4) {
        this.renderer = t4, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
      }
      return t3.prototype.setMaskStack = function(t4) {
        this.maskStack = t4, this.renderer.scissor.setMaskStack(t4), this.renderer.stencil.setMaskStack(t4);
      }, t3.prototype.push = function(t4, e2) {
        var i2 = e2;
        if (!i2.isMaskData) {
          var n2 = this.maskDataPool.pop() || new xe();
          n2.pooled = true, n2.maskObject = e2, i2 = n2;
        }
        var o2 = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (i2.copyCountersOrReset(o2), i2.autoDetect && this.detect(i2), i2._target = t4, i2.type !== r.j.SPRITE && this.maskStack.push(i2), i2.enabled)
          switch (i2.type) {
            case r.j.SCISSOR:
              this.renderer.scissor.push(i2);
              break;
            case r.j.STENCIL:
              this.renderer.stencil.push(i2);
              break;
            case r.j.SPRITE:
              i2.copyCountersOrReset(null), this.pushSpriteMask(i2);
          }
        i2.type === r.j.SPRITE && this.maskStack.push(i2);
      }, t3.prototype.pop = function(t4) {
        var e2 = this.maskStack.pop();
        if (e2 && e2._target === t4) {
          if (e2.enabled)
            switch (e2.type) {
              case r.j.SCISSOR:
                this.renderer.scissor.pop();
                break;
              case r.j.STENCIL:
                this.renderer.stencil.pop(e2.maskObject);
                break;
              case r.j.SPRITE:
                this.popSpriteMask(e2);
            }
          if (e2.reset(), e2.pooled && this.maskDataPool.push(e2), this.maskStack.length !== 0) {
            var i2 = this.maskStack[this.maskStack.length - 1];
            i2.type === r.j.SPRITE && i2._filters && (i2._filters[0].maskSprite = i2.maskObject);
          }
        }
      }, t3.prototype.detect = function(t4) {
        t4.maskObject.isSprite ? t4.type = r.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t4) ? t4.type = r.j.SCISSOR : t4.type = r.j.STENCIL;
      }, t3.prototype.pushSpriteMask = function(t4) {
        var e2, i2, n2 = t4.maskObject, r2 = t4._target, o2 = t4._filters;
        o2 || (o2 = this.alphaMaskPool[this.alphaMaskIndex]) || (o2 = this.alphaMaskPool[this.alphaMaskIndex] = [new Ze()]);
        var s2, a2, l2 = this.renderer, h2 = l2.renderTexture;
        if (h2.current) {
          var u2 = h2.current;
          s2 = t4.resolution || u2.resolution, a2 = (e2 = t4.multisample) !== null && e2 !== void 0 ? e2 : u2.multisample;
        } else
          s2 = t4.resolution || l2.resolution, a2 = (i2 = t4.multisample) !== null && i2 !== void 0 ? i2 : l2.multisample;
        o2[0].resolution = s2, o2[0].multisample = a2, o2[0].maskSprite = n2;
        var c2 = r2.filterArea;
        r2.filterArea = n2.getBounds(true), l2.filter.push(r2, o2), r2.filterArea = c2, t4._filters || this.alphaMaskIndex++;
      }, t3.prototype.popSpriteMask = function(t4) {
        this.renderer.filter.pop(), t4._filters ? t4._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), Ke = function() {
      function t3(t4) {
        this.renderer = t4, this.maskStack = [], this.glConst = 0;
      }
      return t3.prototype.getStackLength = function() {
        return this.maskStack.length;
      }, t3.prototype.setMaskStack = function(t4) {
        var e2 = this.renderer.gl, i2 = this.getStackLength();
        this.maskStack = t4;
        var n2 = this.getStackLength();
        n2 !== i2 && (n2 === 0 ? e2.disable(this.glConst) : (e2.enable(this.glConst), this._useCurrent()));
      }, t3.prototype._useCurrent = function() {
      }, t3.prototype.destroy = function() {
        this.renderer = null, this.maskStack = null;
      }, t3;
    }(), Qe = new dt(), $e = function(t3) {
      function e2(e3) {
        var i2 = t3.call(this, e3) || this;
        return i2.glConst = WebGLRenderingContext.SCISSOR_TEST, i2;
      }
      return St(e2, t3), e2.prototype.getStackLength = function() {
        var t4 = this.maskStack[this.maskStack.length - 1];
        return t4 ? t4._scissorCounter : 0;
      }, e2.prototype.calcScissorRect = function(t4) {
        if (!t4._scissorRectLocal) {
          var e3 = t4._scissorRect, i2 = t4.maskObject, n2 = this.renderer, r2 = n2.renderTexture;
          i2.renderable = true;
          var o2 = i2.getBounds();
          this.roundFrameToPixels(o2, r2.current ? r2.current.resolution : n2.resolution, r2.sourceFrame, r2.destinationFrame, n2.projection.transform), i2.renderable = false, e3 && o2.fit(e3), t4._scissorRectLocal = o2;
        }
      }, e2.isMatrixRotated = function(t4) {
        if (!t4)
          return false;
        var e3 = t4.a, i2 = t4.b, n2 = t4.c, r2 = t4.d;
        return (Math.abs(i2) > 1e-4 || Math.abs(n2) > 1e-4) && (Math.abs(e3) > 1e-4 || Math.abs(r2) > 1e-4);
      }, e2.prototype.testScissor = function(t4) {
        var i2 = t4.maskObject;
        if (!i2.isFastRect || !i2.isFastRect())
          return false;
        if (e2.isMatrixRotated(i2.worldTransform))
          return false;
        if (e2.isMatrixRotated(this.renderer.projection.transform))
          return false;
        this.calcScissorRect(t4);
        var n2 = t4._scissorRectLocal;
        return n2.width > 0 && n2.height > 0;
      }, e2.prototype.roundFrameToPixels = function(t4, i2, n2, r2, o2) {
        e2.isMatrixRotated(o2) || ((o2 = o2 ? Qe.copyFrom(o2) : Qe.identity()).translate(-n2.x, -n2.y).scale(r2.width / n2.width, r2.height / n2.height).translate(r2.x, r2.y), this.renderer.filter.transformAABB(o2, t4), t4.fit(r2), t4.x = Math.round(t4.x * i2), t4.y = Math.round(t4.y * i2), t4.width = Math.round(t4.width * i2), t4.height = Math.round(t4.height * i2));
      }, e2.prototype.push = function(t4) {
        t4._scissorRectLocal || this.calcScissorRect(t4);
        var e3 = this.renderer.gl;
        t4._scissorRect || e3.enable(e3.SCISSOR_TEST), t4._scissorCounter++, t4._scissorRect = t4._scissorRectLocal, this._useCurrent();
      }, e2.prototype.pop = function() {
        var t4 = this.renderer.gl;
        this.getStackLength() > 0 ? this._useCurrent() : t4.disable(t4.SCISSOR_TEST);
      }, e2.prototype._useCurrent = function() {
        var t4, e3 = this.maskStack[this.maskStack.length - 1]._scissorRect;
        t4 = this.renderer.renderTexture.current ? e3.y : this.renderer.height - e3.height - e3.y, this.renderer.gl.scissor(e3.x, t4, e3.width, e3.height);
      }, e2;
    }(Ke), ti = function(t3) {
      function e2(e3) {
        var i2 = t3.call(this, e3) || this;
        return i2.glConst = WebGLRenderingContext.STENCIL_TEST, i2;
      }
      return St(e2, t3), e2.prototype.getStackLength = function() {
        var t4 = this.maskStack[this.maskStack.length - 1];
        return t4 ? t4._stencilCounter : 0;
      }, e2.prototype.push = function(t4) {
        var e3 = t4.maskObject, i2 = this.renderer.gl, n2 = t4._stencilCounter;
        n2 === 0 && (this.renderer.framebuffer.forceStencil(), i2.clearStencil(0), i2.clear(i2.STENCIL_BUFFER_BIT), i2.enable(i2.STENCIL_TEST)), t4._stencilCounter++, i2.colorMask(false, false, false, false), i2.stencilFunc(i2.EQUAL, n2, 4294967295), i2.stencilOp(i2.KEEP, i2.KEEP, i2.INCR), e3.renderable = true, e3.render(this.renderer), this.renderer.batch.flush(), e3.renderable = false, this._useCurrent();
      }, e2.prototype.pop = function(t4) {
        var e3 = this.renderer.gl;
        this.getStackLength() === 0 ? e3.disable(e3.STENCIL_TEST) : (e3.colorMask(false, false, false, false), e3.stencilOp(e3.KEEP, e3.KEEP, e3.DECR), t4.renderable = true, t4.render(this.renderer), this.renderer.batch.flush(), t4.renderable = false, this._useCurrent());
      }, e2.prototype._useCurrent = function() {
        var t4 = this.renderer.gl;
        t4.colorMask(true, true, true, true), t4.stencilFunc(t4.EQUAL, this.getStackLength(), 4294967295), t4.stencilOp(t4.KEEP, t4.KEEP, t4.KEEP);
      }, e2;
    }(Ke), ei = function() {
      function t3(t4) {
        this.renderer = t4, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new dt(), this.transform = null;
      }
      return t3.prototype.update = function(t4, e2, i2, n2) {
        this.destinationFrame = t4 || this.destinationFrame || this.defaultFrame, this.sourceFrame = e2 || this.sourceFrame || t4, this.calculateProjection(this.destinationFrame, this.sourceFrame, i2, n2), this.transform && this.projectionMatrix.append(this.transform);
        var r2 = this.renderer;
        r2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r2.globalUniforms.update(), r2.shader.shader && r2.shader.syncUniformGroup(r2.shader.shader.uniforms.globals);
      }, t3.prototype.calculateProjection = function(t4, e2, i2, n2) {
        var r2 = this.projectionMatrix, o2 = n2 ? -1 : 1;
        r2.identity(), r2.a = 1 / e2.width * 2, r2.d = o2 * (1 / e2.height * 2), r2.tx = -1 - e2.x * r2.a, r2.ty = -o2 - e2.y * r2.d;
      }, t3.prototype.setTransform = function(t4) {
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), ii = new ut(), ni = new ut(), ri = function() {
      function t3(t4) {
        this.renderer = t4, this.clearColor = t4._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.viewportFrame = new ut();
      }
      return t3.prototype.bind = function(t4, e2, i2) {
        t4 === void 0 && (t4 = null);
        var n2, r2, o2, s2 = this.renderer;
        this.current = t4, t4 ? (o2 = (n2 = t4.baseTexture).resolution, e2 || (ii.width = t4.frame.width, ii.height = t4.frame.height, e2 = ii), i2 || (ni.x = t4.frame.x, ni.y = t4.frame.y, ni.width = e2.width, ni.height = e2.height, i2 = ni), r2 = n2.framebuffer) : (o2 = s2.resolution, e2 || (ii.width = s2.screen.width, ii.height = s2.screen.height, e2 = ii), i2 || ((i2 = ii).width = e2.width, i2.height = e2.height));
        var a2 = this.viewportFrame;
        a2.x = i2.x * o2, a2.y = i2.y * o2, a2.width = i2.width * o2, a2.height = i2.height * o2, t4 || (a2.y = s2.view.height - (a2.y + a2.height)), a2.ceil(), this.renderer.framebuffer.bind(r2, a2), this.renderer.projection.update(i2, e2, o2, !r2), t4 ? this.renderer.mask.setMaskStack(n2.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e2), this.destinationFrame.copyFrom(i2);
      }, t3.prototype.clear = function(t4, e2) {
        t4 = this.current ? t4 || this.current.baseTexture.clearColor : t4 || this.clearColor;
        var i2 = this.destinationFrame, n2 = this.current ? this.current.baseTexture : this.renderer.screen, r2 = i2.width !== n2.width || i2.height !== n2.height;
        if (r2) {
          var o2 = this.viewportFrame, s2 = o2.x, a2 = o2.y, l2 = o2.width, h2 = o2.height;
          s2 = Math.round(s2), a2 = Math.round(a2), l2 = Math.round(l2), h2 = Math.round(h2), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s2, a2, l2, h2);
        }
        this.renderer.framebuffer.clear(t4[0], t4[1], t4[2], t4[3], e2), r2 && this.renderer.scissor.pop();
      }, t3.prototype.resize = function() {
        this.bind(null);
      }, t3.prototype.reset = function() {
        this.bind(null);
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }();
    function oi(t3, e2, i2, n2, r2) {
      i2.buffer.update(r2);
    }
    var si = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, ai = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
    function li(t3, e2) {
      if (!t3.autoManage)
        return { size: 0, syncFunc: oi };
      for (var i2 = function(t4) {
        for (var e3 = t4.map(function(t5) {
          return { data: t5, offset: 0, dataLen: 0, dirty: 0 };
        }), i3 = 0, n3 = 0, r3 = 0, o3 = 0; o3 < e3.length; o3++) {
          var s3 = e3[o3];
          if (i3 = ai[s3.data.type], s3.data.size > 1 && (i3 = Math.max(i3, 16) * s3.data.size), s3.dataLen = i3, n3 % i3 != 0 && n3 < 16) {
            var a3 = n3 % i3 % 16;
            n3 += a3, r3 += a3;
          }
          n3 + i3 > 16 ? (r3 = 16 * Math.ceil(r3 / 16), s3.offset = r3, r3 += i3, n3 = i3) : (s3.offset = r3, n3 += i3, r3 += i3);
        }
        return { uboElements: e3, size: r3 = 16 * Math.ceil(r3 / 16) };
      }(function(t4, e3) {
        var i3 = [];
        for (var n3 in t4)
          e3[n3] && i3.push(e3[n3]);
        return i3.sort(function(t5, e4) {
          return t5.index - e4.index;
        }), i3;
      }(t3.uniforms, e2)), n2 = i2.uboElements, r2 = i2.size, o2 = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s2 = 0; s2 < n2.length; s2++) {
        for (var a2 = n2[s2], l2 = t3.uniforms[a2.data.name], h2 = a2.data.name, u2 = false, c2 = 0; c2 < De.length; c2++) {
          var d2 = De[c2];
          if (d2.codeUbo && d2.test(a2.data, l2)) {
            o2.push("offset = " + a2.offset / 4 + ";", De[c2].codeUbo(a2.data.name, l2)), u2 = true;
            break;
          }
        }
        if (!u2)
          if (a2.data.size > 1) {
            var p2 = Pe(a2.data.type), f2 = Math.max(ai[a2.data.type] / 16, 1), m2 = p2 / f2, g2 = (4 - m2 % 4) % 4;
            o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a2.data.size * f2 + "; i++)\n                {\n                    for(var j = 0; j < " + m2 + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g2 + ";\n                }\n\n                ");
          } else {
            var v2 = si[a2.data.type];
            o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n                " + v2 + ";\n                ");
          }
      }
      return o2.push("\n       renderer.buffer.update(buffer);\n    "), { size: r2, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o2.join("\n")) };
    }
    var hi = function() {
      function t3(t4, e2) {
        this.program = t4, this.uniformData = e2, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
      }
      return t3.prototype.destroy = function() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
      }, t3;
    }();
    function ui(t3, e2) {
      var i2 = be(t3, t3.VERTEX_SHADER, e2.vertexSrc), n2 = be(t3, t3.FRAGMENT_SHADER, e2.fragmentSrc), r2 = t3.createProgram();
      if (t3.attachShader(r2, i2), t3.attachShader(r2, n2), t3.linkProgram(r2), t3.getProgramParameter(r2, t3.LINK_STATUS) || function(t4, e3, i3, n3) {
        t4.getProgramParameter(e3, t4.LINK_STATUS) || (t4.getShaderParameter(i3, t4.COMPILE_STATUS) || Te(t4, i3), t4.getShaderParameter(n3, t4.COMPILE_STATUS) || Te(t4, n3), console.error("PixiJS Error: Could not initialize shader."), t4.getProgramInfoLog(e3) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t4.getProgramInfoLog(e3)));
      }(t3, r2, i2, n2), e2.attributeData = function(t4, e3) {
        for (var i3 = {}, n3 = e3.getProgramParameter(t4, e3.ACTIVE_ATTRIBUTES), r3 = 0; r3 < n3; r3++) {
          var o3 = e3.getActiveAttrib(t4, r3);
          if (o3.name.indexOf("gl_") !== 0) {
            var s3 = Le(e3, o3.type), a3 = { type: s3, name: o3.name, size: Pe(s3), location: e3.getAttribLocation(t4, o3.name) };
            i3[o3.name] = a3;
          }
        }
        return i3;
      }(r2, t3), e2.uniformData = function(t4, e3) {
        for (var i3 = {}, n3 = e3.getProgramParameter(t4, e3.ACTIVE_UNIFORMS), r3 = 0; r3 < n3; r3++) {
          var o3 = e3.getActiveUniform(t4, r3), s3 = o3.name.replace(/\[.*?\]$/, ""), a3 = !!o3.name.match(/\[.*?\]$/), l3 = Le(e3, o3.type);
          i3[s3] = { name: s3, index: r3, type: l3, size: o3.size, isArray: a3, value: Se(l3, o3.size) };
        }
        return i3;
      }(r2, t3), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e2.vertexSrc)) {
        var o2 = Object.keys(e2.attributeData);
        o2.sort(function(t4, e3) {
          return t4 > e3 ? 1 : -1;
        });
        for (var s2 = 0; s2 < o2.length; s2++)
          e2.attributeData[o2[s2]].location = s2, t3.bindAttribLocation(r2, s2, o2[s2]);
        t3.linkProgram(r2);
      }
      t3.deleteShader(i2), t3.deleteShader(n2);
      var a2 = {};
      for (var s2 in e2.uniformData) {
        var l2 = e2.uniformData[s2];
        a2[s2] = { location: t3.getUniformLocation(r2, s2), value: Se(l2.type, l2.size) };
      }
      return new hi(r2, a2);
    }
    var ci = 0, di = { textureCount: 0, uboCount: 0 }, pi = function() {
      function t3(t4) {
        this.destroyed = false, this.renderer = t4, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ci++;
      }
      return t3.prototype.systemCheck = function() {
        if (!function() {
          if (typeof Ue == "boolean")
            return Ue;
          try {
            var t4 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
            Ue = t4({ a: "b" }, "a", "b") === true;
          } catch (t5) {
            Ue = false;
          }
          return Ue;
        }())
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }, t3.prototype.contextChange = function(t4) {
        this.gl = t4, this.reset();
      }, t3.prototype.bind = function(t4, e2) {
        t4.uniforms.globals = this.renderer.globalUniforms;
        var i2 = t4.program, n2 = i2.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t4);
        return this.shader = t4, this.program !== i2 && (this.program = i2, this.gl.useProgram(n2.program)), e2 || (di.textureCount = 0, di.uboCount = 0, this.syncUniformGroup(t4.uniformGroup, di)), n2;
      }, t3.prototype.setUniforms = function(t4) {
        var e2 = this.shader.program, i2 = e2.glPrograms[this.renderer.CONTEXT_UID];
        e2.syncUniforms(i2.uniformData, t4, this.renderer);
      }, t3.prototype.syncUniformGroup = function(t4, e2) {
        var i2 = this.getGlProgram();
        t4.static && t4.dirtyId === i2.uniformDirtyGroups[t4.id] || (i2.uniformDirtyGroups[t4.id] = t4.dirtyId, this.syncUniforms(t4, i2, e2));
      }, t3.prototype.syncUniforms = function(t4, e2, i2) {
        (t4.syncUniforms[this.shader.program.id] || this.createSyncGroups(t4))(e2.uniformData, t4.uniforms, this.renderer, i2);
      }, t3.prototype.createSyncGroups = function(t4) {
        var e2 = this.getSignature(t4, this.shader.program.uniformData, "u");
        return this.cache[e2] || (this.cache[e2] = function(t5, e3) {
          var i2, n2 = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
          for (var r2 in t5.uniforms) {
            var o2 = e3[r2];
            if (o2) {
              for (var s2 = t5.uniforms[r2], a2 = false, l2 = 0; l2 < De.length; l2++)
                if (De[l2].test(o2, s2)) {
                  n2.push(De[l2].code(r2, s2)), a2 = true;
                  break;
                }
              if (!a2) {
                var h2 = (o2.size === 1 ? Fe : Be)[o2.type].replace("location", 'ud["' + r2 + '"].location');
                n2.push('\n            cu = ud["' + r2 + '"];\n            cv = cu.value;\n            v = uv["' + r2 + '"];\n            ' + h2 + ";");
              }
            } else
              ((i2 = t5.uniforms[r2]) === null || i2 === void 0 ? void 0 : i2.group) && (t5.uniforms[r2].ubo ? n2.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + r2 + ", '" + r2 + "');\n                    ") : n2.push("\n                        renderer.shader.syncUniformGroup(uv." + r2 + ", syncData);\n                    "));
          }
          return new Function("ud", "uv", "renderer", "syncData", n2.join("\n"));
        }(t4, this.shader.program.uniformData)), t4.syncUniforms[this.shader.program.id] = this.cache[e2], t4.syncUniforms[this.shader.program.id];
      }, t3.prototype.syncUniformBufferGroup = function(t4, e2) {
        var i2 = this.getGlProgram();
        if (!t4.static || t4.dirtyId !== 0 || !i2.uniformGroups[t4.id]) {
          t4.dirtyId = 0;
          var n2 = i2.uniformGroups[t4.id] || this.createSyncBufferGroup(t4, i2, e2);
          t4.buffer.update(), n2(i2.uniformData, t4.uniforms, this.renderer, di, t4.buffer);
        }
        this.renderer.buffer.bindBufferBase(t4.buffer, i2.uniformBufferBindings[e2]);
      }, t3.prototype.createSyncBufferGroup = function(t4, e2, i2) {
        var n2 = this.renderer.gl;
        this.renderer.buffer.bind(t4.buffer);
        var r2 = this.gl.getUniformBlockIndex(e2.program, i2);
        e2.uniformBufferBindings[i2] = this.shader.uniformBindCount, n2.uniformBlockBinding(e2.program, r2, this.shader.uniformBindCount), this.shader.uniformBindCount++;
        var o2 = this.getSignature(t4, this.shader.program.uniformData, "ubo"), s2 = this._uboCache[o2];
        if (s2 || (s2 = this._uboCache[o2] = li(t4, this.shader.program.uniformData)), t4.autoManage) {
          var a2 = new Float32Array(s2.size / 4);
          t4.buffer.update(a2);
        }
        return e2.uniformGroups[t4.id] = s2.syncFunc, e2.uniformGroups[t4.id];
      }, t3.prototype.getSignature = function(t4, e2, i2) {
        var n2 = t4.uniforms, r2 = [i2 + "-"];
        for (var o2 in n2)
          r2.push(o2), e2[o2] && r2.push(e2[o2].type);
        return r2.join("-");
      }, t3.prototype.getGlProgram = function() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
      }, t3.prototype.generateProgram = function(t4) {
        var e2 = this.gl, i2 = t4.program, n2 = ui(e2, i2);
        return i2.glPrograms[this.renderer.CONTEXT_UID] = n2, n2;
      }, t3.prototype.reset = function() {
        this.program = null, this.shader = null;
      }, t3.prototype.destroy = function() {
        this.renderer = null, this.destroyed = true;
      }, t3;
    }();
    var fi = function() {
      function t3() {
        this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = r.b.NONE, this._blendEq = false, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Xe(), this.defaultState.blend = true;
      }
      return t3.prototype.contextChange = function(t4) {
        this.gl = t4, this.blendModes = function(t5, e2) {
          return e2 === void 0 && (e2 = []), e2[r.b.NORMAL] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD] = [t5.ONE, t5.ONE], e2[r.b.MULTIPLY] = [t5.DST_COLOR, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SCREEN] = [t5.ONE, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.OVERLAY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DARKEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.LIGHTEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_DODGE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_BURN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.HARD_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SOFT_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DIFFERENCE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.EXCLUSION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.HUE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SATURATION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.LUMINOSITY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.NONE] = [0, 0], e2[r.b.NORMAL_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD_NPM] = [t5.SRC_ALPHA, t5.ONE, t5.ONE, t5.ONE], e2[r.b.SCREEN_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SRC_IN] = [t5.DST_ALPHA, t5.ZERO], e2[r.b.SRC_OUT] = [t5.ONE_MINUS_DST_ALPHA, t5.ZERO], e2[r.b.SRC_ATOP] = [t5.DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_OVER] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE], e2[r.b.DST_IN] = [t5.ZERO, t5.SRC_ALPHA], e2[r.b.DST_OUT] = [t5.ZERO, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_ATOP] = [t5.ONE_MINUS_DST_ALPHA, t5.SRC_ALPHA], e2[r.b.XOR] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SUBTRACT] = [t5.ONE, t5.ONE, t5.ONE, t5.ONE, t5.FUNC_REVERSE_SUBTRACT, t5.FUNC_ADD], e2;
        }(t4), this.set(this.defaultState), this.reset();
      }, t3.prototype.set = function(t4) {
        if (t4 = t4 || this.defaultState, this.stateId !== t4.data) {
          for (var e2 = this.stateId ^ t4.data, i2 = 0; e2; )
            1 & e2 && this.map[i2].call(this, !!(t4.data & 1 << i2)), e2 >>= 1, i2++;
          this.stateId = t4.data;
        }
        for (i2 = 0; i2 < this.checks.length; i2++)
          this.checks[i2](this, t4);
      }, t3.prototype.forceState = function(t4) {
        t4 = t4 || this.defaultState;
        for (var e2 = 0; e2 < this.map.length; e2++)
          this.map[e2].call(this, !!(t4.data & 1 << e2));
        for (e2 = 0; e2 < this.checks.length; e2++)
          this.checks[e2](this, t4);
        this.stateId = t4.data;
      }, t3.prototype.setBlend = function(e2) {
        this.updateCheck(t3.checkBlendMode, e2), this.gl[e2 ? "enable" : "disable"](this.gl.BLEND);
      }, t3.prototype.setOffset = function(e2) {
        this.updateCheck(t3.checkPolygonOffset, e2), this.gl[e2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }, t3.prototype.setDepthTest = function(t4) {
        this.gl[t4 ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }, t3.prototype.setDepthMask = function(t4) {
        this.gl.depthMask(t4);
      }, t3.prototype.setCullFace = function(t4) {
        this.gl[t4 ? "enable" : "disable"](this.gl.CULL_FACE);
      }, t3.prototype.setFrontFace = function(t4) {
        this.gl.frontFace(this.gl[t4 ? "CW" : "CCW"]);
      }, t3.prototype.setBlendMode = function(t4) {
        if (t4 !== this.blendMode) {
          this.blendMode = t4;
          var e2 = this.blendModes[t4], i2 = this.gl;
          e2.length === 2 ? i2.blendFunc(e2[0], e2[1]) : i2.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), e2.length === 6 ? (this._blendEq = true, i2.blendEquationSeparate(e2[4], e2[5])) : this._blendEq && (this._blendEq = false, i2.blendEquationSeparate(i2.FUNC_ADD, i2.FUNC_ADD));
        }
      }, t3.prototype.setPolygonOffset = function(t4, e2) {
        this.gl.polygonOffset(t4, e2);
      }, t3.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
      }, t3.prototype.updateCheck = function(t4, e2) {
        var i2 = this.checks.indexOf(t4);
        e2 && i2 === -1 ? this.checks.push(t4) : e2 || i2 === -1 || this.checks.splice(i2, 1);
      }, t3.checkBlendMode = function(t4, e2) {
        t4.setBlendMode(e2.blendMode);
      }, t3.checkPolygonOffset = function(t4, e2) {
        t4.setPolygonOffset(1, e2.polygonOffset);
      }, t3.prototype.destroy = function() {
        this.gl = null;
      }, t3;
    }(), mi = function() {
      function t3(t4) {
        this.renderer = t4, this.count = 0, this.checkCount = 0, this.maxIdle = n.b.GC_MAX_IDLE, this.checkCountMax = n.b.GC_MAX_CHECK_COUNT, this.mode = n.b.GC_MODE;
      }
      return t3.prototype.postrender = function() {
        this.renderer.renderingToScreen && (this.count++, this.mode !== r.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
      }, t3.prototype.run = function() {
        for (var t4 = this.renderer.texture, e2 = t4.managedTextures, i2 = false, n2 = 0; n2 < e2.length; n2++) {
          var r2 = e2[n2];
          !r2.framebuffer && this.count - r2.touched > this.maxIdle && (t4.destroyTexture(r2, true), e2[n2] = null, i2 = true);
        }
        if (i2) {
          var o2 = 0;
          for (n2 = 0; n2 < e2.length; n2++)
            e2[n2] !== null && (e2[o2++] = e2[n2]);
          e2.length = o2;
        }
      }, t3.prototype.unload = function(t4) {
        var e2 = this.renderer.texture, i2 = t4._texture;
        i2 && !i2.framebuffer && e2.destroyTexture(i2);
        for (var n2 = t4.children.length - 1; n2 >= 0; n2--)
          this.unload(t4.children[n2]);
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }();
    var gi = function(t3) {
      this.texture = t3, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = r.r.UNSIGNED_BYTE, this.internalFormat = r.h.RGBA, this.samplerType = 0;
    }, vi = function() {
      function t3(t4) {
        this.renderer = t4, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new Ct(), this.hasIntegerTextures = false;
      }
      return t3.prototype.contextChange = function() {
        var t4 = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t5) {
          var e3, i3, n3, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
          return "WebGL2RenderingContext" in globalThis && t5 instanceof globalThis.WebGL2RenderingContext ? ((e3 = {})[r.r.UNSIGNED_BYTE] = ((i3 = {})[r.h.RGBA] = t5.RGBA8, i3[r.h.RGB] = t5.RGB8, i3[r.h.RG] = t5.RG8, i3[r.h.RED] = t5.R8, i3[r.h.RGBA_INTEGER] = t5.RGBA8UI, i3[r.h.RGB_INTEGER] = t5.RGB8UI, i3[r.h.RG_INTEGER] = t5.RG8UI, i3[r.h.RED_INTEGER] = t5.R8UI, i3[r.h.ALPHA] = t5.ALPHA, i3[r.h.LUMINANCE] = t5.LUMINANCE, i3[r.h.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, i3), e3[r.r.BYTE] = ((n3 = {})[r.h.RGBA] = t5.RGBA8_SNORM, n3[r.h.RGB] = t5.RGB8_SNORM, n3[r.h.RG] = t5.RG8_SNORM, n3[r.h.RED] = t5.R8_SNORM, n3[r.h.RGBA_INTEGER] = t5.RGBA8I, n3[r.h.RGB_INTEGER] = t5.RGB8I, n3[r.h.RG_INTEGER] = t5.RG8I, n3[r.h.RED_INTEGER] = t5.R8I, n3), e3[r.r.UNSIGNED_SHORT] = ((o2 = {})[r.h.RGBA_INTEGER] = t5.RGBA16UI, o2[r.h.RGB_INTEGER] = t5.RGB16UI, o2[r.h.RG_INTEGER] = t5.RG16UI, o2[r.h.RED_INTEGER] = t5.R16UI, o2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT16, o2), e3[r.r.SHORT] = ((s2 = {})[r.h.RGBA_INTEGER] = t5.RGBA16I, s2[r.h.RGB_INTEGER] = t5.RGB16I, s2[r.h.RG_INTEGER] = t5.RG16I, s2[r.h.RED_INTEGER] = t5.R16I, s2), e3[r.r.UNSIGNED_INT] = ((a2 = {})[r.h.RGBA_INTEGER] = t5.RGBA32UI, a2[r.h.RGB_INTEGER] = t5.RGB32UI, a2[r.h.RG_INTEGER] = t5.RG32UI, a2[r.h.RED_INTEGER] = t5.R32UI, a2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT24, a2), e3[r.r.INT] = ((l2 = {})[r.h.RGBA_INTEGER] = t5.RGBA32I, l2[r.h.RGB_INTEGER] = t5.RGB32I, l2[r.h.RG_INTEGER] = t5.RG32I, l2[r.h.RED_INTEGER] = t5.R32I, l2), e3[r.r.FLOAT] = ((h2 = {})[r.h.RGBA] = t5.RGBA32F, h2[r.h.RGB] = t5.RGB32F, h2[r.h.RG] = t5.RG32F, h2[r.h.RED] = t5.R32F, h2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT32F, h2), e3[r.r.HALF_FLOAT] = ((u2 = {})[r.h.RGBA] = t5.RGBA16F, u2[r.h.RGB] = t5.RGB16F, u2[r.h.RG] = t5.RG16F, u2[r.h.RED] = t5.R16F, u2), e3[r.r.UNSIGNED_SHORT_5_6_5] = ((c2 = {})[r.h.RGB] = t5.RGB565, c2), e3[r.r.UNSIGNED_SHORT_4_4_4_4] = ((d2 = {})[r.h.RGBA] = t5.RGBA4, d2), e3[r.r.UNSIGNED_SHORT_5_5_5_1] = ((p2 = {})[r.h.RGBA] = t5.RGB5_A1, p2), e3[r.r.UNSIGNED_INT_2_10_10_10_REV] = ((f2 = {})[r.h.RGBA] = t5.RGB10_A2, f2[r.h.RGBA_INTEGER] = t5.RGB10_A2UI, f2), e3[r.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m2 = {})[r.h.RGB] = t5.R11F_G11F_B10F, m2), e3[r.r.UNSIGNED_INT_5_9_9_9_REV] = ((g2 = {})[r.h.RGB] = t5.RGB9_E5, g2), e3[r.r.UNSIGNED_INT_24_8] = ((v2 = {})[r.h.DEPTH_STENCIL] = t5.DEPTH24_STENCIL8, v2), e3[r.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_2 = {})[r.h.DEPTH_STENCIL] = t5.DEPTH32F_STENCIL8, _2), S2 = e3) : ((y2 = {})[r.r.UNSIGNED_BYTE] = ((x2 = {})[r.h.RGBA] = t5.RGBA, x2[r.h.RGB] = t5.RGB, x2[r.h.ALPHA] = t5.ALPHA, x2[r.h.LUMINANCE] = t5.LUMINANCE, x2[r.h.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, x2), y2[r.r.UNSIGNED_SHORT_5_6_5] = ((b2 = {})[r.h.RGB] = t5.RGB, b2), y2[r.r.UNSIGNED_SHORT_4_4_4_4] = ((T2 = {})[r.h.RGBA] = t5.RGBA, T2), y2[r.r.UNSIGNED_SHORT_5_5_5_1] = ((E2 = {})[r.h.RGBA] = t5.RGBA, E2), S2 = y2), S2;
        }(t4);
        var e2 = t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = e2;
        for (var i2 = 0; i2 < e2; i2++)
          this.boundTextures[i2] = null;
        this.emptyTextures = {};
        var n2 = new gi(t4.createTexture());
        t4.bindTexture(t4.TEXTURE_2D, n2.texture), t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t4.TEXTURE_2D] = n2, this.emptyTextures[t4.TEXTURE_CUBE_MAP] = new gi(t4.createTexture()), t4.bindTexture(t4.TEXTURE_CUBE_MAP, this.emptyTextures[t4.TEXTURE_CUBE_MAP].texture);
        for (i2 = 0; i2 < 6; i2++)
          t4.texImage2D(t4.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, null);
        t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MAG_FILTER, t4.LINEAR), t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MIN_FILTER, t4.LINEAR);
        for (i2 = 0; i2 < this.boundTextures.length; i2++)
          this.bind(null, i2);
      }, t3.prototype.bind = function(t4, e2) {
        e2 === void 0 && (e2 = 0);
        var i2 = this.gl;
        if ((t4 = t4 == null ? void 0 : t4.castToBaseTexture()) && t4.valid && !t4.parentTextureArray) {
          t4.touched = this.renderer.textureGC.count;
          var n2 = t4._glTextures[this.CONTEXT_UID] || this.initTexture(t4);
          this.boundTextures[e2] !== t4 && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(t4.target, n2.texture)), n2.dirtyId !== t4.dirtyId && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), this.updateTexture(t4)), this.boundTextures[e2] = t4;
        } else
          this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(i2.TEXTURE_2D, this.emptyTextures[i2.TEXTURE_2D].texture), this.boundTextures[e2] = null;
      }, t3.prototype.reset = function() {
        this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
        for (var t4 = 0; t4 < this.boundTextures.length; t4++)
          this.boundTextures[t4] = this.unknownTexture;
      }, t3.prototype.unbind = function(t4) {
        var e2 = this.gl, i2 = this.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var n2 = 0; n2 < i2.length; n2++)
            i2[n2] === this.unknownTexture && this.bind(null, n2);
        }
        for (n2 = 0; n2 < i2.length; n2++)
          i2[n2] === t4 && (this.currentLocation !== n2 && (e2.activeTexture(e2.TEXTURE0 + n2), this.currentLocation = n2), e2.bindTexture(t4.target, this.emptyTextures[t4.target].texture), i2[n2] = null);
      }, t3.prototype.ensureSamplerType = function(t4) {
        var e2 = this.boundTextures, i2 = this.hasIntegerTextures, n2 = this.CONTEXT_UID;
        if (i2)
          for (var o2 = t4 - 1; o2 >= 0; --o2) {
            var s2 = e2[o2];
            if (s2)
              s2._glTextures[n2].samplerType !== r.o.FLOAT && this.renderer.texture.unbind(s2);
          }
      }, t3.prototype.initTexture = function(t4) {
        var e2 = new gi(this.gl.createTexture());
        return e2.dirtyId = -1, t4._glTextures[this.CONTEXT_UID] = e2, this.managedTextures.push(t4), t4.on("dispose", this.destroyTexture, this), e2;
      }, t3.prototype.initTextureType = function(t4, e2) {
        var i2, n2;
        e2.internalFormat = (n2 = (i2 = this.internalFormats[t4.type]) === null || i2 === void 0 ? void 0 : i2[t4.format]) !== null && n2 !== void 0 ? n2 : t4.format, this.webGLVersion === 2 && t4.type === r.r.HALF_FLOAT ? e2.type = this.gl.HALF_FLOAT : e2.type = t4.type;
      }, t3.prototype.updateTexture = function(t4) {
        var e2 = t4._glTextures[this.CONTEXT_UID];
        if (e2) {
          var i2 = this.renderer;
          if (this.initTextureType(t4, e2), t4.resource && t4.resource.upload(i2, t4, e2))
            e2.samplerType !== r.o.FLOAT && (this.hasIntegerTextures = true);
          else {
            var n2 = t4.realWidth, o2 = t4.realHeight, s2 = i2.gl;
            (e2.width !== n2 || e2.height !== o2 || e2.dirtyId < 0) && (e2.width = n2, e2.height = o2, s2.texImage2D(t4.target, 0, e2.internalFormat, n2, o2, 0, t4.format, e2.type, null));
          }
          t4.dirtyStyleId !== e2.dirtyStyleId && this.updateTextureStyle(t4), e2.dirtyId = t4.dirtyId;
        }
      }, t3.prototype.destroyTexture = function(t4, e2) {
        var i2 = this.gl;
        if ((t4 = t4.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t4), i2.deleteTexture(t4._glTextures[this.CONTEXT_UID].texture), t4.off("dispose", this.destroyTexture, this), delete t4._glTextures[this.CONTEXT_UID], !e2)) {
          var n2 = this.managedTextures.indexOf(t4);
          n2 !== -1 && function(t5, e3, i3) {
            var n3, r2 = t5.length;
            if (!(e3 >= r2 || i3 === 0)) {
              var o2 = r2 - (i3 = e3 + i3 > r2 ? r2 - e3 : i3);
              for (n3 = e3; n3 < o2; ++n3)
                t5[n3] = t5[n3 + i3];
              t5.length = o2;
            }
          }(this.managedTextures, n2, 1);
        }
      }, t3.prototype.updateTextureStyle = function(t4) {
        var e2 = t4._glTextures[this.CONTEXT_UID];
        e2 && (t4.mipmap !== r.k.POW2 && this.webGLVersion === 2 || t4.isPowerOfTwo ? e2.mipmap = t4.mipmap >= 1 : e2.mipmap = false, this.webGLVersion === 2 || t4.isPowerOfTwo ? e2.wrapMode = t4.wrapMode : e2.wrapMode = r.s.CLAMP, t4.resource && t4.resource.style(this.renderer, t4, e2) || this.setStyle(t4, e2), e2.dirtyStyleId = t4.dirtyStyleId);
      }, t3.prototype.setStyle = function(t4, e2) {
        var i2 = this.gl;
        if (e2.mipmap && t4.mipmap !== r.k.ON_MANUAL && i2.generateMipmap(t4.target), i2.texParameteri(t4.target, i2.TEXTURE_WRAP_S, e2.wrapMode), i2.texParameteri(t4.target, i2.TEXTURE_WRAP_T, e2.wrapMode), e2.mipmap) {
          i2.texParameteri(t4.target, i2.TEXTURE_MIN_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR_MIPMAP_LINEAR : i2.NEAREST_MIPMAP_NEAREST);
          var n2 = this.renderer.context.extensions.anisotropicFiltering;
          if (n2 && t4.anisotropicLevel > 0 && t4.scaleMode === r.p.LINEAR) {
            var o2 = Math.min(t4.anisotropicLevel, i2.getParameter(n2.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            i2.texParameterf(t4.target, n2.TEXTURE_MAX_ANISOTROPY_EXT, o2);
          }
        } else
          i2.texParameteri(t4.target, i2.TEXTURE_MIN_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
        i2.texParameteri(t4.target, i2.TEXTURE_MAG_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }(), yi = new dt(), xi = function(t3) {
      function e2(e3, i2) {
        e3 === void 0 && (e3 = r.n.UNKNOWN);
        var o2 = t3.call(this) || this;
        return i2 = Object.assign({}, n.b.RENDER_OPTIONS, i2), o2.options = i2, o2.type = e3, o2.screen = new ut(0, 0, i2.width, i2.height), o2.view = i2.view || document.createElement("canvas"), o2.resolution = i2.resolution || n.b.RESOLUTION, o2.useContextAlpha = i2.useContextAlpha, o2.autoDensity = !!i2.autoDensity, o2.preserveDrawingBuffer = i2.preserveDrawingBuffer, o2.clearBeforeRender = i2.clearBeforeRender, o2._backgroundColor = 0, o2._backgroundColorRgba = [0, 0, 0, 1], o2._backgroundColorString = "#000000", o2.backgroundColor = i2.backgroundColor || o2._backgroundColor, o2.backgroundAlpha = i2.backgroundAlpha, i2.transparent !== void 0 && (Z("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), o2.useContextAlpha = i2.transparent, o2.backgroundAlpha = i2.transparent ? 0 : 1), o2._lastObjectRendered = null, o2.plugins = {}, o2;
      }
      return St(e2, t3), e2.prototype.initPlugins = function(t4) {
        for (var e3 in t4)
          this.plugins[e3] = new t4[e3](this);
      }, Object.defineProperty(e2.prototype, "width", { get: function() {
        return this.view.width;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
        return this.view.height;
      }, enumerable: false, configurable: true }), e2.prototype.resize = function(t4, e3) {
        this.view.width = Math.round(t4 * this.resolution), this.view.height = Math.round(e3 * this.resolution);
        var i2 = this.view.width / this.resolution, n2 = this.view.height / this.resolution;
        this.screen.width = i2, this.screen.height = n2, this.autoDensity && (this.view.style.width = i2 + "px", this.view.style.height = n2 + "px"), this.emit("resize", i2, n2);
      }, e2.prototype.generateTexture = function(t4, e3, i2, n2) {
        e3 === void 0 && (e3 = {}), typeof e3 == "number" && (Z("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e3 = { scaleMode: e3, resolution: i2, region: n2 });
        var r2 = e3.region, o2 = function(t5, e4) {
          var i3 = {};
          for (var n3 in t5)
            Object.prototype.hasOwnProperty.call(t5, n3) && e4.indexOf(n3) < 0 && (i3[n3] = t5[n3]);
          if (t5 != null && typeof Object.getOwnPropertySymbols == "function") {
            var r3 = 0;
            for (n3 = Object.getOwnPropertySymbols(t5); r3 < n3.length; r3++)
              e4.indexOf(n3[r3]) < 0 && (i3[n3[r3]] = t5[n3[r3]]);
          }
          return i3;
        }(e3, ["region"]);
        (n2 = r2 || t4.getLocalBounds(null, true)).width === 0 && (n2.width = 1), n2.height === 0 && (n2.height = 1);
        var s2 = Yt.create(wt({ width: n2.width, height: n2.height }, o2));
        return yi.tx = -n2.x, yi.ty = -n2.y, this.render(t4, { renderTexture: s2, clear: false, transform: yi, skipUpdateTransform: !!t4.parent }), s2;
      }, e2.prototype.destroy = function(t4) {
        for (var e3 in this.plugins)
          this.plugins[e3].destroy(), this.plugins[e3] = null;
        t4 && this.view.parentNode && this.view.parentNode.removeChild(this.view);
        this.plugins = null, this.type = r.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
      }, Object.defineProperty(e2.prototype, "backgroundColor", { get: function() {
        return this._backgroundColor;
      }, set: function(t4) {
        var e3;
        this._backgroundColor = t4, this._backgroundColorString = (e3 = t4.toString(16), "#" + (e3 = "000000".substring(0, 6 - e3.length) + e3)), function(t5, e4) {
          e4 === void 0 && (e4 = []), e4[0] = (t5 >> 16 & 255) / 255, e4[1] = (t5 >> 8 & 255) / 255, e4[2] = (255 & t5) / 255;
        }(t4, this._backgroundColorRgba);
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "backgroundAlpha", { get: function() {
        return this._backgroundColorRgba[3];
      }, set: function(t4) {
        this._backgroundColorRgba[3] = t4;
      }, enumerable: false, configurable: true }), e2;
    }(u), bi = function(t3) {
      this.buffer = t3 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }, Ti = function() {
      function t3(t4) {
        this.renderer = t4, this.managedBuffers = {}, this.boundBufferBases = {};
      }
      return t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3.prototype.contextChange = function() {
        this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      }, t3.prototype.bind = function(t4) {
        var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t4._glBuffers[i2] || this.createGLBuffer(t4);
        e2.bindBuffer(t4.type, n2.buffer);
      }, t3.prototype.bindBufferBase = function(t4, e2) {
        var i2 = this.gl, n2 = this.CONTEXT_UID;
        if (this.boundBufferBases[e2] !== t4) {
          var r2 = t4._glBuffers[n2] || this.createGLBuffer(t4);
          this.boundBufferBases[e2] = t4, i2.bindBufferBase(i2.UNIFORM_BUFFER, e2, r2.buffer);
        }
      }, t3.prototype.bindBufferRange = function(t4, e2, i2) {
        var n2 = this.gl, r2 = this.CONTEXT_UID;
        i2 = i2 || 0;
        var o2 = t4._glBuffers[r2] || this.createGLBuffer(t4);
        n2.bindBufferRange(n2.UNIFORM_BUFFER, e2 || 0, o2.buffer, 256 * i2, 256);
      }, t3.prototype.update = function(t4) {
        var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t4._glBuffers[i2];
        if (t4._updateID !== n2.updateID)
          if (n2.updateID = t4._updateID, e2.bindBuffer(t4.type, n2.buffer), n2.byteLength >= t4.data.byteLength)
            e2.bufferSubData(t4.type, 0, t4.data);
          else {
            var r2 = t4.static ? e2.STATIC_DRAW : e2.DYNAMIC_DRAW;
            n2.byteLength = t4.data.byteLength, e2.bufferData(t4.type, t4.data, r2);
          }
      }, t3.prototype.dispose = function(t4, e2) {
        if (this.managedBuffers[t4.id]) {
          delete this.managedBuffers[t4.id];
          var i2 = t4._glBuffers[this.CONTEXT_UID], n2 = this.gl;
          t4.disposeRunner.remove(this), i2 && (e2 || n2.deleteBuffer(i2.buffer), delete t4._glBuffers[this.CONTEXT_UID]);
        }
      }, t3.prototype.disposeAll = function(t4) {
        for (var e2 = Object.keys(this.managedBuffers), i2 = 0; i2 < e2.length; i2++)
          this.dispose(this.managedBuffers[e2[i2]], t4);
      }, t3.prototype.createGLBuffer = function(t4) {
        var e2 = this.CONTEXT_UID, i2 = this.gl;
        return t4._glBuffers[e2] = new bi(i2.createBuffer()), this.managedBuffers[t4.id] = t4, t4.disposeRunner.add(this), t4._glBuffers[e2];
      }, t3;
    }();
    !function(t3) {
      function e2(i2) {
        var n2 = t3.call(this, r.n.WEBGL, i2) || this;
        return i2 = n2.options, n2.gl = null, n2.CONTEXT_UID = 0, n2.runners = { destroy: new nt("destroy"), contextChange: new nt("contextChange"), reset: new nt("reset"), update: new nt("update"), postrender: new nt("postrender"), prerender: new nt("prerender"), resize: new nt("resize") }, n2.runners.contextChange.add(n2), n2.globalUniforms = new se({ projectionMatrix: new dt() }, true), n2.addSystem(Je, "mask").addSystem(fe, "context").addSystem(fi, "state").addSystem(pi, "shader").addSystem(vi, "texture").addSystem(Ti, "buffer").addSystem(ye, "geometry").addSystem(ve, "framebuffer").addSystem($e, "scissor").addSystem(ti, "stencil").addSystem(ei, "projection").addSystem(mi, "textureGC").addSystem(ue, "filter").addSystem(ri, "renderTexture").addSystem(de, "batch"), n2.initPlugins(e2.__plugins), n2.multisample = void 0, i2.context ? n2.context.initFromContext(i2.context) : n2.context.initFromOptions({ alpha: !!n2.useContextAlpha, antialias: i2.antialias, premultipliedAlpha: n2.useContextAlpha && n2.useContextAlpha !== "notMultiplied", stencil: true, preserveDrawingBuffer: i2.preserveDrawingBuffer, powerPreference: n2.options.powerPreference }), n2.renderingToScreen = true, function(t4) {
          var e3;
          if (!G) {
            if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
              var i3 = ["\n %c %c %c PixiJS 6.4.2 - \u2730 " + t4 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
              (e3 = globalThis.console).log.apply(e3, i3);
            } else
              globalThis.console && globalThis.console.log("PixiJS 6.4.2 - " + t4 + " - http://www.pixijs.com/");
            G = true;
          }
        }(n2.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), n2.resize(n2.options.width, n2.options.height), n2;
      }
      St(e2, t3), e2.create = function(t4) {
        if (k === void 0 && (k = function() {
          var t5 = { stencil: true, failIfMajorPerformanceCaveat: n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
          try {
            if (!globalThis.WebGLRenderingContext)
              return false;
            var e3 = document.createElement("canvas"), i2 = e3.getContext("webgl", t5) || e3.getContext("experimental-webgl", t5), r2 = !(!i2 || !i2.getContextAttributes().stencil);
            if (i2) {
              var o2 = i2.getExtension("WEBGL_lose_context");
              o2 && o2.loseContext();
            }
            return i2 = null, r2;
          } catch (t6) {
            return false;
          }
        }()), k)
          return new e2(t4);
        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
      }, e2.prototype.contextChange = function() {
        var t4, e3 = this.gl;
        if (this.context.webGLVersion === 1) {
          var i2 = e3.getParameter(e3.FRAMEBUFFER_BINDING);
          e3.bindFramebuffer(e3.FRAMEBUFFER, null), t4 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.FRAMEBUFFER, i2);
        } else {
          i2 = e3.getParameter(e3.DRAW_FRAMEBUFFER_BINDING);
          e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, null), t4 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, i2);
        }
        t4 >= r.l.HIGH ? this.multisample = r.l.HIGH : t4 >= r.l.MEDIUM ? this.multisample = r.l.MEDIUM : t4 >= r.l.LOW ? this.multisample = r.l.LOW : this.multisample = r.l.NONE;
      }, e2.prototype.addSystem = function(t4, e3) {
        var i2 = new t4(this);
        if (this[e3])
          throw new Error('Whoops! The name "' + e3 + '" is already in use');
        for (var n2 in this[e3] = i2, this.runners)
          this.runners[n2].add(i2);
        return this;
      }, e2.prototype.render = function(t4, e3) {
        var i2, n2, r2, o2;
        if (e3 && (e3 instanceof Yt ? (Z("6.0.0", "Renderer#render arguments changed, use options instead."), i2 = e3, n2 = arguments[2], r2 = arguments[3], o2 = arguments[4]) : (i2 = e3.renderTexture, n2 = e3.clear, r2 = e3.transform, o2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = r2, !this.context.isLost) {
          if (i2 || (this._lastObjectRendered = t4), !o2) {
            var s2 = t4.enableTempParent();
            t4.updateTransform(), t4.disableTempParent(s2);
          }
          this.renderTexture.bind(i2), this.batch.currentRenderer.start(), (n2 !== void 0 ? n2 : this.clearBeforeRender) && this.renderTexture.clear(), t4.render(this), this.batch.currentRenderer.flush(), i2 && i2.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
        }
      }, e2.prototype.generateTexture = function(e3, i2, n2, r2) {
        i2 === void 0 && (i2 = {});
        var o2 = t3.prototype.generateTexture.call(this, e3, i2, n2, r2);
        return this.framebuffer.blit(), o2;
      }, e2.prototype.resize = function(e3, i2) {
        t3.prototype.resize.call(this, e3, i2), this.runners.resize.emit(this.screen.height, this.screen.width);
      }, e2.prototype.reset = function() {
        return this.runners.reset.emit(), this;
      }, e2.prototype.clear = function() {
        this.renderTexture.bind(), this.renderTexture.clear();
      }, e2.prototype.destroy = function(e3) {
        for (var i2 in this.runners.destroy.emit(), this.runners)
          this.runners[i2].destroy();
        t3.prototype.destroy.call(this, e3), this.gl = null;
      }, Object.defineProperty(e2.prototype, "extract", { get: function() {
        return Z("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      }, enumerable: false, configurable: true }), e2.registerPlugin = function(t4, i2) {
        e2.__plugins = e2.__plugins || {}, e2.__plugins[t4] = i2;
      };
    }(xi);
    var Ei = function() {
      this.texArray = null, this.blend = 0, this.type = r.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }, Si = function() {
      function t3() {
        this.elements = [], this.ids = [], this.count = 0;
      }
      return t3.prototype.clear = function() {
        for (var t4 = 0; t4 < this.count; t4++)
          this.elements[t4] = null;
        this.count = 0;
      }, t3;
    }(), wi = function() {
      function t3(t4) {
        typeof t4 == "number" ? this.rawBinaryData = new ArrayBuffer(t4) : t4 instanceof Uint8Array ? this.rawBinaryData = t4.buffer : this.rawBinaryData = t4, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
      }
      return Object.defineProperty(t3.prototype, "int8View", { get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint8View", { get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int16View", { get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint16View", { get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int32View", { get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      }, enumerable: false, configurable: true }), t3.prototype.view = function(t4) {
        return this[t4 + "View"];
      }, t3.prototype.destroy = function() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
      }, t3.sizeOf = function(t4) {
        switch (t4) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(t4 + " isn't a valid view type");
        }
      }, t3;
    }(), Ai = function(t3) {
      function e2(e3) {
        var i2 = t3.call(this, e3) || this;
        return i2.shaderGenerator = null, i2.geometryClass = null, i2.vertexSize = null, i2.state = Xe.for2d(), i2.size = 4 * n.b.SPRITE_BATCH_SIZE, i2._vertexCount = 0, i2._indexCount = 0, i2._bufferedElements = [], i2._bufferedTextures = [], i2._bufferSize = 0, i2._shader = null, i2._packedGeometries = [], i2._packedGeometryPoolSize = 2, i2._flushId = 0, i2._aBuffers = {}, i2._iBuffers = {}, i2.MAX_TEXTURES = 1, i2.renderer.on("prerender", i2.onPrerender, i2), e3.runners.contextChange.add(i2), i2._dcIndex = 0, i2._aIndex = 0, i2._iIndex = 0, i2._attributeBuffer = null, i2._indexBuffer = null, i2._tempBoundTextures = [], i2;
      }
      return St(e2, t3), e2.prototype.contextChange = function() {
        var t4 = this.renderer.gl;
        n.b.PREFER_ENV === r.g.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS), n.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t5, e4) {
          if (t5 === 0)
            throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
          for (var i2 = e4.createShader(e4.FRAGMENT_SHADER); ; ) {
            var n2 = ke.replace(/%forloop%/gi, Ge(t5));
            if (e4.shaderSource(i2, n2), e4.compileShader(i2), e4.getShaderParameter(i2, e4.COMPILE_STATUS))
              break;
            t5 = t5 / 2 | 0;
          }
          return t5;
        }(this.MAX_TEXTURES, t4)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++)
          this._packedGeometries[e3] = new this.geometryClass();
        this.initFlushBuffers();
      }, e2.prototype.initFlushBuffers = function() {
        for (var t4 = e2._drawCallPool, i2 = e2._textureArrayPool, n2 = this.size / 4, r2 = Math.floor(n2 / this.MAX_TEXTURES) + 1; t4.length < n2; )
          t4.push(new Ei());
        for (; i2.length < r2; )
          i2.push(new Si());
        for (var o2 = 0; o2 < this.MAX_TEXTURES; o2++)
          this._tempBoundTextures[o2] = null;
      }, e2.prototype.onPrerender = function() {
        this._flushId = 0;
      }, e2.prototype.render = function(t4) {
        t4._texture.valid && (this._vertexCount + t4.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t4.vertexData.length / 2, this._indexCount += t4.indices.length, this._bufferedTextures[this._bufferSize] = t4._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t4);
      }, e2.prototype.buildTexturesAndDrawCalls = function() {
        var t4 = this._bufferedTextures, i2 = this.MAX_TEXTURES, n2 = e2._textureArrayPool, r2 = this.renderer.batch, o2 = this._tempBoundTextures, s2 = this.renderer.textureGC.count, a2 = ++Ct._globalBatch, l2 = 0, h2 = n2[0], u2 = 0;
        r2.copyBoundTextures(o2, i2);
        for (var c2 = 0; c2 < this._bufferSize; ++c2) {
          var d2 = t4[c2];
          t4[c2] = null, d2._batchEnabled !== a2 && (h2.count >= i2 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, c2), u2 = c2, h2 = n2[++l2], ++a2), d2._batchEnabled = a2, d2.touched = s2, h2.elements[h2.count++] = d2);
        }
        h2.count > 0 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, this._bufferSize), ++l2, ++a2);
        for (c2 = 0; c2 < o2.length; c2++)
          o2[c2] = null;
        Ct._globalBatch = a2;
      }, e2.prototype.buildDrawCalls = function(t4, i2, n2) {
        var r2 = this._bufferedElements, o2 = this._attributeBuffer, s2 = this._indexBuffer, a2 = this.vertexSize, l2 = e2._drawCallPool, h2 = this._dcIndex, u2 = this._aIndex, c2 = this._iIndex, d2 = l2[h2];
        d2.start = this._iIndex, d2.texArray = t4;
        for (var p2 = i2; p2 < n2; ++p2) {
          var f2 = r2[p2], m2 = f2._texture.baseTexture, g2 = H[m2.alphaMode ? 1 : 0][f2.blendMode];
          r2[p2] = null, i2 < p2 && d2.blend !== g2 && (d2.size = c2 - d2.start, i2 = p2, (d2 = l2[++h2]).texArray = t4, d2.start = c2), this.packInterleavedGeometry(f2, o2, s2, u2, c2), u2 += f2.vertexData.length / 2 * a2, c2 += f2.indices.length, d2.blend = g2;
        }
        i2 < n2 && (d2.size = c2 - d2.start, ++h2), this._dcIndex = h2, this._aIndex = u2, this._iIndex = c2;
      }, e2.prototype.bindAndClearTexArray = function(t4) {
        for (var e3 = this.renderer.texture, i2 = 0; i2 < t4.count; i2++)
          e3.bind(t4.elements[i2], t4.ids[i2]), t4.elements[i2] = null;
        t4.count = 0;
      }, e2.prototype.updateGeometry = function() {
        var t4 = this._packedGeometries, e3 = this._attributeBuffer, i2 = this._indexBuffer;
        n.b.CAN_UPLOAD_SAME_BUFFER ? (t4[this._flushId]._buffer.update(e3.rawBinaryData), t4[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t4[this._flushId] = new this.geometryClass()), t4[this._flushId]._buffer.update(e3.rawBinaryData), t4[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.bind(t4[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
      }, e2.prototype.drawBatches = function() {
        for (var t4 = this._dcIndex, i2 = this.renderer, n2 = i2.gl, r2 = i2.state, o2 = e2._drawCallPool, s2 = null, a2 = 0; a2 < t4; a2++) {
          var l2 = o2[a2], h2 = l2.texArray, u2 = l2.type, c2 = l2.size, d2 = l2.start, p2 = l2.blend;
          s2 !== h2 && (s2 = h2, this.bindAndClearTexArray(h2)), this.state.blendMode = p2, r2.set(this.state), n2.drawElements(u2, c2, n2.UNSIGNED_SHORT, 2 * d2);
        }
      }, e2.prototype.flush = function() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
      }, e2.prototype.start = function() {
        this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), n.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }, e2.prototype.stop = function() {
        this.flush();
      }, e2.prototype.destroy = function() {
        for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++)
          this._packedGeometries[e3] && this._packedGeometries[e3].destroy();
        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t3.prototype.destroy.call(this);
      }, e2.prototype.getAttributeBuffer = function(t4) {
        var e3 = z(Math.ceil(t4 / 8)), i2 = X(e3), n2 = 8 * e3;
        this._aBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
        var r2 = this._aBuffers[n2];
        return r2 || (this._aBuffers[n2] = r2 = new wi(n2 * this.vertexSize * 4)), r2;
      }, e2.prototype.getIndexBuffer = function(t4) {
        var e3 = z(Math.ceil(t4 / 12)), i2 = X(e3), n2 = 12 * e3;
        this._iBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
        var r2 = this._iBuffers[i2];
        return r2 || (this._iBuffers[i2] = r2 = new Uint16Array(n2)), r2;
      }, e2.prototype.packInterleavedGeometry = function(t4, e3, i2, n2, r2) {
        for (var o2 = e3.uint32View, s2 = e3.float32View, a2 = n2 / this.vertexSize, l2 = t4.uvs, h2 = t4.indices, u2 = t4.vertexData, c2 = t4._texture.baseTexture._batchLocation, d2 = Math.min(t4.worldAlpha, 1), p2 = d2 < 1 && t4._texture.baseTexture.alphaMode ? function(t5, e4) {
          if (e4 === 1)
            return (255 * e4 << 24) + t5;
          if (e4 === 0)
            return 0;
          var i3 = t5 >> 16 & 255, n3 = t5 >> 8 & 255, r3 = 255 & t5;
          return (255 * e4 << 24) + ((i3 = i3 * e4 + 0.5 | 0) << 16) + ((n3 = n3 * e4 + 0.5 | 0) << 8) + (r3 = r3 * e4 + 0.5 | 0);
        }(t4._tintRGB, d2) : t4._tintRGB + (255 * d2 << 24), f2 = 0; f2 < u2.length; f2 += 2)
          s2[n2++] = u2[f2], s2[n2++] = u2[f2 + 1], s2[n2++] = l2[f2], s2[n2++] = l2[f2 + 1], o2[n2++] = p2, s2[n2++] = c2;
        for (f2 = 0; f2 < h2.length; f2++)
          i2[r2++] = a2 + h2[f2];
      }, e2._drawCallPool = [], e2._textureArrayPool = [], e2;
    }(ce), Mi = function() {
      function t3(t4, e2) {
        if (this.vertexSrc = t4, this.fragTemplate = e2, this.programCache = {}, this.defaultGroupCache = {}, e2.indexOf("%count%") < 0)
          throw new Error('Fragment template must contain "%count%".');
        if (e2.indexOf("%forloop%") < 0)
          throw new Error('Fragment template must contain "%forloop%".');
      }
      return t3.prototype.generateShader = function(t4) {
        if (!this.programCache[t4]) {
          for (var e2 = new Int32Array(t4), i2 = 0; i2 < t4; i2++)
            e2[i2] = i2;
          this.defaultGroupCache[t4] = se.from({ uSamplers: e2 }, true);
          var n2 = this.fragTemplate;
          n2 = (n2 = n2.replace(/%count%/gi, "" + t4)).replace(/%forloop%/gi, this.generateSampleSrc(t4)), this.programCache[t4] = new ze(this.vertexSrc, n2);
        }
        var r2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new dt(), default: this.defaultGroupCache[t4] };
        return new Ve(this.programCache[t4], r2);
      }, t3.prototype.generateSampleSrc = function(t4) {
        var e2 = "";
        e2 += "\n", e2 += "\n";
        for (var i2 = 0; i2 < t4; i2++)
          i2 > 0 && (e2 += "\nelse "), i2 < t4 - 1 && (e2 += "if(vTextureId < " + i2 + ".5)"), e2 += "\n{", e2 += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);", e2 += "\n}";
        return e2 += "\n", e2 += "\n";
      }, t3;
    }(), Ri = function(t3) {
      function e2(e3) {
        e3 === void 0 && (e3 = false);
        var i2 = t3.call(this) || this;
        return i2._buffer = new Kt(null, e3, false), i2._indexBuffer = new Kt(null, e3, true), i2.addAttribute("aVertexPosition", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aTextureCoord", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aColor", i2._buffer, 4, true, r.r.UNSIGNED_BYTE).addAttribute("aTextureId", i2._buffer, 1, true, r.r.FLOAT).addIndex(i2._indexBuffer), i2;
      }
      return St(e2, t3), e2;
    }(ie), Ci = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Ii = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
    (function() {
      function t3() {
      }
      return t3.create = function(t4) {
        var e2 = Object.assign({ vertex: Ci, fragment: Ii, geometryClass: Ri, vertexSize: 6 }, t4), i2 = e2.vertex, n2 = e2.fragment, r2 = e2.vertexSize, o2 = e2.geometryClass;
        return function(t5) {
          function e3(e4) {
            var s2 = t5.call(this, e4) || this;
            return s2.shaderGenerator = new Mi(i2, n2), s2.geometryClass = o2, s2.vertexSize = r2, s2;
          }
          return St(e3, t5), e3;
        }(Ai);
      }, Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
        return Ci;
      }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentTemplate", { get: function() {
        return Ii;
      }, enumerable: false, configurable: true }), t3;
    })().create();
    var Fi = function() {
      function t3(t4) {
        this.renderer = t4;
      }
      return t3.prototype.render = function(t4) {
        var e2 = this.renderer, i2 = t4.worldTransform;
        e2.context.globalAlpha = t4.worldAlpha, e2.setBlendMode(t4.blendMode), e2.setContextTransform(i2, t4.roundPixels), t4.drawMode !== r.f.TRIANGLES ? this._renderTriangleMesh(t4) : this._renderTriangles(t4);
      }, t3.prototype._renderTriangleMesh = function(t4) {
        for (var e2 = t4.geometry.buffers[0].data.length, i2 = 0; i2 < e2 - 2; i2++) {
          var n2 = 2 * i2;
          this._renderDrawTriangle(t4, n2, n2 + 2, n2 + 4);
        }
      }, t3.prototype._renderTriangles = function(t4) {
        for (var e2 = t4.geometry.getIndex().data, i2 = e2.length, n2 = 0; n2 < i2; n2 += 3) {
          var r2 = 2 * e2[n2], o2 = 2 * e2[n2 + 1], s2 = 2 * e2[n2 + 2];
          this._renderDrawTriangle(t4, r2, o2, s2);
        }
      }, t3.prototype._renderDrawTriangle = function(t4, e2, i2, n2) {
        var r2 = this.renderer.context, s2 = t4.geometry.buffers[0].data, a2 = t4.uvs, l2 = t4.texture;
        if (l2.valid) {
          var h2 = t4.tint !== 16777215, u2 = l2.baseTexture, c2 = u2.width, d2 = u2.height;
          h2 && t4._cachedTint !== t4.tint && (t4._cachedTint = t4.tint, t4._cachedTexture = t4._cachedTexture || new Wt(u2), t4._tintedCanvas = o.b.getTintedCanvas({ texture: t4._cachedTexture }, t4.tint));
          var p2 = h2 ? t4._tintedCanvas : u2.getDrawableSource(), f2 = a2[e2] * u2.width, m2 = a2[i2] * u2.width, g2 = a2[n2] * u2.width, v2 = a2[e2 + 1] * u2.height, _2 = a2[i2 + 1] * u2.height, y2 = a2[n2 + 1] * u2.height, x2 = s2[e2], b2 = s2[i2], T2 = s2[n2], E2 = s2[e2 + 1], S2 = s2[i2 + 1], w2 = s2[n2 + 1], A2 = t4.canvasPadding / this.renderer.resolution;
          if (A2 > 0) {
            var M2 = t4.worldTransform, R2 = M2.a, C2 = M2.b, I2 = M2.c, P2 = M2.d, O2 = (x2 + b2 + T2) / 3, N2 = (E2 + S2 + w2) / 3, L2 = x2 - O2, D2 = E2 - N2, F2 = R2 * L2 + I2 * D2, B2 = C2 * L2 + P2 * D2, U2 = Math.sqrt(F2 * F2 + B2 * B2), k2 = 1 + A2 / U2;
            x2 = O2 + L2 * k2, E2 = N2 + D2 * k2, F2 = R2 * (L2 = b2 - O2) + I2 * (D2 = S2 - N2), B2 = C2 * L2 + P2 * D2, b2 = O2 + L2 * (k2 = 1 + A2 / (U2 = Math.sqrt(F2 * F2 + B2 * B2))), S2 = N2 + D2 * k2, F2 = R2 * (L2 = T2 - O2) + I2 * (D2 = w2 - N2), B2 = C2 * L2 + P2 * D2, T2 = O2 + L2 * (k2 = 1 + A2 / (U2 = Math.sqrt(F2 * F2 + B2 * B2))), w2 = N2 + D2 * k2;
          }
          r2.save(), r2.beginPath(), r2.moveTo(x2, E2), r2.lineTo(b2, S2), r2.lineTo(T2, w2), r2.closePath(), r2.clip();
          var G2 = f2 * _2 + v2 * g2 + m2 * y2 - _2 * g2 - v2 * m2 - f2 * y2, H2 = x2 * _2 + v2 * T2 + b2 * y2 - _2 * T2 - v2 * b2 - x2 * y2, j2 = f2 * b2 + x2 * g2 + m2 * T2 - b2 * g2 - x2 * m2 - f2 * T2, z2 = f2 * _2 * T2 + v2 * b2 * g2 + x2 * m2 * y2 - x2 * _2 * g2 - v2 * m2 * T2 - f2 * b2 * y2, V2 = E2 * _2 + v2 * w2 + S2 * y2 - _2 * w2 - v2 * S2 - E2 * y2, X2 = f2 * S2 + E2 * g2 + m2 * w2 - S2 * g2 - E2 * m2 - f2 * w2, W2 = f2 * _2 * w2 + v2 * S2 * g2 + E2 * m2 * y2 - E2 * _2 * g2 - v2 * m2 * w2 - f2 * S2 * y2;
          r2.transform(H2 / G2, V2 / G2, j2 / G2, X2 / G2, z2 / G2, W2 / G2), r2.drawImage(p2, 0, 0, c2 * u2.resolution, d2 * u2.resolution, 0, 0, c2, d2), r2.restore(), this.renderer.invalidateBlendMode();
        }
      }, t3.prototype.renderMeshFlat = function(t4) {
        var e2 = this.renderer.context, i2 = t4.geometry.getBuffer("aVertexPosition").data, n2 = i2.length / 2;
        e2.beginPath();
        for (var r2 = 1; r2 < n2 - 2; ++r2) {
          var o2 = 2 * r2, s2 = i2[o2], a2 = i2[o2 + 1], l2 = i2[o2 + 2], h2 = i2[o2 + 3], u2 = i2[o2 + 4], c2 = i2[o2 + 5];
          e2.moveTo(s2, a2), e2.lineTo(l2, h2), e2.lineTo(u2, c2);
        }
        e2.fillStyle = "#FF0000", e2.fill(), e2.closePath();
      }, t3.prototype.destroy = function() {
        this.renderer = null;
      }, t3;
    }();
    n.b.MESH_CANVAS_PADDING = 0, s.c.prototype._renderCanvas = function(t3, e2) {
      t3.plugins.mesh.render(e2);
    }, a.a.prototype._cachedTint = 16777215, a.a.prototype._tintedCanvas = null, a.a.prototype._canvasUvs = null, a.a.prototype._renderCanvas = function(t3) {
      var e2 = t3.context, i2 = this.worldTransform, n2 = this.tint !== 16777215, r2 = this.texture;
      if (r2.valid) {
        n2 && this._cachedTint !== this.tint && (this._cachedTint = this.tint, this._tintedCanvas = o.b.getTintedCanvas(this, this.tint));
        var s2 = n2 ? this._tintedCanvas : r2.baseTexture.getDrawableSource();
        this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
        var a2 = this.vertices, l2 = this._canvasUvs, h2 = n2 ? 0 : r2.frame.x, u2 = n2 ? 0 : r2.frame.y, c2 = h2 + r2.frame.width, d2 = u2 + r2.frame.height;
        l2[0] = h2, l2[1] = h2 + this._leftWidth, l2[2] = c2 - this._rightWidth, l2[3] = c2, l2[4] = u2, l2[5] = u2 + this._topHeight, l2[6] = d2 - this._bottomHeight, l2[7] = d2;
        for (var p2 = 0; p2 < 8; p2++)
          l2[p2] *= r2.baseTexture.resolution;
        e2.globalAlpha = this.worldAlpha, t3.setBlendMode(this.blendMode), t3.setContextTransform(i2, this.roundPixels);
        for (var f2 = 0; f2 < 3; f2++)
          for (var m2 = 0; m2 < 3; m2++) {
            var g2 = 2 * m2 + 8 * f2, v2 = Math.max(1, l2[m2 + 1] - l2[m2]), _2 = Math.max(1, l2[f2 + 5] - l2[f2 + 4]), y2 = Math.max(1, a2[g2 + 10] - a2[g2]), x2 = Math.max(1, a2[g2 + 11] - a2[g2 + 1]);
            e2.drawImage(s2, l2[m2], l2[f2 + 4], v2, _2, a2[g2], a2[g2 + 1], y2, x2);
          }
      }
    };
    var Bi = false;
    s.a.prototype._cachedTint = 16777215, s.a.prototype._tintedCanvas = null, s.a.prototype._cachedTexture = null, s.a.prototype._renderCanvas = function(t3) {
      this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(t3, this) : Bi || (Bi = true, globalThis.console && console.warn("Mesh with custom shaders are not supported in CanvasRenderer."));
    }, s.a.prototype._canvasPadding = null, Object.defineProperty(s.a.prototype, "canvasPadding", { get: function() {
      return this._canvasPadding !== null ? this._canvasPadding : n.b.MESH_CANVAS_PADDING;
    }, set: function(t3) {
      this._canvasPadding = t3;
    } }), a.b.prototype._renderCanvas = function(t3) {
      this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t3, this);
    }, a.c.prototype._renderCanvas = function(t3) {
      (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height, this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t3, this);
    };
  }).call(this, i(17));
}, function(t, e, i) {
  var n = i(143), r = i(144);
  function o() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  e.parse = y, e.resolve = function(t2, e2) {
    return y(t2, false, true).resolve(e2);
  }, e.resolveObject = function(t2, e2) {
    return t2 ? y(t2, false, true).resolveObject(e2) : e2;
  }, e.format = function(t2) {
    r.isString(t2) && (t2 = y(t2));
    return t2 instanceof o ? t2.format() : o.prototype.format.call(t2);
  }, e.Url = o;
  var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), u = ["'"].concat(h), c = ["%", "/", "?", ";", "#"].concat(u), d = ["/", "?", "#"], p = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, g = { javascript: true, "javascript:": true }, v = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, _ = i(145);
  function y(t2, e2, i2) {
    if (t2 && r.isObject(t2) && t2 instanceof o)
      return t2;
    var n2 = new o();
    return n2.parse(t2, e2, i2), n2;
  }
  o.prototype.parse = function(t2, e2, i2) {
    if (!r.isString(t2))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof t2);
    var o2 = t2.indexOf("?"), a2 = o2 !== -1 && o2 < t2.indexOf("#") ? "?" : "#", h2 = t2.split(a2);
    h2[0] = h2[0].replace(/\\/g, "/");
    var y2 = t2 = h2.join(a2);
    if (y2 = y2.trim(), !i2 && t2.split("#").length === 1) {
      var x = l.exec(y2);
      if (x)
        return this.path = y2, this.href = y2, this.pathname = x[1], x[2] ? (this.search = x[2], this.query = e2 ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e2 && (this.search = "", this.query = {}), this;
    }
    var b = s.exec(y2);
    if (b) {
      var T = (b = b[0]).toLowerCase();
      this.protocol = T, y2 = y2.substr(b.length);
    }
    if (i2 || b || y2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var E = y2.substr(0, 2) === "//";
      !E || b && g[b] || (y2 = y2.substr(2), this.slashes = true);
    }
    if (!g[b] && (E || b && !v[b])) {
      for (var S, w, A = -1, M = 0; M < d.length; M++) {
        (R = y2.indexOf(d[M])) !== -1 && (A === -1 || R < A) && (A = R);
      }
      (w = A === -1 ? y2.lastIndexOf("@") : y2.lastIndexOf("@", A)) !== -1 && (S = y2.slice(0, w), y2 = y2.slice(w + 1), this.auth = decodeURIComponent(S)), A = -1;
      for (M = 0; M < c.length; M++) {
        var R;
        (R = y2.indexOf(c[M])) !== -1 && (A === -1 || R < A) && (A = R);
      }
      A === -1 && (A = y2.length), this.host = y2.slice(0, A), y2 = y2.slice(A), this.parseHost(), this.hostname = this.hostname || "";
      var C = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!C)
        for (var I = this.hostname.split(/\./), P = (M = 0, I.length); M < P; M++) {
          var O = I[M];
          if (O && !O.match(p)) {
            for (var N = "", L = 0, D = O.length; L < D; L++)
              O.charCodeAt(L) > 127 ? N += "x" : N += O[L];
            if (!N.match(p)) {
              var F = I.slice(0, M), B = I.slice(M + 1), U = O.match(f);
              U && (F.push(U[1]), B.unshift(U[2])), B.length && (y2 = "/" + B.join(".") + y2), this.hostname = F.join(".");
              break;
            }
          }
        }
      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), C || (this.hostname = n.toASCII(this.hostname));
      var k = this.port ? ":" + this.port : "", G = this.hostname || "";
      this.host = G + k, this.href += this.host, C && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), y2[0] !== "/" && (y2 = "/" + y2));
    }
    if (!m[T])
      for (M = 0, P = u.length; M < P; M++) {
        var H = u[M];
        if (y2.indexOf(H) !== -1) {
          var j = encodeURIComponent(H);
          j === H && (j = escape(H)), y2 = y2.split(H).join(j);
        }
      }
    var z = y2.indexOf("#");
    z !== -1 && (this.hash = y2.substr(z), y2 = y2.slice(0, z));
    var V = y2.indexOf("?");
    if (V !== -1 ? (this.search = y2.substr(V), this.query = y2.substr(V + 1), e2 && (this.query = _.parse(this.query)), y2 = y2.slice(0, V)) : e2 && (this.search = "", this.query = {}), y2 && (this.pathname = y2), v[T] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      k = this.pathname || "";
      var X = this.search || "";
      this.path = k + X;
    }
    return this.href = this.format(), this;
  }, o.prototype.format = function() {
    var t2 = this.auth || "";
    t2 && (t2 = (t2 = encodeURIComponent(t2)).replace(/%3A/i, ":"), t2 += "@");
    var e2 = this.protocol || "", i2 = this.pathname || "", n2 = this.hash || "", o2 = false, s2 = "";
    this.host ? o2 = t2 + this.host : this.hostname && (o2 = t2 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (s2 = _.stringify(this.query));
    var a2 = this.search || s2 && "?" + s2 || "";
    return e2 && e2.substr(-1) !== ":" && (e2 += ":"), this.slashes || (!e2 || v[e2]) && o2 !== false ? (o2 = "//" + (o2 || ""), i2 && i2.charAt(0) !== "/" && (i2 = "/" + i2)) : o2 || (o2 = ""), n2 && n2.charAt(0) !== "#" && (n2 = "#" + n2), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), e2 + o2 + (i2 = i2.replace(/[?#]/g, function(t3) {
      return encodeURIComponent(t3);
    })) + (a2 = a2.replace("#", "%23")) + n2;
  }, o.prototype.resolve = function(t2) {
    return this.resolveObject(y(t2, false, true)).format();
  }, o.prototype.resolveObject = function(t2) {
    if (r.isString(t2)) {
      var e2 = new o();
      e2.parse(t2, false, true), t2 = e2;
    }
    for (var i2 = new o(), n2 = Object.keys(this), s2 = 0; s2 < n2.length; s2++) {
      var a2 = n2[s2];
      i2[a2] = this[a2];
    }
    if (i2.hash = t2.hash, t2.href === "")
      return i2.href = i2.format(), i2;
    if (t2.slashes && !t2.protocol) {
      for (var l2 = Object.keys(t2), h2 = 0; h2 < l2.length; h2++) {
        var u2 = l2[h2];
        u2 !== "protocol" && (i2[u2] = t2[u2]);
      }
      return v[i2.protocol] && i2.hostname && !i2.pathname && (i2.path = i2.pathname = "/"), i2.href = i2.format(), i2;
    }
    if (t2.protocol && t2.protocol !== i2.protocol) {
      if (!v[t2.protocol]) {
        for (var c2 = Object.keys(t2), d2 = 0; d2 < c2.length; d2++) {
          var p2 = c2[d2];
          i2[p2] = t2[p2];
        }
        return i2.href = i2.format(), i2;
      }
      if (i2.protocol = t2.protocol, t2.host || g[t2.protocol])
        i2.pathname = t2.pathname;
      else {
        for (var f2 = (t2.pathname || "").split("/"); f2.length && !(t2.host = f2.shift()); )
          ;
        t2.host || (t2.host = ""), t2.hostname || (t2.hostname = ""), f2[0] !== "" && f2.unshift(""), f2.length < 2 && f2.unshift(""), i2.pathname = f2.join("/");
      }
      if (i2.search = t2.search, i2.query = t2.query, i2.host = t2.host || "", i2.auth = t2.auth, i2.hostname = t2.hostname || t2.host, i2.port = t2.port, i2.pathname || i2.search) {
        var m2 = i2.pathname || "", _2 = i2.search || "";
        i2.path = m2 + _2;
      }
      return i2.slashes = i2.slashes || t2.slashes, i2.href = i2.format(), i2;
    }
    var y2 = i2.pathname && i2.pathname.charAt(0) === "/", x = t2.host || t2.pathname && t2.pathname.charAt(0) === "/", b = x || y2 || i2.host && t2.pathname, T = b, E = i2.pathname && i2.pathname.split("/") || [], S = (f2 = t2.pathname && t2.pathname.split("/") || [], i2.protocol && !v[i2.protocol]);
    if (S && (i2.hostname = "", i2.port = null, i2.host && (E[0] === "" ? E[0] = i2.host : E.unshift(i2.host)), i2.host = "", t2.protocol && (t2.hostname = null, t2.port = null, t2.host && (f2[0] === "" ? f2[0] = t2.host : f2.unshift(t2.host)), t2.host = null), b = b && (f2[0] === "" || E[0] === "")), x)
      i2.host = t2.host || t2.host === "" ? t2.host : i2.host, i2.hostname = t2.hostname || t2.hostname === "" ? t2.hostname : i2.hostname, i2.search = t2.search, i2.query = t2.query, E = f2;
    else if (f2.length)
      E || (E = []), E.pop(), E = E.concat(f2), i2.search = t2.search, i2.query = t2.query;
    else if (!r.isNullOrUndefined(t2.search)) {
      if (S)
        i2.hostname = i2.host = E.shift(), (C = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = C.shift(), i2.host = i2.hostname = C.shift());
      return i2.search = t2.search, i2.query = t2.query, r.isNull(i2.pathname) && r.isNull(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.href = i2.format(), i2;
    }
    if (!E.length)
      return i2.pathname = null, i2.search ? i2.path = "/" + i2.search : i2.path = null, i2.href = i2.format(), i2;
    for (var w = E.slice(-1)[0], A = (i2.host || t2.host || E.length > 1) && (w === "." || w === "..") || w === "", M = 0, R = E.length; R >= 0; R--)
      (w = E[R]) === "." ? E.splice(R, 1) : w === ".." ? (E.splice(R, 1), M++) : M && (E.splice(R, 1), M--);
    if (!b && !T)
      for (; M--; M)
        E.unshift("..");
    !b || E[0] === "" || E[0] && E[0].charAt(0) === "/" || E.unshift(""), A && E.join("/").substr(-1) !== "/" && E.push("");
    var C, I = E[0] === "" || E[0] && E[0].charAt(0) === "/";
    S && (i2.hostname = i2.host = I ? "" : E.length ? E.shift() : "", (C = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = C.shift(), i2.host = i2.hostname = C.shift()));
    return (b = b || i2.host && E.length) && !I && E.unshift(""), E.length ? i2.pathname = E.join("/") : (i2.pathname = null, i2.path = null), r.isNull(i2.pathname) && r.isNull(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.auth = t2.auth || i2.auth, i2.slashes = i2.slashes || t2.slashes, i2.href = i2.format(), i2;
  }, o.prototype.parseHost = function() {
    var t2 = this.host, e2 = a.exec(t2);
    e2 && ((e2 = e2[0]) !== ":" && (this.port = e2.substr(1)), t2 = t2.substr(0, t2.length - e2.length)), t2 && (this.hostname = t2);
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    return t2 === e2 || t2 != t2 && e2 != e2;
  };
}, function(t, e, i) {
  var n = i(22)(i(14), "Map");
  t.exports = n;
}, function(t, e, i) {
  var n = i(187), r = i(62), o = Object.prototype.propertyIsEnumerable, s = Object.getOwnPropertySymbols, a = s ? function(t2) {
    return t2 == null ? [] : (t2 = Object(t2), n(s(t2), function(e2) {
      return o.call(t2, e2);
    }));
  } : r;
  t.exports = a;
}, function(t, e, i) {
  var n = i(63), r = i(194), o = i(67);
  t.exports = function(t2) {
    return o(t2) ? n(t2) : r(t2);
  };
}, function(t, e, i) {
  (function(t2) {
    var n = i(14), r = i(191), o = e && !e.nodeType && e, s = o && typeof t2 == "object" && t2 && !t2.nodeType && t2, a = s && s.exports === o ? n.Buffer : void 0, l = (a ? a.isBuffer : void 0) || r;
    t2.exports = l;
  }).call(this, i(25)(t));
}, function(t, e) {
  t.exports = function(t2) {
    return function(e2) {
      return t2(e2);
    };
  };
}, function(t, e, i) {
  (function(t2) {
    var n = i(51), r = e && !e.nodeType && e, o = r && typeof t2 == "object" && t2 && !t2.nodeType && t2, s = o && o.exports === r && n.process, a = function() {
      try {
        var t3 = o && o.require && o.require("util").types;
        return t3 || s && s.binding && s.binding("util");
      } catch (t4) {
      }
    }();
    t2.exports = a;
  }).call(this, i(25)(t));
}, function(t, e) {
  var i = Object.prototype;
  t.exports = function(t2) {
    var e2 = t2 && t2.constructor;
    return t2 === (typeof e2 == "function" && e2.prototype || i);
  };
}, function(t, e, i) {
  var n = i(63), r = i(210), o = i(67);
  t.exports = function(t2) {
    return o(t2) ? n(t2, true) : r(t2);
  };
}, function(t, e, i) {
  var n = i(58);
  t.exports = function(t2) {
    var e2 = new t2.constructor(t2.byteLength);
    return new n(e2).set(new n(t2)), e2;
  };
}, function(t, e) {
  t.exports = "#define PI 3.14159265\nuniform float galleryHeight;\nvarying vec2 vUv;\nvarying float vPixelY;\nvoid main() {\n	vUv = uv;\n	float pixelHeight = (galleryHeight * 1.2) + 8.0;\n	float pixelY = (pixelHeight * 0.5) - position.y;\n	vPixelY = pixelY;\n	vec4 newPosition = vec4(position, 1.0);\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D galleryTexture;\nuniform float galleryHeight;\nvarying vec2 vUv;\nvarying float vPixelY;\nvoid main() {\n	vec4 color;\n	if ((vPixelY >= 0.0) && (vPixelY <= galleryHeight)) {\n		color = texture2D(galleryTexture, vec2(vUv.x, 1.0 - (vPixelY / galleryHeight)));\n	}\n	else if ((vPixelY > galleryHeight) && (vPixelY < (galleryHeight + 8.0))) {\n		color = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n	else {\n		float alpha = 1.0 - ((vPixelY - (galleryHeight + 8.0)) / (galleryHeight * 0.2));\n		color = texture2D(galleryTexture, vec2(vUv.x, ((vPixelY - galleryHeight) + 8.0) / galleryHeight));\n		color.a = alpha;\n		vec4 shadow = vec4(0.0, 0.0, 0.0, 1.0);\n		color = blendSrcOver(color, shadow);\n	}\n	gl_FragColor = color;\n}\n";
}, function(t, e, i) {
  var n = i(148);
  t.exports = function(t2, e2) {
    e2 = e2 || {};
    var i2 = new n(), r = e2.inPlace || false, o = t2.map(function(t3) {
      return r ? t3 : { width: t3.width, height: t3.height, item: t3 };
    });
    o = o.sort(function(t3, e3) {
      return e3.width * e3.height - t3.width * t3.height;
    }), i2.fit(o);
    var s = { width: o.reduce(function(t3, e3) {
      return Math.max(t3, e3.x + e3.width);
    }, 0), height: o.reduce(function(t3, e3) {
      return Math.max(t3, e3.y + e3.height);
    }, 0) };
    return r || (s.items = o), s;
  };
}, function(t, e, i) {
  var n = i(21), r = i(200), o = i(201), s = Math.max, a = Math.min;
  t.exports = function(t2, e2, i2) {
    var l, h, u, c, d, p, f = 0, m = false, g = false, v = true;
    if (typeof t2 != "function")
      throw new TypeError("Expected a function");
    function _(e3) {
      var i3 = l, n2 = h;
      return l = h = void 0, f = e3, c = t2.apply(n2, i3);
    }
    function y(t3) {
      return f = t3, d = setTimeout(b, e2), m ? _(t3) : c;
    }
    function x(t3) {
      var i3 = t3 - p;
      return p === void 0 || i3 >= e2 || i3 < 0 || g && t3 - f >= u;
    }
    function b() {
      var t3 = r();
      if (x(t3))
        return T(t3);
      d = setTimeout(b, function(t4) {
        var i3 = e2 - (t4 - p);
        return g ? a(i3, u - (t4 - f)) : i3;
      }(t3));
    }
    function T(t3) {
      return d = void 0, v && l ? _(t3) : (l = h = void 0, c);
    }
    function E() {
      var t3 = r(), i3 = x(t3);
      if (l = arguments, h = this, p = t3, i3) {
        if (d === void 0)
          return y(p);
        if (g)
          return clearTimeout(d), d = setTimeout(b, e2), _(p);
      }
      return d === void 0 && (d = setTimeout(b, e2)), c;
    }
    return e2 = o(e2) || 0, n(i2) && (m = !!i2.leading, u = (g = "maxWait" in i2) ? s(o(i2.maxWait) || 0, e2) : u, v = "trailing" in i2 ? !!i2.trailing : v), E.cancel = function() {
      d !== void 0 && clearTimeout(d), f = 0, l = p = h = d = void 0;
    }, E.flush = function() {
      return d === void 0 ? c : T(r());
    }, E;
  };
}, function(t, e, i) {
  var n = i(205);
  t.exports = function(t2) {
    return n(t2, 5);
  };
}, function(t, e, i) {
  (function(e2) {
    var i2 = typeof e2 == "object" && e2 && e2.Object === Object && e2;
    t.exports = i2;
  }).call(this, i(17));
}, function(t, e, i) {
  var n = Object.prototype.hasOwnProperty, r = "~";
  function o() {
  }
  function s(t2, e2, i2) {
    this.fn = t2, this.context = e2, this.once = i2 || false;
  }
  function a(t2, e2, i2, n2, o2) {
    if (typeof i2 != "function")
      throw new TypeError("The listener must be a function");
    var a2 = new s(i2, n2 || t2, o2), l2 = r ? r + e2 : e2;
    return t2._events[l2] ? t2._events[l2].fn ? t2._events[l2] = [t2._events[l2], a2] : t2._events[l2].push(a2) : (t2._events[l2] = a2, t2._eventsCount++), t2;
  }
  function l(t2, e2) {
    --t2._eventsCount == 0 ? t2._events = new o() : delete t2._events[e2];
  }
  function h() {
    this._events = new o(), this._eventsCount = 0;
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (r = false)), h.prototype.eventNames = function() {
    var t2, e2, i2 = [];
    if (this._eventsCount === 0)
      return i2;
    for (e2 in t2 = this._events)
      n.call(t2, e2) && i2.push(r ? e2.slice(1) : e2);
    return Object.getOwnPropertySymbols ? i2.concat(Object.getOwnPropertySymbols(t2)) : i2;
  }, h.prototype.listeners = function(t2) {
    var e2 = r ? r + t2 : t2, i2 = this._events[e2];
    if (!i2)
      return [];
    if (i2.fn)
      return [i2.fn];
    for (var n2 = 0, o2 = i2.length, s2 = new Array(o2); n2 < o2; n2++)
      s2[n2] = i2[n2].fn;
    return s2;
  }, h.prototype.listenerCount = function(t2) {
    var e2 = r ? r + t2 : t2, i2 = this._events[e2];
    return i2 ? i2.fn ? 1 : i2.length : 0;
  }, h.prototype.emit = function(t2, e2, i2, n2, o2, s2) {
    var a2 = r ? r + t2 : t2;
    if (!this._events[a2])
      return false;
    var l2, h2, u = this._events[a2], c = arguments.length;
    if (u.fn) {
      switch (u.once && this.removeListener(t2, u.fn, void 0, true), c) {
        case 1:
          return u.fn.call(u.context), true;
        case 2:
          return u.fn.call(u.context, e2), true;
        case 3:
          return u.fn.call(u.context, e2, i2), true;
        case 4:
          return u.fn.call(u.context, e2, i2, n2), true;
        case 5:
          return u.fn.call(u.context, e2, i2, n2, o2), true;
        case 6:
          return u.fn.call(u.context, e2, i2, n2, o2, s2), true;
      }
      for (h2 = 1, l2 = new Array(c - 1); h2 < c; h2++)
        l2[h2 - 1] = arguments[h2];
      u.fn.apply(u.context, l2);
    } else {
      var d, p = u.length;
      for (h2 = 0; h2 < p; h2++)
        switch (u[h2].once && this.removeListener(t2, u[h2].fn, void 0, true), c) {
          case 1:
            u[h2].fn.call(u[h2].context);
            break;
          case 2:
            u[h2].fn.call(u[h2].context, e2);
            break;
          case 3:
            u[h2].fn.call(u[h2].context, e2, i2);
            break;
          case 4:
            u[h2].fn.call(u[h2].context, e2, i2, n2);
            break;
          default:
            if (!l2)
              for (d = 1, l2 = new Array(c - 1); d < c; d++)
                l2[d - 1] = arguments[d];
            u[h2].fn.apply(u[h2].context, l2);
        }
    }
    return true;
  }, h.prototype.on = function(t2, e2, i2) {
    return a(this, t2, e2, i2, false);
  }, h.prototype.once = function(t2, e2, i2) {
    return a(this, t2, e2, i2, true);
  }, h.prototype.removeListener = function(t2, e2, i2, n2) {
    var o2 = r ? r + t2 : t2;
    if (!this._events[o2])
      return this;
    if (!e2)
      return l(this, o2), this;
    var s2 = this._events[o2];
    if (s2.fn)
      s2.fn !== e2 || n2 && !s2.once || i2 && s2.context !== i2 || l(this, o2);
    else {
      for (var a2 = 0, h2 = [], u = s2.length; a2 < u; a2++)
        (s2[a2].fn !== e2 || n2 && !s2[a2].once || i2 && s2[a2].context !== i2) && h2.push(s2[a2]);
      h2.length ? this._events[o2] = h2.length === 1 ? h2[0] : h2 : l(this, o2);
    }
    return this;
  }, h.prototype.removeAllListeners = function(t2) {
    var e2;
    return t2 ? (e2 = r ? r + t2 : t2, this._events[e2] && l(this, e2)) : (this._events = new o(), this._eventsCount = 0), this;
  }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = r, h.EventEmitter = h, t.exports = h;
}, function(t, e, i) {
  function n(t2, e2, i2) {
    i2 = i2 || 2;
    var n2, o2, a2, l2, h2, u2, p2, f2 = e2 && e2.length, g2 = f2 ? e2[0] * i2 : t2.length, v2 = r(t2, 0, g2, i2, true), _2 = [];
    if (!v2 || v2.next === v2.prev)
      return _2;
    if (f2 && (v2 = function(t3, e3, i3, n3) {
      var o3, s2, a3, l3, h3, u3 = [];
      for (o3 = 0, s2 = e3.length; o3 < s2; o3++)
        a3 = e3[o3] * n3, l3 = o3 < s2 - 1 ? e3[o3 + 1] * n3 : t3.length, (h3 = r(t3, a3, l3, n3, false)) === h3.next && (h3.steiner = true), u3.push(m(h3));
      for (u3.sort(c), o3 = 0; o3 < u3.length; o3++)
        i3 = d(u3[o3], i3);
      return i3;
    }(t2, e2, v2, i2)), t2.length > 80 * i2) {
      n2 = a2 = t2[0], o2 = l2 = t2[1];
      for (var y2 = i2; y2 < g2; y2 += i2)
        (h2 = t2[y2]) < n2 && (n2 = h2), (u2 = t2[y2 + 1]) < o2 && (o2 = u2), h2 > a2 && (a2 = h2), u2 > l2 && (l2 = u2);
      p2 = (p2 = Math.max(a2 - n2, l2 - o2)) !== 0 ? 32767 / p2 : 0;
    }
    return s(v2, _2, i2, n2, o2, p2, 0), _2;
  }
  function r(t2, e2, i2, n2, r2) {
    var o2, s2;
    if (r2 === R(t2, e2, i2, n2) > 0)
      for (o2 = e2; o2 < i2; o2 += n2)
        s2 = w(o2, t2[o2], t2[o2 + 1], s2);
    else
      for (o2 = i2 - n2; o2 >= e2; o2 -= n2)
        s2 = w(o2, t2[o2], t2[o2 + 1], s2);
    return s2 && y(s2, s2.next) && (A(s2), s2 = s2.next), s2;
  }
  function o(t2, e2) {
    if (!t2)
      return t2;
    e2 || (e2 = t2);
    var i2, n2 = t2;
    do {
      if (i2 = false, n2.steiner || !y(n2, n2.next) && _(n2.prev, n2, n2.next) !== 0)
        n2 = n2.next;
      else {
        if (A(n2), (n2 = e2 = n2.prev) === n2.next)
          break;
        i2 = true;
      }
    } while (i2 || n2 !== e2);
    return e2;
  }
  function s(t2, e2, i2, n2, r2, c2, d2) {
    if (t2) {
      !d2 && c2 && function(t3, e3, i3, n3) {
        var r3 = t3;
        do {
          r3.z === 0 && (r3.z = f(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
        } while (r3 !== t3);
        r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
          var e4, i4, n4, r4, o2, s2, a2, l2, h2 = 1;
          do {
            for (i4 = t4, t4 = null, o2 = null, s2 = 0; i4; ) {
              for (s2++, n4 = i4, a2 = 0, e4 = 0; e4 < h2 && (a2++, n4 = n4.nextZ); e4++)
                ;
              for (l2 = h2; a2 > 0 || l2 > 0 && n4; )
                a2 !== 0 && (l2 === 0 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a2--) : (r4 = n4, n4 = n4.nextZ, l2--), o2 ? o2.nextZ = r4 : t4 = r4, r4.prevZ = o2, o2 = r4;
              i4 = n4;
            }
            o2.nextZ = null, h2 *= 2;
          } while (s2 > 1);
        }(r3);
      }(t2, n2, r2, c2);
      for (var p2, m2, g2 = t2; t2.prev !== t2.next; )
        if (p2 = t2.prev, m2 = t2.next, c2 ? l(t2, n2, r2, c2) : a(t2))
          e2.push(p2.i / i2 | 0), e2.push(t2.i / i2 | 0), e2.push(m2.i / i2 | 0), A(t2), t2 = m2.next, g2 = m2.next;
        else if ((t2 = m2) === g2) {
          d2 ? d2 === 1 ? s(t2 = h(o(t2), e2, i2), e2, i2, n2, r2, c2, 2) : d2 === 2 && u(t2, e2, i2, n2, r2, c2) : s(o(t2), e2, i2, n2, r2, c2, 1);
          break;
        }
    }
  }
  function a(t2) {
    var e2 = t2.prev, i2 = t2, n2 = t2.next;
    if (_(e2, i2, n2) >= 0)
      return false;
    for (var r2 = e2.x, o2 = i2.x, s2 = n2.x, a2 = e2.y, l2 = i2.y, h2 = n2.y, u2 = r2 < o2 ? r2 < s2 ? r2 : s2 : o2 < s2 ? o2 : s2, c2 = a2 < l2 ? a2 < h2 ? a2 : h2 : l2 < h2 ? l2 : h2, d2 = r2 > o2 ? r2 > s2 ? r2 : s2 : o2 > s2 ? o2 : s2, p2 = a2 > l2 ? a2 > h2 ? a2 : h2 : l2 > h2 ? l2 : h2, f2 = n2.next; f2 !== e2; ) {
      if (f2.x >= u2 && f2.x <= d2 && f2.y >= c2 && f2.y <= p2 && g(r2, a2, o2, l2, s2, h2, f2.x, f2.y) && _(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.next;
    }
    return true;
  }
  function l(t2, e2, i2, n2) {
    var r2 = t2.prev, o2 = t2, s2 = t2.next;
    if (_(r2, o2, s2) >= 0)
      return false;
    for (var a2 = r2.x, l2 = o2.x, h2 = s2.x, u2 = r2.y, c2 = o2.y, d2 = s2.y, p2 = a2 < l2 ? a2 < h2 ? a2 : h2 : l2 < h2 ? l2 : h2, m2 = u2 < c2 ? u2 < d2 ? u2 : d2 : c2 < d2 ? c2 : d2, v2 = a2 > l2 ? a2 > h2 ? a2 : h2 : l2 > h2 ? l2 : h2, y2 = u2 > c2 ? u2 > d2 ? u2 : d2 : c2 > d2 ? c2 : d2, x2 = f(p2, m2, e2, i2, n2), b2 = f(v2, y2, e2, i2, n2), T2 = t2.prevZ, E2 = t2.nextZ; T2 && T2.z >= x2 && E2 && E2.z <= b2; ) {
      if (T2.x >= p2 && T2.x <= v2 && T2.y >= m2 && T2.y <= y2 && T2 !== r2 && T2 !== s2 && g(a2, u2, l2, c2, h2, d2, T2.x, T2.y) && _(T2.prev, T2, T2.next) >= 0)
        return false;
      if (T2 = T2.prevZ, E2.x >= p2 && E2.x <= v2 && E2.y >= m2 && E2.y <= y2 && E2 !== r2 && E2 !== s2 && g(a2, u2, l2, c2, h2, d2, E2.x, E2.y) && _(E2.prev, E2, E2.next) >= 0)
        return false;
      E2 = E2.nextZ;
    }
    for (; T2 && T2.z >= x2; ) {
      if (T2.x >= p2 && T2.x <= v2 && T2.y >= m2 && T2.y <= y2 && T2 !== r2 && T2 !== s2 && g(a2, u2, l2, c2, h2, d2, T2.x, T2.y) && _(T2.prev, T2, T2.next) >= 0)
        return false;
      T2 = T2.prevZ;
    }
    for (; E2 && E2.z <= b2; ) {
      if (E2.x >= p2 && E2.x <= v2 && E2.y >= m2 && E2.y <= y2 && E2 !== r2 && E2 !== s2 && g(a2, u2, l2, c2, h2, d2, E2.x, E2.y) && _(E2.prev, E2, E2.next) >= 0)
        return false;
      E2 = E2.nextZ;
    }
    return true;
  }
  function h(t2, e2, i2) {
    var n2 = t2;
    do {
      var r2 = n2.prev, s2 = n2.next.next;
      !y(r2, s2) && x(r2, n2, n2.next, s2) && E(r2, s2) && E(s2, r2) && (e2.push(r2.i / i2 | 0), e2.push(n2.i / i2 | 0), e2.push(s2.i / i2 | 0), A(n2), A(n2.next), n2 = t2 = s2), n2 = n2.next;
    } while (n2 !== t2);
    return o(n2);
  }
  function u(t2, e2, i2, n2, r2, a2) {
    var l2 = t2;
    do {
      for (var h2 = l2.next.next; h2 !== l2.prev; ) {
        if (l2.i !== h2.i && v(l2, h2)) {
          var u2 = S(l2, h2);
          return l2 = o(l2, l2.next), u2 = o(u2, u2.next), s(l2, e2, i2, n2, r2, a2, 0), void s(u2, e2, i2, n2, r2, a2, 0);
        }
        h2 = h2.next;
      }
      l2 = l2.next;
    } while (l2 !== t2);
  }
  function c(t2, e2) {
    return t2.x - e2.x;
  }
  function d(t2, e2) {
    var i2 = function(t3, e3) {
      var i3, n3 = e3, r2 = t3.x, o2 = t3.y, s2 = -1 / 0;
      do {
        if (o2 <= n3.y && o2 >= n3.next.y && n3.next.y !== n3.y) {
          var a2 = n3.x + (o2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
          if (a2 <= r2 && a2 > s2 && (s2 = a2, i3 = n3.x < n3.next.x ? n3 : n3.next, a2 === r2))
            return i3;
        }
        n3 = n3.next;
      } while (n3 !== e3);
      if (!i3)
        return null;
      var l2, h2 = i3, u2 = i3.x, c2 = i3.y, d2 = 1 / 0;
      n3 = i3;
      do {
        r2 >= n3.x && n3.x >= u2 && r2 !== n3.x && g(o2 < c2 ? r2 : s2, o2, u2, c2, o2 < c2 ? s2 : r2, o2, n3.x, n3.y) && (l2 = Math.abs(o2 - n3.y) / (r2 - n3.x), E(n3, t3) && (l2 < d2 || l2 === d2 && (n3.x > i3.x || n3.x === i3.x && p(i3, n3))) && (i3 = n3, d2 = l2)), n3 = n3.next;
      } while (n3 !== h2);
      return i3;
    }(t2, e2);
    if (!i2)
      return e2;
    var n2 = S(i2, t2);
    return o(n2, n2.next), o(i2, i2.next);
  }
  function p(t2, e2) {
    return _(t2.prev, t2, e2.prev) < 0 && _(e2.next, t2, t2.next) < 0;
  }
  function f(t2, e2, i2, n2, r2) {
    return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - i2) * r2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * r2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
  }
  function m(t2) {
    var e2 = t2, i2 = t2;
    do {
      (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
    } while (e2 !== t2);
    return i2;
  }
  function g(t2, e2, i2, n2, r2, o2, s2, a2) {
    return (r2 - s2) * (e2 - a2) >= (t2 - s2) * (o2 - a2) && (t2 - s2) * (n2 - a2) >= (i2 - s2) * (e2 - a2) && (i2 - s2) * (o2 - a2) >= (r2 - s2) * (n2 - a2);
  }
  function v(t2, e2) {
    return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
      var i2 = t3;
      do {
        if (i2.i !== t3.i && i2.next.i !== t3.i && i2.i !== e3.i && i2.next.i !== e3.i && x(i2, i2.next, t3, e3))
          return true;
        i2 = i2.next;
      } while (i2 !== t3);
      return false;
    }(t2, e2) && (E(t2, e2) && E(e2, t2) && function(t3, e3) {
      var i2 = t3, n2 = false, r2 = (t3.x + e3.x) / 2, o2 = (t3.y + e3.y) / 2;
      do {
        i2.y > o2 != i2.next.y > o2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (o2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
      } while (i2 !== t3);
      return n2;
    }(t2, e2) && (_(t2.prev, t2, e2.prev) || _(t2, e2.prev, e2)) || y(t2, e2) && _(t2.prev, t2, t2.next) > 0 && _(e2.prev, e2, e2.next) > 0);
  }
  function _(t2, e2, i2) {
    return (e2.y - t2.y) * (i2.x - e2.x) - (e2.x - t2.x) * (i2.y - e2.y);
  }
  function y(t2, e2) {
    return t2.x === e2.x && t2.y === e2.y;
  }
  function x(t2, e2, i2, n2) {
    var r2 = T(_(t2, e2, i2)), o2 = T(_(t2, e2, n2)), s2 = T(_(i2, n2, t2)), a2 = T(_(i2, n2, e2));
    return r2 !== o2 && s2 !== a2 || (!(r2 !== 0 || !b(t2, i2, e2)) || (!(o2 !== 0 || !b(t2, n2, e2)) || (!(s2 !== 0 || !b(i2, t2, n2)) || !(a2 !== 0 || !b(i2, e2, n2)))));
  }
  function b(t2, e2, i2) {
    return e2.x <= Math.max(t2.x, i2.x) && e2.x >= Math.min(t2.x, i2.x) && e2.y <= Math.max(t2.y, i2.y) && e2.y >= Math.min(t2.y, i2.y);
  }
  function T(t2) {
    return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
  }
  function E(t2, e2) {
    return _(t2.prev, t2, t2.next) < 0 ? _(t2, e2, t2.next) >= 0 && _(t2, t2.prev, e2) >= 0 : _(t2, e2, t2.prev) < 0 || _(t2, t2.next, e2) < 0;
  }
  function S(t2, e2) {
    var i2 = new M(t2.i, t2.x, t2.y), n2 = new M(e2.i, e2.x, e2.y), r2 = t2.next, o2 = e2.prev;
    return t2.next = e2, e2.prev = t2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, o2.next = n2, n2.prev = o2, n2;
  }
  function w(t2, e2, i2, n2) {
    var r2 = new M(t2, e2, i2);
    return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
  }
  function A(t2) {
    t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
  }
  function M(t2, e2, i2) {
    this.i = t2, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function R(t2, e2, i2, n2) {
    for (var r2 = 0, o2 = e2, s2 = i2 - n2; o2 < i2; o2 += n2)
      r2 += (t2[s2] - t2[o2]) * (t2[o2 + 1] + t2[s2 + 1]), s2 = o2;
    return r2;
  }
  t.exports = n, t.exports.default = n, n.deviation = function(t2, e2, i2, n2) {
    var r2 = e2 && e2.length, o2 = r2 ? e2[0] * i2 : t2.length, s2 = Math.abs(R(t2, 0, o2, i2));
    if (r2)
      for (var a2 = 0, l2 = e2.length; a2 < l2; a2++) {
        var h2 = e2[a2] * i2, u2 = a2 < l2 - 1 ? e2[a2 + 1] * i2 : t2.length;
        s2 -= Math.abs(R(t2, h2, u2, i2));
      }
    var c2 = 0;
    for (a2 = 0; a2 < n2.length; a2 += 3) {
      var d2 = n2[a2] * i2, p2 = n2[a2 + 1] * i2, f2 = n2[a2 + 2] * i2;
      c2 += Math.abs((t2[d2] - t2[f2]) * (t2[p2 + 1] - t2[d2 + 1]) - (t2[d2] - t2[p2]) * (t2[f2 + 1] - t2[d2 + 1]));
    }
    return s2 === 0 && c2 === 0 ? 0 : Math.abs((c2 - s2) / s2);
  }, n.flatten = function(t2) {
    for (var e2 = t2[0][0].length, i2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, r2 = 0; r2 < t2.length; r2++) {
      for (var o2 = 0; o2 < t2[r2].length; o2++)
        for (var s2 = 0; s2 < e2; s2++)
          i2.vertices.push(t2[r2][o2][s2]);
      r2 > 0 && (n2 += t2[r2 - 1].length, i2.holes.push(n2));
    }
    return i2;
  };
}, function(t, e, i) {
  var n = i(26), r = i(157), o = i(158), s = i(159), a = i(160), l = i(161);
  function h(t2) {
    var e2 = this.__data__ = new n(t2);
    this.size = e2.size;
  }
  h.prototype.clear = r, h.prototype.delete = o, h.prototype.get = s, h.prototype.has = a, h.prototype.set = l, t.exports = h;
}, function(t, e) {
  var i = Function.prototype.toString;
  t.exports = function(t2) {
    if (t2 != null) {
      try {
        return i.call(t2);
      } catch (t3) {
      }
      try {
        return t2 + "";
      } catch (t3) {
      }
    }
    return "";
  };
}, function(t, e, i) {
  var n = i(166), r = i(173), o = i(175), s = i(176), a = i(177);
  function l(t2) {
    var e2 = -1, i2 = t2 == null ? 0 : t2.length;
    for (this.clear(); ++e2 < i2; ) {
      var n2 = t2[e2];
      this.set(n2[0], n2[1]);
    }
  }
  l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
}, function(t, e, i) {
  var n = i(178), r = i(181), o = i(182);
  t.exports = function(t2, e2, i2, s, a, l) {
    var h = 1 & i2, u = t2.length, c = e2.length;
    if (u != c && !(h && c > u))
      return false;
    var d = l.get(t2), p = l.get(e2);
    if (d && p)
      return d == e2 && p == t2;
    var f = -1, m = true, g = 2 & i2 ? new n() : void 0;
    for (l.set(t2, e2), l.set(e2, t2); ++f < u; ) {
      var v = t2[f], _ = e2[f];
      if (s)
        var y = h ? s(_, v, f, e2, t2, l) : s(v, _, f, t2, e2, l);
      if (y !== void 0) {
        if (y)
          continue;
        m = false;
        break;
      }
      if (g) {
        if (!r(e2, function(t3, e3) {
          if (!o(g, e3) && (v === t3 || a(v, t3, i2, s, l)))
            return g.push(e3);
        })) {
          m = false;
          break;
        }
      } else if (v !== _ && !a(v, _, i2, s, l)) {
        m = false;
        break;
      }
    }
    return l.delete(t2), l.delete(e2), m;
  };
}, function(t, e, i) {
  var n = i(14).Uint8Array;
  t.exports = n;
}, function(t, e, i) {
  var n = i(60), r = i(38), o = i(39);
  t.exports = function(t2) {
    return n(t2, o, r);
  };
}, function(t, e, i) {
  var n = i(61), r = i(30);
  t.exports = function(t2, e2, i2) {
    var o = e2(t2);
    return r(t2) ? o : n(o, i2(t2));
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    for (var i = -1, n = e2.length, r = t2.length; ++i < n; )
      t2[r + i] = e2[i];
    return t2;
  };
}, function(t, e) {
  t.exports = function() {
    return [];
  };
}, function(t, e, i) {
  var n = i(188), r = i(189), o = i(30), s = i(40), a = i(192), l = i(64), h = Object.prototype.hasOwnProperty;
  t.exports = function(t2, e2) {
    var i2 = o(t2), u = !i2 && r(t2), c = !i2 && !u && s(t2), d = !i2 && !u && !c && l(t2), p = i2 || u || c || d, f = p ? n(t2.length, String) : [], m = f.length;
    for (var g in t2)
      !e2 && !h.call(t2, g) || p && (g == "length" || c && (g == "offset" || g == "parent") || d && (g == "buffer" || g == "byteLength" || g == "byteOffset") || a(g, m)) || f.push(g);
    return f;
  };
}, function(t, e, i) {
  var n = i(193), r = i(41), o = i(42), s = o && o.isTypedArray, a = s ? r(s) : n;
  t.exports = a;
}, function(t, e) {
  t.exports = function(t2) {
    return typeof t2 == "number" && t2 > -1 && t2 % 1 == 0 && t2 <= 9007199254740991;
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    return function(i) {
      return t2(e2(i));
    };
  };
}, function(t, e, i) {
  var n = i(33), r = i(65);
  t.exports = function(t2) {
    return t2 != null && r(t2.length) && !n(t2);
  };
}, function(t, e, i) {
  var n = i(69), r = i(36), o = Object.prototype.hasOwnProperty;
  t.exports = function(t2, e2, i2) {
    var s = t2[e2];
    o.call(t2, e2) && r(s, i2) && (i2 !== void 0 || e2 in t2) || n(t2, e2, i2);
  };
}, function(t, e, i) {
  var n = i(207);
  t.exports = function(t2, e2, i2) {
    e2 == "__proto__" && n ? n(t2, e2, { configurable: true, enumerable: true, value: i2, writable: true }) : t2[e2] = i2;
  };
}, function(t, e, i) {
  var n = i(61), r = i(71), o = i(38), s = i(62), a = Object.getOwnPropertySymbols ? function(t2) {
    for (var e2 = []; t2; )
      n(e2, o(t2)), t2 = r(t2);
    return e2;
  } : s;
  t.exports = a;
}, function(t, e, i) {
  var n = i(66)(Object.getPrototypeOf, Object);
  t.exports = n;
}, function(t, e) {
  t.exports = "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform float lines[26];\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float direction;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float middleAlpha = 0.0;\n	float endAlpha = 0.0;\n	float headLength = 0.0;\n	if (timePercent < 0.5) {\n		middleAlpha = 1.0;\n		endAlpha = 1.0 - (timePercent / 0.5);\n	}\n	else {\n		middleAlpha = 1.0 - ((timePercent - 0.5) / 0.5);\n		endAlpha = 0.0;\n	}\n	for (int i = 0; i < 26; i++) {\n		float halfDis = lines[i] / 2.0;\n		float middle = headLength + halfDis;\n		headLength += lines[i];\n		if ((direction > 0.9) && (direction < 1.1)) {\n			if (abs(vUv.y - middle) <= halfDis) {\n				srcColor.a = endAlpha + (((halfDis - abs(vUv.y - middle)) / halfDis) * (middleAlpha - endAlpha));\n				gl_FragColor = blendSrcOver(srcColor, distColor);\n				return ;\n			}\n		}\n		else {\n			if (abs(vUv.x - middle) <= halfDis) {\n				srcColor.a = endAlpha + (((halfDis - abs(vUv.x - middle)) / halfDis) * (middleAlpha - endAlpha));\n				gl_FragColor = blendSrcOver(srcColor, distColor);\n				return ;\n			}\n		}\n	}\n	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	vec2 uv = vec2(vUv.x, vUv.y);\n	maxR = length(transform(vec2(1.0, 1.0)));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	dist = length(transform(uv));\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvec2 transformTo(vec2 uv, vec2 origin) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(origin.x, (origin.y * height) / width);\n}\nvec2 offset(float progress[4], float band, float amp, float radius, vec2 centerPosition) {\n	vec2 tc = vUv.xy;\n	vec2 uv = vec2(0.0, 0.0);\n	vec2 p;\n	float len;\n	vec2 uv_offset;\n	float wave_width = band * radius;\n	for (int i = 0; i < 4; i += 1) {\n		if (progress[i] == -1.0) {\n			continue;\n		}\n		p = tc - centerPosition;\n		p.x = (p.x * width) / height;\n		len = length(p);\n		float current_progress = progress[i];\n		float current_radius = radius * current_progress;\n		float damp_factor = 1.0;\n		if (current_progress > .5) {\n			damp_factor = (1.0 - current_progress) * 2.0;\n		}\n		float cut_factor = clamp((wave_width * damp_factor) - abs(current_radius - len), 0.0, 1.0);\n		float waves_factor = (4.0 * len) / radius;\n		uv_offset = (((p / len) * cos((waves_factor - (current_progress * 10.0)) * 3.14)) * amp) * cut_factor;\n		uv += uv_offset;\n	}\n	return uv;\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	float progress[4];\n	vec2 uv = vUv.xy;\n	vec2 uvOffset = vec2(0.0, 0.0);\n	vec2 startPosition = vec2(0.5, 0.5);\n	float redius = 2.0;\n	if (option == 1) {\n		startPosition = vec2(0.0, 0.0);\n	}\n	else if (option == 2) {\n		startPosition = vec2(1.0, 0.0);\n	}\n	else if (option == 3) {\n		startPosition = vec2(1.0, 1.0);\n	}\n	else if (option == 4) {\n		startPosition = vec2(0.0, 1.0);\n	}\n	maxR = length(transformTo(vec2(1.0, 1.0), vec2(0.0, 0.0)));\n	if (option == 0) {\n		maxR = maxR / 2.0;\n		redius = redius / 2.0;\n	}\n	dist = length(transformTo(uv, startPosition));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	for (int i = 0; i < 4; i++) {\n		progress[i] = timePercent + (0.1 * float(i));\n		if (progress[i] < 0.0) {\n			progress[i] = 0.0;\n		}\n	}\n	uvOffset = offset(progress, 0.2, 0.3, redius, startPosition);\n	vec4 srcColor = texture2D(texturePrev, fract(vUv + uvOffset));\n	vec4 distColor = texture2D(textureNext, fract(vUv + uvOffset));\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alphaStart;\n	float alphaEnd;\n	float rectStart;\n	float rectEnd;\n	bool isRevert = option > 1 ? true : false;\n	if (timePercent <= 0.33) {\n		alphaStart = isRevert ? 1.0 - (timePercent / 0.33) : 1.0;\n		alphaEnd = isRevert ? 1.0 : 1.0 - (timePercent / 0.33);\n		rectStart = isRevert ? 0.0 : 0.5;\n		rectEnd = isRevert ? 0.5 : 1.0;\n	}\n	else if ((timePercent > 0.33) && (timePercent <= 0.66)) {\n		alphaStart = isRevert ? 0.0 : 1.0;\n		alphaEnd = isRevert ? 1.0 : 0.0;\n		rectEnd = isRevert ? (((timePercent - 0.33) / 0.33) * 0.5) + 0.5 : 1.0 - (((timePercent - 0.33) / 0.33) * 0.5);\n		rectStart = rectEnd - 0.5;\n	}\n	else {\n		alphaStart = isRevert ? 0.0 : (1.0 - timePercent) / (1.0 - 0.66);\n		alphaEnd = isRevert ? (1.0 - timePercent) / (1.0 - 0.66) : 0.0;\n		rectStart = isRevert ? 0.5 : 0.0;\n		rectEnd = isRevert ? 1.0 : 0.5;\n	}\n	float changAxis = (option % 2) == 0 ? vUv.x : vUv.y;\n	if (changAxis >= rectEnd) {\n		srcColor.a = isRevert ? 1.0 : 0.0;\n	}\n	else if (changAxis <= rectStart) {\n		srcColor.a = isRevert ? 0.0 : 1.0;\n	}\n	else {\n		srcColor.a = alphaStart + (((changAxis - rectStart) / 0.5) * (alphaEnd - alphaStart));\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform sampler2D dissolveTexture;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 dissolveColor = texture2D(dissolveTexture, vUv);\n	if (dissolveColor.r == 0.0) {\n		result = srcColor;\n	}\n	else {\n		result = distColor;\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	if (timePercent < 0.5) {\n		float stagePercent = timePercent / 0.5;\n		result = srcColor + (stagePercent * (1.0 - srcColor));\n	}\n	else {\n		float stagePercent = (timePercent - 0.5) / 0.5;\n		result = 1.0 - (stagePercent * (1.0 - distColor));\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	if (option == 1) {\n		if (timePercent < 0.5) {\n			srcColor.rgb *= (1.0 - (timePercent * 2.0));\n			gl_FragColor = srcColor;\n		}\n		else {\n			distColor.rgb *= ((timePercent - 0.5) * 2.0);\n			gl_FragColor = distColor;\n		}\n	}\n	else {\n		srcColor.a = 1.0 - timePercent;\n		gl_FragColor = blendSrcOver(srcColor, distColor);\n	}\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float changeAxis = (option % 2) == 1 ? vUv.x : vUv.y;\n	bool changeAxisX = (option % 2) == 1;\n	bool isRevert = option > 1;\n	float line;\n	if (isRevert) {\n		line = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 3);\n	}\n	else {\n		line = interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 3);\n	}\n	vec2 uv = vUv.xy;\n	if (changeAxis > line) {\n		if (changeAxisX) {\n			uv.x -= line;\n		}\n		else {\n			uv.y -= line;\n		}\n	}\n	else {\n		if (changeAxisX) {\n			uv.x += (1.0 - line);\n		}\n		else {\n			uv.y += (1.0 - line);\n		}\n	}\n	if (isRevert) {\n		result = changeAxis > line ? texture2D(textureNext, uv) : texture2D(texturePrev, uv);\n	}\n	else {\n		result = changeAxis > line ? texture2D(texturePrev, uv) : texture2D(textureNext, uv);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform bool direction;\nuniform bool orient;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec2 rectLeft = direction ? vec2(0.25, 0.0) : vec2(0.25, 0.5);\n	vec2 rectRight = direction ? vec2(1, 0.75) : vec2(0.5, 0.75);\n	vec2 alphaLeft = vec2(1.0, 1.0);\n	vec2 alphaRight = vec2(1.0, 1.0);\n	if (timePercent <= 0.333) {\n		alphaLeft.y = 1.0 - (timePercent / 0.333);\n		alphaRight.x = 1.0 - (timePercent / 0.333);\n	}\n	else if ((timePercent <= 0.666) && (timePercent > 0.333)) {\n		rectLeft.x = direction ? (((timePercent - 0.333) / 0.333) * 0.25) + rectLeft.x : rectLeft.x - (((timePercent - 0.333) / 0.333) * 0.25);\n		rectLeft.y = direction ? rectLeft.x - 0.25 : rectLeft.x + 0.25;\n		rectRight.y = direction ? rectRight.y - (((timePercent - 0.333) / 0.333) * 0.25) : rectRight.y + (((timePercent - 0.333) / 0.333) * 0.25);\n		rectRight.x = direction ? rectRight.y + 0.25 : rectRight.y - 0.25;\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n	}\n	else {\n		rectLeft = direction ? vec2(0.5, 0.25) : vec2(0.0, 0.25);\n		rectRight = direction ? vec2(0.75, 0.5) : vec2(0.75, 1.0);\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n		alphaLeft.x = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n		alphaRight.y = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n	}\n	float axis = orient ? vUv.x : vUv.y;\n	if (direction) {\n		if ((axis < rectLeft.y) || (axis > rectRight.x)) {\n			srcColor.a = 0.0;\n		}\n		else if ((axis > rectLeft.x) && (axis < rectRight.y)) {\n			srcColor.a = 1.0;\n		}\n		else {\n			if ((axis < rectLeft.x) && (axis > rectLeft.y)) {\n				srcColor.a = alphaLeft.y - (((axis - rectLeft.y) / (rectLeft.x - rectLeft.y)) * (alphaLeft.y - alphaLeft.x));\n			}\n			else {\n				srcColor.a = alphaRight.x - (((rectRight.x - axis) / (rectLeft.x - rectLeft.y)) * (alphaRight.x - alphaRight.y));\n			}\n		}\n	}\n	else {\n		if ((axis < rectLeft.x) || (axis > rectRight.y)) {\n			srcColor.a = 1.0;\n		}\n		else if ((axis > rectLeft.y) && (axis < rectRight.x)) {\n			srcColor.a = 0.0;\n		}\n		else {\n			if ((axis >= rectLeft.x) && (axis <= rectLeft.y)) {\n				srcColor.a = alphaLeft.x - (((axis - rectLeft.x) / (rectLeft.y - rectLeft.x)) * (alphaLeft.x - alphaLeft.y));\n			}\n			else {\n				srcColor.a = alphaRight.y - (((rectRight.y - axis) / (rectLeft.y - rectLeft.x)) * (alphaRight.y - alphaRight.x));\n			}\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform bool direction;\nuniform bool thruBlk;\nvarying vec2 vUv;\nvoid main() {\n	vec4 uv4 = vec4(vUv.xy, 1.0, 1.0);\n	float scale;\n	float transform;\n	if (timePercent < 0.5) {\n		scale = 1.0 - ((timePercent / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	else {\n		scale = 0.95 + (((timePercent - 0.5) / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	mat4 matrix = mat4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, transform, transform, 0.0, 1.0);\n	vec4 uv = matrix * uv4;\n	vec4 srcColor = texture2D(texturePrev, uv.xy);\n	vec4 distColor = texture2D(textureNext, uv.xy);\n	vec4 result = timePercent < 0.5 ? srcColor : distColor;\n	vec3 start;\n	vec3 end;\n	vec3 middleColor = thruBlk ? vec3(0.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n	if ((timePercent < 0.25) || (timePercent > 0.75)) {\n		result *= 1.0;\n	}\n	else if ((timePercent >= 0.25) && (timePercent <= 0.5)) {\n		if (timePercent <= 0.375) {\n			start = result.rgb;\n			end = start + (((timePercent - 0.25) / 0.125) * (middleColor - result.rgb));\n		}\n		else {\n			start = result.rgb + (((timePercent - 0.375) / 0.125) * (middleColor - result.rgb));\n			end = middleColor;\n		}\n		result = direction ? vec4(end - (vUv.x * (end - start)), result.a) : vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	else if ((timePercent > 0.5) && (timePercent <= 0.75)) {\n		if (timePercent < 0.625) {\n			start = middleColor - (((timePercent - 0.5) / 0.125) * (middleColor - result.rgb));\n			end = middleColor;\n		}\n		else {\n			start = result.rgb;\n			end = middleColor - (((timePercent - 0.625) / 0.125) * (middleColor - result.rgb));\n		}\n		result = direction ? vec4(end - (vUv.x * (end - start)), result.a) : vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int optionX;\nuniform int optionY;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float lineX = optionX > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	float lineY = optionY > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	vec2 uv = vUv.xy;\n	if ((optionX < 0) && (vUv.x <= lineX)) {\n		uv.x += (1.0 - lineX);\n	}\n	if ((optionX > 0) && (vUv.x >= lineX)) {\n		uv.x -= lineX;\n	}\n	if ((optionY < 0) && (vUv.y <= lineY)) {\n		uv.y += (1.0 - lineY);\n	}\n	if ((optionY > 0) && (vUv.y >= lineY)) {\n		uv.y -= lineY;\n	}\n	if ((optionX != 0) && (optionY == 0)) {\n		if (optionX > 0) {\n			result = vUv.x > lineX ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = vUv.x > lineX ? texture2D(textureNext, vUv) : texture2D(texturePrev, uv);\n		}\n	}\n	if ((optionX == 0) && (optionY != 0)) {\n		if (optionY > 0) {\n			result = vUv.y > lineY ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = vUv.y > lineY ? texture2D(textureNext, vUv) : texture2D(texturePrev, uv);\n		}\n	}\n	if ((optionX != 0) && (optionY != 0)) {\n		if ((optionX > 0) && (optionY > 0)) {\n			result = (vUv.x > lineX) && (vUv.y > lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else if ((optionX > 0) && (optionY < 0)) {\n			result = (vUv.x > lineX) && (vUv.y < lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else if ((optionX < 0) && (optionY > 0)) {\n			result = (vUv.x < lineX) && (vUv.y > lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = (vUv.x < lineX) && (vUv.y < lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int optionX;\nuniform int optionY;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float lineX = optionX > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	float lineY = optionY > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	vec2 uv = vUv.xy;\n	if ((optionX < 0) && (vUv.x > lineX)) {\n		uv.x -= lineX;\n	}\n	if ((optionX > 0) && (vUv.x < lineX)) {\n		uv.x += (1.0 - lineX);\n	}\n	if ((optionY < 0) && (vUv.y > lineY)) {\n		uv.y -= lineY;\n	}\n	if ((optionY > 0) && (vUv.y < lineY)) {\n		uv.y += (1.0 - lineY);\n	}\n	if ((optionX != 0) && (optionY == 0)) {\n		if (optionX > 0) {\n			result = vUv.x > lineX ? texture2D(texturePrev, vUv) : texture2D(textureNext, uv);\n		}\n		else {\n			result = vUv.x > lineX ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	if ((optionX == 0) && (optionY != 0)) {\n		if (optionY > 0) {\n			result = vUv.y > lineY ? texture2D(texturePrev, vUv) : texture2D(textureNext, uv);\n		}\n		else {\n			result = vUv.y > lineY ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	if ((optionX != 0) && (optionY != 0)) {\n		if ((optionX > 0) && (optionY > 0)) {\n			result = (vUv.x < lineX) && (vUv.y < lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else if ((optionX > 0) && (optionY < 0)) {\n			result = (vUv.x < lineX) && (vUv.y > lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else if ((optionX < 0) && (optionY > 0)) {\n			result = (vUv.x > lineX) && (vUv.y < lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else {\n			result = (vUv.x > lineX) && (vUv.y > lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	gl_FragColor = result;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 result;\n	float resultAlpha;\n	if (timePercent < 0.5) {\n		result = srcColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(0.0, 1.0, 0.0, 0.5, timePercent, 0);\n		resultAlpha = srcColor.a;\n	}\n	else {\n		result = distColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(1.0, 0.0, 0.5, 1.0, timePercent, 0);\n		resultAlpha = distColor.a;\n	}\n	result *= yuv2rgb;\n	gl_FragColor = vec4(result.rgb, resultAlpha);\n}\n";
}, function(t, e) {
  t.exports = "uniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute vec2 segment;\nattribute float times;\nattribute int option;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	vec4 newPosition = vec4(position, 1.0);\n	vec2 segmentOrigin = vec2(((segment.x + 0.5) * segmentWidth) - (width * 0.5), (height * 0.5) - ((1.0 * (segment.y + 0.5)) * segmentHeight));\n	if (timePercent > times) {\n		float percent = (timePercent - times) / 0.7;\n		if (percent > 1.0) {\n			percent = 1.0;\n		}\n		if (percent > 0.5) {\n			percent += 1.0;\n		}\n		mat4 matrix = mat4(cos((-1.0 * percent) * 3.14), 0.0, sin((-1.0 * percent) * 3.14), 0.0, 0.0, 1.0, 0.0, 0.0, -sin((-1.0 * percent) * 3.14), 0.0, cos((-1.0 * percent) * 3.14), 0.0, 0.0, 0.0, 0.0, 1.0);\n		if (option == 1) {\n			matrix = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(percent * 3.14), -sin(percent * 3.14), 0.0, 0.0, sin(percent * 3.13), cos(percent * 3.14), 0.0, 0.0, 0.0, 0.0, 1.0);\n		}\n		newPosition.x -= segmentOrigin.x;\n		newPosition.y -= segmentOrigin.y;\n		newPosition = matrix * newPosition;\n		newPosition.x += segmentOrigin.x;\n		newPosition.y += segmentOrigin.y;\n		if (segment.x < (horizontalSegments / 2.0)) {\n			fakePercent = percent - (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n		else {\n			fakePercent = percent + (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (fakePercent > 0.5) {\n		color = distColor;\n	}\n	if ((fakePercent < 0.5) && (fakePercent > 0.35)) {\n		color.a = 0.5;\n	}\n	gl_FragColor = color;\n}\n";
}, function(t, e) {
  t.exports = "#define PI 3.14159265\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform float duration;\nattribute vec2 segment;\nattribute float times;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	mat4 matrix;\n	float stagePercent;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfTimePercent = (timePercent - times) / (4.0 / 5.0);\n	if (selfTimePercent < 0.0) {\n		selfTimePercent = 0.0;\n	}\n	else if (selfTimePercent > 1.0) {\n		selfTimePercent = 1.0;\n	}\n	if (selfTimePercent < (2.0 / 5.0)) {\n		stagePercent = selfTimePercent / (2.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 0.5);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n	}\n	else if ((selfTimePercent >= (2.0 / 5.0)) && (selfTimePercent < (3.0 / 5.0))) {\n		stagePercent = (selfTimePercent - (2.0 / 5.0)) / (1.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		newPosition = rotateY((-1.0 * PI) * 0.5) * newPosition;\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 2.0);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= (width * stagePercent);\n	}\n	else {\n		float offset = (((newPosition.x + (0.5 * width)) / width) * 2.0) / 5.0;\n		stagePercent = (selfTimePercent - (1.0 / 5.0)) / ((2.0 / 5.0) + offset);\n		if (stagePercent > 1.0) {\n			stagePercent = 1.0;\n		}\n		vec4 vvUvv = vec4(vUv.x - 0.5, vUv.y - 0.5, 0.0, 1.0);\n		vvUvv = rotateY(-1.0 * PI) * vvUvv;\n		vUv = vvUvv.xy + 0.5;\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY((((-1.0 * stagePercent) * PI) * 0.5) - (PI * 2.5));\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= width;\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		vUv = uv;\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (timePercent > 0.5) {\n		color = distColor;\n	}\n	if (timePercent < 0.0001) {\n		color = srcColor;\n	}\n	else if (timePercent > 0.9999) {\n		color = distColor;\n	}\n	gl_FragColor = color;\n}\n";
}, function(t, e) {
  t.exports = "#define PI 3.14159265\nattribute float index;\nattribute float type;\nattribute float delay;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segments;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	vType = type;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfPercent = (timePercent - delay) / 0.7;\n	rotatePercent = selfPercent;\n	if (selfPercent < 0.0) {\n		selfPercent = 0.0;\n	}\n	else if (selfPercent > 1.0) {\n		selfPercent = 1.0;\n	}\n	float offsetX = ((segments * segmentWidth) * 0.5) - ((index + 0.5) * segmentWidth);\n	float offsetZ = segmentWidth * 0.5;\n	newPosition.x += offsetX;\n	newPosition.z += offsetZ;\n	newPosition.x *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition.z *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition = rotateY((PI * 0.5) * selfPercent) * newPosition;\n	newPosition.x -= offsetX;\n	newPosition.z -= offsetZ;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 srcYuv;\n	vec3 distYuv;\n	if (rotatePercent < 0.5) {\n		distYuv = distColor.rgb * rgb2yuv;\n		distYuv.r *= (1.0 - (abs(rotatePercent - 0.5) / 0.5));\n		distColor = vec4(distYuv * yuv2rgb, distColor.a);\n	}\n	else {\n		srcYuv = distColor.rgb * rgb2yuv;\n		srcYuv.r *= (abs(rotatePercent - 0.5) / 0.5);\n		srcColor = vec4(srcYuv * yuv2rgb, srcColor.a);\n	}\n	vec4 color = vType < 0.5 ? srcColor : distColor;\n	gl_FragColor = color;\n}\n";
}, function(t, e) {
  t.exports = "float easeInFloat(float t, float b, float c, float d) {\n	t = t / d;\n	return ((c * t) * t) + b;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.141592653\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute float isLeft;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vUv = uv;\n	float scaleX;\n	float transform;\n	float displacement;\n	vec4 newPosition = vec4(position, 1.0);\n	vec4 glPosition = (projectionMatrix * modelViewMatrix) * newPosition;\n	float crestCount = 24.0;\n	float width = horizontalSegments * segmentWidth;\n	float height = verticalSegments * segmentHeight;\n	float heightFactor = (newPosition.y + (height * 0.5)) / height;\n	float scaleY = interpolationFloat(1.0, 1.05, 0.0, 0.11, timePercent, 0);\n	newPosition.y += (height * 0.5);\n	newPosition.y *= scaleY;\n	newPosition.y -= (height * 0.5);\n	newPosition.y += 10.0;\n	if ((timePercent > 0.0) && (timePercent < 0.333)) {\n		float delay = (1.0 - heightFactor) * 0.1;\n		scaleX = interpolationFloat(1.0, 0.5, 0.0 + delay, 0.333, timePercent, 1);\n	}\n	else if ((timePercent >= 0.333) && (timePercent < 0.5)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.25, 0.333, 0.5, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if ((timePercent >= 0.5) && (timePercent < 0.583)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.25, 0.5, 0.5, 0.583, timePercent, 1);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if (timePercent >= 0.583) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.75, 0.583, 0.666, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop + incr;\n	}\n	if (timePercent > 0.583) {\n		displacement = (isLeft < 0.5 ? 1.0 : -1.0) * interpolationFloat(0.0, width / 2.0, 0.583, 1.0, timePercent, 0);\n	}\n	float ampTop = interpolationFloat(0.0, 1.0, 0.0, 0.11, timePercent, 0);\n	float ampBottom = interpolationFloat(0.0, 1.0, 0.11, 0.22, timePercent, 0);\n	float amp = ampBottom + (heightFactor * abs(ampBottom - ampTop));\n	float foo = newPosition.x * ((crestCount * PI) / width);\n	newPosition.z = (amp * cos(foo + (PI / 2.0))) * 20.0;\n	transform = (isLeft < 0.5 ? -1.0 : 1.0) * (width * 0.5);\n	newPosition.x += transform;\n	newPosition.x *= scaleX;\n	newPosition.x -= transform;\n	newPosition.x += displacement;\n	shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	if (newPosition.z < 15.0) {\n		float alpha = 0.3 * (1.0 - ((newPosition.z + 20.0) / 35.0));\n		shadow.a = alpha * amp;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = blendSrcOver(shadow, srcColor);\n	gl_FragColor = color;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265\nuniform float timePercent;\nuniform float aCoefficient;\nuniform float zCurveLimit;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float curve;\n	float progress = option == 1 ? halfWidth - newPosition.x : newPosition.x + halfWidth;\n	float aStart = interpolationFloat(0.00000009, aCoefficient, 0.0, 0.5, timePercent, 0);\n	float aEnd = 0.0000009;\n	float zStart = interpolationFloat(0.0, zCurveLimit, 0.0, 0.5, timePercent, 0);\n	float zEnd = 0.0;\n	float a = interpolationFloat(aStart, aEnd, 0.0, halfWidth * 2.0, progress, 0);\n	float z = interpolationFloat(zStart, zEnd, 0.0, halfWidth * 2.0, progress, 0);\n	newPosition.z -= (((-a * newPosition.y) * newPosition.y) + z);\n	float scaleYStart = interpolationFloat(1.0, 0.8, 0.0, 0.5, timePercent, 0);\n	float scaleYEnd = 1.0;\n	float scaleY = interpolationFloat(scaleYStart, scaleYEnd, 0.0, halfWidth * 2.0, progress, 0);\n	newPosition.y += halfHeight;\n	newPosition.y *= scaleY;\n	float angle = interpolationFloat(0.0, -((2.0 * PI) / 3.0), 0.111, 1.0, timePercent, 1);\n	mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	newPosition = rotateX * newPosition;\n	newPosition.y -= halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, alpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nmat2 rotateOrigin(float angle) {\n	return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec2 shadowPosition = vec2(position.xy);\n	float presetAngle = option == 1 ? 0.77 : 0.27;\n	float rotateAngle = PI * presetAngle;\n	float min_r = halfWidth * 0.05;\n	shadowPosition = rotateOrigin(rotateAngle) * shadowPosition;\n	vec4 newPosition = vec4(shadowPosition.xy, position.z, 1.0);\n	float line = interpolationFloat(0.0, halfWidth * 2.8, 0.0, 1.0, timePercent, 1);\n	float dis2BaseLine = halfWidth - newPosition.x;\n	float dis2Line = line - dis2BaseLine;\n	float L = line <= (halfWidth * 2.0) ? line : halfWidth * 2.0;\n	float r = L / PI;\n	r = r < min_r ? min_r : r;\n	float angle = dis2Line / r;\n	if (((dis2Line > 0.0) && (dis2Line < (line * 0.5))) && (r > min_r)) {\n		shadowAlpha = interpolationFloat(0.0, 0.3, 0.0, line * 0.5, dis2Line, 0);\n	}\n	else {\n		shadowAlpha = 0.0;\n	}\n	if (dis2BaseLine < line) {\n		newPosition.x = ((sin(angle) * r) + halfWidth) - line;\n		newPosition.z = (r - (cos(angle) * r)) * 0.5;\n	}\n	vec2 finalPosition = vec2(newPosition.xy);\n	finalPosition = rotateOrigin(-rotateAngle) * finalPosition;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(finalPosition.xy, newPosition.z, 1.0);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, shadowAlpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nmat4 rotateX(float angle) {\n	return mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float progress = option == 0 ? halfWidth - newPosition.x : halfWidth + newPosition.x;\n	float delay = interpolationFloat(0.0, 0.08, 0.0, halfWidth * 2.0, progress, 0);\n	float arc = halfHeight - newPosition.y;\n	float L;\n	if (timePercent < 0.8) {\n		L = interpolationFloat(halfHeight * 4.0, halfHeight * 22.0, 0.3 + delay, 0.8, timePercent, 0);\n	}\n	else {\n		L = interpolationFloat(halfHeight * 22.0, halfHeight * 300.0, 0.8, 1.0, timePercent, 0);\n	}\n	float r = L / (2.0 * PI);\n	float angle = PI - (arc / r);\n	float y = sin(angle) * r;\n	float z = cos(angle) * r;\n	newPosition.y = halfHeight - y;\n	newPosition.z = (z + r) * 0.45;\n	float rotateAngle = interpolationFloat(-PI * 0.5, 0.0, 0.0 + delay, 0.4, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(rotateAngle) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate1 = interpolationFloat(0.0, PI * 0.03, 0.75, 0.9, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate1) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate2 = interpolationFloat(0.0, -PI * 0.03, 0.8, 1.0, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate2) * newPosition;\n	newPosition.y += halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	gl_FragColor = blendSrcOver(shadow, distColor);\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float shadowAngle = PI / 6.0;\n	float clockAngle;\n	vec2 a;\n	vec2 b = transform(vUv);\n	float angle;\n	if (timePercent < 0.5) {\n		a = vec2(0.0, 0.5);\n		clockAngle = interpolationFloat(0.0, PI, 0.0, 0.5, timePercent, 0);\n		if (b.x > 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 1.0;\n		}\n	}\n	else {\n		a = vec2(0.0, -0.5);\n		clockAngle = interpolationFloat(0.0, PI + shadowAngle, 0.5, 1.0, timePercent, 0);\n		if (b.x <= 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 0.0;\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uv = vUv;\n	bool useSrc = false;\n	vec2 row;\n	float delay = 0.02;\n	bool isVert = bool(option);\n	int segmentCount = isVert ? 10 : 7;\n	float axis = isVert ? uv.y : uv.x;\n	float compareAxis = isVert ? uv.x : uv.y;\n	for (int i = 0; i < segmentCount; i++) {\n		float fi = float(i);\n		row.r = (fi * 1.0) / float(segmentCount);\n		row.g = (float(i + 1) * 1.0) / float(segmentCount);\n		if ((compareAxis <= row.g) && (compareAxis > row.r)) {\n			if ((i % 2) == 0) {\n				float line = interpolationFloat(0.0, 1.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (axis < line) {\n					useSrc = false;\n				}\n				else {\n					axis -= line;\n					useSrc = true;\n				}\n			}\n			else {\n				float line = interpolationFloat(1.0, 0.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (axis < line) {\n					axis = (1.0 - line) + axis;\n					useSrc = true;\n				}\n				else {\n					useSrc = false;\n				}\n			}\n			break;\n		}\n	}\n	if (isVert) {\n		uv.y = axis;\n	}\n	else {\n		uv.x = axis;\n	}\n	vec4 srcColor = texture2D(texturePrev, uv);\n	vec4 distColor = texture2D(textureNext, uv);\n	gl_FragColor = useSrc ? srcColor : distColor;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uvSrc = vUv;\n	vec2 uvDist = vUv;\n	float scaleSrc = option == 1 ? interpolationFloat(1.0, 2.0, 0.0, 1.0, timePercent, 0) : interpolationFloat(1.0, 0.1, 0.0, 1.0, timePercent, 0);\n	float scaleDist = option == 1 ? interpolationFloat(0.1, 1.0, 0.0, 1.0, timePercent, 0) : interpolationFloat(2.0, 1.0, 0.0, 1.0, timePercent, 0);\n	uvSrc -= 0.5;\n	uvSrc *= scaleSrc;\n	uvSrc += 0.5;\n	uvDist -= 0.5;\n	uvDist *= scaleDist;\n	uvDist += 0.5;\n	vec4 srcColor = texture2D(texturePrev, uvSrc);\n	srcColor.a = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 0);\n	vec4 distColor;\n	if ((((uvDist.x > 1.0) || (uvDist.x < 0.0)) || (uvDist.y > 1.0)) || (uvDist.y < 0.0)) {\n		distColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n	else {\n		distColor = texture2D(textureNext, uvDist);\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	if (option == 1) {\n		angle *= -1.0;\n	}\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float stageOneAngle = PI / 14.0;\n	float stageTwoAngle = (PI * 12.0) / 14.0;\n	float stage_1 = 0.1;\n	float stage_2 = 0.8;\n	if (timePercent < 0.5) {\n		newPosition.z = interpolationFloat(0.0, -100.0, 0.0, 0.5, timePercent, 0);\n	}\n	else {\n		newPosition.z = interpolationFloat(-100.0, 0.0, 0.5, 1.0, timePercent, 0);\n	}\n	if (timePercent < stage_1) {\n		float angle = interpolationFloat(0.0, stageOneAngle, 0.0, stage_1, timePercent, 0);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x -= halfWidth;\n	}\n	else if ((timePercent >= stage_1) && (timePercent < stage_2)) {\n		if (timePercent > 0.5) {\n			newPosition *= rotateY(PI);\n		}\n		float offset = halfWidth - (sin((PI * 0.5) - stageOneAngle) * halfWidth);\n		float angle = interpolationFloat(0.0, stageTwoAngle, stage_1, stage_2, timePercent, 0);\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(stageOneAngle);\n		newPosition.x -= halfWidth;\n		newPosition.x += interpolationFloat(0.0, 2.0 * offset, stage_1, stage_2, timePercent, 0);\n	}\n	else {\n		float angle = interpolationFloat(-stageOneAngle, 0.0, stage_2, 1.0, timePercent, 0);\n		newPosition.x -= halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	gl_FragColor = timePercent < 0.5 ? srcColor : distColor;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nmat2 rotateOrigin(float angle) {\n	return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvoid main() {\n	float alphaStart;\n	float alphaEnd;\n	float rectStart;\n	float rectEnd;\n	bool isRevert = (option == 3) || (option == 2);\n	bool rotateParam = (option == 3) || (option == 1);\n	if (timePercent <= 0.33) {\n		alphaStart = isRevert ? 1.0 - (timePercent / 0.33) : 1.0;\n		alphaEnd = isRevert ? 1.0 : 1.0 - (timePercent / 0.33);\n		rectStart = isRevert ? 0.0 : 1.5;\n		rectEnd = isRevert ? 0.5 : 2.0;\n	}\n	else if ((timePercent > 0.33) && (timePercent <= 0.66)) {\n		alphaStart = isRevert ? 0.0 : 1.0;\n		alphaEnd = isRevert ? 1.0 : 0.0;\n		rectEnd = isRevert ? (((timePercent - 0.33) / 0.33) * 1.5) + 0.5 : 2.0 - (((timePercent - 0.33) / 0.33) * 1.5);\n		rectStart = rectEnd - 0.5;\n	}\n	else {\n		alphaStart = isRevert ? 0.0 : (1.0 - timePercent) / (1.0 - 0.66);\n		alphaEnd = isRevert ? (1.0 - timePercent) / (1.0 - 0.66) : 0.0;\n		rectStart = isRevert ? 1.5 : 0.0;\n		rectEnd = isRevert ? 2.0 : 0.5;\n	}\n	if (!rotateParam) {\n		rectStart -= 1.0;\n		rectEnd -= 1.0;\n	}\n	float rotate = rotateParam ? PI * 0.25 : PI * 0.75;\n	vec2 rotateUv = vUv * rotateOrigin(rotate);\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec2 startPoint = vec2(rectStart, 0.0) * rotateOrigin(rotate);\n	vec2 endPoint = vec2(rectEnd, 0.0) * rotateOrigin(rotate);\n	if (rotateParam) {\n		if (rotateUv.x >= endPoint.x) {\n			srcColor.a = isRevert ? 1.0 : 0.0;\n		}\n		else if (rotateUv.x <= startPoint.x) {\n			srcColor.a = isRevert ? 0.0 : 1.0;\n		}\n		else {\n			srcColor.a = alphaStart + (((rotateUv.x - startPoint.x) / (0.5 / sqrt(2.0))) * (alphaEnd - alphaStart));\n		}\n	}\n	else {\n		if (rotateUv.x <= endPoint.x) {\n			srcColor.a = isRevert ? 1.0 : 0.0;\n		}\n		else if (rotateUv.x >= startPoint.x) {\n			srcColor.a = isRevert ? 0.0 : 1.0;\n		}\n		else {\n			srcColor.a = alphaStart + (((startPoint.x - rotateUv.x) / (0.5 / sqrt(2.0))) * (alphaEnd - alphaStart));\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t, e) {
  t.exports = "#define PI 3.14159265\nattribute float left;\nuniform float timePercent;\nuniform float offset;\nvarying vec2 vUv;\nuniform float option;\nvoid main() {\n	vUv = uv;\n	float angle;\n	if (left > 0.0) {\n		angle = (PI / 6.0) * timePercent;\n	}\n	else {\n		angle = (-PI / 6.0) * timePercent;\n	}\n	if (option > 0.5) {\n		if (left > 0.0) {\n			angle = (-PI / 6.0) * timePercent;\n		}\n		else {\n			angle = (PI / 6.0) * timePercent;\n		}\n	}\n	vec4 newPosition = vec4(position, 1.0);\n	mat4 transform;\n	mat4 rotateY = mat4(cos(angle), 0.0, -sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, sin(angle), 0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	if (option > 0.5) {\n		rotateY = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	}\n	if (option > 0.5) {\n		if (left > 0.0) {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, offset * timePercent, 0.0, 1.0);\n		}\n		else {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, -offset * timePercent, 0.0, 1.0);\n		}\n	}\n	else {\n		if (left > 0.0) {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -offset * timePercent, 0.0, 0.0, 1.0);\n		}\n		else {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, offset * timePercent, 0.0, 0.0, 1.0);\n		}\n	}\n	newPosition = transform * newPosition;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t, e) {
  t.exports = "uniform sampler2D prevTexture;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 color = texture2D(prevTexture, vUv);\n	color.a = 1.0 - timePercent;\n	gl_FragColor = color;\n}\n";
}, function(t, e, i) {
  (function(t2) {
    var n = i(109), r = i(110), o = setTimeout;
    function s(t3) {
      return Boolean(t3 && t3.length !== void 0);
    }
    function a() {
    }
    function l(t3) {
      if (!(this instanceof l))
        throw new TypeError("Promises must be constructed via new");
      if (typeof t3 != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], f(t3, this);
    }
    function h(t3, e2) {
      for (; t3._state === 3; )
        t3 = t3._value;
      t3._state !== 0 ? (t3._handled = true, l._immediateFn(function() {
        var i2 = t3._state === 1 ? e2.onFulfilled : e2.onRejected;
        if (i2 !== null) {
          var n2;
          try {
            n2 = i2(t3._value);
          } catch (t4) {
            return void c(e2.promise, t4);
          }
          u(e2.promise, n2);
        } else
          (t3._state === 1 ? u : c)(e2.promise, t3._value);
      })) : t3._deferreds.push(e2);
    }
    function u(t3, e2) {
      try {
        if (e2 === t3)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (e2 && (typeof e2 == "object" || typeof e2 == "function")) {
          var i2 = e2.then;
          if (e2 instanceof l)
            return t3._state = 3, t3._value = e2, void d(t3);
          if (typeof i2 == "function")
            return void f((n2 = i2, r2 = e2, function() {
              n2.apply(r2, arguments);
            }), t3);
        }
        t3._state = 1, t3._value = e2, d(t3);
      } catch (e3) {
        c(t3, e3);
      }
      var n2, r2;
    }
    function c(t3, e2) {
      t3._state = 2, t3._value = e2, d(t3);
    }
    function d(t3) {
      t3._state === 2 && t3._deferreds.length === 0 && l._immediateFn(function() {
        t3._handled || l._unhandledRejectionFn(t3._value);
      });
      for (var e2 = 0, i2 = t3._deferreds.length; e2 < i2; e2++)
        h(t3, t3._deferreds[e2]);
      t3._deferreds = null;
    }
    function p(t3, e2, i2) {
      this.onFulfilled = typeof t3 == "function" ? t3 : null, this.onRejected = typeof e2 == "function" ? e2 : null, this.promise = i2;
    }
    function f(t3, e2) {
      var i2 = false;
      try {
        t3(function(t4) {
          i2 || (i2 = true, u(e2, t4));
        }, function(t4) {
          i2 || (i2 = true, c(e2, t4));
        });
      } catch (t4) {
        if (i2)
          return;
        i2 = true, c(e2, t4);
      }
    }
    l.prototype.catch = function(t3) {
      return this.then(null, t3);
    }, l.prototype.then = function(t3, e2) {
      var i2 = new this.constructor(a);
      return h(this, new p(t3, e2, i2)), i2;
    }, l.prototype.finally = n.a, l.all = function(t3) {
      return new l(function(e2, i2) {
        if (!s(t3))
          return i2(new TypeError("Promise.all accepts an array"));
        var n2 = Array.prototype.slice.call(t3);
        if (n2.length === 0)
          return e2([]);
        var r2 = n2.length;
        function o2(t4, s2) {
          try {
            if (s2 && (typeof s2 == "object" || typeof s2 == "function")) {
              var a3 = s2.then;
              if (typeof a3 == "function")
                return void a3.call(s2, function(e3) {
                  o2(t4, e3);
                }, i2);
            }
            n2[t4] = s2, --r2 == 0 && e2(n2);
          } catch (t5) {
            i2(t5);
          }
        }
        for (var a2 = 0; a2 < n2.length; a2++)
          o2(a2, n2[a2]);
      });
    }, l.allSettled = r.a, l.resolve = function(t3) {
      return t3 && typeof t3 == "object" && t3.constructor === l ? t3 : new l(function(e2) {
        e2(t3);
      });
    }, l.reject = function(t3) {
      return new l(function(e2, i2) {
        i2(t3);
      });
    }, l.race = function(t3) {
      return new l(function(e2, i2) {
        if (!s(t3))
          return i2(new TypeError("Promise.race accepts an array"));
        for (var n2 = 0, r2 = t3.length; n2 < r2; n2++)
          l.resolve(t3[n2]).then(e2, i2);
      });
    }, l._immediateFn = typeof t2 == "function" && function(e2) {
      t2(e2);
    } || function(t3) {
      o(t3, 0);
    }, l._unhandledRejectionFn = function(t3) {
      typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", t3);
    }, e.a = l;
  }).call(this, i(140).setImmediate);
}, function(t, e, i) {
  e.a = function(t2) {
    var e2 = this.constructor;
    return this.then(function(i2) {
      return e2.resolve(t2()).then(function() {
        return i2;
      });
    }, function(i2) {
      return e2.resolve(t2()).then(function() {
        return e2.reject(i2);
      });
    });
  };
}, function(t, e, i) {
  e.a = function(t2) {
    return new this(function(e2, i2) {
      if (!t2 || t2.length === void 0)
        return i2(new TypeError(typeof t2 + " " + t2 + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
      var n = Array.prototype.slice.call(t2);
      if (n.length === 0)
        return e2([]);
      var r = n.length;
      function o(t3, i3) {
        if (i3 && (typeof i3 == "object" || typeof i3 == "function")) {
          var s2 = i3.then;
          if (typeof s2 == "function")
            return void s2.call(i3, function(e3) {
              o(t3, e3);
            }, function(i4) {
              n[t3] = { status: "rejected", reason: i4 }, --r == 0 && e2(n);
            });
        }
        n[t3] = { status: "fulfilled", value: i3 }, --r == 0 && e2(n);
      }
      for (var s = 0; s < n.length; s++)
        o(s, n[s]);
    });
  };
}, function(t, e, i) {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var n = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, o = Object.prototype.propertyIsEnumerable;
  function s(t2) {
    if (t2 == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(t2);
  }
  t.exports = function() {
    try {
      if (!Object.assign)
        return false;
      var t2 = new String("abc");
      if (t2[5] = "de", Object.getOwnPropertyNames(t2)[0] === "5")
        return false;
      for (var e2 = {}, i2 = 0; i2 < 10; i2++)
        e2["_" + String.fromCharCode(i2)] = i2;
      if (Object.getOwnPropertyNames(e2).map(function(t3) {
        return e2[t3];
      }).join("") !== "0123456789")
        return false;
      var n2 = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(t3) {
        n2[t3] = t3;
      }), Object.keys(Object.assign({}, n2)).join("") === "abcdefghijklmnopqrst";
    } catch (t3) {
      return false;
    }
  }() ? Object.assign : function(t2, e2) {
    for (var i2, a, l = s(t2), h = 1; h < arguments.length; h++) {
      for (var u in i2 = Object(arguments[h]))
        r.call(i2, u) && (l[u] = i2[u]);
      if (n) {
        a = n(i2);
        for (var c = 0; c < a.length; c++)
          o.call(i2, a[c]) && (l[a[c]] = i2[a[c]]);
      }
    }
    return l;
  };
}, function(t, e, i) {
  var n = i(20), r = i(15);
  t.exports = function(t2) {
    return t2 === true || t2 === false || r(t2) && n(t2) == "[object Boolean]";
  };
}, function(t, e) {
  t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
}, function(t, e) {
  t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nprecision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nuniform sampler2D uSdfSampler;\nuniform float uSdfIsReady;\nuniform float uSdfMaxDis;\nuniform float uRad;\nuniform vec4 uGlowColor;\nuniform vec2 uSdfPosition;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	vec4 glowColor = vec4(uGlowColor.rgb * uGlowColor.a, uGlowColor.a);\n	float a = 1.0;\n	if (uSdfIsReady > 0.0) {\n		vec2 cod = vec2(filterCoord.x / uShapeFilterArea.z, filterCoord.y / uShapeFilterArea.w);\n		vec4 sdfColor = texture2D(uSdfSampler, cod + uSdfPosition);\n		float dis = sdfColor.a * uSdfMaxDis;\n		if ((sdfColor.r <= 0.0) && (dis >= (uRad * 0.5))) {\n			a = 1.0 - smoothstep(uRad * 0.5, uRad, dis);\n		}\n	}\n	vec4 resultColor = blendSrcOver(texColor, glowColor);\n	resultColor.rgb *= resultColor.a;\n	resultColor.rgb *= a;\n	resultColor.a *= a;\n	gl_FragColor = resultColor;\n}\n";
}, function(t, e) {
  t.exports = "precision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nuniform sampler2D uSdfSampler;\nuniform float uSdfIsReady;\nuniform float uSdfMaxDis;\nuniform float uRad;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	if (uSdfIsReady > 0.0) {\n		float dx = uShapeFilterArea.x < 0.0 ? -uShapeFilterArea.x : 0.0;\n		float dy = uShapeFilterArea.y < 0.0 ? -uShapeFilterArea.y : 0.0;\n		vec2 cod = vec2((filterCoord.x + dx) / uShapeFilterArea.z, (filterCoord.y + dy) / uShapeFilterArea.w);\n		vec4 sdfColor = texture2D(uSdfSampler, cod);\n		float dis = sdfColor.a * uSdfMaxDis;\n		if (texColor.a > 0.0392156862745098) {\n			if (dis <= (uRad / 2.0)) {\n				float a = smoothstep(0.0, uRad / 2.0, dis) * 0.1;\n				texColor.rgb *= a;\n				texColor.a = a;\n			}\n			else if ((dis > (uRad / 2.0)) && (dis < (uRad * 1.2))) {\n				float a = (smoothstep(uRad / 2.0, uRad * 1.2, dis) * 0.9) + 0.1;\n				texColor.rgb *= a;\n				texColor.a = a;\n			}\n		}\n		else {\n			texColor.rgba *= 0.0;\n		}\n	}\n	gl_FragColor = texColor;\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nvoid main() {\n	vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n	if (sourceColor.a == 0.0) {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n	else {\n		gl_FragColor = uColor * sourceColor.a;\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform vec4 inputSize;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform float uStartAlpha;\nuniform float uEndAlpha;\nuniform float uStartPos;\nuniform float uEndPos;\nuniform float uHeight;\nvoid main() {\n	vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n	vec2 cod = vTextureCoord * inputSize.xy;\n	float startY = uStartPos * uHeight;\n	float endY = uEndPos * uHeight;\n	if ((cod.y >= startY) && (cod.y <= endY)) {\n		float alpha = uStartAlpha - (((cod.y - startY) / (endY - startY)) * (uStartAlpha - uEndAlpha));\n		gl_FragColor = sourceColor * alpha;\n	}\n	else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n}\n";
}, function(t, e) {
  t.exports = "precision mediump float;\nvarying vec2 vTextureCoord;\nuniform vec4 inputSize;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	if (texColor.r > 0.0) {\n		vec2 translateCoord = vec2(filterCoord.x + 10.0, filterCoord.y);\n		vec4 translateColor = texture2D(uSampler, translateCoord * inputSize.zw);\n		if (translateColor.a > 0.0) {\n			gl_FragColor = texColor;\n		}\n		else {\n			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n		}\n	}\n	else {\n		gl_FragColor = texColor;\n	}\n}\n";
}, function(t, e, i) {
  var n;
  !function(r, o) {
    var s = "model", a = "name", l = "type", h = "vendor", u = "version", c = "mobile", d = "tablet", p = "smarttv", f = function(t2) {
      for (var e2 = {}, i2 = 0; i2 < t2.length; i2++)
        e2[t2[i2].toUpperCase()] = t2[i2];
      return e2;
    }, m = function(t2, e2) {
      return typeof t2 == "string" && g(e2).indexOf(g(t2)) !== -1;
    }, g = function(t2) {
      return t2.toLowerCase();
    }, v = function(t2, e2) {
      if (typeof t2 == "string")
        return t2 = t2.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), e2 === void 0 ? t2 : t2.substring(0, 255);
    }, _ = function(t2, e2) {
      for (var i2, n2, r2, o2, s2, a2, l2 = 0; l2 < e2.length && !s2; ) {
        var h2 = e2[l2], u2 = e2[l2 + 1];
        for (i2 = n2 = 0; i2 < h2.length && !s2; )
          if (s2 = h2[i2++].exec(t2))
            for (r2 = 0; r2 < u2.length; r2++)
              a2 = s2[++n2], typeof (o2 = u2[r2]) == "object" && o2.length > 0 ? o2.length === 2 ? typeof o2[1] == "function" ? this[o2[0]] = o2[1].call(this, a2) : this[o2[0]] = o2[1] : o2.length === 3 ? typeof o2[1] != "function" || o2[1].exec && o2[1].test ? this[o2[0]] = a2 ? a2.replace(o2[1], o2[2]) : void 0 : this[o2[0]] = a2 ? o2[1].call(this, a2, o2[2]) : void 0 : o2.length === 4 && (this[o2[0]] = a2 ? o2[3].call(this, a2.replace(o2[1], o2[2])) : void 0) : this[o2] = a2 || void 0;
        l2 += 2;
      }
    }, y = function(t2, e2) {
      for (var i2 in e2)
        if (typeof e2[i2] == "object" && e2[i2].length > 0) {
          for (var n2 = 0; n2 < e2[i2].length; n2++)
            if (m(e2[i2][n2], t2))
              return i2 === "?" ? void 0 : i2;
        } else if (m(e2[i2], t2))
          return i2 === "?" ? void 0 : i2;
      return t2;
    }, x = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, b = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [u, [a, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [u, [a, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [a, u], [/opios[\/ ]+([\w\.]+)/i], [u, [a, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [u, [a, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [a, u], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [u, [a, "UCBrowser"]], [/\bqbcore\/([\w\.]+)/i], [u, [a, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [u, [a, "WeChat"]], [/konqueror\/([\w\.]+)/i], [u, [a, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [u, [a, "IE"]], [/yabrowser\/([\w\.]+)/i], [u, [a, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[a, /(.+)/, "$1 Secure Browser"], u], [/\bfocus\/([\w\.]+)/i], [u, [a, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [u, [a, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [u, [a, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [u, [a, "Dolphin"]], [/coast\/([\w\.]+)/i], [u, [a, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [u, [a, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [u, [a, "Firefox"]], [/\bqihu|(qi?ho?o?|360)browser/i], [[a, "360 Browser"]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[a, /(.+)/, "$1 Browser"], u], [/(comodo_dragon)\/([\w\.]+)/i], [[a, /_/g, " "], u], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [a, u], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [a], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[a, "Facebook"], u], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [a, u], [/\bgsa\/([\w\.]+) .*safari\//i], [u, [a, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [u, [a, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[a, "Chrome WebView"], u], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [u, [a, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [a, u], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [u, [a, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [u, a], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [a, [u, y, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [a, u], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[a, "Netscape"], u], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [u, [a, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [a, u]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [["architecture", "amd64"]], [/(ia32(?=;))/i], [["architecture", g]], [/((?:i[346]|x)86)[;\)]/i], [["architecture", "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [["architecture", "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [["architecture", "armhf"]], [/windows (ce|mobile); ppc;/i], [["architecture", "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [["architecture", /ower/, "", g]], [/(sun4\w)[;\)]/i], [["architecture", "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [["architecture", g]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [s, [h, "Samsung"], [l, d]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [s, [h, "Samsung"], [l, c]], [/\((ip(?:hone|od)[\w ]*);/i], [s, [h, "Apple"], [l, c]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [s, [h, "Apple"], [l, d]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [s, [h, "Huawei"], [l, d]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i], [s, [h, "Huawei"], [l, c]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[s, /_/g, " "], [h, "Xiaomi"], [l, c]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[s, /_/g, " "], [h, "Xiaomi"], [l, d]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [s, [h, "OPPO"], [l, c]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [s, [h, "Vivo"], [l, c]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [s, [h, "Realme"], [l, c]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [s, [h, "Motorola"], [l, c]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [s, [h, "Motorola"], [l, d]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [s, [h, "LG"], [l, d]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [s, [h, "LG"], [l, c]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [s, [h, "Lenovo"], [l, d]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[s, /_/g, " "], [h, "Nokia"], [l, c]], [/(pixel c)\b/i], [s, [h, "Google"], [l, d]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [s, [h, "Google"], [l, c]], [/droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [s, [h, "Sony"], [l, c]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[s, "Xperia Tablet"], [h, "Sony"], [l, d]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [s, [h, "OnePlus"], [l, c]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [s, [h, "Amazon"], [l, d]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[s, /(.+)/g, "Fire Phone $1"], [h, "Amazon"], [l, c]], [/(playbook);[-\w\),; ]+(rim)/i], [s, h, [l, d]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [s, [h, "BlackBerry"], [l, c]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [s, [h, "ASUS"], [l, d]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [s, [h, "ASUS"], [l, c]], [/(nexus 9)/i], [s, [h, "HTC"], [l, d]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [h, [s, /_/g, " "], [l, c]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [s, [h, "Acer"], [l, d]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [s, [h, "Meizu"], [l, c]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [s, [h, "Sharp"], [l, c]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h, s, [l, c]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h, s, [l, d]], [/(surface duo)/i], [s, [h, "Microsoft"], [l, d]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [s, [h, "Fairphone"], [l, c]], [/(u304aa)/i], [s, [h, "AT&T"], [l, c]], [/\bsie-(\w*)/i], [s, [h, "Siemens"], [l, c]], [/\b(rct\w+) b/i], [s, [h, "RCA"], [l, d]], [/\b(venue[\d ]{2,7}) b/i], [s, [h, "Dell"], [l, d]], [/\b(q(?:mv|ta)\w+) b/i], [s, [h, "Verizon"], [l, d]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [s, [h, "Barnes & Noble"], [l, d]], [/\b(tm\d{3}\w+) b/i], [s, [h, "NuVision"], [l, d]], [/\b(k88) b/i], [s, [h, "ZTE"], [l, d]], [/\b(nx\d{3}j) b/i], [s, [h, "ZTE"], [l, c]], [/\b(gen\d{3}) b.+49h/i], [s, [h, "Swiss"], [l, c]], [/\b(zur\d{3}) b/i], [s, [h, "Swiss"], [l, d]], [/\b((zeki)?tb.*\b) b/i], [s, [h, "Zeki"], [l, d]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h, "Dragon Touch"], s, [l, d]], [/\b(ns-?\w{0,9}) b/i], [s, [h, "Insignia"], [l, d]], [/\b((nxa|next)-?\w{0,9}) b/i], [s, [h, "NextBook"], [l, d]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h, "Voice"], s, [l, c]], [/\b(lvtel\-)?(v1[12]) b/i], [[h, "LvTel"], s, [l, c]], [/\b(ph-1) /i], [s, [h, "Essential"], [l, c]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [s, [h, "Envizen"], [l, d]], [/\b(trio[-\w\. ]+) b/i], [s, [h, "MachSpeed"], [l, d]], [/\btu_(1491) b/i], [s, [h, "Rotor"], [l, d]], [/(shield[\w ]+) b/i], [s, [h, "Nvidia"], [l, d]], [/(sprint) (\w+)/i], [h, s, [l, c]], [/(kin\.[onetw]{3})/i], [[s, /\./g, " "], [h, "Microsoft"], [l, c]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [s, [h, "Zebra"], [l, d]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [s, [h, "Zebra"], [l, c]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h, s, [l, "console"]], [/droid.+; (shield) bui/i], [s, [h, "Nvidia"], [l, "console"]], [/(playstation [345portablevi]+)/i], [s, [h, "Sony"], [l, "console"]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [s, [h, "Microsoft"], [l, "console"]], [/smart-tv.+(samsung)/i], [h, [l, p]], [/hbbtv.+maple;(\d+)/i], [[s, /^/, "SmartTV"], [h, "Samsung"], [l, p]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h, "LG"], [l, p]], [/(apple) ?tv/i], [h, [s, "Apple TV"], [l, p]], [/crkey/i], [[s, "Chromecast"], [h, "Google"], [l, p]], [/droid.+aft(\w)( bui|\))/i], [s, [h, "Amazon"], [l, p]], [/\(dtv[\);].+(aquos)/i], [s, [h, "Sharp"], [l, p]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[h, v], [s, v], [l, p]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[l, p]], [/((pebble))app/i], [h, s, [l, "wearable"]], [/droid.+; (glass) \d/i], [s, [h, "Google"], [l, "wearable"]], [/droid.+; (wt63?0{2,3})\)/i], [s, [h, "Zebra"], [l, "wearable"]], [/(quest( 2)?)/i], [s, [h, "Facebook"], [l, "wearable"]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h, [l, "embedded"]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [s, [l, c]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [s, [l, d]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[l, d]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[l, c]], [/(android[-\w\. ]{0,9});.+buil/i], [s, [h, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [u, [a, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [u, [a, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [a, u], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [u, a]], os: [[/microsoft (windows) (vista|xp)/i], [a, u], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [a, [u, y, x]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[a, "Windows"], [u, y, x]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[u, /_/g, "."], [a, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[a, "Mac OS"], [u, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [u, a], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [a, u], [/\(bb(10);/i], [u, [a, "BlackBerry"]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [u, [a, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [u, [a, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [u, [a, "webOS"]], [/crkey\/([\d\.]+)/i], [u, [a, "Chromecast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[a, "Chromium OS"], u], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [a, u], [/(sunos) ?([\w\.\d]*)/i], [[a, "Solaris"], u], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [a, u]] }, T = function(t2, e2) {
      if (typeof t2 == "object" && (e2 = t2, t2 = void 0), !(this instanceof T))
        return new T(t2, e2).getResult();
      var i2 = t2 || (r !== void 0 && r.navigator && r.navigator.userAgent ? r.navigator.userAgent : ""), n2 = e2 ? function(t3, e3) {
        var i3 = {};
        for (var n3 in t3)
          e3[n3] && e3[n3].length % 2 == 0 ? i3[n3] = e3[n3].concat(t3[n3]) : i3[n3] = t3[n3];
        return i3;
      }(b, e2) : b;
      return this.getBrowser = function() {
        var t3, e3 = {};
        return e3[a] = void 0, e3[u] = void 0, _.call(e3, i2, n2.browser), e3.major = typeof (t3 = e3.version) == "string" ? t3.replace(/[^\d\.]/g, "").split(".")[0] : void 0, e3;
      }, this.getCPU = function() {
        var t3 = { architecture: void 0 };
        return _.call(t3, i2, n2.cpu), t3;
      }, this.getDevice = function() {
        var t3 = { vendor: void 0, model: void 0, type: void 0 };
        return _.call(t3, i2, n2.device), t3;
      }, this.getEngine = function() {
        var t3 = { name: void 0, version: void 0 };
        return _.call(t3, i2, n2.engine), t3;
      }, this.getOS = function() {
        var t3 = { name: void 0, version: void 0 };
        return _.call(t3, i2, n2.os), t3;
      }, this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      }, this.getUA = function() {
        return i2;
      }, this.setUA = function(t3) {
        return i2 = typeof t3 == "string" && t3.length > 255 ? v(t3, 255) : t3, this;
      }, this.setUA(i2), this;
    };
    T.VERSION = "1.0.2", T.BROWSER = f([a, u, "major"]), T.CPU = f(["architecture"]), T.DEVICE = f([s, h, l, "console", c, p, d, "wearable", "embedded"]), T.ENGINE = T.OS = f([a, u]), e !== void 0 ? (t !== void 0 && t.exports && (e = t.exports = T), e.UAParser = T) : i(149) ? (n = function() {
      return T;
    }.call(e, i, e, t)) === void 0 || (t.exports = n) : r !== void 0 && (r.UAParser = T);
    var E = r !== void 0 && (r.jQuery || r.Zepto);
    if (E && !E.ua) {
      var S = new T();
      E.ua = S.getResult(), E.ua.get = function() {
        return S.getUA();
      }, E.ua.set = function(t2) {
        S.setUA(t2);
        var e2 = S.getResult();
        for (var i2 in e2)
          E.ua[i2] = e2[i2];
      };
    }
  }(typeof window == "object" ? window : this);
}, function(t, e, i) {
  (function(i2) {
    var n;
    /*!
     *  howler.js v2.2.3
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
    !function() {
      var r = function() {
        this.init();
      };
      r.prototype = { init: function() {
        var t2 = this || o;
        return t2._counter = 1e3, t2._html5AudioPool = [], t2.html5PoolSize = 10, t2._codecs = {}, t2._howls = [], t2._muted = false, t2._volume = 1, t2._canPlayEvent = "canplaythrough", t2._navigator = typeof window != "undefined" && window.navigator ? window.navigator : null, t2.masterGain = null, t2.noAudio = false, t2.usingWebAudio = true, t2.autoSuspend = true, t2.ctx = null, t2.autoUnlock = true, t2._setup(), t2;
      }, volume: function(t2) {
        var e2 = this || o;
        if (t2 = parseFloat(t2), e2.ctx || p(), t2 !== void 0 && t2 >= 0 && t2 <= 1) {
          if (e2._volume = t2, e2._muted)
            return e2;
          e2.usingWebAudio && e2.masterGain.gain.setValueAtTime(t2, o.ctx.currentTime);
          for (var i3 = 0; i3 < e2._howls.length; i3++)
            if (!e2._howls[i3]._webAudio)
              for (var n2 = e2._howls[i3]._getSoundIds(), r2 = 0; r2 < n2.length; r2++) {
                var s2 = e2._howls[i3]._soundById(n2[r2]);
                s2 && s2._node && (s2._node.volume = s2._volume * t2);
              }
          return e2;
        }
        return e2._volume;
      }, mute: function(t2) {
        var e2 = this || o;
        e2.ctx || p(), e2._muted = t2, e2.usingWebAudio && e2.masterGain.gain.setValueAtTime(t2 ? 0 : e2._volume, o.ctx.currentTime);
        for (var i3 = 0; i3 < e2._howls.length; i3++)
          if (!e2._howls[i3]._webAudio)
            for (var n2 = e2._howls[i3]._getSoundIds(), r2 = 0; r2 < n2.length; r2++) {
              var s2 = e2._howls[i3]._soundById(n2[r2]);
              s2 && s2._node && (s2._node.muted = !!t2 || s2._muted);
            }
        return e2;
      }, stop: function() {
        for (var t2 = this || o, e2 = 0; e2 < t2._howls.length; e2++)
          t2._howls[e2].stop();
        return t2;
      }, unload: function() {
        for (var t2 = this || o, e2 = t2._howls.length - 1; e2 >= 0; e2--)
          t2._howls[e2].unload();
        return t2.usingWebAudio && t2.ctx && t2.ctx.close !== void 0 && (t2.ctx.close(), t2.ctx = null, p()), t2;
      }, codecs: function(t2) {
        return (this || o)._codecs[t2.replace(/^x-/, "")];
      }, _setup: function() {
        var t2 = this || o;
        if (t2.state = t2.ctx && t2.ctx.state || "suspended", t2._autoSuspend(), !t2.usingWebAudio)
          if (typeof Audio != "undefined")
            try {
              new Audio().oncanplaythrough === void 0 && (t2._canPlayEvent = "canplay");
            } catch (e2) {
              t2.noAudio = true;
            }
          else
            t2.noAudio = true;
        try {
          new Audio().muted && (t2.noAudio = true);
        } catch (t3) {
        }
        return t2.noAudio || t2._setupCodecs(), t2;
      }, _setupCodecs: function() {
        var t2 = this || o, e2 = null;
        try {
          e2 = typeof Audio != "undefined" ? new Audio() : null;
        } catch (e3) {
          return t2;
        }
        if (!e2 || typeof e2.canPlayType != "function")
          return t2;
        var i3 = e2.canPlayType("audio/mpeg;").replace(/^no$/, ""), n2 = t2._navigator ? t2._navigator.userAgent : "", r2 = n2.match(/OPR\/([0-6].)/g), s2 = r2 && parseInt(r2[0].split("/")[1], 10) < 33, a2 = n2.indexOf("Safari") !== -1 && n2.indexOf("Chrome") === -1, l2 = n2.match(/Version\/(.*?) /), h2 = a2 && l2 && parseInt(l2[1], 10) < 15;
        return t2._codecs = { mp3: !(s2 || !i3 && !e2.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!i3, opus: !!e2.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!e2.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!e2.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(e2.canPlayType('audio/wav; codecs="1"') || e2.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!e2.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!e2.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(e2.canPlayType("audio/x-m4a;") || e2.canPlayType("audio/m4a;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(e2.canPlayType("audio/x-m4b;") || e2.canPlayType("audio/m4b;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(e2.canPlayType("audio/x-mp4;") || e2.canPlayType("audio/mp4;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !(h2 || !e2.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !(h2 || !e2.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!e2.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(e2.canPlayType("audio/x-flac;") || e2.canPlayType("audio/flac;")).replace(/^no$/, "") }, t2;
      }, _unlockAudio: function() {
        var t2 = this || o;
        if (!t2._audioUnlocked && t2.ctx) {
          t2._audioUnlocked = false, t2.autoUnlock = false, t2._mobileUnloaded || t2.ctx.sampleRate === 44100 || (t2._mobileUnloaded = true, t2.unload()), t2._scratchBuffer = t2.ctx.createBuffer(1, 1, 22050);
          var e2 = function(i3) {
            for (; t2._html5AudioPool.length < t2.html5PoolSize; )
              try {
                var n2 = new Audio();
                n2._unlocked = true, t2._releaseHtml5Audio(n2);
              } catch (i4) {
                t2.noAudio = true;
                break;
              }
            for (var r2 = 0; r2 < t2._howls.length; r2++)
              if (!t2._howls[r2]._webAudio)
                for (var o2 = t2._howls[r2]._getSoundIds(), s2 = 0; s2 < o2.length; s2++) {
                  var a2 = t2._howls[r2]._soundById(o2[s2]);
                  a2 && a2._node && !a2._node._unlocked && (a2._node._unlocked = true, a2._node.load());
                }
            t2._autoResume();
            var l2 = t2.ctx.createBufferSource();
            l2.buffer = t2._scratchBuffer, l2.connect(t2.ctx.destination), l2.start === void 0 ? l2.noteOn(0) : l2.start(0), typeof t2.ctx.resume == "function" && t2.ctx.resume(), l2.onended = function() {
              l2.disconnect(0), t2._audioUnlocked = true, document.removeEventListener("touchstart", e2, true), document.removeEventListener("touchend", e2, true), document.removeEventListener("click", e2, true), document.removeEventListener("keydown", e2, true);
              for (var i4 = 0; i4 < t2._howls.length; i4++)
                t2._howls[i4]._emit("unlock");
            };
          };
          return document.addEventListener("touchstart", e2, true), document.addEventListener("touchend", e2, true), document.addEventListener("click", e2, true), document.addEventListener("keydown", e2, true), t2;
        }
      }, _obtainHtml5Audio: function() {
        var t2 = this || o;
        if (t2._html5AudioPool.length)
          return t2._html5AudioPool.pop();
        var e2 = new Audio().play();
        return e2 && typeof Promise != "undefined" && (e2 instanceof Promise || typeof e2.then == "function") && e2.catch(function() {
          console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
        }), new Audio();
      }, _releaseHtml5Audio: function(t2) {
        var e2 = this || o;
        return t2._unlocked && e2._html5AudioPool.push(t2), e2;
      }, _autoSuspend: function() {
        var t2 = this;
        if (t2.autoSuspend && t2.ctx && t2.ctx.suspend !== void 0 && o.usingWebAudio) {
          for (var e2 = 0; e2 < t2._howls.length; e2++)
            if (t2._howls[e2]._webAudio) {
              for (var i3 = 0; i3 < t2._howls[e2]._sounds.length; i3++)
                if (!t2._howls[e2]._sounds[i3]._paused)
                  return t2;
            }
          return t2._suspendTimer && clearTimeout(t2._suspendTimer), t2._suspendTimer = setTimeout(function() {
            if (t2.autoSuspend) {
              t2._suspendTimer = null, t2.state = "suspending";
              var e3 = function() {
                t2.state = "suspended", t2._resumeAfterSuspend && (delete t2._resumeAfterSuspend, t2._autoResume());
              };
              t2.ctx.suspend().then(e3, e3);
            }
          }, 3e4), t2;
        }
      }, _autoResume: function() {
        var t2 = this;
        if (t2.ctx && t2.ctx.resume !== void 0 && o.usingWebAudio)
          return t2.state === "running" && t2.ctx.state !== "interrupted" && t2._suspendTimer ? (clearTimeout(t2._suspendTimer), t2._suspendTimer = null) : t2.state === "suspended" || t2.state === "running" && t2.ctx.state === "interrupted" ? (t2.ctx.resume().then(function() {
            t2.state = "running";
            for (var e2 = 0; e2 < t2._howls.length; e2++)
              t2._howls[e2]._emit("resume");
          }), t2._suspendTimer && (clearTimeout(t2._suspendTimer), t2._suspendTimer = null)) : t2.state === "suspending" && (t2._resumeAfterSuspend = true), t2;
      } };
      var o = new r(), s = function(t2) {
        t2.src && t2.src.length !== 0 ? this.init(t2) : console.error("An array of source files must be passed with any new Howl.");
      };
      s.prototype = { init: function(t2) {
        var e2 = this;
        return o.ctx || p(), e2._autoplay = t2.autoplay || false, e2._format = typeof t2.format != "string" ? t2.format : [t2.format], e2._html5 = t2.html5 || false, e2._muted = t2.mute || false, e2._loop = t2.loop || false, e2._pool = t2.pool || 5, e2._preload = typeof t2.preload != "boolean" && t2.preload !== "metadata" || t2.preload, e2._rate = t2.rate || 1, e2._sprite = t2.sprite || {}, e2._src = typeof t2.src != "string" ? t2.src : [t2.src], e2._volume = t2.volume !== void 0 ? t2.volume : 1, e2._xhr = { method: t2.xhr && t2.xhr.method ? t2.xhr.method : "GET", headers: t2.xhr && t2.xhr.headers ? t2.xhr.headers : null, withCredentials: !(!t2.xhr || !t2.xhr.withCredentials) && t2.xhr.withCredentials }, e2._duration = 0, e2._state = "unloaded", e2._sounds = [], e2._endTimers = {}, e2._queue = [], e2._playLock = false, e2._onend = t2.onend ? [{ fn: t2.onend }] : [], e2._onfade = t2.onfade ? [{ fn: t2.onfade }] : [], e2._onload = t2.onload ? [{ fn: t2.onload }] : [], e2._onloaderror = t2.onloaderror ? [{ fn: t2.onloaderror }] : [], e2._onplayerror = t2.onplayerror ? [{ fn: t2.onplayerror }] : [], e2._onpause = t2.onpause ? [{ fn: t2.onpause }] : [], e2._onplay = t2.onplay ? [{ fn: t2.onplay }] : [], e2._onstop = t2.onstop ? [{ fn: t2.onstop }] : [], e2._onmute = t2.onmute ? [{ fn: t2.onmute }] : [], e2._onvolume = t2.onvolume ? [{ fn: t2.onvolume }] : [], e2._onrate = t2.onrate ? [{ fn: t2.onrate }] : [], e2._onseek = t2.onseek ? [{ fn: t2.onseek }] : [], e2._onunlock = t2.onunlock ? [{ fn: t2.onunlock }] : [], e2._onresume = [], e2._webAudio = o.usingWebAudio && !e2._html5, o.ctx !== void 0 && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e2), e2._autoplay && e2._queue.push({ event: "play", action: function() {
          e2.play();
        } }), e2._preload && e2._preload !== "none" && e2.load(), e2;
      }, load: function() {
        var t2 = null;
        if (o.noAudio)
          this._emit("loaderror", null, "No audio support.");
        else {
          typeof this._src == "string" && (this._src = [this._src]);
          for (var e2 = 0; e2 < this._src.length; e2++) {
            var i3, n2;
            if (this._format && this._format[e2])
              i3 = this._format[e2];
            else {
              if (typeof (n2 = this._src[e2]) != "string") {
                this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              (i3 = /^data:audio\/([^;,]+);/i.exec(n2)) || (i3 = /\.([^.]+)$/.exec(n2.split("?", 1)[0])), i3 && (i3 = i3[1].toLowerCase());
            }
            if (i3 || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), i3 && o.codecs(i3)) {
              t2 = this._src[e2];
              break;
            }
          }
          if (t2)
            return this._src = t2, this._state = "loading", window.location.protocol === "https:" && t2.slice(0, 5) === "http:" && (this._html5 = true, this._webAudio = false), new a(this), this._webAudio && h(this), this;
          this._emit("loaderror", null, "No codec support for selected audio sources.");
        }
      }, play: function(t2, e2) {
        var i3 = this, n2 = null;
        if (typeof t2 == "number")
          n2 = t2, t2 = null;
        else {
          if (typeof t2 == "string" && i3._state === "loaded" && !i3._sprite[t2])
            return null;
          if (t2 === void 0 && (t2 = "__default", !i3._playLock)) {
            for (var r2 = 0, s2 = 0; s2 < i3._sounds.length; s2++)
              i3._sounds[s2]._paused && !i3._sounds[s2]._ended && (r2++, n2 = i3._sounds[s2]._id);
            r2 === 1 ? t2 = null : n2 = null;
          }
        }
        var a2 = n2 ? i3._soundById(n2) : i3._inactiveSound();
        if (!a2)
          return null;
        if (n2 && !t2 && (t2 = a2._sprite || "__default"), i3._state !== "loaded") {
          a2._sprite = t2, a2._ended = false;
          var l2 = a2._id;
          return i3._queue.push({ event: "play", action: function() {
            i3.play(l2);
          } }), l2;
        }
        if (n2 && !a2._paused)
          return e2 || i3._loadQueue("play"), a2._id;
        i3._webAudio && o._autoResume();
        var h2 = Math.max(0, a2._seek > 0 ? a2._seek : i3._sprite[t2][0] / 1e3), u2 = Math.max(0, (i3._sprite[t2][0] + i3._sprite[t2][1]) / 1e3 - h2), c2 = 1e3 * u2 / Math.abs(a2._rate), d2 = i3._sprite[t2][0] / 1e3, p2 = (i3._sprite[t2][0] + i3._sprite[t2][1]) / 1e3;
        a2._sprite = t2, a2._ended = false;
        var f = function() {
          a2._paused = false, a2._seek = h2, a2._start = d2, a2._stop = p2, a2._loop = !(!a2._loop && !i3._sprite[t2][2]);
        };
        if (!(h2 >= p2)) {
          var m = a2._node;
          if (i3._webAudio) {
            var g = function() {
              i3._playLock = false, f(), i3._refreshBuffer(a2);
              var t3 = a2._muted || i3._muted ? 0 : a2._volume;
              m.gain.setValueAtTime(t3, o.ctx.currentTime), a2._playStart = o.ctx.currentTime, m.bufferSource.start === void 0 ? a2._loop ? m.bufferSource.noteGrainOn(0, h2, 86400) : m.bufferSource.noteGrainOn(0, h2, u2) : a2._loop ? m.bufferSource.start(0, h2, 86400) : m.bufferSource.start(0, h2, u2), c2 !== 1 / 0 && (i3._endTimers[a2._id] = setTimeout(i3._ended.bind(i3, a2), c2)), e2 || setTimeout(function() {
                i3._emit("play", a2._id), i3._loadQueue();
              }, 0);
            };
            o.state === "running" && o.ctx.state !== "interrupted" ? g() : (i3._playLock = true, i3.once("resume", g), i3._clearTimer(a2._id));
          } else {
            var v = function() {
              m.currentTime = h2, m.muted = a2._muted || i3._muted || o._muted || m.muted, m.volume = a2._volume * o.volume(), m.playbackRate = a2._rate;
              try {
                var n3 = m.play();
                if (n3 && typeof Promise != "undefined" && (n3 instanceof Promise || typeof n3.then == "function") ? (i3._playLock = true, f(), n3.then(function() {
                  i3._playLock = false, m._unlocked = true, e2 ? i3._loadQueue() : i3._emit("play", a2._id);
                }).catch(function() {
                  i3._playLock = false, i3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a2._ended = true, a2._paused = true;
                })) : e2 || (i3._playLock = false, f(), i3._emit("play", a2._id)), m.playbackRate = a2._rate, m.paused)
                  return void i3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                t2 !== "__default" || a2._loop ? i3._endTimers[a2._id] = setTimeout(i3._ended.bind(i3, a2), c2) : (i3._endTimers[a2._id] = function() {
                  i3._ended(a2), m.removeEventListener("ended", i3._endTimers[a2._id], false);
                }, m.addEventListener("ended", i3._endTimers[a2._id], false));
              } catch (t3) {
                i3._emit("playerror", a2._id, t3);
              }
            };
            m.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (m.src = i3._src, m.load());
            var _ = window && window.ejecta || !m.readyState && o._navigator.isCocoonJS;
            if (m.readyState >= 3 || _)
              v();
            else {
              i3._playLock = true, i3._state = "loading";
              var y = function() {
                i3._state = "loaded", v(), m.removeEventListener(o._canPlayEvent, y, false);
              };
              m.addEventListener(o._canPlayEvent, y, false), i3._clearTimer(a2._id);
            }
          }
          return a2._id;
        }
        i3._ended(a2);
      }, pause: function(t2) {
        var e2 = this;
        if (e2._state !== "loaded" || e2._playLock)
          return e2._queue.push({ event: "pause", action: function() {
            e2.pause(t2);
          } }), e2;
        for (var i3 = e2._getSoundIds(t2), n2 = 0; n2 < i3.length; n2++) {
          e2._clearTimer(i3[n2]);
          var r2 = e2._soundById(i3[n2]);
          if (r2 && !r2._paused && (r2._seek = e2.seek(i3[n2]), r2._rateSeek = 0, r2._paused = true, e2._stopFade(i3[n2]), r2._node))
            if (e2._webAudio) {
              if (!r2._node.bufferSource)
                continue;
              r2._node.bufferSource.stop === void 0 ? r2._node.bufferSource.noteOff(0) : r2._node.bufferSource.stop(0), e2._cleanBuffer(r2._node);
            } else
              isNaN(r2._node.duration) && r2._node.duration !== 1 / 0 || r2._node.pause();
          arguments[1] || e2._emit("pause", r2 ? r2._id : null);
        }
        return e2;
      }, stop: function(t2, e2) {
        var i3 = this;
        if (i3._state !== "loaded" || i3._playLock)
          return i3._queue.push({ event: "stop", action: function() {
            i3.stop(t2);
          } }), i3;
        for (var n2 = i3._getSoundIds(t2), r2 = 0; r2 < n2.length; r2++) {
          i3._clearTimer(n2[r2]);
          var o2 = i3._soundById(n2[r2]);
          o2 && (o2._seek = o2._start || 0, o2._rateSeek = 0, o2._paused = true, o2._ended = true, i3._stopFade(n2[r2]), o2._node && (i3._webAudio ? o2._node.bufferSource && (o2._node.bufferSource.stop === void 0 ? o2._node.bufferSource.noteOff(0) : o2._node.bufferSource.stop(0), i3._cleanBuffer(o2._node)) : isNaN(o2._node.duration) && o2._node.duration !== 1 / 0 || (o2._node.currentTime = o2._start || 0, o2._node.pause(), o2._node.duration === 1 / 0 && i3._clearSound(o2._node))), e2 || i3._emit("stop", o2._id));
        }
        return i3;
      }, mute: function(t2, e2) {
        var i3 = this;
        if (i3._state !== "loaded" || i3._playLock)
          return i3._queue.push({ event: "mute", action: function() {
            i3.mute(t2, e2);
          } }), i3;
        if (e2 === void 0) {
          if (typeof t2 != "boolean")
            return i3._muted;
          i3._muted = t2;
        }
        for (var n2 = i3._getSoundIds(e2), r2 = 0; r2 < n2.length; r2++) {
          var s2 = i3._soundById(n2[r2]);
          s2 && (s2._muted = t2, s2._interval && i3._stopFade(s2._id), i3._webAudio && s2._node ? s2._node.gain.setValueAtTime(t2 ? 0 : s2._volume, o.ctx.currentTime) : s2._node && (s2._node.muted = !!o._muted || t2), i3._emit("mute", s2._id));
        }
        return i3;
      }, volume: function() {
        var t2, e2, i3, n2 = this, r2 = arguments;
        if (r2.length === 0)
          return n2._volume;
        if (r2.length === 1 || r2.length === 2 && r2[1] === void 0) {
          var s2 = n2._getSoundIds(), a2 = s2.indexOf(r2[0]);
          a2 >= 0 ? e2 = parseInt(r2[0], 10) : t2 = parseFloat(r2[0]);
        } else
          r2.length >= 2 && (t2 = parseFloat(r2[0]), e2 = parseInt(r2[1], 10));
        if (!(t2 !== void 0 && t2 >= 0 && t2 <= 1))
          return (i3 = e2 ? n2._soundById(e2) : n2._sounds[0]) ? i3._volume : 0;
        if (n2._state !== "loaded" || n2._playLock)
          return n2._queue.push({ event: "volume", action: function() {
            n2.volume.apply(n2, r2);
          } }), n2;
        e2 === void 0 && (n2._volume = t2), e2 = n2._getSoundIds(e2);
        for (var l2 = 0; l2 < e2.length; l2++)
          (i3 = n2._soundById(e2[l2])) && (i3._volume = t2, r2[2] || n2._stopFade(e2[l2]), n2._webAudio && i3._node && !i3._muted ? i3._node.gain.setValueAtTime(t2, o.ctx.currentTime) : i3._node && !i3._muted && (i3._node.volume = t2 * o.volume()), n2._emit("volume", i3._id));
        return n2;
      }, fade: function(t2, e2, i3, n2) {
        var r2 = this;
        if (r2._state !== "loaded" || r2._playLock)
          return r2._queue.push({ event: "fade", action: function() {
            r2.fade(t2, e2, i3, n2);
          } }), r2;
        t2 = Math.min(Math.max(0, parseFloat(t2)), 1), e2 = Math.min(Math.max(0, parseFloat(e2)), 1), i3 = parseFloat(i3), r2.volume(t2, n2);
        for (var s2 = r2._getSoundIds(n2), a2 = 0; a2 < s2.length; a2++) {
          var l2 = r2._soundById(s2[a2]);
          if (l2) {
            if (n2 || r2._stopFade(s2[a2]), r2._webAudio && !l2._muted) {
              var h2 = o.ctx.currentTime, u2 = h2 + i3 / 1e3;
              l2._volume = t2, l2._node.gain.setValueAtTime(t2, h2), l2._node.gain.linearRampToValueAtTime(e2, u2);
            }
            r2._startFadeInterval(l2, t2, e2, i3, s2[a2], n2 === void 0);
          }
        }
        return r2;
      }, _startFadeInterval: function(t2, e2, i3, n2, r2, o2) {
        var s2 = this, a2 = e2, l2 = i3 - e2, h2 = Math.abs(l2 / 0.01), u2 = Math.max(4, h2 > 0 ? n2 / h2 : n2), c2 = Date.now();
        t2._fadeTo = i3, t2._interval = setInterval(function() {
          var r3 = (Date.now() - c2) / n2;
          c2 = Date.now(), a2 += l2 * r3, a2 = Math.round(100 * a2) / 100, a2 = l2 < 0 ? Math.max(i3, a2) : Math.min(i3, a2), s2._webAudio ? t2._volume = a2 : s2.volume(a2, t2._id, true), o2 && (s2._volume = a2), (i3 < e2 && a2 <= i3 || i3 > e2 && a2 >= i3) && (clearInterval(t2._interval), t2._interval = null, t2._fadeTo = null, s2.volume(i3, t2._id), s2._emit("fade", t2._id));
        }, u2);
      }, _stopFade: function(t2) {
        var e2 = this._soundById(t2);
        return e2 && e2._interval && (this._webAudio && e2._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(e2._interval), e2._interval = null, this.volume(e2._fadeTo, t2), e2._fadeTo = null, this._emit("fade", t2)), this;
      }, loop: function() {
        var t2, e2, i3, n2 = this, r2 = arguments;
        if (r2.length === 0)
          return n2._loop;
        if (r2.length === 1) {
          if (typeof r2[0] != "boolean")
            return !!(i3 = n2._soundById(parseInt(r2[0], 10))) && i3._loop;
          t2 = r2[0], n2._loop = t2;
        } else
          r2.length === 2 && (t2 = r2[0], e2 = parseInt(r2[1], 10));
        for (var o2 = n2._getSoundIds(e2), s2 = 0; s2 < o2.length; s2++)
          (i3 = n2._soundById(o2[s2])) && (i3._loop = t2, n2._webAudio && i3._node && i3._node.bufferSource && (i3._node.bufferSource.loop = t2, t2 && (i3._node.bufferSource.loopStart = i3._start || 0, i3._node.bufferSource.loopEnd = i3._stop, n2.playing(o2[s2]) && (n2.pause(o2[s2], true), n2.play(o2[s2], true)))));
        return n2;
      }, rate: function() {
        var t2, e2, i3, n2 = this, r2 = arguments;
        if (r2.length === 0)
          e2 = n2._sounds[0]._id;
        else if (r2.length === 1) {
          var s2 = n2._getSoundIds(), a2 = s2.indexOf(r2[0]);
          a2 >= 0 ? e2 = parseInt(r2[0], 10) : t2 = parseFloat(r2[0]);
        } else
          r2.length === 2 && (t2 = parseFloat(r2[0]), e2 = parseInt(r2[1], 10));
        if (typeof t2 != "number")
          return (i3 = n2._soundById(e2)) ? i3._rate : n2._rate;
        if (n2._state !== "loaded" || n2._playLock)
          return n2._queue.push({ event: "rate", action: function() {
            n2.rate.apply(n2, r2);
          } }), n2;
        e2 === void 0 && (n2._rate = t2), e2 = n2._getSoundIds(e2);
        for (var l2 = 0; l2 < e2.length; l2++)
          if (i3 = n2._soundById(e2[l2])) {
            n2.playing(e2[l2]) && (i3._rateSeek = n2.seek(e2[l2]), i3._playStart = n2._webAudio ? o.ctx.currentTime : i3._playStart), i3._rate = t2, n2._webAudio && i3._node && i3._node.bufferSource ? i3._node.bufferSource.playbackRate.setValueAtTime(t2, o.ctx.currentTime) : i3._node && (i3._node.playbackRate = t2);
            var h2 = n2.seek(e2[l2]), u2 = (n2._sprite[i3._sprite][0] + n2._sprite[i3._sprite][1]) / 1e3 - h2, c2 = 1e3 * u2 / Math.abs(i3._rate);
            !n2._endTimers[e2[l2]] && i3._paused || (n2._clearTimer(e2[l2]), n2._endTimers[e2[l2]] = setTimeout(n2._ended.bind(n2, i3), c2)), n2._emit("rate", i3._id);
          }
        return n2;
      }, seek: function() {
        var t2, e2, i3 = this, n2 = arguments;
        if (n2.length === 0)
          i3._sounds.length && (e2 = i3._sounds[0]._id);
        else if (n2.length === 1) {
          var r2 = i3._getSoundIds(), s2 = r2.indexOf(n2[0]);
          s2 >= 0 ? e2 = parseInt(n2[0], 10) : i3._sounds.length && (e2 = i3._sounds[0]._id, t2 = parseFloat(n2[0]));
        } else
          n2.length === 2 && (t2 = parseFloat(n2[0]), e2 = parseInt(n2[1], 10));
        if (e2 === void 0)
          return 0;
        if (typeof t2 == "number" && (i3._state !== "loaded" || i3._playLock))
          return i3._queue.push({ event: "seek", action: function() {
            i3.seek.apply(i3, n2);
          } }), i3;
        var a2 = i3._soundById(e2);
        if (a2) {
          if (!(typeof t2 == "number" && t2 >= 0)) {
            if (i3._webAudio) {
              var l2 = i3.playing(e2) ? o.ctx.currentTime - a2._playStart : 0, h2 = a2._rateSeek ? a2._rateSeek - a2._seek : 0;
              return a2._seek + (h2 + l2 * Math.abs(a2._rate));
            }
            return a2._node.currentTime;
          }
          var u2 = i3.playing(e2);
          u2 && i3.pause(e2, true), a2._seek = t2, a2._ended = false, i3._clearTimer(e2), i3._webAudio || !a2._node || isNaN(a2._node.duration) || (a2._node.currentTime = t2);
          var c2 = function() {
            u2 && i3.play(e2, true), i3._emit("seek", e2);
          };
          if (u2 && !i3._webAudio) {
            var d2 = function() {
              i3._playLock ? setTimeout(d2, 0) : c2();
            };
            setTimeout(d2, 0);
          } else
            c2();
        }
        return i3;
      }, playing: function(t2) {
        if (typeof t2 == "number") {
          var e2 = this._soundById(t2);
          return !!e2 && !e2._paused;
        }
        for (var i3 = 0; i3 < this._sounds.length; i3++)
          if (!this._sounds[i3]._paused)
            return true;
        return false;
      }, duration: function(t2) {
        var e2 = this._duration, i3 = this._soundById(t2);
        return i3 && (e2 = this._sprite[i3._sprite][1] / 1e3), e2;
      }, state: function() {
        return this._state;
      }, unload: function() {
        for (var t2 = this, e2 = t2._sounds, i3 = 0; i3 < e2.length; i3++)
          e2[i3]._paused || t2.stop(e2[i3]._id), t2._webAudio || (t2._clearSound(e2[i3]._node), e2[i3]._node.removeEventListener("error", e2[i3]._errorFn, false), e2[i3]._node.removeEventListener(o._canPlayEvent, e2[i3]._loadFn, false), e2[i3]._node.removeEventListener("ended", e2[i3]._endFn, false), o._releaseHtml5Audio(e2[i3]._node)), delete e2[i3]._node, t2._clearTimer(e2[i3]._id);
        var n2 = o._howls.indexOf(t2);
        n2 >= 0 && o._howls.splice(n2, 1);
        var r2 = true;
        for (i3 = 0; i3 < o._howls.length; i3++)
          if (o._howls[i3]._src === t2._src || t2._src.indexOf(o._howls[i3]._src) >= 0) {
            r2 = false;
            break;
          }
        return l && r2 && delete l[t2._src], o.noAudio = false, t2._state = "unloaded", t2._sounds = [], t2 = null, null;
      }, on: function(t2, e2, i3, n2) {
        var r2 = this["_on" + t2];
        return typeof e2 == "function" && r2.push(n2 ? { id: i3, fn: e2, once: n2 } : { id: i3, fn: e2 }), this;
      }, off: function(t2, e2, i3) {
        var n2 = this["_on" + t2], r2 = 0;
        if (typeof e2 == "number" && (i3 = e2, e2 = null), e2 || i3)
          for (r2 = 0; r2 < n2.length; r2++) {
            var o2 = i3 === n2[r2].id;
            if (e2 === n2[r2].fn && o2 || !e2 && o2) {
              n2.splice(r2, 1);
              break;
            }
          }
        else if (t2)
          this["_on" + t2] = [];
        else {
          var s2 = Object.keys(this);
          for (r2 = 0; r2 < s2.length; r2++)
            s2[r2].indexOf("_on") === 0 && Array.isArray(this[s2[r2]]) && (this[s2[r2]] = []);
        }
        return this;
      }, once: function(t2, e2, i3) {
        return this.on(t2, e2, i3, 1), this;
      }, _emit: function(t2, e2, i3) {
        for (var n2 = this["_on" + t2], r2 = n2.length - 1; r2 >= 0; r2--)
          n2[r2].id && n2[r2].id !== e2 && t2 !== "load" || (setTimeout(function(t3) {
            t3.call(this, e2, i3);
          }.bind(this, n2[r2].fn), 0), n2[r2].once && this.off(t2, n2[r2].fn, n2[r2].id));
        return this._loadQueue(t2), this;
      }, _loadQueue: function(t2) {
        if (this._queue.length > 0) {
          var e2 = this._queue[0];
          e2.event === t2 && (this._queue.shift(), this._loadQueue()), t2 || e2.action();
        }
        return this;
      }, _ended: function(t2) {
        var e2 = t2._sprite;
        if (!this._webAudio && t2._node && !t2._node.paused && !t2._node.ended && t2._node.currentTime < t2._stop)
          return setTimeout(this._ended.bind(this, t2), 100), this;
        var i3 = !(!t2._loop && !this._sprite[e2][2]);
        if (this._emit("end", t2._id), !this._webAudio && i3 && this.stop(t2._id, true).play(t2._id), this._webAudio && i3) {
          this._emit("play", t2._id), t2._seek = t2._start || 0, t2._rateSeek = 0, t2._playStart = o.ctx.currentTime;
          var n2 = 1e3 * (t2._stop - t2._start) / Math.abs(t2._rate);
          this._endTimers[t2._id] = setTimeout(this._ended.bind(this, t2), n2);
        }
        return this._webAudio && !i3 && (t2._paused = true, t2._ended = true, t2._seek = t2._start || 0, t2._rateSeek = 0, this._clearTimer(t2._id), this._cleanBuffer(t2._node), o._autoSuspend()), this._webAudio || i3 || this.stop(t2._id, true), this;
      }, _clearTimer: function(t2) {
        if (this._endTimers[t2]) {
          if (typeof this._endTimers[t2] != "function")
            clearTimeout(this._endTimers[t2]);
          else {
            var e2 = this._soundById(t2);
            e2 && e2._node && e2._node.removeEventListener("ended", this._endTimers[t2], false);
          }
          delete this._endTimers[t2];
        }
        return this;
      }, _soundById: function(t2) {
        for (var e2 = 0; e2 < this._sounds.length; e2++)
          if (t2 === this._sounds[e2]._id)
            return this._sounds[e2];
        return null;
      }, _inactiveSound: function() {
        this._drain();
        for (var t2 = 0; t2 < this._sounds.length; t2++)
          if (this._sounds[t2]._ended)
            return this._sounds[t2].reset();
        return new a(this);
      }, _drain: function() {
        var t2 = this._pool, e2 = 0, i3 = 0;
        if (!(this._sounds.length < t2)) {
          for (i3 = 0; i3 < this._sounds.length; i3++)
            this._sounds[i3]._ended && e2++;
          for (i3 = this._sounds.length - 1; i3 >= 0; i3--) {
            if (e2 <= t2)
              return;
            this._sounds[i3]._ended && (this._webAudio && this._sounds[i3]._node && this._sounds[i3]._node.disconnect(0), this._sounds.splice(i3, 1), e2--);
          }
        }
      }, _getSoundIds: function(t2) {
        if (t2 === void 0) {
          for (var e2 = [], i3 = 0; i3 < this._sounds.length; i3++)
            e2.push(this._sounds[i3]._id);
          return e2;
        }
        return [t2];
      }, _refreshBuffer: function(t2) {
        return t2._node.bufferSource = o.ctx.createBufferSource(), t2._node.bufferSource.buffer = l[this._src], t2._panner ? t2._node.bufferSource.connect(t2._panner) : t2._node.bufferSource.connect(t2._node), t2._node.bufferSource.loop = t2._loop, t2._loop && (t2._node.bufferSource.loopStart = t2._start || 0, t2._node.bufferSource.loopEnd = t2._stop || 0), t2._node.bufferSource.playbackRate.setValueAtTime(t2._rate, o.ctx.currentTime), this;
      }, _cleanBuffer: function(t2) {
        var e2 = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
        if (o._scratchBuffer && t2.bufferSource && (t2.bufferSource.onended = null, t2.bufferSource.disconnect(0), e2))
          try {
            t2.bufferSource.buffer = o._scratchBuffer;
          } catch (t3) {
          }
        return t2.bufferSource = null, this;
      }, _clearSound: function(t2) {
        /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t2.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
      } };
      var a = function(t2) {
        this._parent = t2, this.init();
      };
      a.prototype = { init: function() {
        var t2 = this._parent;
        return this._muted = t2._muted, this._loop = t2._loop, this._volume = t2._volume, this._rate = t2._rate, this._seek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o._counter, t2._sounds.push(this), this.create(), this;
      }, create: function() {
        var t2 = this._parent, e2 = o._muted || this._muted || this._parent._muted ? 0 : this._volume;
        return t2._webAudio ? (this._node = o.ctx.createGain === void 0 ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(e2, o.ctx.currentTime), this._node.paused = true, this._node.connect(o.masterGain)) : o.noAudio || (this._node = o._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, false), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, false), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, false), this._node.src = t2._src, this._node.preload = t2._preload === true ? "auto" : t2._preload, this._node.volume = e2 * o.volume(), this._node.load()), this;
      }, reset: function() {
        var t2 = this._parent;
        return this._muted = t2._muted, this._loop = t2._loop, this._volume = t2._volume, this._rate = t2._rate, this._seek = 0, this._rateSeek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o._counter, this;
      }, _errorListener: function() {
        this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, false);
      }, _loadListener: function() {
        var t2 = this._parent;
        t2._duration = Math.ceil(10 * this._node.duration) / 10, Object.keys(t2._sprite).length === 0 && (t2._sprite = { __default: [0, 1e3 * t2._duration] }), t2._state !== "loaded" && (t2._state = "loaded", t2._emit("load"), t2._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, false);
      }, _endListener: function() {
        var t2 = this._parent;
        t2._duration === 1 / 0 && (t2._duration = Math.ceil(10 * this._node.duration) / 10, t2._sprite.__default[1] === 1 / 0 && (t2._sprite.__default[1] = 1e3 * t2._duration), t2._ended(this)), this._node.removeEventListener("ended", this._endFn, false);
      } };
      var l = {}, h = function(t2) {
        var e2 = t2._src;
        if (l[e2])
          return t2._duration = l[e2].duration, void d(t2);
        if (/^data:[^;]+;base64,/.test(e2)) {
          for (var i3 = atob(e2.split(",")[1]), n2 = new Uint8Array(i3.length), r2 = 0; r2 < i3.length; ++r2)
            n2[r2] = i3.charCodeAt(r2);
          c(n2.buffer, t2);
        } else {
          var o2 = new XMLHttpRequest();
          o2.open(t2._xhr.method, e2, true), o2.withCredentials = t2._xhr.withCredentials, o2.responseType = "arraybuffer", t2._xhr.headers && Object.keys(t2._xhr.headers).forEach(function(e3) {
            o2.setRequestHeader(e3, t2._xhr.headers[e3]);
          }), o2.onload = function() {
            var e3 = (o2.status + "")[0];
            e3 === "0" || e3 === "2" || e3 === "3" ? c(o2.response, t2) : t2._emit("loaderror", null, "Failed loading audio file with status: " + o2.status + ".");
          }, o2.onerror = function() {
            t2._webAudio && (t2._html5 = true, t2._webAudio = false, t2._sounds = [], delete l[e2], t2.load());
          }, u(o2);
        }
      }, u = function(t2) {
        try {
          t2.send();
        } catch (e2) {
          t2.onerror();
        }
      }, c = function(t2, e2) {
        var i3 = function() {
          e2._emit("loaderror", null, "Decoding audio data failed.");
        }, n2 = function(t3) {
          t3 && e2._sounds.length > 0 ? (l[e2._src] = t3, d(e2, t3)) : i3();
        };
        typeof Promise != "undefined" && o.ctx.decodeAudioData.length === 1 ? o.ctx.decodeAudioData(t2).then(n2).catch(i3) : o.ctx.decodeAudioData(t2, n2, i3);
      }, d = function(t2, e2) {
        e2 && !t2._duration && (t2._duration = e2.duration), Object.keys(t2._sprite).length === 0 && (t2._sprite = { __default: [0, 1e3 * t2._duration] }), t2._state !== "loaded" && (t2._state = "loaded", t2._emit("load"), t2._loadQueue());
      }, p = function() {
        if (o.usingWebAudio) {
          try {
            typeof AudioContext != "undefined" ? o.ctx = new AudioContext() : typeof webkitAudioContext != "undefined" ? o.ctx = new webkitAudioContext() : o.usingWebAudio = false;
          } catch (t3) {
            o.usingWebAudio = false;
          }
          o.ctx || (o.usingWebAudio = false);
          var t2 = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform), e2 = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), i3 = e2 ? parseInt(e2[1], 10) : null;
          if (t2 && i3 && i3 < 9) {
            var n2 = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
            o._navigator && !n2 && (o.usingWebAudio = false);
          }
          o.usingWebAudio && (o.masterGain = o.ctx.createGain === void 0 ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup();
        }
      };
      (n = function() {
        return { Howler: o, Howl: s };
      }.apply(e, [])) === void 0 || (t.exports = n), e.Howler = o, e.Howl = s, i2 !== void 0 ? (i2.HowlerGlobal = r, i2.Howler = o, i2.Howl = s, i2.Sound = a) : typeof window != "undefined" && (window.HowlerGlobal = r, window.Howler = o, window.Howl = s, window.Sound = a);
    }(), function() {
      var t2;
      HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t3) {
        if (!this.ctx || !this.ctx.listener)
          return this;
        for (var e3 = this._howls.length - 1; e3 >= 0; e3--)
          this._howls[e3].stereo(t3);
        return this;
      }, HowlerGlobal.prototype.pos = function(t3, e3, i3) {
        return this.ctx && this.ctx.listener ? (e3 = typeof e3 != "number" ? this._pos[1] : e3, i3 = typeof i3 != "number" ? this._pos[2] : i3, typeof t3 != "number" ? this._pos : (this._pos = [t3, e3, i3], this.ctx.listener.positionX !== void 0 ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this;
      }, HowlerGlobal.prototype.orientation = function(t3, e3, i3, n2, r, o) {
        if (!this.ctx || !this.ctx.listener)
          return this;
        var s = this._orientation;
        return e3 = typeof e3 != "number" ? s[1] : e3, i3 = typeof i3 != "number" ? s[2] : i3, n2 = typeof n2 != "number" ? s[3] : n2, r = typeof r != "number" ? s[4] : r, o = typeof o != "number" ? s[5] : o, typeof t3 != "number" ? s : (this._orientation = [t3, e3, i3, n2, r, o], this.ctx.listener.forwardX !== void 0 ? (this.ctx.listener.forwardX.setTargetAtTime(t3, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardY.setTargetAtTime(e3, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardZ.setTargetAtTime(i3, Howler.ctx.currentTime, 0.1), this.ctx.listener.upX.setTargetAtTime(n2, Howler.ctx.currentTime, 0.1), this.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), this.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setOrientation(t3, e3, i3, n2, r, o), this);
      }, Howl.prototype.init = (t2 = Howl.prototype.init, function(e3) {
        return this._orientation = e3.orientation || [1, 0, 0], this._stereo = e3.stereo || null, this._pos = e3.pos || null, this._pannerAttr = { coneInnerAngle: e3.coneInnerAngle !== void 0 ? e3.coneInnerAngle : 360, coneOuterAngle: e3.coneOuterAngle !== void 0 ? e3.coneOuterAngle : 360, coneOuterGain: e3.coneOuterGain !== void 0 ? e3.coneOuterGain : 0, distanceModel: e3.distanceModel !== void 0 ? e3.distanceModel : "inverse", maxDistance: e3.maxDistance !== void 0 ? e3.maxDistance : 1e4, panningModel: e3.panningModel !== void 0 ? e3.panningModel : "HRTF", refDistance: e3.refDistance !== void 0 ? e3.refDistance : 1, rolloffFactor: e3.rolloffFactor !== void 0 ? e3.rolloffFactor : 1 }, this._onstereo = e3.onstereo ? [{ fn: e3.onstereo }] : [], this._onpos = e3.onpos ? [{ fn: e3.onpos }] : [], this._onorientation = e3.onorientation ? [{ fn: e3.onorientation }] : [], t2.call(this, e3);
      }), Howl.prototype.stereo = function(t3, i3) {
        var n2 = this;
        if (!n2._webAudio)
          return n2;
        if (n2._state !== "loaded")
          return n2._queue.push({ event: "stereo", action: function() {
            n2.stereo(t3, i3);
          } }), n2;
        var r = Howler.ctx.createStereoPanner === void 0 ? "spatial" : "stereo";
        if (i3 === void 0) {
          if (typeof t3 != "number")
            return n2._stereo;
          n2._stereo = t3, n2._pos = [t3, 0, 0];
        }
        for (var o = n2._getSoundIds(i3), s = 0; s < o.length; s++) {
          var a = n2._soundById(o[s]);
          if (a) {
            if (typeof t3 != "number")
              return a._stereo;
            a._stereo = t3, a._pos = [t3, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || e2(a, r), r === "spatial" ? a._panner.positionX !== void 0 ? (a._panner.positionX.setValueAtTime(t3, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t3, 0, 0) : a._panner.pan.setValueAtTime(t3, Howler.ctx.currentTime)), n2._emit("stereo", a._id);
          }
        }
        return n2;
      }, Howl.prototype.pos = function(t3, i3, n2, r) {
        var o = this;
        if (!o._webAudio)
          return o;
        if (o._state !== "loaded")
          return o._queue.push({ event: "pos", action: function() {
            o.pos(t3, i3, n2, r);
          } }), o;
        if (i3 = typeof i3 != "number" ? 0 : i3, n2 = typeof n2 != "number" ? -0.5 : n2, r === void 0) {
          if (typeof t3 != "number")
            return o._pos;
          o._pos = [t3, i3, n2];
        }
        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
          var l = o._soundById(s[a]);
          if (l) {
            if (typeof t3 != "number")
              return l._pos;
            l._pos = [t3, i3, n2], l._node && (l._panner && !l._panner.pan || e2(l, "spatial"), l._panner.positionX !== void 0 ? (l._panner.positionX.setValueAtTime(t3, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(i3, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(n2, Howler.ctx.currentTime)) : l._panner.setPosition(t3, i3, n2)), o._emit("pos", l._id);
          }
        }
        return o;
      }, Howl.prototype.orientation = function(t3, i3, n2, r) {
        var o = this;
        if (!o._webAudio)
          return o;
        if (o._state !== "loaded")
          return o._queue.push({ event: "orientation", action: function() {
            o.orientation(t3, i3, n2, r);
          } }), o;
        if (i3 = typeof i3 != "number" ? o._orientation[1] : i3, n2 = typeof n2 != "number" ? o._orientation[2] : n2, r === void 0) {
          if (typeof t3 != "number")
            return o._orientation;
          o._orientation = [t3, i3, n2];
        }
        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
          var l = o._soundById(s[a]);
          if (l) {
            if (typeof t3 != "number")
              return l._orientation;
            l._orientation = [t3, i3, n2], l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -0.5]), e2(l, "spatial")), l._panner.orientationX !== void 0 ? (l._panner.orientationX.setValueAtTime(t3, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(i3, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(n2, Howler.ctx.currentTime)) : l._panner.setOrientation(t3, i3, n2)), o._emit("orientation", l._id);
          }
        }
        return o;
      }, Howl.prototype.pannerAttr = function() {
        var t3, i3, n2, r = this, o = arguments;
        if (!r._webAudio)
          return r;
        if (o.length === 0)
          return r._pannerAttr;
        if (o.length === 1) {
          if (typeof o[0] != "object")
            return (n2 = r._soundById(parseInt(o[0], 10))) ? n2._pannerAttr : r._pannerAttr;
          t3 = o[0], i3 === void 0 && (t3.pannerAttr || (t3.pannerAttr = { coneInnerAngle: t3.coneInnerAngle, coneOuterAngle: t3.coneOuterAngle, coneOuterGain: t3.coneOuterGain, distanceModel: t3.distanceModel, maxDistance: t3.maxDistance, refDistance: t3.refDistance, rolloffFactor: t3.rolloffFactor, panningModel: t3.panningModel }), r._pannerAttr = { coneInnerAngle: t3.pannerAttr.coneInnerAngle !== void 0 ? t3.pannerAttr.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: t3.pannerAttr.coneOuterAngle !== void 0 ? t3.pannerAttr.coneOuterAngle : r._coneOuterAngle, coneOuterGain: t3.pannerAttr.coneOuterGain !== void 0 ? t3.pannerAttr.coneOuterGain : r._coneOuterGain, distanceModel: t3.pannerAttr.distanceModel !== void 0 ? t3.pannerAttr.distanceModel : r._distanceModel, maxDistance: t3.pannerAttr.maxDistance !== void 0 ? t3.pannerAttr.maxDistance : r._maxDistance, refDistance: t3.pannerAttr.refDistance !== void 0 ? t3.pannerAttr.refDistance : r._refDistance, rolloffFactor: t3.pannerAttr.rolloffFactor !== void 0 ? t3.pannerAttr.rolloffFactor : r._rolloffFactor, panningModel: t3.pannerAttr.panningModel !== void 0 ? t3.pannerAttr.panningModel : r._panningModel });
        } else
          o.length === 2 && (t3 = o[0], i3 = parseInt(o[1], 10));
        for (var s = r._getSoundIds(i3), a = 0; a < s.length; a++)
          if (n2 = r._soundById(s[a])) {
            var l = n2._pannerAttr;
            l = { coneInnerAngle: t3.coneInnerAngle !== void 0 ? t3.coneInnerAngle : l.coneInnerAngle, coneOuterAngle: t3.coneOuterAngle !== void 0 ? t3.coneOuterAngle : l.coneOuterAngle, coneOuterGain: t3.coneOuterGain !== void 0 ? t3.coneOuterGain : l.coneOuterGain, distanceModel: t3.distanceModel !== void 0 ? t3.distanceModel : l.distanceModel, maxDistance: t3.maxDistance !== void 0 ? t3.maxDistance : l.maxDistance, refDistance: t3.refDistance !== void 0 ? t3.refDistance : l.refDistance, rolloffFactor: t3.rolloffFactor !== void 0 ? t3.rolloffFactor : l.rolloffFactor, panningModel: t3.panningModel !== void 0 ? t3.panningModel : l.panningModel };
            var h = n2._panner;
            h ? (h.coneInnerAngle = l.coneInnerAngle, h.coneOuterAngle = l.coneOuterAngle, h.coneOuterGain = l.coneOuterGain, h.distanceModel = l.distanceModel, h.maxDistance = l.maxDistance, h.refDistance = l.refDistance, h.rolloffFactor = l.rolloffFactor, h.panningModel = l.panningModel) : (n2._pos || (n2._pos = r._pos || [0, 0, -0.5]), e2(n2, "spatial"));
          }
        return r;
      }, Sound.prototype.init = function(t3) {
        return function() {
          var e3 = this._parent;
          this._orientation = e3._orientation, this._stereo = e3._stereo, this._pos = e3._pos, this._pannerAttr = e3._pannerAttr, t3.call(this), this._stereo ? e3.stereo(this._stereo) : this._pos && e3.pos(this._pos[0], this._pos[1], this._pos[2], this._id);
        };
      }(Sound.prototype.init), Sound.prototype.reset = function(t3) {
        return function() {
          var e3 = this._parent;
          return this._orientation = e3._orientation, this._stereo = e3._stereo, this._pos = e3._pos, this._pannerAttr = e3._pannerAttr, this._stereo ? e3.stereo(this._stereo) : this._pos ? e3.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e3._refreshBuffer(this)), t3.call(this);
        };
      }(Sound.prototype.reset);
      var e2 = function(t3, e3) {
        (e3 = e3 || "spatial") === "spatial" ? (t3._panner = Howler.ctx.createPanner(), t3._panner.coneInnerAngle = t3._pannerAttr.coneInnerAngle, t3._panner.coneOuterAngle = t3._pannerAttr.coneOuterAngle, t3._panner.coneOuterGain = t3._pannerAttr.coneOuterGain, t3._panner.distanceModel = t3._pannerAttr.distanceModel, t3._panner.maxDistance = t3._pannerAttr.maxDistance, t3._panner.refDistance = t3._pannerAttr.refDistance, t3._panner.rolloffFactor = t3._pannerAttr.rolloffFactor, t3._panner.panningModel = t3._pannerAttr.panningModel, t3._panner.positionX !== void 0 ? (t3._panner.positionX.setValueAtTime(t3._pos[0], Howler.ctx.currentTime), t3._panner.positionY.setValueAtTime(t3._pos[1], Howler.ctx.currentTime), t3._panner.positionZ.setValueAtTime(t3._pos[2], Howler.ctx.currentTime)) : t3._panner.setPosition(t3._pos[0], t3._pos[1], t3._pos[2]), t3._panner.orientationX !== void 0 ? (t3._panner.orientationX.setValueAtTime(t3._orientation[0], Howler.ctx.currentTime), t3._panner.orientationY.setValueAtTime(t3._orientation[1], Howler.ctx.currentTime), t3._panner.orientationZ.setValueAtTime(t3._orientation[2], Howler.ctx.currentTime)) : t3._panner.setOrientation(t3._orientation[0], t3._orientation[1], t3._orientation[2])) : (t3._panner = Howler.ctx.createStereoPanner(), t3._panner.pan.setValueAtTime(t3._stereo, Howler.ctx.currentTime)), t3._panner.connect(t3._node), t3._paused || t3._parent.pause(t3._id, true).play(t3._id, true);
      };
    }();
  }).call(this, i(17));
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform sampler2D uSampler;\nvoid main() {\n	vec4 outputColor;\n	float percent = vPercent;\n	float direction = vDirection;\n	if (vTransition < 0.0) {\n		percent = 1.0 - percent;\n		if ((vDirection > 1.5) && (vDirection < 2.5)) {\n			direction = 1.0;\n		}\n		else if ((vDirection > 0.5) && (vDirection < 1.5)) {\n			direction = 2.0;\n		}\n		else if ((vDirection > 2.5) && (vDirection < 3.5)) {\n			direction = 4.0;\n		}\n		else {\n			direction = 3.0;\n		}\n	}\n	if ((direction > 1.5) && (direction < 2.5)) {\n		if (vVertexPosition.y >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y >= (1.0 - percent)) && (vVertexPosition.y <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.y - (1.0 - percent)) / 0.2);\n		}\n	}\n	else if ((direction > 0.5) && (direction < 1.5)) {\n		if (vVertexPosition.y <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y <= percent) && (vVertexPosition.y >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.y - (percent - 0.2)) / 0.2));\n		}\n	}\n	else if ((direction > 2.5) && (direction < 3.5)) {\n		if (vVertexPosition.x <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x <= percent) && (vVertexPosition.x >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.x - (percent - 0.2)) / 0.2));\n		}\n	}\n	else {\n		if (vVertexPosition.x >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x >= (1.0 - percent)) && (vVertexPosition.x <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.x - (1.0 - percent)) / 0.2);\n		}\n	}\n	gl_FragColor = outputColor;\n}\n";
}, function(t, e) {
  t.exports = "attribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform float percent;\nuniform float direction;\nuniform float transition;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord(vec2 aVertexPosition) {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	vTransition = transition;\n	vDirection = direction;\n	vPercent = percent;\n	vVertexPosition = aVertexPosition;\n	vec2 localVertexPosition = aVertexPosition;\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord(localVertexPosition);\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nuniform float transition;\nvoid main() {\n	float alpha = (transition * (percent - 0.5)) + 0.5;\n	vec4 color1 = texture2D(uSampler, vTextureCoord);\n	gl_FragColor = color1 * alpha;\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	float barCount = 6.0;\n	float barWidth = (option < 0.5 ? uBoundRect.w : uBoundRect.z) / barCount;\n	float alphaWidthPercent = 0.03;\n	float alphaWidth = alphaWidthPercent * (option < 0.5 ? uBoundRect.w : uBoundRect.z);\n	float selectAxis = option < 0.5 ? -position.y : -position.x;\n	float countAxis = floor(selectAxis / barWidth);\n	float modAxis = mod(selectAxis, barWidth);\n	float timePosition = barWidth * timePercent;\n	if (modAxis < timePosition) {\n		outputColor = outputColor;\n	}\n	else if (modAxis < (timePosition + alphaWidth)) {\n		outputColor = (outputColor * ((alphaWidth - modAxis) + timePosition)) / alphaWidth;\n	}\n	else {\n		outputColor = outputColor * 0.0;\n	}\n	gl_FragColor = outputColor;\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	float barCount = 6.0;\n	float horizontalBarWidth = uBoundRect.z / barCount;\n	float verticalBarWidth = uBoundRect.w / barCount;\n	float alphaWidthPercent = 0.01;\n	float alphaWidth = alphaWidthPercent * (option < 0.5 ? uBoundRect.z : uBoundRect.w);\n	float timePosition = horizontalBarWidth * timePercent;\n	float countAxisY = floor(-position.y / verticalBarWidth);\n	float modAxisY = mod(-position.y, verticalBarWidth);\n	float countAxisX = floor(-position.x / horizontalBarWidth);\n	float modAxisX = mod(-position.x, horizontalBarWidth);\n	float modAxis = modAxisX;\n	if (option < 0.5) {\n		if (mod(countAxisY, 2.0) > 0.5) {\n			countAxisX = floor(((horizontalBarWidth * 0.5) - position.x) / horizontalBarWidth);\n			modAxisX = mod((horizontalBarWidth * 0.5) - position.x, horizontalBarWidth);\n		}\n		modAxis = modAxisX;\n	}\n	else {\n		if (mod(countAxisX, 2.0) > 0.5) {\n			countAxisY = floor(((verticalBarWidth * 0.5) - position.y) / verticalBarWidth);\n			modAxisY = mod((verticalBarWidth * 0.5) - position.y, verticalBarWidth);\n		}\n		modAxis = modAxisY;\n	}\n	if (modAxis < timePosition) {\n		outputColor = outputColor;\n	}\n	else if (modAxis < (timePosition + alphaWidth)) {\n		outputColor = (outputColor * ((alphaWidth - modAxis) + timePosition)) / alphaWidth;\n	}\n	else {\n		outputColor = outputColor * 0.0;\n	}\n	gl_FragColor = outputColor;\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform sampler2D dissolveSampler;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	float splitWidth = max(uBoundRect.z, uBoundRect.w) / 3.0;\n	vec2 position = mod(filterCoord.xy, splitWidth);\n	vec2 loopTime = floor(filterCoord.xy / splitWidth);\n	if (loopTime.x > 0.5) {\n		position.x = splitWidth - position.x;\n	}\n	if (loopTime.y > 0.5) {\n		position.y = splitWidth - position.y;\n	}\n	vec4 dissolveColor = texture2D(dissolveSampler, position.xy / splitWidth);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	if (dissolveColor.r < percent) {\n		gl_FragColor = outputColor;\n	}\n	else {\n		gl_FragColor = vec4(0, 0, 0, 0);\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform sampler2D dissolveSampler;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	vec4 dissolveColor;\n	if (option > 0.5) {\n		dissolveColor = texture2D(dissolveSampler, vec2(vTextureCoord.x, 0.0));\n	}\n	else {\n		dissolveColor = texture2D(dissolveSampler, vec2(0.0, vTextureCoord.y));\n	}\n	if (dissolveColor.r < percent) {\n		gl_FragColor = outputColor * min(percent + dissolveColor.r, 1.0);\n	}\n	else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	float radius = sqrt(pow(uBoundRect.z, 2.0) + pow(uBoundRect.w, 2.0)) / 2.0;\n	float alphaWidth = 0.1;\n	float pointDistance = sqrt(pow(point.x, 2.0) + pow(point.y, 2.0));\n	float alphaRadiusFormula;\n	if (option > 0.5) {\n		if (transition > 0.0) {\n			alphaRadiusFormula = 1.0 - ((pointDistance - (radius * timePercent)) / (alphaWidth * radius));\n		}\n		else {\n			alphaRadiusFormula = (pointDistance - (radius * timePercent)) / (alphaWidth * radius);\n		}\n	}\n	else {\n		if (transition > 0.0) {\n			alphaRadiusFormula = (pointDistance - (radius * (1.0 - timePercent))) / (alphaWidth * radius);\n		}\n		else {\n			alphaRadiusFormula = 1.0 - ((pointDistance - (radius * (1.0 - timePercent))) / (alphaWidth * radius));\n		}\n	}\n	if (option > 0.5) {\n		if (pointDistance < (radius * timePercent)) {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n		else if (pointDistance < (radius * (timePercent + alphaWidth))) {\n			gl_FragColor = outputColor * alphaRadiusFormula;\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n	}\n	else {\n		if (pointDistance < (radius * (1.0 - timePercent))) {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n		else if (pointDistance < (radius * ((1.0 - timePercent) + alphaWidth))) {\n			gl_FragColor = outputColor * alphaRadiusFormula;\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n	}\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.2;\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	vec2 absPoint = abs(point.xy);\n	vec2 alphaFormula = vec2(((halfRect.x * (timePercent + alphaWidth)) - absPoint.x) / (halfRect.x * alphaWidth), ((halfRect.y * (timePercent + alphaWidth)) - absPoint.y) / (halfRect.y * alphaWidth));\n	if (option < 0.5) {\n		if ((absPoint.x < (halfRect.x * timePercent)) && (absPoint.y < (halfRect.y * timePercent))) {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n		else if ((absPoint.x < (halfRect.x * (timePercent + alphaWidth))) && (absPoint.y < (halfRect.y * (timePercent + alphaWidth)))) {\n			if (absPoint.x > absPoint.y) {\n				gl_FragColor = outputColor * (transition > 0.0 ? 1.0 - alphaFormula.x : alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (transition > 0.0 ? 1.0 - alphaFormula.y : alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n	}\n	else {\n		if ((absPoint.x < (halfRect.x * timePercent)) && (absPoint.y < (halfRect.y * timePercent))) {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n		else if ((absPoint.x < (halfRect.x * (timePercent + alphaWidth))) && (absPoint.y < (halfRect.y * (timePercent + alphaWidth)))) {\n			if (absPoint.x > absPoint.y) {\n				gl_FragColor = outputColor * (transition > 0.0 ? alphaFormula.x : 1.0 - alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (transition > 0.0 ? alphaFormula.y : 1.0 - alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n	}\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), (uBoundRect.w / 2.0) - filterCoord.y);\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.1;\n	float rightTop = (((2.0 * uBoundRect.w) * timePercent) - ((uBoundRect.w * point.x) / uBoundRect.z)) - point.y;\n	float rightBottom = (((uBoundRect.w * point.x) / uBoundRect.z) - ((2.0 * uBoundRect.w) * timePercent)) - point.y;\n	float leftTop = (((2.0 * uBoundRect.w) * timePercent) + ((uBoundRect.w * point.x) / uBoundRect.z)) - point.y;\n	float leftBottom = (((-uBoundRect.w * point.x) / uBoundRect.z) - ((2.0 * uBoundRect.w) * timePercent)) - point.y;\n	if (((option < 0.5) && (transition > 0.0)) || ((option > 0.5) && (transition < 0.0))) {\n		if ((point.x >= 0.0) && (point.y >= 0.0)) {\n			if (rightTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor;\n			}\n			else if (rightTop < 0.0) {\n				gl_FragColor = outputColor * (-rightTop / (alphaWidth * uBoundRect.w));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x >= 0.0) && (point.y <= 0.0)) {\n			if (rightBottom < 0.0) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (rightBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = (outputColor * rightBottom) / (alphaWidth * uBoundRect.w);\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x <= 0.0) && (point.y >= 0.0)) {\n			if (leftTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor;\n			}\n			else if (leftTop < 0.0) {\n				gl_FragColor = outputColor * (-leftTop / (alphaWidth * uBoundRect.w));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x <= 0.0) && (point.y <= 0.0)) {\n			if (leftBottom < 0.0) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (leftBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = (outputColor * leftBottom) / (alphaWidth * uBoundRect.w);\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n	}\n	else {\n		if ((point.x >= 0.0) && (point.y >= 0.0)) {\n			if (rightTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (rightTop < 0.0) {\n				gl_FragColor = outputColor * (1.0 + (rightTop / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x >= 0.0) && (point.y <= 0.0)) {\n			if (rightBottom < 0.0) {\n				gl_FragColor = outputColor;\n			}\n			else if (rightBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor * (1.0 - (rightBottom / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x <= 0.0) && (point.y >= 0.0)) {\n			if (leftTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (leftTop < 0.0) {\n				gl_FragColor = outputColor * (1.0 + (leftTop / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x <= 0.0) && (point.y <= 0.0)) {\n			if (leftBottom < 0.0) {\n				gl_FragColor = outputColor;\n			}\n			else if (leftBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor * (1.0 - (leftBottom / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n	}\n}\n";
}, function(t, e) {
  t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.1;\n	vec2 absPoint = abs(point);\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	vec2 alphaFormula = vec2(((halfRect.x * (timePercent + alphaWidth)) - absPoint.x) / (halfRect.x * alphaWidth), ((halfRect.y * (timePercent + alphaWidth)) - absPoint.y) / (halfRect.y * alphaWidth));\n	if (((option < 0.5) && (transition > 0.0)) || ((option > 0.5) && (transition < 0.0))) {\n		if ((absPoint.x < ((uBoundRect.z * 0.5) * timePercent)) || (absPoint.y < ((uBoundRect.w * 0.5) * timePercent))) {\n			gl_FragColor = vec4(0, 0, 0, 0);\n		}\n		else if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) || (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n			if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) && (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n				gl_FragColor = (outputColor * (1.0 - alphaFormula.x)) * (1.0 - alphaFormula.y);\n			}\n			else if (absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) {\n				gl_FragColor = outputColor * (1.0 - alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (1.0 - alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = outputColor;\n		}\n	}\n	else {\n		if ((absPoint.x < ((uBoundRect.z * 0.5) * timePercent)) || (absPoint.y < ((uBoundRect.w * 0.5) * timePercent))) {\n			gl_FragColor = outputColor;\n		}\n		else if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) || (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n			if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) && (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n				gl_FragColor = outputColor * (1.0 - ((1.0 - alphaFormula.x) * (1.0 - alphaFormula.y)));\n			}\n			else if (absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) {\n				gl_FragColor = outputColor * alphaFormula.x;\n			}\n			else {\n				gl_FragColor = outputColor * alphaFormula.y;\n			}\n		}\n		else {\n			gl_FragColor = vec4(0, 0, 0, 0);\n		}\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 absPoint = abs(point);\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	float alphaWidth = 0.1;\n	float timePercent = percent;\n	if (option < 1.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float axis = (option > 0.5) && (option < 2.5) ? absPoint.y : absPoint.x;\n	float compareAxis = (option > 0.5) && (option < 2.5) ? halfRect.y : halfRect.x;\n	float alphaColor = abs(((timePercent * compareAxis) - axis) / (alphaWidth * compareAxis));\n	vec4 beginColor;\n	vec4 endColor;\n	if ((option > 1.5) && (option < 3.5)) {\n		if (transition < 0.0) {\n			beginColor = vec4(0, 0, 0, 0);\n			endColor = outputColor;\n		}\n		else {\n			beginColor = outputColor;\n			endColor = vec4(0, 0, 0, 0);\n			alphaColor = 1.0 - alphaColor;\n		}\n	}\n	else {\n		if (transition < 0.0) {\n			beginColor = outputColor;\n			endColor = vec4(0, 0, 0, 0);\n			alphaColor = 1.0 - alphaColor;\n		}\n		else {\n			beginColor = vec4(0, 0, 0, 0);\n			endColor = outputColor;\n		}\n	}\n	if (axis < (timePercent * compareAxis)) {\n		gl_FragColor = beginColor;\n	}\n	else if (axis < ((timePercent + alphaWidth) * compareAxis)) {\n		gl_FragColor = outputColor * alphaColor;\n	}\n	else {\n		gl_FragColor = endColor;\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x, filterCoord.y);\n	if ((option > 0.5) && (option < 1.5)) {\n		point = filterCoord.xy;\n	}\n	else if ((option > 1.5) && (option < 2.5)) {\n		point = uBoundRect.zw - point.xy;\n	}\n	else if ((option > 2.5) && (option < 3.5)) {\n		point = vec2(uBoundRect.z - filterCoord.x, filterCoord.y);\n	}\n	else {\n		point = vec2(filterCoord.x, uBoundRect.w - filterCoord.y);\n	}\n	float squareCount = 16.0;\n	float horzBarWidth = uBoundRect.z / squareCount;\n	float verticalBarWidth = uBoundRect.w / squareCount;\n	float horzCount = floor(point.x / horzBarWidth);\n	float verticalCount = floor(point.y / verticalBarWidth);\n	float timePercent = (percent * squareCount) * 2.5;\n	vec4 alphaStage;\n	if (transition > 0.0) {\n		alphaStage = vec4(0.2, 0.4, 0.6, 0.8);\n	}\n	else {\n		alphaStage = vec4(0.8, 0.6, 0.4, 0.2);\n	}\n	if ((horzCount + verticalCount) < (timePercent - 4.0)) {\n		gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 3.0)) {\n		gl_FragColor = outputColor * alphaStage.w;\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 2.0)) {\n		gl_FragColor = outputColor * alphaStage.z;\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 1.0)) {\n		gl_FragColor = outputColor * alphaStage.y;\n	}\n	else if ((horzCount + verticalCount) < timePercent) {\n		gl_FragColor = outputColor * alphaStage.x;\n	}\n	else {\n		gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\n#define PI 3.1415926538\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 start = vec2(0.0, -1.0);\n	float arc = acos((dot(point.xy, start) / length(point)) / length(start));\n	if ((point.x == 0.0) && (point.y < 0.0)) {\n		arc = 0.0;\n	}\n	if ((point.x == 0.0) && (point.y > 0.0)) {\n		arc = PI;\n	}\n	float alphaBarArcWidth = 0.3;\n	float timePercent = (percent * PI) * (1.0 + alphaBarArcWidth);\n	vec3 colorAlpha = transition > 0.0 ? vec3(1.0, (timePercent - arc) / alphaBarArcWidth, 0.0) : vec3(0.0, 1.0 - ((timePercent - arc) / alphaBarArcWidth), 1.0);\n	if ((arc + alphaBarArcWidth) <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.x;\n	}\n	else if (arc <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.y;\n	}\n	else {\n		gl_FragColor = outputColor * colorAlpha.z;\n	}\n}\n";
}, function(t, e) {
  t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\n#define PI 3.1415926538\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 start = vec2(0.0, -1.0);\n	float arc = acos((dot(point.xy, start) / length(point)) / length(start));\n	if ((point.x == 0.0) && (point.y < 0.0)) {\n		arc = 0.0;\n	}\n	if ((point.x == 0.0) && (point.y > 0.0)) {\n		arc = PI;\n	}\n	if (point.x < 0.0) {\n		arc = (2.0 * PI) - arc;\n	}\n	arc = arc == 0.0 ? arc : mod(arc, (2.0 * PI) / option);\n	float totalAlphaBarArcWidth = 0.75;\n	float alphaBarArcWidth = totalAlphaBarArcWidth / option;\n	float timePercent = ((percent * PI) * (2.0 + totalAlphaBarArcWidth)) / option;\n	vec3 colorAlpha = transition > 0.0 ? vec3(1.0, (timePercent - arc) / alphaBarArcWidth, 0.0) : vec3(0.0, 1.0 - ((timePercent - arc) / alphaBarArcWidth), 1.0);\n	if ((arc + alphaBarArcWidth) <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.x;\n	}\n	else if (arc <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.y;\n	}\n	else {\n		gl_FragColor = outputColor * colorAlpha.z;\n	}\n}\n";
}, function(t, e, i) {
  var n = i(150);
  t.exports = function(t2, e2) {
    return n(t2, e2);
  };
}, function(t, e, i) {
  var n = i(24), r = Object.prototype, o = r.hasOwnProperty, s = r.toString, a = n ? n.toStringTag : void 0;
  t.exports = function(t2) {
    var e2 = o.call(t2, a), i2 = t2[a];
    try {
      t2[a] = void 0;
      var n2 = true;
    } catch (t3) {
    }
    var r2 = s.call(t2);
    return n2 && (e2 ? t2[a] = i2 : delete t2[a]), r2;
  };
}, function(t, e) {
  var i = Object.prototype.toString;
  t.exports = function(t2) {
    return i.call(t2);
  };
}, function(t, e, i) {
  (function(t2) {
    var e2 = i(108), n = i(111), r = i.n(n);
    /*!
     * @pixi/polyfill - v6.4.2
     * Compiled Thu, 02 Jun 2022 15:39:26 UTC
     *
     * @pixi/polyfill is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    typeof globalThis == "undefined" && (typeof self != "undefined" ? self.globalThis = self : t2 !== void 0 && (t2.globalThis = t2)), globalThis.Promise || (globalThis.Promise = e2.a), Object.assign || (Object.assign = r.a);
    if (Date.now && Date.prototype.getTime || (Date.now = function() {
      return new Date().getTime();
    }), !globalThis.performance || !globalThis.performance.now) {
      var o = Date.now();
      globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
        return Date.now() - o;
      };
    }
    for (var s = Date.now(), a = ["ms", "moz", "webkit", "o"], l = 0; l < a.length && !globalThis.requestAnimationFrame; ++l) {
      var h = a[l];
      globalThis.requestAnimationFrame = globalThis[h + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[h + "CancelAnimationFrame"] || globalThis[h + "CancelRequestAnimationFrame"];
    }
    globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(t3) {
      if (typeof t3 != "function")
        throw new TypeError(t3 + "is not a function");
      var e3 = Date.now(), i2 = 16 + s - e3;
      return i2 < 0 && (i2 = 0), s = e3, globalThis.self.setTimeout(function() {
        s = Date.now(), t3(performance.now());
      }, i2);
    }), globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(t3) {
      return clearTimeout(t3);
    }), Math.sign || (Math.sign = function(t3) {
      return (t3 = Number(t3)) === 0 || isNaN(t3) ? t3 : t3 > 0 ? 1 : -1;
    }), Number.isInteger || (Number.isInteger = function(t3) {
      return typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3;
    }), globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array), globalThis.Float32Array || (globalThis.Float32Array = Array), globalThis.Uint32Array || (globalThis.Uint32Array = Array), globalThis.Uint16Array || (globalThis.Uint16Array = Array), globalThis.Uint8Array || (globalThis.Uint8Array = Array), globalThis.Int32Array || (globalThis.Int32Array = Array);
  }).call(this, i(17));
}, function(t, e, i) {
  (function(t2) {
    var n = t2 !== void 0 && t2 || typeof self != "undefined" && self || window, r = Function.prototype.apply;
    function o(t3, e2) {
      this._id = t3, this._clearFn = e2;
    }
    e.setTimeout = function() {
      return new o(r.call(setTimeout, n, arguments), clearTimeout);
    }, e.setInterval = function() {
      return new o(r.call(setInterval, n, arguments), clearInterval);
    }, e.clearTimeout = e.clearInterval = function(t3) {
      t3 && t3.close();
    }, o.prototype.unref = o.prototype.ref = function() {
    }, o.prototype.close = function() {
      this._clearFn.call(n, this._id);
    }, e.enroll = function(t3, e2) {
      clearTimeout(t3._idleTimeoutId), t3._idleTimeout = e2;
    }, e.unenroll = function(t3) {
      clearTimeout(t3._idleTimeoutId), t3._idleTimeout = -1;
    }, e._unrefActive = e.active = function(t3) {
      clearTimeout(t3._idleTimeoutId);
      var e2 = t3._idleTimeout;
      e2 >= 0 && (t3._idleTimeoutId = setTimeout(function() {
        t3._onTimeout && t3._onTimeout();
      }, e2));
    }, i(141), e.setImmediate = typeof self != "undefined" && self.setImmediate || t2 !== void 0 && t2.setImmediate || this && this.setImmediate, e.clearImmediate = typeof self != "undefined" && self.clearImmediate || t2 !== void 0 && t2.clearImmediate || this && this.clearImmediate;
  }).call(this, i(17));
}, function(t, e, i) {
  (function(t2, e2) {
    !function(t3, i2) {
      if (!t3.setImmediate) {
        var n, r, o, s, a, l = 1, h = {}, u = false, c = t3.document, d = Object.getPrototypeOf && Object.getPrototypeOf(t3);
        d = d && d.setTimeout ? d : t3, {}.toString.call(t3.process) === "[object process]" ? n = function(t4) {
          e2.nextTick(function() {
            f(t4);
          });
        } : !function() {
          if (t3.postMessage && !t3.importScripts) {
            var e3 = true, i3 = t3.onmessage;
            return t3.onmessage = function() {
              e3 = false;
            }, t3.postMessage("", "*"), t3.onmessage = i3, e3;
          }
        }() ? t3.MessageChannel ? ((o = new MessageChannel()).port1.onmessage = function(t4) {
          f(t4.data);
        }, n = function(t4) {
          o.port2.postMessage(t4);
        }) : c && "onreadystatechange" in c.createElement("script") ? (r = c.documentElement, n = function(t4) {
          var e3 = c.createElement("script");
          e3.onreadystatechange = function() {
            f(t4), e3.onreadystatechange = null, r.removeChild(e3), e3 = null;
          }, r.appendChild(e3);
        }) : n = function(t4) {
          setTimeout(f, 0, t4);
        } : (s = "setImmediate$" + Math.random() + "$", a = function(e3) {
          e3.source === t3 && typeof e3.data == "string" && e3.data.indexOf(s) === 0 && f(+e3.data.slice(s.length));
        }, t3.addEventListener ? t3.addEventListener("message", a, false) : t3.attachEvent("onmessage", a), n = function(e3) {
          t3.postMessage(s + e3, "*");
        }), d.setImmediate = function(t4) {
          typeof t4 != "function" && (t4 = new Function("" + t4));
          for (var e3 = new Array(arguments.length - 1), i3 = 0; i3 < e3.length; i3++)
            e3[i3] = arguments[i3 + 1];
          var r2 = { callback: t4, args: e3 };
          return h[l] = r2, n(l), l++;
        }, d.clearImmediate = p;
      }
      function p(t4) {
        delete h[t4];
      }
      function f(t4) {
        if (u)
          setTimeout(f, 0, t4);
        else {
          var e3 = h[t4];
          if (e3) {
            u = true;
            try {
              !function(t5) {
                var e4 = t5.callback, i3 = t5.args;
                switch (i3.length) {
                  case 0:
                    e4();
                    break;
                  case 1:
                    e4(i3[0]);
                    break;
                  case 2:
                    e4(i3[0], i3[1]);
                    break;
                  case 3:
                    e4(i3[0], i3[1], i3[2]);
                    break;
                  default:
                    e4.apply(void 0, i3);
                }
              }(e3);
            } finally {
              p(t4), u = false;
            }
          }
        }
      }
    }(typeof self == "undefined" ? t2 === void 0 ? this : t2 : self);
  }).call(this, i(17), i(142));
}, function(t, e) {
  var i, n, r = t.exports = {};
  function o() {
    throw new Error("setTimeout has not been defined");
  }
  function s() {
    throw new Error("clearTimeout has not been defined");
  }
  function a(t2) {
    if (i === setTimeout)
      return setTimeout(t2, 0);
    if ((i === o || !i) && setTimeout)
      return i = setTimeout, setTimeout(t2, 0);
    try {
      return i(t2, 0);
    } catch (e2) {
      try {
        return i.call(null, t2, 0);
      } catch (e3) {
        return i.call(this, t2, 0);
      }
    }
  }
  !function() {
    try {
      i = typeof setTimeout == "function" ? setTimeout : o;
    } catch (t2) {
      i = o;
    }
    try {
      n = typeof clearTimeout == "function" ? clearTimeout : s;
    } catch (t2) {
      n = s;
    }
  }();
  var l, h = [], u = false, c = -1;
  function d() {
    u && l && (u = false, l.length ? h = l.concat(h) : c = -1, h.length && p());
  }
  function p() {
    if (!u) {
      var t2 = a(d);
      u = true;
      for (var e2 = h.length; e2; ) {
        for (l = h, h = []; ++c < e2; )
          l && l[c].run();
        c = -1, e2 = h.length;
      }
      l = null, u = false, function(t3) {
        if (n === clearTimeout)
          return clearTimeout(t3);
        if ((n === s || !n) && clearTimeout)
          return n = clearTimeout, clearTimeout(t3);
        try {
          n(t3);
        } catch (e3) {
          try {
            return n.call(null, t3);
          } catch (e4) {
            return n.call(this, t3);
          }
        }
      }(t2);
    }
  }
  function f(t2, e2) {
    this.fun = t2, this.array = e2;
  }
  function m() {
  }
  r.nextTick = function(t2) {
    var e2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var i2 = 1; i2 < arguments.length; i2++)
        e2[i2 - 1] = arguments[i2];
    h.push(new f(t2, e2)), h.length !== 1 || u || a(p);
  }, f.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, r.title = "browser", r.browser = true, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = m, r.addListener = m, r.once = m, r.off = m, r.removeListener = m, r.removeAllListeners = m, r.emit = m, r.prependListener = m, r.prependOnceListener = m, r.listeners = function(t2) {
    return [];
  }, r.binding = function(t2) {
    throw new Error("process.binding is not supported");
  }, r.cwd = function() {
    return "/";
  }, r.chdir = function(t2) {
    throw new Error("process.chdir is not supported");
  }, r.umask = function() {
    return 0;
  };
}, function(t, e, i) {
  (function(t2, n) {
    var r;
    /*! https://mths.be/punycode v1.4.1 by @mathias */
    !function(o) {
      e && e.nodeType, t2 && t2.nodeType;
      var s = typeof n == "object" && n;
      s.global !== s && s.window !== s && s.self;
      var a, l = 2147483647, h = /^xn--/, u = /[^\x20-\x7E]/, c = /[\x2E\u3002\uFF0E\uFF61]/g, d = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, p = Math.floor, f = String.fromCharCode;
      function m(t3) {
        throw new RangeError(d[t3]);
      }
      function g(t3, e2) {
        for (var i2 = t3.length, n2 = []; i2--; )
          n2[i2] = e2(t3[i2]);
        return n2;
      }
      function v(t3, e2) {
        var i2 = t3.split("@"), n2 = "";
        return i2.length > 1 && (n2 = i2[0] + "@", t3 = i2[1]), n2 + g((t3 = t3.replace(c, ".")).split("."), e2).join(".");
      }
      function _(t3) {
        for (var e2, i2, n2 = [], r2 = 0, o2 = t3.length; r2 < o2; )
          (e2 = t3.charCodeAt(r2++)) >= 55296 && e2 <= 56319 && r2 < o2 ? (64512 & (i2 = t3.charCodeAt(r2++))) == 56320 ? n2.push(((1023 & e2) << 10) + (1023 & i2) + 65536) : (n2.push(e2), r2--) : n2.push(e2);
        return n2;
      }
      function y(t3) {
        return g(t3, function(t4) {
          var e2 = "";
          return t4 > 65535 && (e2 += f((t4 -= 65536) >>> 10 & 1023 | 55296), t4 = 56320 | 1023 & t4), e2 += f(t4);
        }).join("");
      }
      function x(t3, e2) {
        return t3 + 22 + 75 * (t3 < 26) - ((e2 != 0) << 5);
      }
      function b(t3, e2, i2) {
        var n2 = 0;
        for (t3 = i2 ? p(t3 / 700) : t3 >> 1, t3 += p(t3 / e2); t3 > 455; n2 += 36)
          t3 = p(t3 / 35);
        return p(n2 + 36 * t3 / (t3 + 38));
      }
      function T(t3) {
        var e2, i2, n2, r2, o2, s2, a2, h2, u2, c2, d2, f2 = [], g2 = t3.length, v2 = 0, _2 = 128, x2 = 72;
        for ((i2 = t3.lastIndexOf("-")) < 0 && (i2 = 0), n2 = 0; n2 < i2; ++n2)
          t3.charCodeAt(n2) >= 128 && m("not-basic"), f2.push(t3.charCodeAt(n2));
        for (r2 = i2 > 0 ? i2 + 1 : 0; r2 < g2; ) {
          for (o2 = v2, s2 = 1, a2 = 36; r2 >= g2 && m("invalid-input"), ((h2 = (d2 = t3.charCodeAt(r2++)) - 48 < 10 ? d2 - 22 : d2 - 65 < 26 ? d2 - 65 : d2 - 97 < 26 ? d2 - 97 : 36) >= 36 || h2 > p((l - v2) / s2)) && m("overflow"), v2 += h2 * s2, !(h2 < (u2 = a2 <= x2 ? 1 : a2 >= x2 + 26 ? 26 : a2 - x2)); a2 += 36)
            s2 > p(l / (c2 = 36 - u2)) && m("overflow"), s2 *= c2;
          x2 = b(v2 - o2, e2 = f2.length + 1, o2 == 0), p(v2 / e2) > l - _2 && m("overflow"), _2 += p(v2 / e2), v2 %= e2, f2.splice(v2++, 0, _2);
        }
        return y(f2);
      }
      function E(t3) {
        var e2, i2, n2, r2, o2, s2, a2, h2, u2, c2, d2, g2, v2, y2, T2, E2 = [];
        for (g2 = (t3 = _(t3)).length, e2 = 128, i2 = 0, o2 = 72, s2 = 0; s2 < g2; ++s2)
          (d2 = t3[s2]) < 128 && E2.push(f(d2));
        for (n2 = r2 = E2.length, r2 && E2.push("-"); n2 < g2; ) {
          for (a2 = l, s2 = 0; s2 < g2; ++s2)
            (d2 = t3[s2]) >= e2 && d2 < a2 && (a2 = d2);
          for (a2 - e2 > p((l - i2) / (v2 = n2 + 1)) && m("overflow"), i2 += (a2 - e2) * v2, e2 = a2, s2 = 0; s2 < g2; ++s2)
            if ((d2 = t3[s2]) < e2 && ++i2 > l && m("overflow"), d2 == e2) {
              for (h2 = i2, u2 = 36; !(h2 < (c2 = u2 <= o2 ? 1 : u2 >= o2 + 26 ? 26 : u2 - o2)); u2 += 36)
                T2 = h2 - c2, y2 = 36 - c2, E2.push(f(x(c2 + T2 % y2, 0))), h2 = p(T2 / y2);
              E2.push(f(x(h2, 0))), o2 = b(i2, v2, n2 == r2), i2 = 0, ++n2;
            }
          ++i2, ++e2;
        }
        return E2.join("");
      }
      a = { version: "1.4.1", ucs2: { decode: _, encode: y }, decode: T, encode: E, toASCII: function(t3) {
        return v(t3, function(t4) {
          return u.test(t4) ? "xn--" + E(t4) : t4;
        });
      }, toUnicode: function(t3) {
        return v(t3, function(t4) {
          return h.test(t4) ? T(t4.slice(4).toLowerCase()) : t4;
        });
      } }, (r = function() {
        return a;
      }.call(e, i, e, t2)) === void 0 || (t2.exports = r);
    }();
  }).call(this, i(25)(t), i(17));
}, function(t, e, i) {
  t.exports = { isString: function(t2) {
    return typeof t2 == "string";
  }, isObject: function(t2) {
    return typeof t2 == "object" && t2 !== null;
  }, isNull: function(t2) {
    return t2 === null;
  }, isNullOrUndefined: function(t2) {
    return t2 == null;
  } };
}, function(t, e, i) {
  e.decode = e.parse = i(146), e.encode = e.stringify = i(147);
}, function(t, e, i) {
  function n(t2, e2) {
    return Object.prototype.hasOwnProperty.call(t2, e2);
  }
  t.exports = function(t2, e2, i2, o) {
    e2 = e2 || "&", i2 = i2 || "=";
    var s = {};
    if (typeof t2 != "string" || t2.length === 0)
      return s;
    var a = /\+/g;
    t2 = t2.split(e2);
    var l = 1e3;
    o && typeof o.maxKeys == "number" && (l = o.maxKeys);
    var h = t2.length;
    l > 0 && h > l && (h = l);
    for (var u = 0; u < h; ++u) {
      var c, d, p, f, m = t2[u].replace(a, "%20"), g = m.indexOf(i2);
      g >= 0 ? (c = m.substr(0, g), d = m.substr(g + 1)) : (c = m, d = ""), p = decodeURIComponent(c), f = decodeURIComponent(d), n(s, p) ? r(s[p]) ? s[p].push(f) : s[p] = [s[p], f] : s[p] = f;
    }
    return s;
  };
  var r = Array.isArray || function(t2) {
    return Object.prototype.toString.call(t2) === "[object Array]";
  };
}, function(t, e, i) {
  var n = function(t2) {
    switch (typeof t2) {
      case "string":
        return t2;
      case "boolean":
        return t2 ? "true" : "false";
      case "number":
        return isFinite(t2) ? t2 : "";
      default:
        return "";
    }
  };
  t.exports = function(t2, e2, i2, a) {
    return e2 = e2 || "&", i2 = i2 || "=", t2 === null && (t2 = void 0), typeof t2 == "object" ? o(s(t2), function(s2) {
      var a2 = encodeURIComponent(n(s2)) + i2;
      return r(t2[s2]) ? o(t2[s2], function(t3) {
        return a2 + encodeURIComponent(n(t3));
      }).join(e2) : a2 + encodeURIComponent(n(t2[s2]));
    }).join(e2) : a ? encodeURIComponent(n(a)) + i2 + encodeURIComponent(n(t2)) : "";
  };
  var r = Array.isArray || function(t2) {
    return Object.prototype.toString.call(t2) === "[object Array]";
  };
  function o(t2, e2) {
    if (t2.map)
      return t2.map(e2);
    for (var i2 = [], n2 = 0; n2 < t2.length; n2++)
      i2.push(e2(t2[n2], n2));
    return i2;
  }
  var s = Object.keys || function(t2) {
    var e2 = [];
    for (var i2 in t2)
      Object.prototype.hasOwnProperty.call(t2, i2) && e2.push(i2);
    return e2;
  };
}, function(t, e) {
  var i = function() {
  };
  i.prototype = { fit: function(t2) {
    var e2, i2, n, r, o = t2.length, s = o > 0 ? t2[0].width : 0, a = o > 0 ? t2[0].height : 0;
    for (this.root = { x: 0, y: 0, width: s, height: a }, e2 = 0; e2 < o; e2++)
      n = t2[e2], (i2 = this.findNode(this.root, n.width, n.height)) ? (r = this.splitNode(i2, n.width, n.height), n.x = r.x, n.y = r.y) : (r = this.growNode(n.width, n.height), n.x = r.x, n.y = r.y);
  }, findNode: function(t2, e2, i2) {
    return t2.used ? this.findNode(t2.right, e2, i2) || this.findNode(t2.down, e2, i2) : e2 <= t2.width && i2 <= t2.height ? t2 : null;
  }, splitNode: function(t2, e2, i2) {
    return t2.used = true, t2.down = { x: t2.x, y: t2.y + i2, width: t2.width, height: t2.height - i2 }, t2.right = { x: t2.x + e2, y: t2.y, width: t2.width - e2, height: i2 }, t2;
  }, growNode: function(t2, e2) {
    var i2 = t2 <= this.root.width, n = e2 <= this.root.height, r = n && this.root.height >= this.root.width + t2, o = i2 && this.root.width >= this.root.height + e2;
    return r ? this.growRight(t2, e2) : o ? this.growDown(t2, e2) : n ? this.growRight(t2, e2) : i2 ? this.growDown(t2, e2) : null;
  }, growRight: function(t2, e2) {
    var i2;
    return this.root = { used: true, x: 0, y: 0, width: this.root.width + t2, height: this.root.height, down: this.root, right: { x: this.root.width, y: 0, width: t2, height: this.root.height } }, (i2 = this.findNode(this.root, t2, e2)) ? this.splitNode(i2, t2, e2) : null;
  }, growDown: function(t2, e2) {
    var i2;
    return this.root = { used: true, x: 0, y: 0, width: this.root.width, height: this.root.height + e2, down: { x: 0, y: this.root.height, width: this.root.width, height: e2 }, right: this.root }, (i2 = this.findNode(this.root, t2, e2)) ? this.splitNode(i2, t2, e2) : null;
  } }, t.exports = i;
}, function(t, e) {
  (function(e2) {
    t.exports = e2;
  }).call(this, {});
}, function(t, e, i) {
  var n = i(151), r = i(15);
  t.exports = function t2(e2, i2, o, s, a) {
    return e2 === i2 || (e2 == null || i2 == null || !r(e2) && !r(i2) ? e2 != e2 && i2 != i2 : n(e2, i2, o, s, t2, a));
  };
}, function(t, e, i) {
  var n = i(54), r = i(57), o = i(183), s = i(186), a = i(31), l = i(30), h = i(40), u = i(64), c = "[object Object]", d = Object.prototype.hasOwnProperty;
  t.exports = function(t2, e2, i2, p, f, m) {
    var g = l(t2), v = l(e2), _ = g ? "[object Array]" : a(t2), y = v ? "[object Array]" : a(e2), x = (_ = _ == "[object Arguments]" ? c : _) == c, b = (y = y == "[object Arguments]" ? c : y) == c, T = _ == y;
    if (T && h(t2)) {
      if (!h(e2))
        return false;
      g = true, x = false;
    }
    if (T && !x)
      return m || (m = new n()), g || u(t2) ? r(t2, e2, i2, p, f, m) : o(t2, e2, _, i2, p, f, m);
    if (!(1 & i2)) {
      var E = x && d.call(t2, "__wrapped__"), S = b && d.call(e2, "__wrapped__");
      if (E || S) {
        var w = E ? t2.value() : t2, A = S ? e2.value() : e2;
        return m || (m = new n()), f(w, A, i2, p, m);
      }
    }
    return !!T && (m || (m = new n()), s(t2, e2, i2, p, f, m));
  };
}, function(t, e) {
  t.exports = function() {
    this.__data__ = [], this.size = 0;
  };
}, function(t, e, i) {
  var n = i(27), r = Array.prototype.splice;
  t.exports = function(t2) {
    var e2 = this.__data__, i2 = n(e2, t2);
    return !(i2 < 0) && (i2 == e2.length - 1 ? e2.pop() : r.call(e2, i2, 1), --this.size, true);
  };
}, function(t, e, i) {
  var n = i(27);
  t.exports = function(t2) {
    var e2 = this.__data__, i2 = n(e2, t2);
    return i2 < 0 ? void 0 : e2[i2][1];
  };
}, function(t, e, i) {
  var n = i(27);
  t.exports = function(t2) {
    return n(this.__data__, t2) > -1;
  };
}, function(t, e, i) {
  var n = i(27);
  t.exports = function(t2, e2) {
    var i2 = this.__data__, r = n(i2, t2);
    return r < 0 ? (++this.size, i2.push([t2, e2])) : i2[r][1] = e2, this;
  };
}, function(t, e, i) {
  var n = i(26);
  t.exports = function() {
    this.__data__ = new n(), this.size = 0;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = this.__data__, i = e2.delete(t2);
    return this.size = e2.size, i;
  };
}, function(t, e) {
  t.exports = function(t2) {
    return this.__data__.get(t2);
  };
}, function(t, e) {
  t.exports = function(t2) {
    return this.__data__.has(t2);
  };
}, function(t, e, i) {
  var n = i(26), r = i(37), o = i(56);
  t.exports = function(t2, e2) {
    var i2 = this.__data__;
    if (i2 instanceof n) {
      var s = i2.__data__;
      if (!r || s.length < 199)
        return s.push([t2, e2]), this.size = ++i2.size, this;
      i2 = this.__data__ = new o(s);
    }
    return i2.set(t2, e2), this.size = i2.size, this;
  };
}, function(t, e, i) {
  var n = i(33), r = i(163), o = i(21), s = i(55), a = /^\[object .+?Constructor\]$/, l = Function.prototype, h = Object.prototype, u = l.toString, c = h.hasOwnProperty, d = RegExp("^" + u.call(c).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  t.exports = function(t2) {
    return !(!o(t2) || r(t2)) && (n(t2) ? d : a).test(s(t2));
  };
}, function(t, e, i) {
  var n, r = i(164), o = (n = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "";
  t.exports = function(t2) {
    return !!o && o in t2;
  };
}, function(t, e, i) {
  var n = i(14)["__core-js_shared__"];
  t.exports = n;
}, function(t, e) {
  t.exports = function(t2, e2) {
    return t2 == null ? void 0 : t2[e2];
  };
}, function(t, e, i) {
  var n = i(167), r = i(26), o = i(37);
  t.exports = function() {
    this.size = 0, this.__data__ = { hash: new n(), map: new (o || r)(), string: new n() };
  };
}, function(t, e, i) {
  var n = i(168), r = i(169), o = i(170), s = i(171), a = i(172);
  function l(t2) {
    var e2 = -1, i2 = t2 == null ? 0 : t2.length;
    for (this.clear(); ++e2 < i2; ) {
      var n2 = t2[e2];
      this.set(n2[0], n2[1]);
    }
  }
  l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
}, function(t, e, i) {
  var n = i(28);
  t.exports = function() {
    this.__data__ = n ? n(null) : {}, this.size = 0;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = this.has(t2) && delete this.__data__[t2];
    return this.size -= e2 ? 1 : 0, e2;
  };
}, function(t, e, i) {
  var n = i(28), r = Object.prototype.hasOwnProperty;
  t.exports = function(t2) {
    var e2 = this.__data__;
    if (n) {
      var i2 = e2[t2];
      return i2 === "__lodash_hash_undefined__" ? void 0 : i2;
    }
    return r.call(e2, t2) ? e2[t2] : void 0;
  };
}, function(t, e, i) {
  var n = i(28), r = Object.prototype.hasOwnProperty;
  t.exports = function(t2) {
    var e2 = this.__data__;
    return n ? e2[t2] !== void 0 : r.call(e2, t2);
  };
}, function(t, e, i) {
  var n = i(28);
  t.exports = function(t2, e2) {
    var i2 = this.__data__;
    return this.size += this.has(t2) ? 0 : 1, i2[t2] = n && e2 === void 0 ? "__lodash_hash_undefined__" : e2, this;
  };
}, function(t, e, i) {
  var n = i(29);
  t.exports = function(t2) {
    var e2 = n(this, t2).delete(t2);
    return this.size -= e2 ? 1 : 0, e2;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = typeof t2;
    return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t2 !== "__proto__" : t2 === null;
  };
}, function(t, e, i) {
  var n = i(29);
  t.exports = function(t2) {
    return n(this, t2).get(t2);
  };
}, function(t, e, i) {
  var n = i(29);
  t.exports = function(t2) {
    return n(this, t2).has(t2);
  };
}, function(t, e, i) {
  var n = i(29);
  t.exports = function(t2, e2) {
    var i2 = n(this, t2), r = i2.size;
    return i2.set(t2, e2), this.size += i2.size == r ? 0 : 1, this;
  };
}, function(t, e, i) {
  var n = i(56), r = i(179), o = i(180);
  function s(t2) {
    var e2 = -1, i2 = t2 == null ? 0 : t2.length;
    for (this.__data__ = new n(); ++e2 < i2; )
      this.add(t2[e2]);
  }
  s.prototype.add = s.prototype.push = r, s.prototype.has = o, t.exports = s;
}, function(t, e) {
  t.exports = function(t2) {
    return this.__data__.set(t2, "__lodash_hash_undefined__"), this;
  };
}, function(t, e) {
  t.exports = function(t2) {
    return this.__data__.has(t2);
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    for (var i = -1, n = t2 == null ? 0 : t2.length; ++i < n; )
      if (e2(t2[i], i, t2))
        return true;
    return false;
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    return t2.has(e2);
  };
}, function(t, e, i) {
  var n = i(24), r = i(58), o = i(36), s = i(57), a = i(184), l = i(185), h = n ? n.prototype : void 0, u = h ? h.valueOf : void 0;
  t.exports = function(t2, e2, i2, n2, h2, c, d) {
    switch (i2) {
      case "[object DataView]":
        if (t2.byteLength != e2.byteLength || t2.byteOffset != e2.byteOffset)
          return false;
        t2 = t2.buffer, e2 = e2.buffer;
      case "[object ArrayBuffer]":
        return !(t2.byteLength != e2.byteLength || !c(new r(t2), new r(e2)));
      case "[object Boolean]":
      case "[object Date]":
      case "[object Number]":
        return o(+t2, +e2);
      case "[object Error]":
        return t2.name == e2.name && t2.message == e2.message;
      case "[object RegExp]":
      case "[object String]":
        return t2 == e2 + "";
      case "[object Map]":
        var p = a;
      case "[object Set]":
        var f = 1 & n2;
        if (p || (p = l), t2.size != e2.size && !f)
          return false;
        var m = d.get(t2);
        if (m)
          return m == e2;
        n2 |= 2, d.set(t2, e2);
        var g = s(p(t2), p(e2), n2, h2, c, d);
        return d.delete(t2), g;
      case "[object Symbol]":
        if (u)
          return u.call(t2) == u.call(e2);
    }
    return false;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = -1, i = Array(t2.size);
    return t2.forEach(function(t3, n) {
      i[++e2] = [n, t3];
    }), i;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = -1, i = Array(t2.size);
    return t2.forEach(function(t3) {
      i[++e2] = t3;
    }), i;
  };
}, function(t, e, i) {
  var n = i(59), r = Object.prototype.hasOwnProperty;
  t.exports = function(t2, e2, i2, o, s, a) {
    var l = 1 & i2, h = n(t2), u = h.length;
    if (u != n(e2).length && !l)
      return false;
    for (var c = u; c--; ) {
      var d = h[c];
      if (!(l ? d in e2 : r.call(e2, d)))
        return false;
    }
    var p = a.get(t2), f = a.get(e2);
    if (p && f)
      return p == e2 && f == t2;
    var m = true;
    a.set(t2, e2), a.set(e2, t2);
    for (var g = l; ++c < u; ) {
      var v = t2[d = h[c]], _ = e2[d];
      if (o)
        var y = l ? o(_, v, d, e2, t2, a) : o(v, _, d, t2, e2, a);
      if (!(y === void 0 ? v === _ || s(v, _, i2, o, a) : y)) {
        m = false;
        break;
      }
      g || (g = d == "constructor");
    }
    if (m && !g) {
      var x = t2.constructor, b = e2.constructor;
      x == b || !("constructor" in t2) || !("constructor" in e2) || typeof x == "function" && x instanceof x && typeof b == "function" && b instanceof b || (m = false);
    }
    return a.delete(t2), a.delete(e2), m;
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    for (var i = -1, n = t2 == null ? 0 : t2.length, r = 0, o = []; ++i < n; ) {
      var s = t2[i];
      e2(s, i, t2) && (o[r++] = s);
    }
    return o;
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    for (var i = -1, n = Array(t2); ++i < t2; )
      n[i] = e2(i);
    return n;
  };
}, function(t, e, i) {
  var n = i(190), r = i(15), o = Object.prototype, s = o.hasOwnProperty, a = o.propertyIsEnumerable, l = n(function() {
    return arguments;
  }()) ? n : function(t2) {
    return r(t2) && s.call(t2, "callee") && !a.call(t2, "callee");
  };
  t.exports = l;
}, function(t, e, i) {
  var n = i(20), r = i(15);
  t.exports = function(t2) {
    return r(t2) && n(t2) == "[object Arguments]";
  };
}, function(t, e) {
  t.exports = function() {
    return false;
  };
}, function(t, e) {
  var i = /^(?:0|[1-9]\d*)$/;
  t.exports = function(t2, e2) {
    var n = typeof t2;
    return !!(e2 = e2 == null ? 9007199254740991 : e2) && (n == "number" || n != "symbol" && i.test(t2)) && t2 > -1 && t2 % 1 == 0 && t2 < e2;
  };
}, function(t, e, i) {
  var n = i(20), r = i(65), o = i(15), s = {};
  s["[object Float32Array]"] = s["[object Float64Array]"] = s["[object Int8Array]"] = s["[object Int16Array]"] = s["[object Int32Array]"] = s["[object Uint8Array]"] = s["[object Uint8ClampedArray]"] = s["[object Uint16Array]"] = s["[object Uint32Array]"] = true, s["[object Arguments]"] = s["[object Array]"] = s["[object ArrayBuffer]"] = s["[object Boolean]"] = s["[object DataView]"] = s["[object Date]"] = s["[object Error]"] = s["[object Function]"] = s["[object Map]"] = s["[object Number]"] = s["[object Object]"] = s["[object RegExp]"] = s["[object Set]"] = s["[object String]"] = s["[object WeakMap]"] = false, t.exports = function(t2) {
    return o(t2) && r(t2.length) && !!s[n(t2)];
  };
}, function(t, e, i) {
  var n = i(43), r = i(195), o = Object.prototype.hasOwnProperty;
  t.exports = function(t2) {
    if (!n(t2))
      return r(t2);
    var e2 = [];
    for (var i2 in Object(t2))
      o.call(t2, i2) && i2 != "constructor" && e2.push(i2);
    return e2;
  };
}, function(t, e, i) {
  var n = i(66)(Object.keys, Object);
  t.exports = n;
}, function(t, e, i) {
  var n = i(22)(i(14), "DataView");
  t.exports = n;
}, function(t, e, i) {
  var n = i(22)(i(14), "Promise");
  t.exports = n;
}, function(t, e, i) {
  var n = i(22)(i(14), "Set");
  t.exports = n;
}, function(t, e, i) {
  var n = i(22)(i(14), "WeakMap");
  t.exports = n;
}, function(t, e, i) {
  var n = i(14);
  t.exports = function() {
    return n.Date.now();
  };
}, function(t, e, i) {
  var n = i(202), r = i(21), o = i(204), s = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, l = /^0o[0-7]+$/i, h = parseInt;
  t.exports = function(t2) {
    if (typeof t2 == "number")
      return t2;
    if (o(t2))
      return NaN;
    if (r(t2)) {
      var e2 = typeof t2.valueOf == "function" ? t2.valueOf() : t2;
      t2 = r(e2) ? e2 + "" : e2;
    }
    if (typeof t2 != "string")
      return t2 === 0 ? t2 : +t2;
    t2 = n(t2);
    var i2 = a.test(t2);
    return i2 || l.test(t2) ? h(t2.slice(2), i2 ? 2 : 8) : s.test(t2) ? NaN : +t2;
  };
}, function(t, e, i) {
  var n = i(203), r = /^\s+/;
  t.exports = function(t2) {
    return t2 ? t2.slice(0, n(t2) + 1).replace(r, "") : t2;
  };
}, function(t, e) {
  var i = /\s/;
  t.exports = function(t2) {
    for (var e2 = t2.length; e2-- && i.test(t2.charAt(e2)); )
      ;
    return e2;
  };
}, function(t, e, i) {
  var n = i(20), r = i(15);
  t.exports = function(t2) {
    return typeof t2 == "symbol" || r(t2) && n(t2) == "[object Symbol]";
  };
}, function(t, e, i) {
  var n = i(54), r = i(206), o = i(68), s = i(208), a = i(209), l = i(212), h = i(213), u = i(214), c = i(215), d = i(59), p = i(216), f = i(31), m = i(217), g = i(218), v = i(223), _ = i(30), y = i(40), x = i(225), b = i(21), T = i(227), E = i(39), S = i(44), w = {};
  w["[object Arguments]"] = w["[object Array]"] = w["[object ArrayBuffer]"] = w["[object DataView]"] = w["[object Boolean]"] = w["[object Date]"] = w["[object Float32Array]"] = w["[object Float64Array]"] = w["[object Int8Array]"] = w["[object Int16Array]"] = w["[object Int32Array]"] = w["[object Map]"] = w["[object Number]"] = w["[object Object]"] = w["[object RegExp]"] = w["[object Set]"] = w["[object String]"] = w["[object Symbol]"] = w["[object Uint8Array]"] = w["[object Uint8ClampedArray]"] = w["[object Uint16Array]"] = w["[object Uint32Array]"] = true, w["[object Error]"] = w["[object Function]"] = w["[object WeakMap]"] = false, t.exports = function t2(e2, i2, A, M, R, C) {
    var I, P = 1 & i2, O = 2 & i2, N = 4 & i2;
    if (A && (I = R ? A(e2, M, R, C) : A(e2)), I !== void 0)
      return I;
    if (!b(e2))
      return e2;
    var L = _(e2);
    if (L) {
      if (I = m(e2), !P)
        return h(e2, I);
    } else {
      var D = f(e2), F = D == "[object Function]" || D == "[object GeneratorFunction]";
      if (y(e2))
        return l(e2, P);
      if (D == "[object Object]" || D == "[object Arguments]" || F && !R) {
        if (I = O || F ? {} : v(e2), !P)
          return O ? c(e2, a(I, e2)) : u(e2, s(I, e2));
      } else {
        if (!w[D])
          return R ? e2 : {};
        I = g(e2, D, P);
      }
    }
    C || (C = new n());
    var B = C.get(e2);
    if (B)
      return B;
    C.set(e2, I), T(e2) ? e2.forEach(function(n2) {
      I.add(t2(n2, i2, A, n2, e2, C));
    }) : x(e2) && e2.forEach(function(n2, r2) {
      I.set(r2, t2(n2, i2, A, r2, e2, C));
    });
    var U = L ? void 0 : (N ? O ? p : d : O ? S : E)(e2);
    return r(U || e2, function(n2, r2) {
      U && (n2 = e2[r2 = n2]), o(I, r2, t2(n2, i2, A, r2, e2, C));
    }), I;
  };
}, function(t, e) {
  t.exports = function(t2, e2) {
    for (var i = -1, n = t2 == null ? 0 : t2.length; ++i < n && e2(t2[i], i, t2) !== false; )
      ;
    return t2;
  };
}, function(t, e, i) {
  var n = i(22), r = function() {
    try {
      var t2 = n(Object, "defineProperty");
      return t2({}, "", {}), t2;
    } catch (t3) {
    }
  }();
  t.exports = r;
}, function(t, e, i) {
  var n = i(32), r = i(39);
  t.exports = function(t2, e2) {
    return t2 && n(e2, r(e2), t2);
  };
}, function(t, e, i) {
  var n = i(32), r = i(44);
  t.exports = function(t2, e2) {
    return t2 && n(e2, r(e2), t2);
  };
}, function(t, e, i) {
  var n = i(21), r = i(43), o = i(211), s = Object.prototype.hasOwnProperty;
  t.exports = function(t2) {
    if (!n(t2))
      return o(t2);
    var e2 = r(t2), i2 = [];
    for (var a in t2)
      (a != "constructor" || !e2 && s.call(t2, a)) && i2.push(a);
    return i2;
  };
}, function(t, e) {
  t.exports = function(t2) {
    var e2 = [];
    if (t2 != null)
      for (var i in Object(t2))
        e2.push(i);
    return e2;
  };
}, function(t, e, i) {
  (function(t2) {
    var n = i(14), r = e && !e.nodeType && e, o = r && typeof t2 == "object" && t2 && !t2.nodeType && t2, s = o && o.exports === r ? n.Buffer : void 0, a = s ? s.allocUnsafe : void 0;
    t2.exports = function(t3, e2) {
      if (e2)
        return t3.slice();
      var i2 = t3.length, n2 = a ? a(i2) : new t3.constructor(i2);
      return t3.copy(n2), n2;
    };
  }).call(this, i(25)(t));
}, function(t, e) {
  t.exports = function(t2, e2) {
    var i = -1, n = t2.length;
    for (e2 || (e2 = Array(n)); ++i < n; )
      e2[i] = t2[i];
    return e2;
  };
}, function(t, e, i) {
  var n = i(32), r = i(38);
  t.exports = function(t2, e2) {
    return n(t2, r(t2), e2);
  };
}, function(t, e, i) {
  var n = i(32), r = i(70);
  t.exports = function(t2, e2) {
    return n(t2, r(t2), e2);
  };
}, function(t, e, i) {
  var n = i(60), r = i(70), o = i(44);
  t.exports = function(t2) {
    return n(t2, o, r);
  };
}, function(t, e) {
  var i = Object.prototype.hasOwnProperty;
  t.exports = function(t2) {
    var e2 = t2.length, n = new t2.constructor(e2);
    return e2 && typeof t2[0] == "string" && i.call(t2, "index") && (n.index = t2.index, n.input = t2.input), n;
  };
}, function(t, e, i) {
  var n = i(45), r = i(219), o = i(220), s = i(221), a = i(222);
  t.exports = function(t2, e2, i2) {
    var l = t2.constructor;
    switch (e2) {
      case "[object ArrayBuffer]":
        return n(t2);
      case "[object Boolean]":
      case "[object Date]":
        return new l(+t2);
      case "[object DataView]":
        return r(t2, i2);
      case "[object Float32Array]":
      case "[object Float64Array]":
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object Int32Array]":
      case "[object Uint8Array]":
      case "[object Uint8ClampedArray]":
      case "[object Uint16Array]":
      case "[object Uint32Array]":
        return a(t2, i2);
      case "[object Map]":
        return new l();
      case "[object Number]":
      case "[object String]":
        return new l(t2);
      case "[object RegExp]":
        return o(t2);
      case "[object Set]":
        return new l();
      case "[object Symbol]":
        return s(t2);
    }
  };
}, function(t, e, i) {
  var n = i(45);
  t.exports = function(t2, e2) {
    var i2 = e2 ? n(t2.buffer) : t2.buffer;
    return new t2.constructor(i2, t2.byteOffset, t2.byteLength);
  };
}, function(t, e) {
  var i = /\w*$/;
  t.exports = function(t2) {
    var e2 = new t2.constructor(t2.source, i.exec(t2));
    return e2.lastIndex = t2.lastIndex, e2;
  };
}, function(t, e, i) {
  var n = i(24), r = n ? n.prototype : void 0, o = r ? r.valueOf : void 0;
  t.exports = function(t2) {
    return o ? Object(o.call(t2)) : {};
  };
}, function(t, e, i) {
  var n = i(45);
  t.exports = function(t2, e2) {
    var i2 = e2 ? n(t2.buffer) : t2.buffer;
    return new t2.constructor(i2, t2.byteOffset, t2.length);
  };
}, function(t, e, i) {
  var n = i(224), r = i(71), o = i(43);
  t.exports = function(t2) {
    return typeof t2.constructor != "function" || o(t2) ? {} : n(r(t2));
  };
}, function(t, e, i) {
  var n = i(21), r = Object.create, o = function() {
    function t2() {
    }
    return function(e2) {
      if (!n(e2))
        return {};
      if (r)
        return r(e2);
      t2.prototype = e2;
      var i2 = new t2();
      return t2.prototype = void 0, i2;
    };
  }();
  t.exports = o;
}, function(t, e, i) {
  var n = i(226), r = i(41), o = i(42), s = o && o.isMap, a = s ? r(s) : n;
  t.exports = a;
}, function(t, e, i) {
  var n = i(31), r = i(15);
  t.exports = function(t2) {
    return r(t2) && n(t2) == "[object Map]";
  };
}, function(t, e, i) {
  var n = i(228), r = i(41), o = i(42), s = o && o.isSet, a = s ? r(s) : n;
  t.exports = a;
}, function(t, e, i) {
  var n = i(31), r = i(15);
  t.exports = function(t2) {
    return r(t2) && n(t2) == "[object Set]";
  };
}, function(t, e, i) {
  i.r(e), i.d(e, "delay", function() {
    return dT;
  }), i.d(e, "waitUntil", function() {
    return pT;
  }), i.d(e, "SLIDE_EVENTS", function() {
    return fT;
  }), i.d(e, "Slide", function() {
    return _T;
  });
  const n = [];
  for (let t2 = 0; t2 < 256; t2++)
    n[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
  function r() {
    const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
    return (n[255 & t2] + n[t2 >> 8 & 255] + n[t2 >> 16 & 255] + n[t2 >> 24 & 255] + "-" + n[255 & e2] + n[e2 >> 8 & 255] + "-" + n[e2 >> 16 & 15 | 64] + n[e2 >> 24 & 255] + "-" + n[63 & i2 | 128] + n[i2 >> 8 & 255] + "-" + n[i2 >> 16 & 255] + n[i2 >> 24 & 255] + n[255 & r2] + n[r2 >> 8 & 255] + n[r2 >> 16 & 255] + n[r2 >> 24 & 255]).toUpperCase();
  }
  var o = i(23);
  /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  class s {
    addEventListener(t2, e2) {
      this._listeners === void 0 && (this._listeners = {});
      const i2 = this._listeners;
      i2[t2] === void 0 && (i2[t2] = []), i2[t2].indexOf(e2) === -1 && i2[t2].push(e2);
    }
    hasEventListener(t2, e2) {
      if (this._listeners === void 0)
        return false;
      const i2 = this._listeners;
      return i2[t2] !== void 0 && i2[t2].indexOf(e2) !== -1;
    }
    removeEventListener(t2, e2) {
      if (this._listeners === void 0)
        return;
      const i2 = this._listeners[t2];
      if (i2 !== void 0) {
        const t3 = i2.indexOf(e2);
        t3 !== -1 && i2.splice(t3, 1);
      }
    }
    dispatchEvent(t2) {
      if (this._listeners === void 0)
        return;
      const e2 = this._listeners[t2.type];
      if (e2 !== void 0) {
        t2.target = this;
        const i2 = e2.slice(0);
        for (let e3 = 0, n2 = i2.length; e3 < n2; e3++)
          i2[e3].call(this, t2);
        t2.target = null;
      }
    }
  }
  const a = [];
  for (let t2 = 0; t2 < 256; t2++)
    a[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
  const l = Math.PI / 180, h = 180 / Math.PI;
  function u() {
    const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
    return (a[255 & t2] + a[t2 >> 8 & 255] + a[t2 >> 16 & 255] + a[t2 >> 24 & 255] + "-" + a[255 & e2] + a[e2 >> 8 & 255] + "-" + a[e2 >> 16 & 15 | 64] + a[e2 >> 24 & 255] + "-" + a[63 & i2 | 128] + a[i2 >> 8 & 255] + "-" + a[i2 >> 16 & 255] + a[i2 >> 24 & 255] + a[255 & n2] + a[n2 >> 8 & 255] + a[n2 >> 16 & 255] + a[n2 >> 24 & 255]).toUpperCase();
  }
  function c(t2, e2, i2) {
    return Math.max(e2, Math.min(i2, t2));
  }
  function d(t2, e2) {
    return (t2 % e2 + e2) % e2;
  }
  function p(t2, e2, i2) {
    return (1 - i2) * t2 + i2 * e2;
  }
  function f(t2) {
    return (t2 & t2 - 1) == 0 && t2 !== 0;
  }
  function m(t2) {
    return Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
  }
  class g {
    constructor(t2 = 0, e2 = 0) {
      this.x = t2, this.y = e2;
    }
    get width() {
      return this.x;
    }
    set width(t2) {
      this.x = t2;
    }
    get height() {
      return this.y;
    }
    set height(t2) {
      this.y = t2;
    }
    set(t2, e2) {
      return this.x = t2, this.y = e2, this;
    }
    setScalar(t2) {
      return this.x = t2, this.y = t2, this;
    }
    setX(t2) {
      return this.x = t2, this;
    }
    setY(t2) {
      return this.y = t2, this;
    }
    setComponent(t2, e2) {
      switch (t2) {
        case 0:
          this.x = e2;
          break;
        case 1:
          this.y = e2;
          break;
        default:
          throw new Error("index is out of range: " + t2);
      }
      return this;
    }
    getComponent(t2) {
      switch (t2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t2) {
      return this.x = t2.x, this.y = t2.y, this;
    }
    add(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this);
    }
    addScalar(t2) {
      return this.x += t2, this.y += t2, this;
    }
    addVectors(t2, e2) {
      return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this;
    }
    addScaledVector(t2, e2) {
      return this.x += t2.x * e2, this.y += t2.y * e2, this;
    }
    sub(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this);
    }
    subScalar(t2) {
      return this.x -= t2, this.y -= t2, this;
    }
    subVectors(t2, e2) {
      return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this;
    }
    multiply(t2) {
      return this.x *= t2.x, this.y *= t2.y, this;
    }
    multiplyScalar(t2) {
      return this.x *= t2, this.y *= t2, this;
    }
    divide(t2) {
      return this.x /= t2.x, this.y /= t2.y, this;
    }
    divideScalar(t2) {
      return this.multiplyScalar(1 / t2);
    }
    applyMatrix3(t2) {
      const e2 = this.x, i2 = this.y, n2 = t2.elements;
      return this.x = n2[0] * e2 + n2[3] * i2 + n2[6], this.y = n2[1] * e2 + n2[4] * i2 + n2[7], this;
    }
    min(t2) {
      return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this;
    }
    max(t2) {
      return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this;
    }
    clamp(t2, e2) {
      return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this;
    }
    clampScalar(t2, e2) {
      return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this;
    }
    clampLength(t2, e2) {
      const i2 = this.length();
      return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t2) {
      return this.x * t2.x + this.y * t2.y;
    }
    cross(t2) {
      return this.x * t2.y - this.y * t2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t2) {
      return Math.sqrt(this.distanceToSquared(t2));
    }
    distanceToSquared(t2) {
      const e2 = this.x - t2.x, i2 = this.y - t2.y;
      return e2 * e2 + i2 * i2;
    }
    manhattanDistanceTo(t2) {
      return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y);
    }
    setLength(t2) {
      return this.normalize().multiplyScalar(t2);
    }
    lerp(t2, e2) {
      return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this;
    }
    lerpVectors(t2, e2, i2) {
      return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this;
    }
    equals(t2) {
      return t2.x === this.x && t2.y === this.y;
    }
    fromArray(t2, e2 = 0) {
      return this.x = t2[e2], this.y = t2[e2 + 1], this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this.x, t2[e2 + 1] = this.y, t2;
    }
    fromBufferAttribute(t2, e2, i2) {
      return i2 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this;
    }
    rotateAround(t2, e2) {
      const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = this.x - t2.x, o2 = this.y - t2.y;
      return this.x = r2 * i2 - o2 * n2 + t2.x, this.y = r2 * n2 + o2 * i2 + t2.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
  }
  g.prototype.isVector2 = true;
  class v {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
      const h2 = this.elements;
      return h2[0] = t2, h2[1] = n2, h2[2] = s2, h2[3] = e2, h2[4] = r2, h2[5] = a2, h2[6] = i2, h2[7] = o2, h2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t2) {
      const e2 = this.elements, i2 = t2.elements;
      return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], this;
    }
    extractBasis(t2, e2, i2) {
      return t2.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), i2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t2) {
      const e2 = t2.elements;
      return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
    }
    multiply(t2) {
      return this.multiplyMatrices(this, t2);
    }
    premultiply(t2) {
      return this.multiplyMatrices(t2, this);
    }
    multiplyMatrices(t2, e2) {
      const i2 = t2.elements, n2 = e2.elements, r2 = this.elements, o2 = i2[0], s2 = i2[3], a2 = i2[6], l2 = i2[1], h2 = i2[4], u2 = i2[7], c2 = i2[2], d2 = i2[5], p2 = i2[8], f2 = n2[0], m2 = n2[3], g2 = n2[6], v2 = n2[1], _2 = n2[4], y2 = n2[7], x2 = n2[2], b2 = n2[5], T2 = n2[8];
      return r2[0] = o2 * f2 + s2 * v2 + a2 * x2, r2[3] = o2 * m2 + s2 * _2 + a2 * b2, r2[6] = o2 * g2 + s2 * y2 + a2 * T2, r2[1] = l2 * f2 + h2 * v2 + u2 * x2, r2[4] = l2 * m2 + h2 * _2 + u2 * b2, r2[7] = l2 * g2 + h2 * y2 + u2 * T2, r2[2] = c2 * f2 + d2 * v2 + p2 * x2, r2[5] = c2 * m2 + d2 * _2 + p2 * b2, r2[8] = c2 * g2 + d2 * y2 + p2 * T2, this;
    }
    multiplyScalar(t2) {
      const e2 = this.elements;
      return e2[0] *= t2, e2[3] *= t2, e2[6] *= t2, e2[1] *= t2, e2[4] *= t2, e2[7] *= t2, e2[2] *= t2, e2[5] *= t2, e2[8] *= t2, this;
    }
    determinant() {
      const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8];
      return e2 * o2 * h2 - e2 * s2 * l2 - i2 * r2 * h2 + i2 * s2 * a2 + n2 * r2 * l2 - n2 * o2 * a2;
    }
    invert() {
      const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8], u2 = h2 * o2 - s2 * l2, c2 = s2 * a2 - h2 * r2, d2 = l2 * r2 - o2 * a2, p2 = e2 * u2 + i2 * c2 + n2 * d2;
      if (p2 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f2 = 1 / p2;
      return t2[0] = u2 * f2, t2[1] = (n2 * l2 - h2 * i2) * f2, t2[2] = (s2 * i2 - n2 * o2) * f2, t2[3] = c2 * f2, t2[4] = (h2 * e2 - n2 * a2) * f2, t2[5] = (n2 * r2 - s2 * e2) * f2, t2[6] = d2 * f2, t2[7] = (i2 * a2 - l2 * e2) * f2, t2[8] = (o2 * e2 - i2 * r2) * f2, this;
    }
    transpose() {
      let t2;
      const e2 = this.elements;
      return t2 = e2[1], e2[1] = e2[3], e2[3] = t2, t2 = e2[2], e2[2] = e2[6], e2[6] = t2, t2 = e2[5], e2[5] = e2[7], e2[7] = t2, this;
    }
    getNormalMatrix(t2) {
      return this.setFromMatrix4(t2).invert().transpose();
    }
    transposeIntoArray(t2) {
      const e2 = this.elements;
      return t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8], this;
    }
    setUvTransform(t2, e2, i2, n2, r2, o2, s2) {
      const a2 = Math.cos(r2), l2 = Math.sin(r2);
      return this.set(i2 * a2, i2 * l2, -i2 * (a2 * o2 + l2 * s2) + o2 + t2, -n2 * l2, n2 * a2, -n2 * (-l2 * o2 + a2 * s2) + s2 + e2, 0, 0, 1), this;
    }
    scale(t2, e2) {
      const i2 = this.elements;
      return i2[0] *= t2, i2[3] *= t2, i2[6] *= t2, i2[1] *= e2, i2[4] *= e2, i2[7] *= e2, this;
    }
    rotate(t2) {
      const e2 = Math.cos(t2), i2 = Math.sin(t2), n2 = this.elements, r2 = n2[0], o2 = n2[3], s2 = n2[6], a2 = n2[1], l2 = n2[4], h2 = n2[7];
      return n2[0] = e2 * r2 + i2 * a2, n2[3] = e2 * o2 + i2 * l2, n2[6] = e2 * s2 + i2 * h2, n2[1] = -i2 * r2 + e2 * a2, n2[4] = -i2 * o2 + e2 * l2, n2[7] = -i2 * s2 + e2 * h2, this;
    }
    translate(t2, e2) {
      const i2 = this.elements;
      return i2[0] += t2 * i2[2], i2[3] += t2 * i2[5], i2[6] += t2 * i2[8], i2[1] += e2 * i2[2], i2[4] += e2 * i2[5], i2[7] += e2 * i2[8], this;
    }
    equals(t2) {
      const e2 = this.elements, i2 = t2.elements;
      for (let t3 = 0; t3 < 9; t3++)
        if (e2[t3] !== i2[t3])
          return false;
      return true;
    }
    fromArray(t2, e2 = 0) {
      for (let i2 = 0; i2 < 9; i2++)
        this.elements[i2] = t2[i2 + e2];
      return this;
    }
    toArray(t2 = [], e2 = 0) {
      const i2 = this.elements;
      return t2[e2] = i2[0], t2[e2 + 1] = i2[1], t2[e2 + 2] = i2[2], t2[e2 + 3] = i2[3], t2[e2 + 4] = i2[4], t2[e2 + 5] = i2[5], t2[e2 + 6] = i2[6], t2[e2 + 7] = i2[7], t2[e2 + 8] = i2[8], t2;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  let _;
  v.prototype.isMatrix3 = true;
  class y {
    static getDataURL(t2) {
      if (/^data:/i.test(t2.src))
        return t2.src;
      if (typeof HTMLCanvasElement == "undefined")
        return t2.src;
      let e2;
      if (t2 instanceof HTMLCanvasElement)
        e2 = t2;
      else {
        _ === void 0 && (_ = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _.width = t2.width, _.height = t2.height;
        const i2 = _.getContext("2d");
        t2 instanceof ImageData ? i2.putImageData(t2, 0, 0) : i2.drawImage(t2, 0, 0, t2.width, t2.height), e2 = _;
      }
      return e2.width > 2048 || e2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t2), e2.toDataURL("image/jpeg", 0.6)) : e2.toDataURL("image/png");
    }
  }
  let x = 0;
  class b extends s {
    constructor(t2 = b.DEFAULT_IMAGE, e2 = b.DEFAULT_MAPPING, i2 = 1001, n2 = 1001, r2 = 1006, o2 = 1008, s2 = 1023, a2 = 1009, l2 = 1, h2 = 3e3) {
      super(), Object.defineProperty(this, "id", { value: x++ }), this.uuid = u(), this.name = "", this.image = t2, this.mipmaps = [], this.mapping = e2, this.wrapS = i2, this.wrapT = n2, this.magFilter = r2, this.minFilter = o2, this.anisotropy = l2, this.format = s2, this.internalFormat = null, this.type = a2, this.offset = new g(0, 0), this.repeat = new g(1, 1), this.center = new g(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new v(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = h2, this.version = 0, this.onUpdate = null;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      return this.name = t2.name, this.image = t2.image, this.mipmaps = t2.mipmaps.slice(0), this.mapping = t2.mapping, this.wrapS = t2.wrapS, this.wrapT = t2.wrapT, this.magFilter = t2.magFilter, this.minFilter = t2.minFilter, this.anisotropy = t2.anisotropy, this.format = t2.format, this.internalFormat = t2.internalFormat, this.type = t2.type, this.offset.copy(t2.offset), this.repeat.copy(t2.repeat), this.center.copy(t2.center), this.rotation = t2.rotation, this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrix.copy(t2.matrix), this.generateMipmaps = t2.generateMipmaps, this.premultiplyAlpha = t2.premultiplyAlpha, this.flipY = t2.flipY, this.unpackAlignment = t2.unpackAlignment, this.encoding = t2.encoding, this;
    }
    toJSON(t2) {
      const e2 = t2 === void 0 || typeof t2 == "string";
      if (!e2 && t2.textures[this.uuid] !== void 0)
        return t2.textures[this.uuid];
      const i2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      if (this.image !== void 0) {
        const n2 = this.image;
        if (n2.uuid === void 0 && (n2.uuid = u()), !e2 && t2.images[n2.uuid] === void 0) {
          let e3;
          if (Array.isArray(n2)) {
            e3 = [];
            for (let t3 = 0, i3 = n2.length; t3 < i3; t3++)
              n2[t3].isDataTexture ? e3.push(T(n2[t3].image)) : e3.push(T(n2[t3]));
          } else
            e3 = T(n2);
          t2.images[n2.uuid] = { uuid: n2.uuid, url: e3 };
        }
        i2.image = n2.uuid;
      }
      return e2 || (t2.textures[this.uuid] = i2), i2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t2) {
      if (this.mapping !== 300)
        return t2;
      if (t2.applyMatrix3(this.matrix), t2.x < 0 || t2.x > 1)
        switch (this.wrapS) {
          case 1e3:
            t2.x = t2.x - Math.floor(t2.x);
            break;
          case 1001:
            t2.x = t2.x < 0 ? 0 : 1;
            break;
          case 1002:
            Math.abs(Math.floor(t2.x) % 2) === 1 ? t2.x = Math.ceil(t2.x) - t2.x : t2.x = t2.x - Math.floor(t2.x);
        }
      if (t2.y < 0 || t2.y > 1)
        switch (this.wrapT) {
          case 1e3:
            t2.y = t2.y - Math.floor(t2.y);
            break;
          case 1001:
            t2.y = t2.y < 0 ? 0 : 1;
            break;
          case 1002:
            Math.abs(Math.floor(t2.y) % 2) === 1 ? t2.y = Math.ceil(t2.y) - t2.y : t2.y = t2.y - Math.floor(t2.y);
        }
      return this.flipY && (t2.y = 1 - t2.y), t2;
    }
    set needsUpdate(t2) {
      t2 === true && this.version++;
    }
  }
  function T(t2) {
    return typeof HTMLImageElement != "undefined" && t2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t2 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap ? y.getDataURL(t2) : t2.data ? { data: Array.prototype.slice.call(t2.data), width: t2.width, height: t2.height, type: t2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  b.DEFAULT_IMAGE = void 0, b.DEFAULT_MAPPING = 300, b.prototype.isTexture = true;
  class E {
    constructor(t2 = 0, e2 = 0, i2 = 0, n2 = 1) {
      this.x = t2, this.y = e2, this.z = i2, this.w = n2;
    }
    get width() {
      return this.z;
    }
    set width(t2) {
      this.z = t2;
    }
    get height() {
      return this.w;
    }
    set height(t2) {
      this.w = t2;
    }
    set(t2, e2, i2, n2) {
      return this.x = t2, this.y = e2, this.z = i2, this.w = n2, this;
    }
    setScalar(t2) {
      return this.x = t2, this.y = t2, this.z = t2, this.w = t2, this;
    }
    setX(t2) {
      return this.x = t2, this;
    }
    setY(t2) {
      return this.y = t2, this;
    }
    setZ(t2) {
      return this.z = t2, this;
    }
    setW(t2) {
      return this.w = t2, this;
    }
    setComponent(t2, e2) {
      switch (t2) {
        case 0:
          this.x = e2;
          break;
        case 1:
          this.y = e2;
          break;
        case 2:
          this.z = e2;
          break;
        case 3:
          this.w = e2;
          break;
        default:
          throw new Error("index is out of range: " + t2);
      }
      return this;
    }
    getComponent(t2) {
      switch (t2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t2) {
      return this.x = t2.x, this.y = t2.y, this.z = t2.z, this.w = t2.w !== void 0 ? t2.w : 1, this;
    }
    add(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this.w += t2.w, this);
    }
    addScalar(t2) {
      return this.x += t2, this.y += t2, this.z += t2, this.w += t2, this;
    }
    addVectors(t2, e2) {
      return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this.w = t2.w + e2.w, this;
    }
    addScaledVector(t2, e2) {
      return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this.w += t2.w * e2, this;
    }
    sub(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this.w -= t2.w, this);
    }
    subScalar(t2) {
      return this.x -= t2, this.y -= t2, this.z -= t2, this.w -= t2, this;
    }
    subVectors(t2, e2) {
      return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this.w = t2.w - e2.w, this;
    }
    multiply(t2) {
      return this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this.w *= t2.w, this;
    }
    multiplyScalar(t2) {
      return this.x *= t2, this.y *= t2, this.z *= t2, this.w *= t2, this;
    }
    applyMatrix4(t2) {
      const e2 = this.x, i2 = this.y, n2 = this.z, r2 = this.w, o2 = t2.elements;
      return this.x = o2[0] * e2 + o2[4] * i2 + o2[8] * n2 + o2[12] * r2, this.y = o2[1] * e2 + o2[5] * i2 + o2[9] * n2 + o2[13] * r2, this.z = o2[2] * e2 + o2[6] * i2 + o2[10] * n2 + o2[14] * r2, this.w = o2[3] * e2 + o2[7] * i2 + o2[11] * n2 + o2[15] * r2, this;
    }
    divideScalar(t2) {
      return this.multiplyScalar(1 / t2);
    }
    setAxisAngleFromQuaternion(t2) {
      this.w = 2 * Math.acos(t2.w);
      const e2 = Math.sqrt(1 - t2.w * t2.w);
      return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t2.x / e2, this.y = t2.y / e2, this.z = t2.z / e2), this;
    }
    setAxisAngleFromRotationMatrix(t2) {
      let e2, i2, n2, r2;
      const o2 = t2.elements, s2 = o2[0], a2 = o2[4], l2 = o2[8], h2 = o2[1], u2 = o2[5], c2 = o2[9], d2 = o2[2], p2 = o2[6], f2 = o2[10];
      if (Math.abs(a2 - h2) < 0.01 && Math.abs(l2 - d2) < 0.01 && Math.abs(c2 - p2) < 0.01) {
        if (Math.abs(a2 + h2) < 0.1 && Math.abs(l2 + d2) < 0.1 && Math.abs(c2 + p2) < 0.1 && Math.abs(s2 + u2 + f2 - 3) < 0.1)
          return this.set(1, 0, 0, 0), this;
        e2 = Math.PI;
        const t3 = (s2 + 1) / 2, o3 = (u2 + 1) / 2, m3 = (f2 + 1) / 2, g2 = (a2 + h2) / 4, v2 = (l2 + d2) / 4, _2 = (c2 + p2) / 4;
        return t3 > o3 && t3 > m3 ? t3 < 0.01 ? (i2 = 0, n2 = 0.707106781, r2 = 0.707106781) : (i2 = Math.sqrt(t3), n2 = g2 / i2, r2 = v2 / i2) : o3 > m3 ? o3 < 0.01 ? (i2 = 0.707106781, n2 = 0, r2 = 0.707106781) : (n2 = Math.sqrt(o3), i2 = g2 / n2, r2 = _2 / n2) : m3 < 0.01 ? (i2 = 0.707106781, n2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(m3), i2 = v2 / r2, n2 = _2 / r2), this.set(i2, n2, r2, e2), this;
      }
      let m2 = Math.sqrt((p2 - c2) * (p2 - c2) + (l2 - d2) * (l2 - d2) + (h2 - a2) * (h2 - a2));
      return Math.abs(m2) < 1e-3 && (m2 = 1), this.x = (p2 - c2) / m2, this.y = (l2 - d2) / m2, this.z = (h2 - a2) / m2, this.w = Math.acos((s2 + u2 + f2 - 1) / 2), this;
    }
    min(t2) {
      return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this.w = Math.min(this.w, t2.w), this;
    }
    max(t2) {
      return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this.w = Math.max(this.w, t2.w), this;
    }
    clamp(t2, e2) {
      return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this.w = Math.max(t2.w, Math.min(e2.w, this.w)), this;
    }
    clampScalar(t2, e2) {
      return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this.w = Math.max(t2, Math.min(e2, this.w)), this;
    }
    clampLength(t2, e2) {
      const i2 = this.length();
      return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t2) {
      return this.x * t2.x + this.y * t2.y + this.z * t2.z + this.w * t2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t2) {
      return this.normalize().multiplyScalar(t2);
    }
    lerp(t2, e2) {
      return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this.w += (t2.w - this.w) * e2, this;
    }
    lerpVectors(t2, e2, i2) {
      return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this.z = t2.z + (e2.z - t2.z) * i2, this.w = t2.w + (e2.w - t2.w) * i2, this;
    }
    equals(t2) {
      return t2.x === this.x && t2.y === this.y && t2.z === this.z && t2.w === this.w;
    }
    fromArray(t2, e2 = 0) {
      return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this.w = t2[e2 + 3], this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2[e2 + 3] = this.w, t2;
    }
    fromBufferAttribute(t2, e2, i2) {
      return i2 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this.w = t2.getW(e2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
  }
  E.prototype.isVector4 = true;
  class S extends s {
    constructor(t2, e2, i2 = {}) {
      super(), this.width = t2, this.height = e2, this.depth = 1, this.scissor = new E(0, 0, t2, e2), this.scissorTest = false, this.viewport = new E(0, 0, t2, e2), this.texture = new b(void 0, i2.mapping, i2.wrapS, i2.wrapT, i2.magFilter, i2.minFilter, i2.format, i2.type, i2.anisotropy, i2.encoding), this.texture.image = { width: t2, height: e2, depth: 1 }, this.texture.generateMipmaps = i2.generateMipmaps !== void 0 && i2.generateMipmaps, this.texture.minFilter = i2.minFilter !== void 0 ? i2.minFilter : 1006, this.depthBuffer = i2.depthBuffer === void 0 || i2.depthBuffer, this.stencilBuffer = i2.stencilBuffer !== void 0 && i2.stencilBuffer, this.depthTexture = i2.depthTexture !== void 0 ? i2.depthTexture : null;
    }
    setTexture(t2) {
      t2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t2;
    }
    setSize(t2, e2, i2 = 1) {
      this.width === t2 && this.height === e2 && this.depth === i2 || (this.width = t2, this.height = e2, this.depth = i2, this.texture.image.width = t2, this.texture.image.height = e2, this.texture.image.depth = i2, this.dispose()), this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      return this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.copy(t2.viewport), this.texture = t2.texture.clone(), this.texture.image = __spreadValues({}, this.texture.image), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  S.prototype.isWebGLRenderTarget = true;
  (class extends S {
    constructor(t2, e2, i2) {
      super(t2, e2);
      const n2 = this.texture;
      this.texture = [];
      for (let t3 = 0; t3 < i2; t3++)
        this.texture[t3] = n2.clone();
    }
    setSize(t2, e2, i2 = 1) {
      if (this.width !== t2 || this.height !== e2 || this.depth !== i2) {
        this.width = t2, this.height = e2, this.depth = i2;
        for (let n2 = 0, r2 = this.texture.length; n2 < r2; n2++)
          this.texture[n2].image.width = t2, this.texture[n2].image.height = e2, this.texture[n2].image.depth = i2;
        this.dispose();
      }
      return this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2), this;
    }
    copy(t2) {
      this.dispose(), this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this.texture.length = 0;
      for (let e2 = 0, i2 = t2.texture.length; e2 < i2; e2++)
        this.texture[e2] = t2.texture[e2].clone();
      return this;
    }
  }).prototype.isWebGLMultipleRenderTargets = true;
  class w extends S {
    constructor(t2, e2, i2) {
      super(t2, e2, i2), this.samples = 4;
    }
    copy(t2) {
      return super.copy.call(this, t2), this.samples = t2.samples, this;
    }
  }
  w.prototype.isWebGLMultisampleRenderTarget = true;
  class A {
    constructor(t2 = 0, e2 = 0, i2 = 0, n2 = 1) {
      this._x = t2, this._y = e2, this._z = i2, this._w = n2;
    }
    static slerp(t2, e2, i2, n2) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i2.slerpQuaternions(t2, e2, n2);
    }
    static slerpFlat(t2, e2, i2, n2, r2, o2, s2) {
      let a2 = i2[n2 + 0], l2 = i2[n2 + 1], h2 = i2[n2 + 2], u2 = i2[n2 + 3];
      const c2 = r2[o2 + 0], d2 = r2[o2 + 1], p2 = r2[o2 + 2], f2 = r2[o2 + 3];
      if (s2 === 0)
        return t2[e2 + 0] = a2, t2[e2 + 1] = l2, t2[e2 + 2] = h2, void (t2[e2 + 3] = u2);
      if (s2 === 1)
        return t2[e2 + 0] = c2, t2[e2 + 1] = d2, t2[e2 + 2] = p2, void (t2[e2 + 3] = f2);
      if (u2 !== f2 || a2 !== c2 || l2 !== d2 || h2 !== p2) {
        let t3 = 1 - s2;
        const e3 = a2 * c2 + l2 * d2 + h2 * p2 + u2 * f2, i3 = e3 >= 0 ? 1 : -1, n3 = 1 - e3 * e3;
        if (n3 > Number.EPSILON) {
          const r4 = Math.sqrt(n3), o3 = Math.atan2(r4, e3 * i3);
          t3 = Math.sin(t3 * o3) / r4, s2 = Math.sin(s2 * o3) / r4;
        }
        const r3 = s2 * i3;
        if (a2 = a2 * t3 + c2 * r3, l2 = l2 * t3 + d2 * r3, h2 = h2 * t3 + p2 * r3, u2 = u2 * t3 + f2 * r3, t3 === 1 - s2) {
          const t4 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + h2 * h2 + u2 * u2);
          a2 *= t4, l2 *= t4, h2 *= t4, u2 *= t4;
        }
      }
      t2[e2] = a2, t2[e2 + 1] = l2, t2[e2 + 2] = h2, t2[e2 + 3] = u2;
    }
    static multiplyQuaternionsFlat(t2, e2, i2, n2, r2, o2) {
      const s2 = i2[n2], a2 = i2[n2 + 1], l2 = i2[n2 + 2], h2 = i2[n2 + 3], u2 = r2[o2], c2 = r2[o2 + 1], d2 = r2[o2 + 2], p2 = r2[o2 + 3];
      return t2[e2] = s2 * p2 + h2 * u2 + a2 * d2 - l2 * c2, t2[e2 + 1] = a2 * p2 + h2 * c2 + l2 * u2 - s2 * d2, t2[e2 + 2] = l2 * p2 + h2 * d2 + s2 * c2 - a2 * u2, t2[e2 + 3] = h2 * p2 - s2 * u2 - a2 * c2 - l2 * d2, t2;
    }
    get x() {
      return this._x;
    }
    set x(t2) {
      this._x = t2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t2) {
      this._y = t2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t2) {
      this._z = t2, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t2) {
      this._w = t2, this._onChangeCallback();
    }
    set(t2, e2, i2, n2) {
      return this._x = t2, this._y = e2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t2) {
      return this._x = t2.x, this._y = t2.y, this._z = t2.z, this._w = t2.w, this._onChangeCallback(), this;
    }
    setFromEuler(t2, e2) {
      if (!t2 || !t2.isEuler)
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      const i2 = t2._x, n2 = t2._y, r2 = t2._z, o2 = t2._order, s2 = Math.cos, a2 = Math.sin, l2 = s2(i2 / 2), h2 = s2(n2 / 2), u2 = s2(r2 / 2), c2 = a2(i2 / 2), d2 = a2(n2 / 2), p2 = a2(r2 / 2);
      switch (o2) {
        case "XYZ":
          this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
          break;
        case "YXZ":
          this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
          break;
        case "ZXY":
          this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
          break;
        case "ZYX":
          this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
          break;
        case "YZX":
          this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
          break;
        case "XZY":
          this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o2);
      }
      return e2 !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t2, e2) {
      const i2 = e2 / 2, n2 = Math.sin(i2);
      return this._x = t2.x * n2, this._y = t2.y * n2, this._z = t2.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t2) {
      const e2 = t2.elements, i2 = e2[0], n2 = e2[4], r2 = e2[8], o2 = e2[1], s2 = e2[5], a2 = e2[9], l2 = e2[2], h2 = e2[6], u2 = e2[10], c2 = i2 + s2 + u2;
      if (c2 > 0) {
        const t3 = 0.5 / Math.sqrt(c2 + 1);
        this._w = 0.25 / t3, this._x = (h2 - a2) * t3, this._y = (r2 - l2) * t3, this._z = (o2 - n2) * t3;
      } else if (i2 > s2 && i2 > u2) {
        const t3 = 2 * Math.sqrt(1 + i2 - s2 - u2);
        this._w = (h2 - a2) / t3, this._x = 0.25 * t3, this._y = (n2 + o2) / t3, this._z = (r2 + l2) / t3;
      } else if (s2 > u2) {
        const t3 = 2 * Math.sqrt(1 + s2 - i2 - u2);
        this._w = (r2 - l2) / t3, this._x = (n2 + o2) / t3, this._y = 0.25 * t3, this._z = (a2 + h2) / t3;
      } else {
        const t3 = 2 * Math.sqrt(1 + u2 - i2 - s2);
        this._w = (o2 - n2) / t3, this._x = (r2 + l2) / t3, this._y = (a2 + h2) / t3, this._z = 0.25 * t3;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t2, e2) {
      let i2 = t2.dot(e2) + 1;
      return i2 < Number.EPSILON ? (i2 = 0, Math.abs(t2.x) > Math.abs(t2.z) ? (this._x = -t2.y, this._y = t2.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -t2.z, this._z = t2.y, this._w = i2)) : (this._x = t2.y * e2.z - t2.z * e2.y, this._y = t2.z * e2.x - t2.x * e2.z, this._z = t2.x * e2.y - t2.y * e2.x, this._w = i2), this.normalize();
    }
    angleTo(t2) {
      return 2 * Math.acos(Math.abs(c(this.dot(t2), -1, 1)));
    }
    rotateTowards(t2, e2) {
      const i2 = this.angleTo(t2);
      if (i2 === 0)
        return this;
      const n2 = Math.min(1, e2 / i2);
      return this.slerp(t2, n2), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t2) {
      return this._x * t2._x + this._y * t2._y + this._z * t2._z + this._w * t2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let t2 = this.length();
      return t2 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t2 = 1 / t2, this._x = this._x * t2, this._y = this._y * t2, this._z = this._z * t2, this._w = this._w * t2), this._onChangeCallback(), this;
    }
    multiply(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t2, e2)) : this.multiplyQuaternions(this, t2);
    }
    premultiply(t2) {
      return this.multiplyQuaternions(t2, this);
    }
    multiplyQuaternions(t2, e2) {
      const i2 = t2._x, n2 = t2._y, r2 = t2._z, o2 = t2._w, s2 = e2._x, a2 = e2._y, l2 = e2._z, h2 = e2._w;
      return this._x = i2 * h2 + o2 * s2 + n2 * l2 - r2 * a2, this._y = n2 * h2 + o2 * a2 + r2 * s2 - i2 * l2, this._z = r2 * h2 + o2 * l2 + i2 * a2 - n2 * s2, this._w = o2 * h2 - i2 * s2 - n2 * a2 - r2 * l2, this._onChangeCallback(), this;
    }
    slerp(t2, e2) {
      if (e2 === 0)
        return this;
      if (e2 === 1)
        return this.copy(t2);
      const i2 = this._x, n2 = this._y, r2 = this._z, o2 = this._w;
      let s2 = o2 * t2._w + i2 * t2._x + n2 * t2._y + r2 * t2._z;
      if (s2 < 0 ? (this._w = -t2._w, this._x = -t2._x, this._y = -t2._y, this._z = -t2._z, s2 = -s2) : this.copy(t2), s2 >= 1)
        return this._w = o2, this._x = i2, this._y = n2, this._z = r2, this;
      const a2 = 1 - s2 * s2;
      if (a2 <= Number.EPSILON) {
        const t3 = 1 - e2;
        return this._w = t3 * o2 + e2 * this._w, this._x = t3 * i2 + e2 * this._x, this._y = t3 * n2 + e2 * this._y, this._z = t3 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const l2 = Math.sqrt(a2), h2 = Math.atan2(l2, s2), u2 = Math.sin((1 - e2) * h2) / l2, c2 = Math.sin(e2 * h2) / l2;
      return this._w = o2 * u2 + this._w * c2, this._x = i2 * u2 + this._x * c2, this._y = n2 * u2 + this._y * c2, this._z = r2 * u2 + this._z * c2, this._onChangeCallback(), this;
    }
    slerpQuaternions(t2, e2, i2) {
      this.copy(t2).slerp(e2, i2);
    }
    equals(t2) {
      return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._w === this._w;
    }
    fromArray(t2, e2 = 0) {
      return this._x = t2[e2], this._y = t2[e2 + 1], this._z = t2[e2 + 2], this._w = t2[e2 + 3], this._onChangeCallback(), this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._w, t2;
    }
    fromBufferAttribute(t2, e2) {
      return this._x = t2.getX(e2), this._y = t2.getY(e2), this._z = t2.getZ(e2), this._w = t2.getW(e2), this;
    }
    _onChange(t2) {
      return this._onChangeCallback = t2, this;
    }
    _onChangeCallback() {
    }
  }
  A.prototype.isQuaternion = true;
  class M {
    constructor(t2 = 0, e2 = 0, i2 = 0) {
      this.x = t2, this.y = e2, this.z = i2;
    }
    set(t2, e2, i2) {
      return i2 === void 0 && (i2 = this.z), this.x = t2, this.y = e2, this.z = i2, this;
    }
    setScalar(t2) {
      return this.x = t2, this.y = t2, this.z = t2, this;
    }
    setX(t2) {
      return this.x = t2, this;
    }
    setY(t2) {
      return this.y = t2, this;
    }
    setZ(t2) {
      return this.z = t2, this;
    }
    setComponent(t2, e2) {
      switch (t2) {
        case 0:
          this.x = e2;
          break;
        case 1:
          this.y = e2;
          break;
        case 2:
          this.z = e2;
          break;
        default:
          throw new Error("index is out of range: " + t2);
      }
      return this;
    }
    getComponent(t2) {
      switch (t2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t2) {
      return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
    }
    add(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this);
    }
    addScalar(t2) {
      return this.x += t2, this.y += t2, this.z += t2, this;
    }
    addVectors(t2, e2) {
      return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this;
    }
    addScaledVector(t2, e2) {
      return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this;
    }
    sub(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this);
    }
    subScalar(t2) {
      return this.x -= t2, this.y -= t2, this.z -= t2, this;
    }
    subVectors(t2, e2) {
      return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this;
    }
    multiply(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t2, e2)) : (this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this);
    }
    multiplyScalar(t2) {
      return this.x *= t2, this.y *= t2, this.z *= t2, this;
    }
    multiplyVectors(t2, e2) {
      return this.x = t2.x * e2.x, this.y = t2.y * e2.y, this.z = t2.z * e2.z, this;
    }
    applyEuler(t2) {
      return t2 && t2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(C.setFromEuler(t2));
    }
    applyAxisAngle(t2, e2) {
      return this.applyQuaternion(C.setFromAxisAngle(t2, e2));
    }
    applyMatrix3(t2) {
      const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements;
      return this.x = r2[0] * e2 + r2[3] * i2 + r2[6] * n2, this.y = r2[1] * e2 + r2[4] * i2 + r2[7] * n2, this.z = r2[2] * e2 + r2[5] * i2 + r2[8] * n2, this;
    }
    applyNormalMatrix(t2) {
      return this.applyMatrix3(t2).normalize();
    }
    applyMatrix4(t2) {
      const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements, o2 = 1 / (r2[3] * e2 + r2[7] * i2 + r2[11] * n2 + r2[15]);
      return this.x = (r2[0] * e2 + r2[4] * i2 + r2[8] * n2 + r2[12]) * o2, this.y = (r2[1] * e2 + r2[5] * i2 + r2[9] * n2 + r2[13]) * o2, this.z = (r2[2] * e2 + r2[6] * i2 + r2[10] * n2 + r2[14]) * o2, this;
    }
    applyQuaternion(t2) {
      const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.x, o2 = t2.y, s2 = t2.z, a2 = t2.w, l2 = a2 * e2 + o2 * n2 - s2 * i2, h2 = a2 * i2 + s2 * e2 - r2 * n2, u2 = a2 * n2 + r2 * i2 - o2 * e2, c2 = -r2 * e2 - o2 * i2 - s2 * n2;
      return this.x = l2 * a2 + c2 * -r2 + h2 * -s2 - u2 * -o2, this.y = h2 * a2 + c2 * -o2 + u2 * -r2 - l2 * -s2, this.z = u2 * a2 + c2 * -s2 + l2 * -o2 - h2 * -r2, this;
    }
    project(t2) {
      return this.applyMatrix4(t2.matrixWorldInverse).applyMatrix4(t2.projectionMatrix);
    }
    unproject(t2) {
      return this.applyMatrix4(t2.projectionMatrixInverse).applyMatrix4(t2.matrixWorld);
    }
    transformDirection(t2) {
      const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements;
      return this.x = r2[0] * e2 + r2[4] * i2 + r2[8] * n2, this.y = r2[1] * e2 + r2[5] * i2 + r2[9] * n2, this.z = r2[2] * e2 + r2[6] * i2 + r2[10] * n2, this.normalize();
    }
    divide(t2) {
      return this.x /= t2.x, this.y /= t2.y, this.z /= t2.z, this;
    }
    divideScalar(t2) {
      return this.multiplyScalar(1 / t2);
    }
    min(t2) {
      return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this;
    }
    max(t2) {
      return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this;
    }
    clamp(t2, e2) {
      return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this;
    }
    clampScalar(t2, e2) {
      return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this;
    }
    clampLength(t2, e2) {
      const i2 = this.length();
      return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t2) {
      return this.x * t2.x + this.y * t2.y + this.z * t2.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t2) {
      return this.normalize().multiplyScalar(t2);
    }
    lerp(t2, e2) {
      return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this;
    }
    lerpVectors(t2, e2, i2) {
      return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this.z = t2.z + (e2.z - t2.z) * i2, this;
    }
    cross(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t2, e2)) : this.crossVectors(this, t2);
    }
    crossVectors(t2, e2) {
      const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = e2.x, s2 = e2.y, a2 = e2.z;
      return this.x = n2 * a2 - r2 * s2, this.y = r2 * o2 - i2 * a2, this.z = i2 * s2 - n2 * o2, this;
    }
    projectOnVector(t2) {
      const e2 = t2.lengthSq();
      if (e2 === 0)
        return this.set(0, 0, 0);
      const i2 = t2.dot(this) / e2;
      return this.copy(t2).multiplyScalar(i2);
    }
    projectOnPlane(t2) {
      return R.copy(this).projectOnVector(t2), this.sub(R);
    }
    reflect(t2) {
      return this.sub(R.copy(t2).multiplyScalar(2 * this.dot(t2)));
    }
    angleTo(t2) {
      const e2 = Math.sqrt(this.lengthSq() * t2.lengthSq());
      if (e2 === 0)
        return Math.PI / 2;
      const i2 = this.dot(t2) / e2;
      return Math.acos(c(i2, -1, 1));
    }
    distanceTo(t2) {
      return Math.sqrt(this.distanceToSquared(t2));
    }
    distanceToSquared(t2) {
      const e2 = this.x - t2.x, i2 = this.y - t2.y, n2 = this.z - t2.z;
      return e2 * e2 + i2 * i2 + n2 * n2;
    }
    manhattanDistanceTo(t2) {
      return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y) + Math.abs(this.z - t2.z);
    }
    setFromSpherical(t2) {
      return this.setFromSphericalCoords(t2.radius, t2.phi, t2.theta);
    }
    setFromSphericalCoords(t2, e2, i2) {
      const n2 = Math.sin(e2) * t2;
      return this.x = n2 * Math.sin(i2), this.y = Math.cos(e2) * t2, this.z = n2 * Math.cos(i2), this;
    }
    setFromCylindrical(t2) {
      return this.setFromCylindricalCoords(t2.radius, t2.theta, t2.y);
    }
    setFromCylindricalCoords(t2, e2, i2) {
      return this.x = t2 * Math.sin(e2), this.y = i2, this.z = t2 * Math.cos(e2), this;
    }
    setFromMatrixPosition(t2) {
      const e2 = t2.elements;
      return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
    }
    setFromMatrixScale(t2) {
      const e2 = this.setFromMatrixColumn(t2, 0).length(), i2 = this.setFromMatrixColumn(t2, 1).length(), n2 = this.setFromMatrixColumn(t2, 2).length();
      return this.x = e2, this.y = i2, this.z = n2, this;
    }
    setFromMatrixColumn(t2, e2) {
      return this.fromArray(t2.elements, 4 * e2);
    }
    setFromMatrix3Column(t2, e2) {
      return this.fromArray(t2.elements, 3 * e2);
    }
    equals(t2) {
      return t2.x === this.x && t2.y === this.y && t2.z === this.z;
    }
    fromArray(t2, e2 = 0) {
      return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2;
    }
    fromBufferAttribute(t2, e2, i2) {
      return i2 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
  }
  M.prototype.isVector3 = true;
  const R = new M(), C = new A();
  class I {
    constructor(t2 = new M(1 / 0, 1 / 0, 1 / 0), e2 = new M(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = t2, this.max = e2;
    }
    set(t2, e2) {
      return this.min.copy(t2), this.max.copy(e2), this;
    }
    setFromArray(t2) {
      let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, o2 = -1 / 0, s2 = -1 / 0;
      for (let a2 = 0, l2 = t2.length; a2 < l2; a2 += 3) {
        const l3 = t2[a2], h2 = t2[a2 + 1], u2 = t2[a2 + 2];
        l3 < e2 && (e2 = l3), h2 < i2 && (i2 = h2), u2 < n2 && (n2 = u2), l3 > r2 && (r2 = l3), h2 > o2 && (o2 = h2), u2 > s2 && (s2 = u2);
      }
      return this.min.set(e2, i2, n2), this.max.set(r2, o2, s2), this;
    }
    setFromBufferAttribute(t2) {
      let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, o2 = -1 / 0, s2 = -1 / 0;
      for (let a2 = 0, l2 = t2.count; a2 < l2; a2++) {
        const l3 = t2.getX(a2), h2 = t2.getY(a2), u2 = t2.getZ(a2);
        l3 < e2 && (e2 = l3), h2 < i2 && (i2 = h2), u2 < n2 && (n2 = u2), l3 > r2 && (r2 = l3), h2 > o2 && (o2 = h2), u2 > s2 && (s2 = u2);
      }
      return this.min.set(e2, i2, n2), this.max.set(r2, o2, s2), this;
    }
    setFromPoints(t2) {
      this.makeEmpty();
      for (let e2 = 0, i2 = t2.length; e2 < i2; e2++)
        this.expandByPoint(t2[e2]);
      return this;
    }
    setFromCenterAndSize(t2, e2) {
      const i2 = O.copy(e2).multiplyScalar(0.5);
      return this.min.copy(t2).sub(i2), this.max.copy(t2).add(i2), this;
    }
    setFromObject(t2) {
      return this.makeEmpty(), this.expandByObject(t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      return this.min.copy(t2.min), this.max.copy(t2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t2) {
      return this.isEmpty() ? t2.set(0, 0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t2) {
      return this.isEmpty() ? t2.set(0, 0, 0) : t2.subVectors(this.max, this.min);
    }
    expandByPoint(t2) {
      return this.min.min(t2), this.max.max(t2), this;
    }
    expandByVector(t2) {
      return this.min.sub(t2), this.max.add(t2), this;
    }
    expandByScalar(t2) {
      return this.min.addScalar(-t2), this.max.addScalar(t2), this;
    }
    expandByObject(t2) {
      t2.updateWorldMatrix(false, false);
      const e2 = t2.geometry;
      e2 !== void 0 && (e2.boundingBox === null && e2.computeBoundingBox(), N.copy(e2.boundingBox), N.applyMatrix4(t2.matrixWorld), this.union(N));
      const i2 = t2.children;
      for (let t3 = 0, e3 = i2.length; t3 < e3; t3++)
        this.expandByObject(i2[t3]);
      return this;
    }
    containsPoint(t2) {
      return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y || t2.z < this.min.z || t2.z > this.max.z);
    }
    containsBox(t2) {
      return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y && this.min.z <= t2.min.z && t2.max.z <= this.max.z;
    }
    getParameter(t2, e2) {
      return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y), (t2.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t2) {
      return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y || t2.max.z < this.min.z || t2.min.z > this.max.z);
    }
    intersectsSphere(t2) {
      return this.clampPoint(t2.center, O), O.distanceToSquared(t2.center) <= t2.radius * t2.radius;
    }
    intersectsPlane(t2) {
      let e2, i2;
      return t2.normal.x > 0 ? (e2 = t2.normal.x * this.min.x, i2 = t2.normal.x * this.max.x) : (e2 = t2.normal.x * this.max.x, i2 = t2.normal.x * this.min.x), t2.normal.y > 0 ? (e2 += t2.normal.y * this.min.y, i2 += t2.normal.y * this.max.y) : (e2 += t2.normal.y * this.max.y, i2 += t2.normal.y * this.min.y), t2.normal.z > 0 ? (e2 += t2.normal.z * this.min.z, i2 += t2.normal.z * this.max.z) : (e2 += t2.normal.z * this.max.z, i2 += t2.normal.z * this.min.z), e2 <= -t2.constant && i2 >= -t2.constant;
    }
    intersectsTriangle(t2) {
      if (this.isEmpty())
        return false;
      this.getCenter(G), H.subVectors(this.max, G), L.subVectors(t2.a, G), D.subVectors(t2.b, G), F.subVectors(t2.c, G), B.subVectors(D, L), U.subVectors(F, D), k.subVectors(L, F);
      let e2 = [0, -B.z, B.y, 0, -U.z, U.y, 0, -k.z, k.y, B.z, 0, -B.x, U.z, 0, -U.x, k.z, 0, -k.x, -B.y, B.x, 0, -U.y, U.x, 0, -k.y, k.x, 0];
      return !!V(e2, L, D, F, H) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!V(e2, L, D, F, H) && (j.crossVectors(B, U), e2 = [j.x, j.y, j.z], V(e2, L, D, F, H)));
    }
    clampPoint(t2, e2) {
      return e2.copy(t2).clamp(this.min, this.max);
    }
    distanceToPoint(t2) {
      return O.copy(t2).clamp(this.min, this.max).sub(t2).length();
    }
    getBoundingSphere(t2) {
      return this.getCenter(t2.center), t2.radius = 0.5 * this.getSize(O).length(), t2;
    }
    intersect(t2) {
      return this.min.max(t2.min), this.max.min(t2.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t2) {
      return this.min.min(t2.min), this.max.max(t2.max), this;
    }
    applyMatrix4(t2) {
      return this.isEmpty() || (P[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t2), P[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t2), P[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t2), P[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t2), P[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t2), P[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t2), P[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t2), P[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t2), this.setFromPoints(P)), this;
    }
    translate(t2) {
      return this.min.add(t2), this.max.add(t2), this;
    }
    equals(t2) {
      return t2.min.equals(this.min) && t2.max.equals(this.max);
    }
  }
  I.prototype.isBox3 = true;
  const P = [new M(), new M(), new M(), new M(), new M(), new M(), new M(), new M()], O = new M(), N = new I(), L = new M(), D = new M(), F = new M(), B = new M(), U = new M(), k = new M(), G = new M(), H = new M(), j = new M(), z = new M();
  function V(t2, e2, i2, n2, r2) {
    for (let o2 = 0, s2 = t2.length - 3; o2 <= s2; o2 += 3) {
      z.fromArray(t2, o2);
      const s3 = r2.x * Math.abs(z.x) + r2.y * Math.abs(z.y) + r2.z * Math.abs(z.z), a2 = e2.dot(z), l2 = i2.dot(z), h2 = n2.dot(z);
      if (Math.max(-Math.max(a2, l2, h2), Math.min(a2, l2, h2)) > s3)
        return false;
    }
    return true;
  }
  const X = new I(), W = new M(), Y = new M(), q = new M();
  class Z {
    constructor(t2 = new M(), e2 = -1) {
      this.center = t2, this.radius = e2;
    }
    set(t2, e2) {
      return this.center.copy(t2), this.radius = e2, this;
    }
    setFromPoints(t2, e2) {
      const i2 = this.center;
      e2 !== void 0 ? i2.copy(e2) : X.setFromPoints(t2).getCenter(i2);
      let n2 = 0;
      for (let e3 = 0, r2 = t2.length; e3 < r2; e3++)
        n2 = Math.max(n2, i2.distanceToSquared(t2[e3]));
      return this.radius = Math.sqrt(n2), this;
    }
    copy(t2) {
      return this.center.copy(t2.center), this.radius = t2.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t2) {
      return t2.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t2) {
      return t2.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t2) {
      const e2 = this.radius + t2.radius;
      return t2.center.distanceToSquared(this.center) <= e2 * e2;
    }
    intersectsBox(t2) {
      return t2.intersectsSphere(this);
    }
    intersectsPlane(t2) {
      return Math.abs(t2.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t2, e2) {
      const i2 = this.center.distanceToSquared(t2);
      return e2.copy(t2), i2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
    }
    getBoundingBox(t2) {
      return this.isEmpty() ? (t2.makeEmpty(), t2) : (t2.set(this.center, this.center), t2.expandByScalar(this.radius), t2);
    }
    applyMatrix4(t2) {
      return this.center.applyMatrix4(t2), this.radius = this.radius * t2.getMaxScaleOnAxis(), this;
    }
    translate(t2) {
      return this.center.add(t2), this;
    }
    expandByPoint(t2) {
      q.subVectors(t2, this.center);
      const e2 = q.lengthSq();
      if (e2 > this.radius * this.radius) {
        const t3 = Math.sqrt(e2), i2 = 0.5 * (t3 - this.radius);
        this.center.add(q.multiplyScalar(i2 / t3)), this.radius += i2;
      }
      return this;
    }
    union(t2) {
      return Y.subVectors(t2.center, this.center).normalize().multiplyScalar(t2.radius), this.expandByPoint(W.copy(t2.center).add(Y)), this.expandByPoint(W.copy(t2.center).sub(Y)), this;
    }
    equals(t2) {
      return t2.center.equals(this.center) && t2.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const J = new M(), K = new M(), Q = new M(), $ = new M(), tt = new M(), et = new M(), it = new M();
  class nt {
    constructor(t2 = new M(), e2 = new M(0, 0, -1)) {
      this.origin = t2, this.direction = e2;
    }
    set(t2, e2) {
      return this.origin.copy(t2), this.direction.copy(e2), this;
    }
    copy(t2) {
      return this.origin.copy(t2.origin), this.direction.copy(t2.direction), this;
    }
    at(t2, e2) {
      return e2.copy(this.direction).multiplyScalar(t2).add(this.origin);
    }
    lookAt(t2) {
      return this.direction.copy(t2).sub(this.origin).normalize(), this;
    }
    recast(t2) {
      return this.origin.copy(this.at(t2, J)), this;
    }
    closestPointToPoint(t2, e2) {
      e2.subVectors(t2, this.origin);
      const i2 = e2.dot(this.direction);
      return i2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(i2).add(this.origin);
    }
    distanceToPoint(t2) {
      return Math.sqrt(this.distanceSqToPoint(t2));
    }
    distanceSqToPoint(t2) {
      const e2 = J.subVectors(t2, this.origin).dot(this.direction);
      return e2 < 0 ? this.origin.distanceToSquared(t2) : (J.copy(this.direction).multiplyScalar(e2).add(this.origin), J.distanceToSquared(t2));
    }
    distanceSqToSegment(t2, e2, i2, n2) {
      K.copy(t2).add(e2).multiplyScalar(0.5), Q.copy(e2).sub(t2).normalize(), $.copy(this.origin).sub(K);
      const r2 = 0.5 * t2.distanceTo(e2), o2 = -this.direction.dot(Q), s2 = $.dot(this.direction), a2 = -$.dot(Q), l2 = $.lengthSq(), h2 = Math.abs(1 - o2 * o2);
      let u2, c2, d2, p2;
      if (h2 > 0)
        if (u2 = o2 * a2 - s2, c2 = o2 * s2 - a2, p2 = r2 * h2, u2 >= 0)
          if (c2 >= -p2)
            if (c2 <= p2) {
              const t3 = 1 / h2;
              u2 *= t3, c2 *= t3, d2 = u2 * (u2 + o2 * c2 + 2 * s2) + c2 * (o2 * u2 + c2 + 2 * a2) + l2;
            } else
              c2 = r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
          else
            c2 = -r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
        else
          c2 <= -p2 ? (u2 = Math.max(0, -(-o2 * r2 + s2)), c2 = u2 > 0 ? -r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2) : c2 <= p2 ? (u2 = 0, c2 = Math.min(Math.max(-r2, -a2), r2), d2 = c2 * (c2 + 2 * a2) + l2) : (u2 = Math.max(0, -(o2 * r2 + s2)), c2 = u2 > 0 ? r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2);
      else
        c2 = o2 > 0 ? -r2 : r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
      return i2 && i2.copy(this.direction).multiplyScalar(u2).add(this.origin), n2 && n2.copy(Q).multiplyScalar(c2).add(K), d2;
    }
    intersectSphere(t2, e2) {
      J.subVectors(t2.center, this.origin);
      const i2 = J.dot(this.direction), n2 = J.dot(J) - i2 * i2, r2 = t2.radius * t2.radius;
      if (n2 > r2)
        return null;
      const o2 = Math.sqrt(r2 - n2), s2 = i2 - o2, a2 = i2 + o2;
      return s2 < 0 && a2 < 0 ? null : s2 < 0 ? this.at(a2, e2) : this.at(s2, e2);
    }
    intersectsSphere(t2) {
      return this.distanceSqToPoint(t2.center) <= t2.radius * t2.radius;
    }
    distanceToPlane(t2) {
      const e2 = t2.normal.dot(this.direction);
      if (e2 === 0)
        return t2.distanceToPoint(this.origin) === 0 ? 0 : null;
      const i2 = -(this.origin.dot(t2.normal) + t2.constant) / e2;
      return i2 >= 0 ? i2 : null;
    }
    intersectPlane(t2, e2) {
      const i2 = this.distanceToPlane(t2);
      return i2 === null ? null : this.at(i2, e2);
    }
    intersectsPlane(t2) {
      const e2 = t2.distanceToPoint(this.origin);
      if (e2 === 0)
        return true;
      return t2.normal.dot(this.direction) * e2 < 0;
    }
    intersectBox(t2, e2) {
      let i2, n2, r2, o2, s2, a2;
      const l2 = 1 / this.direction.x, h2 = 1 / this.direction.y, u2 = 1 / this.direction.z, c2 = this.origin;
      return l2 >= 0 ? (i2 = (t2.min.x - c2.x) * l2, n2 = (t2.max.x - c2.x) * l2) : (i2 = (t2.max.x - c2.x) * l2, n2 = (t2.min.x - c2.x) * l2), h2 >= 0 ? (r2 = (t2.min.y - c2.y) * h2, o2 = (t2.max.y - c2.y) * h2) : (r2 = (t2.max.y - c2.y) * h2, o2 = (t2.min.y - c2.y) * h2), i2 > o2 || r2 > n2 ? null : ((r2 > i2 || i2 != i2) && (i2 = r2), (o2 < n2 || n2 != n2) && (n2 = o2), u2 >= 0 ? (s2 = (t2.min.z - c2.z) * u2, a2 = (t2.max.z - c2.z) * u2) : (s2 = (t2.max.z - c2.z) * u2, a2 = (t2.min.z - c2.z) * u2), i2 > a2 || s2 > n2 ? null : ((s2 > i2 || i2 != i2) && (i2 = s2), (a2 < n2 || n2 != n2) && (n2 = a2), n2 < 0 ? null : this.at(i2 >= 0 ? i2 : n2, e2)));
    }
    intersectsBox(t2) {
      return this.intersectBox(t2, J) !== null;
    }
    intersectTriangle(t2, e2, i2, n2, r2) {
      tt.subVectors(e2, t2), et.subVectors(i2, t2), it.crossVectors(tt, et);
      let o2, s2 = this.direction.dot(it);
      if (s2 > 0) {
        if (n2)
          return null;
        o2 = 1;
      } else {
        if (!(s2 < 0))
          return null;
        o2 = -1, s2 = -s2;
      }
      $.subVectors(this.origin, t2);
      const a2 = o2 * this.direction.dot(et.crossVectors($, et));
      if (a2 < 0)
        return null;
      const l2 = o2 * this.direction.dot(tt.cross($));
      if (l2 < 0)
        return null;
      if (a2 + l2 > s2)
        return null;
      const h2 = -o2 * $.dot(it);
      return h2 < 0 ? null : this.at(h2 / s2, r2);
    }
    applyMatrix4(t2) {
      return this.origin.applyMatrix4(t2), this.direction.transformDirection(t2), this;
    }
    equals(t2) {
      return t2.origin.equals(this.origin) && t2.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class rt {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2) {
      const g2 = this.elements;
      return g2[0] = t2, g2[4] = e2, g2[8] = i2, g2[12] = n2, g2[1] = r2, g2[5] = o2, g2[9] = s2, g2[13] = a2, g2[2] = l2, g2[6] = h2, g2[10] = u2, g2[14] = c2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new rt().fromArray(this.elements);
    }
    copy(t2) {
      const e2 = this.elements, i2 = t2.elements;
      return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15], this;
    }
    copyPosition(t2) {
      const e2 = this.elements, i2 = t2.elements;
      return e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], this;
    }
    setFromMatrix3(t2) {
      const e2 = t2.elements;
      return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t2, e2, i2) {
      return t2.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t2, e2, i2) {
      return this.set(t2.x, e2.x, i2.x, 0, t2.y, e2.y, i2.y, 0, t2.z, e2.z, i2.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t2) {
      const e2 = this.elements, i2 = t2.elements, n2 = 1 / ot.setFromMatrixColumn(t2, 0).length(), r2 = 1 / ot.setFromMatrixColumn(t2, 1).length(), o2 = 1 / ot.setFromMatrixColumn(t2, 2).length();
      return e2[0] = i2[0] * n2, e2[1] = i2[1] * n2, e2[2] = i2[2] * n2, e2[3] = 0, e2[4] = i2[4] * r2, e2[5] = i2[5] * r2, e2[6] = i2[6] * r2, e2[7] = 0, e2[8] = i2[8] * o2, e2[9] = i2[9] * o2, e2[10] = i2[10] * o2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
    }
    makeRotationFromEuler(t2) {
      t2 && t2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const e2 = this.elements, i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = Math.cos(i2), s2 = Math.sin(i2), a2 = Math.cos(n2), l2 = Math.sin(n2), h2 = Math.cos(r2), u2 = Math.sin(r2);
      if (t2.order === "XYZ") {
        const t3 = o2 * h2, i3 = o2 * u2, n3 = s2 * h2, r3 = s2 * u2;
        e2[0] = a2 * h2, e2[4] = -a2 * u2, e2[8] = l2, e2[1] = i3 + n3 * l2, e2[5] = t3 - r3 * l2, e2[9] = -s2 * a2, e2[2] = r3 - t3 * l2, e2[6] = n3 + i3 * l2, e2[10] = o2 * a2;
      } else if (t2.order === "YXZ") {
        const t3 = a2 * h2, i3 = a2 * u2, n3 = l2 * h2, r3 = l2 * u2;
        e2[0] = t3 + r3 * s2, e2[4] = n3 * s2 - i3, e2[8] = o2 * l2, e2[1] = o2 * u2, e2[5] = o2 * h2, e2[9] = -s2, e2[2] = i3 * s2 - n3, e2[6] = r3 + t3 * s2, e2[10] = o2 * a2;
      } else if (t2.order === "ZXY") {
        const t3 = a2 * h2, i3 = a2 * u2, n3 = l2 * h2, r3 = l2 * u2;
        e2[0] = t3 - r3 * s2, e2[4] = -o2 * u2, e2[8] = n3 + i3 * s2, e2[1] = i3 + n3 * s2, e2[5] = o2 * h2, e2[9] = r3 - t3 * s2, e2[2] = -o2 * l2, e2[6] = s2, e2[10] = o2 * a2;
      } else if (t2.order === "ZYX") {
        const t3 = o2 * h2, i3 = o2 * u2, n3 = s2 * h2, r3 = s2 * u2;
        e2[0] = a2 * h2, e2[4] = n3 * l2 - i3, e2[8] = t3 * l2 + r3, e2[1] = a2 * u2, e2[5] = r3 * l2 + t3, e2[9] = i3 * l2 - n3, e2[2] = -l2, e2[6] = s2 * a2, e2[10] = o2 * a2;
      } else if (t2.order === "YZX") {
        const t3 = o2 * a2, i3 = o2 * l2, n3 = s2 * a2, r3 = s2 * l2;
        e2[0] = a2 * h2, e2[4] = r3 - t3 * u2, e2[8] = n3 * u2 + i3, e2[1] = u2, e2[5] = o2 * h2, e2[9] = -s2 * h2, e2[2] = -l2 * h2, e2[6] = i3 * u2 + n3, e2[10] = t3 - r3 * u2;
      } else if (t2.order === "XZY") {
        const t3 = o2 * a2, i3 = o2 * l2, n3 = s2 * a2, r3 = s2 * l2;
        e2[0] = a2 * h2, e2[4] = -u2, e2[8] = l2 * h2, e2[1] = t3 * u2 + r3, e2[5] = o2 * h2, e2[9] = i3 * u2 - n3, e2[2] = n3 * u2 - i3, e2[6] = s2 * h2, e2[10] = r3 * u2 + t3;
      }
      return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
    }
    makeRotationFromQuaternion(t2) {
      return this.compose(at, t2, lt);
    }
    lookAt(t2, e2, i2) {
      const n2 = this.elements;
      return ct.subVectors(t2, e2), ct.lengthSq() === 0 && (ct.z = 1), ct.normalize(), ht.crossVectors(i2, ct), ht.lengthSq() === 0 && (Math.abs(i2.z) === 1 ? ct.x += 1e-4 : ct.z += 1e-4, ct.normalize(), ht.crossVectors(i2, ct)), ht.normalize(), ut.crossVectors(ct, ht), n2[0] = ht.x, n2[4] = ut.x, n2[8] = ct.x, n2[1] = ht.y, n2[5] = ut.y, n2[9] = ct.y, n2[2] = ht.z, n2[6] = ut.z, n2[10] = ct.z, this;
    }
    multiply(t2, e2) {
      return e2 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t2, e2)) : this.multiplyMatrices(this, t2);
    }
    premultiply(t2) {
      return this.multiplyMatrices(t2, this);
    }
    multiplyMatrices(t2, e2) {
      const i2 = t2.elements, n2 = e2.elements, r2 = this.elements, o2 = i2[0], s2 = i2[4], a2 = i2[8], l2 = i2[12], h2 = i2[1], u2 = i2[5], c2 = i2[9], d2 = i2[13], p2 = i2[2], f2 = i2[6], m2 = i2[10], g2 = i2[14], v2 = i2[3], _2 = i2[7], y2 = i2[11], x2 = i2[15], b2 = n2[0], T2 = n2[4], E2 = n2[8], S2 = n2[12], w2 = n2[1], A2 = n2[5], M2 = n2[9], R2 = n2[13], C2 = n2[2], I2 = n2[6], P2 = n2[10], O2 = n2[14], N2 = n2[3], L2 = n2[7], D2 = n2[11], F2 = n2[15];
      return r2[0] = o2 * b2 + s2 * w2 + a2 * C2 + l2 * N2, r2[4] = o2 * T2 + s2 * A2 + a2 * I2 + l2 * L2, r2[8] = o2 * E2 + s2 * M2 + a2 * P2 + l2 * D2, r2[12] = o2 * S2 + s2 * R2 + a2 * O2 + l2 * F2, r2[1] = h2 * b2 + u2 * w2 + c2 * C2 + d2 * N2, r2[5] = h2 * T2 + u2 * A2 + c2 * I2 + d2 * L2, r2[9] = h2 * E2 + u2 * M2 + c2 * P2 + d2 * D2, r2[13] = h2 * S2 + u2 * R2 + c2 * O2 + d2 * F2, r2[2] = p2 * b2 + f2 * w2 + m2 * C2 + g2 * N2, r2[6] = p2 * T2 + f2 * A2 + m2 * I2 + g2 * L2, r2[10] = p2 * E2 + f2 * M2 + m2 * P2 + g2 * D2, r2[14] = p2 * S2 + f2 * R2 + m2 * O2 + g2 * F2, r2[3] = v2 * b2 + _2 * w2 + y2 * C2 + x2 * N2, r2[7] = v2 * T2 + _2 * A2 + y2 * I2 + x2 * L2, r2[11] = v2 * E2 + _2 * M2 + y2 * P2 + x2 * D2, r2[15] = v2 * S2 + _2 * R2 + y2 * O2 + x2 * F2, this;
    }
    multiplyScalar(t2) {
      const e2 = this.elements;
      return e2[0] *= t2, e2[4] *= t2, e2[8] *= t2, e2[12] *= t2, e2[1] *= t2, e2[5] *= t2, e2[9] *= t2, e2[13] *= t2, e2[2] *= t2, e2[6] *= t2, e2[10] *= t2, e2[14] *= t2, e2[3] *= t2, e2[7] *= t2, e2[11] *= t2, e2[15] *= t2, this;
    }
    determinant() {
      const t2 = this.elements, e2 = t2[0], i2 = t2[4], n2 = t2[8], r2 = t2[12], o2 = t2[1], s2 = t2[5], a2 = t2[9], l2 = t2[13], h2 = t2[2], u2 = t2[6], c2 = t2[10], d2 = t2[14];
      return t2[3] * (+r2 * a2 * u2 - n2 * l2 * u2 - r2 * s2 * c2 + i2 * l2 * c2 + n2 * s2 * d2 - i2 * a2 * d2) + t2[7] * (+e2 * a2 * d2 - e2 * l2 * c2 + r2 * o2 * c2 - n2 * o2 * d2 + n2 * l2 * h2 - r2 * a2 * h2) + t2[11] * (+e2 * l2 * u2 - e2 * s2 * d2 - r2 * o2 * u2 + i2 * o2 * d2 + r2 * s2 * h2 - i2 * l2 * h2) + t2[15] * (-n2 * s2 * h2 - e2 * a2 * u2 + e2 * s2 * c2 + n2 * o2 * u2 - i2 * o2 * c2 + i2 * a2 * h2);
    }
    transpose() {
      const t2 = this.elements;
      let e2;
      return e2 = t2[1], t2[1] = t2[4], t2[4] = e2, e2 = t2[2], t2[2] = t2[8], t2[8] = e2, e2 = t2[6], t2[6] = t2[9], t2[9] = e2, e2 = t2[3], t2[3] = t2[12], t2[12] = e2, e2 = t2[7], t2[7] = t2[13], t2[13] = e2, e2 = t2[11], t2[11] = t2[14], t2[14] = e2, this;
    }
    setPosition(t2, e2, i2) {
      const n2 = this.elements;
      return t2.isVector3 ? (n2[12] = t2.x, n2[13] = t2.y, n2[14] = t2.z) : (n2[12] = t2, n2[13] = e2, n2[14] = i2), this;
    }
    invert() {
      const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8], u2 = t2[9], c2 = t2[10], d2 = t2[11], p2 = t2[12], f2 = t2[13], m2 = t2[14], g2 = t2[15], v2 = u2 * m2 * l2 - f2 * c2 * l2 + f2 * a2 * d2 - s2 * m2 * d2 - u2 * a2 * g2 + s2 * c2 * g2, _2 = p2 * c2 * l2 - h2 * m2 * l2 - p2 * a2 * d2 + o2 * m2 * d2 + h2 * a2 * g2 - o2 * c2 * g2, y2 = h2 * f2 * l2 - p2 * u2 * l2 + p2 * s2 * d2 - o2 * f2 * d2 - h2 * s2 * g2 + o2 * u2 * g2, x2 = p2 * u2 * a2 - h2 * f2 * a2 - p2 * s2 * c2 + o2 * f2 * c2 + h2 * s2 * m2 - o2 * u2 * m2, b2 = e2 * v2 + i2 * _2 + n2 * y2 + r2 * x2;
      if (b2 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const T2 = 1 / b2;
      return t2[0] = v2 * T2, t2[1] = (f2 * c2 * r2 - u2 * m2 * r2 - f2 * n2 * d2 + i2 * m2 * d2 + u2 * n2 * g2 - i2 * c2 * g2) * T2, t2[2] = (s2 * m2 * r2 - f2 * a2 * r2 + f2 * n2 * l2 - i2 * m2 * l2 - s2 * n2 * g2 + i2 * a2 * g2) * T2, t2[3] = (u2 * a2 * r2 - s2 * c2 * r2 - u2 * n2 * l2 + i2 * c2 * l2 + s2 * n2 * d2 - i2 * a2 * d2) * T2, t2[4] = _2 * T2, t2[5] = (h2 * m2 * r2 - p2 * c2 * r2 + p2 * n2 * d2 - e2 * m2 * d2 - h2 * n2 * g2 + e2 * c2 * g2) * T2, t2[6] = (p2 * a2 * r2 - o2 * m2 * r2 - p2 * n2 * l2 + e2 * m2 * l2 + o2 * n2 * g2 - e2 * a2 * g2) * T2, t2[7] = (o2 * c2 * r2 - h2 * a2 * r2 + h2 * n2 * l2 - e2 * c2 * l2 - o2 * n2 * d2 + e2 * a2 * d2) * T2, t2[8] = y2 * T2, t2[9] = (p2 * u2 * r2 - h2 * f2 * r2 - p2 * i2 * d2 + e2 * f2 * d2 + h2 * i2 * g2 - e2 * u2 * g2) * T2, t2[10] = (o2 * f2 * r2 - p2 * s2 * r2 + p2 * i2 * l2 - e2 * f2 * l2 - o2 * i2 * g2 + e2 * s2 * g2) * T2, t2[11] = (h2 * s2 * r2 - o2 * u2 * r2 - h2 * i2 * l2 + e2 * u2 * l2 + o2 * i2 * d2 - e2 * s2 * d2) * T2, t2[12] = x2 * T2, t2[13] = (h2 * f2 * n2 - p2 * u2 * n2 + p2 * i2 * c2 - e2 * f2 * c2 - h2 * i2 * m2 + e2 * u2 * m2) * T2, t2[14] = (p2 * s2 * n2 - o2 * f2 * n2 - p2 * i2 * a2 + e2 * f2 * a2 + o2 * i2 * m2 - e2 * s2 * m2) * T2, t2[15] = (o2 * u2 * n2 - h2 * s2 * n2 + h2 * i2 * a2 - e2 * u2 * a2 - o2 * i2 * c2 + e2 * s2 * c2) * T2, this;
    }
    scale(t2) {
      const e2 = this.elements, i2 = t2.x, n2 = t2.y, r2 = t2.z;
      return e2[0] *= i2, e2[4] *= n2, e2[8] *= r2, e2[1] *= i2, e2[5] *= n2, e2[9] *= r2, e2[2] *= i2, e2[6] *= n2, e2[10] *= r2, e2[3] *= i2, e2[7] *= n2, e2[11] *= r2, this;
    }
    getMaxScaleOnAxis() {
      const t2 = this.elements, e2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], i2 = t2[4] * t2[4] + t2[5] * t2[5] + t2[6] * t2[6], n2 = t2[8] * t2[8] + t2[9] * t2[9] + t2[10] * t2[10];
      return Math.sqrt(Math.max(e2, i2, n2));
    }
    makeTranslation(t2, e2, i2) {
      return this.set(1, 0, 0, t2, 0, 1, 0, e2, 0, 0, 1, i2, 0, 0, 0, 1), this;
    }
    makeRotationX(t2) {
      const e2 = Math.cos(t2), i2 = Math.sin(t2);
      return this.set(1, 0, 0, 0, 0, e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t2) {
      const e2 = Math.cos(t2), i2 = Math.sin(t2);
      return this.set(e2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, e2, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t2) {
      const e2 = Math.cos(t2), i2 = Math.sin(t2);
      return this.set(e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t2, e2) {
      const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = 1 - i2, o2 = t2.x, s2 = t2.y, a2 = t2.z, l2 = r2 * o2, h2 = r2 * s2;
      return this.set(l2 * o2 + i2, l2 * s2 - n2 * a2, l2 * a2 + n2 * s2, 0, l2 * s2 + n2 * a2, h2 * s2 + i2, h2 * a2 - n2 * o2, 0, l2 * a2 - n2 * s2, h2 * a2 + n2 * o2, r2 * a2 * a2 + i2, 0, 0, 0, 0, 1), this;
    }
    makeScale(t2, e2, i2) {
      return this.set(t2, 0, 0, 0, 0, e2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
    }
    makeShear(t2, e2, i2, n2, r2, o2) {
      return this.set(1, i2, r2, 0, t2, 1, o2, 0, e2, n2, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t2, e2, i2) {
      const n2 = this.elements, r2 = e2._x, o2 = e2._y, s2 = e2._z, a2 = e2._w, l2 = r2 + r2, h2 = o2 + o2, u2 = s2 + s2, c2 = r2 * l2, d2 = r2 * h2, p2 = r2 * u2, f2 = o2 * h2, m2 = o2 * u2, g2 = s2 * u2, v2 = a2 * l2, _2 = a2 * h2, y2 = a2 * u2, x2 = i2.x, b2 = i2.y, T2 = i2.z;
      return n2[0] = (1 - (f2 + g2)) * x2, n2[1] = (d2 + y2) * x2, n2[2] = (p2 - _2) * x2, n2[3] = 0, n2[4] = (d2 - y2) * b2, n2[5] = (1 - (c2 + g2)) * b2, n2[6] = (m2 + v2) * b2, n2[7] = 0, n2[8] = (p2 + _2) * T2, n2[9] = (m2 - v2) * T2, n2[10] = (1 - (c2 + f2)) * T2, n2[11] = 0, n2[12] = t2.x, n2[13] = t2.y, n2[14] = t2.z, n2[15] = 1, this;
    }
    decompose(t2, e2, i2) {
      const n2 = this.elements;
      let r2 = ot.set(n2[0], n2[1], n2[2]).length();
      const o2 = ot.set(n2[4], n2[5], n2[6]).length(), s2 = ot.set(n2[8], n2[9], n2[10]).length();
      this.determinant() < 0 && (r2 = -r2), t2.x = n2[12], t2.y = n2[13], t2.z = n2[14], st.copy(this);
      const a2 = 1 / r2, l2 = 1 / o2, h2 = 1 / s2;
      return st.elements[0] *= a2, st.elements[1] *= a2, st.elements[2] *= a2, st.elements[4] *= l2, st.elements[5] *= l2, st.elements[6] *= l2, st.elements[8] *= h2, st.elements[9] *= h2, st.elements[10] *= h2, e2.setFromRotationMatrix(st), i2.x = r2, i2.y = o2, i2.z = s2, this;
    }
    makePerspective(t2, e2, i2, n2, r2, o2) {
      o2 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const s2 = this.elements, a2 = 2 * r2 / (e2 - t2), l2 = 2 * r2 / (i2 - n2), h2 = (e2 + t2) / (e2 - t2), u2 = (i2 + n2) / (i2 - n2), c2 = -(o2 + r2) / (o2 - r2), d2 = -2 * o2 * r2 / (o2 - r2);
      return s2[0] = a2, s2[4] = 0, s2[8] = h2, s2[12] = 0, s2[1] = 0, s2[5] = l2, s2[9] = u2, s2[13] = 0, s2[2] = 0, s2[6] = 0, s2[10] = c2, s2[14] = d2, s2[3] = 0, s2[7] = 0, s2[11] = -1, s2[15] = 0, this;
    }
    makeOrthographic(t2, e2, i2, n2, r2, o2) {
      const s2 = this.elements, a2 = 1 / (e2 - t2), l2 = 1 / (i2 - n2), h2 = 1 / (o2 - r2), u2 = (e2 + t2) * a2, c2 = (i2 + n2) * l2, d2 = (o2 + r2) * h2;
      return s2[0] = 2 * a2, s2[4] = 0, s2[8] = 0, s2[12] = -u2, s2[1] = 0, s2[5] = 2 * l2, s2[9] = 0, s2[13] = -c2, s2[2] = 0, s2[6] = 0, s2[10] = -2 * h2, s2[14] = -d2, s2[3] = 0, s2[7] = 0, s2[11] = 0, s2[15] = 1, this;
    }
    equals(t2) {
      const e2 = this.elements, i2 = t2.elements;
      for (let t3 = 0; t3 < 16; t3++)
        if (e2[t3] !== i2[t3])
          return false;
      return true;
    }
    fromArray(t2, e2 = 0) {
      for (let i2 = 0; i2 < 16; i2++)
        this.elements[i2] = t2[i2 + e2];
      return this;
    }
    toArray(t2 = [], e2 = 0) {
      const i2 = this.elements;
      return t2[e2] = i2[0], t2[e2 + 1] = i2[1], t2[e2 + 2] = i2[2], t2[e2 + 3] = i2[3], t2[e2 + 4] = i2[4], t2[e2 + 5] = i2[5], t2[e2 + 6] = i2[6], t2[e2 + 7] = i2[7], t2[e2 + 8] = i2[8], t2[e2 + 9] = i2[9], t2[e2 + 10] = i2[10], t2[e2 + 11] = i2[11], t2[e2 + 12] = i2[12], t2[e2 + 13] = i2[13], t2[e2 + 14] = i2[14], t2[e2 + 15] = i2[15], t2;
    }
  }
  rt.prototype.isMatrix4 = true;
  const ot = new M(), st = new rt(), at = new M(0, 0, 0), lt = new M(1, 1, 1), ht = new M(), ut = new M(), ct = new M(), dt = new rt(), pt = new A();
  class ft {
    constructor(t2 = 0, e2 = 0, i2 = 0, n2 = ft.DefaultOrder) {
      this._x = t2, this._y = e2, this._z = i2, this._order = n2;
    }
    get x() {
      return this._x;
    }
    set x(t2) {
      this._x = t2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t2) {
      this._y = t2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t2) {
      this._z = t2, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t2) {
      this._order = t2, this._onChangeCallback();
    }
    set(t2, e2, i2, n2 = this._order) {
      return this._x = t2, this._y = e2, this._z = i2, this._order = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t2) {
      return this._x = t2._x, this._y = t2._y, this._z = t2._z, this._order = t2._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t2, e2 = this._order, i2 = true) {
      const n2 = t2.elements, r2 = n2[0], o2 = n2[4], s2 = n2[8], a2 = n2[1], l2 = n2[5], h2 = n2[9], u2 = n2[2], d2 = n2[6], p2 = n2[10];
      switch (e2) {
        case "XYZ":
          this._y = Math.asin(c(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(-h2, p2), this._z = Math.atan2(-o2, r2)) : (this._x = Math.atan2(d2, l2), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-c(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._y = Math.atan2(s2, p2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-u2, r2), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(c(d2, -1, 1)), Math.abs(d2) < 0.9999999 ? (this._y = Math.atan2(-u2, p2), this._z = Math.atan2(-o2, l2)) : (this._y = 0, this._z = Math.atan2(a2, r2));
          break;
        case "ZYX":
          this._y = Math.asin(-c(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._x = Math.atan2(d2, p2), this._z = Math.atan2(a2, r2)) : (this._x = 0, this._z = Math.atan2(-o2, l2));
          break;
        case "YZX":
          this._z = Math.asin(c(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-h2, l2), this._y = Math.atan2(-u2, r2)) : (this._x = 0, this._y = Math.atan2(s2, p2));
          break;
        case "XZY":
          this._z = Math.asin(-c(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(d2, l2), this._y = Math.atan2(s2, r2)) : (this._x = Math.atan2(-h2, p2), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
      }
      return this._order = e2, i2 === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(t2, e2, i2) {
      return dt.makeRotationFromQuaternion(t2), this.setFromRotationMatrix(dt, e2, i2);
    }
    setFromVector3(t2, e2 = this._order) {
      return this.set(t2.x, t2.y, t2.z, e2);
    }
    reorder(t2) {
      return pt.setFromEuler(this), this.setFromQuaternion(pt, t2);
    }
    equals(t2) {
      return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._order === this._order;
    }
    fromArray(t2) {
      return this._x = t2[0], this._y = t2[1], this._z = t2[2], t2[3] !== void 0 && (this._order = t2[3]), this._onChangeCallback(), this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._order, t2;
    }
    toVector3(t2) {
      return t2 ? t2.set(this._x, this._y, this._z) : new M(this._x, this._y, this._z);
    }
    _onChange(t2) {
      return this._onChangeCallback = t2, this;
    }
    _onChangeCallback() {
    }
  }
  ft.prototype.isEuler = true, ft.DefaultOrder = "XYZ", ft.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class mt {
    constructor() {
      this.mask = 1;
    }
    set(t2) {
      this.mask = 1 << t2 | 0;
    }
    enable(t2) {
      this.mask |= 1 << t2 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t2) {
      this.mask ^= 1 << t2 | 0;
    }
    disable(t2) {
      this.mask &= ~(1 << t2 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t2) {
      return (this.mask & t2.mask) != 0;
    }
  }
  let gt = 0;
  const vt = new M(), _t = new A(), yt = new rt(), xt = new M(), bt = new M(), Tt = new M(), Et = new A(), St = new M(1, 0, 0), wt = new M(0, 1, 0), At = new M(0, 0, 1), Mt = { type: "added" }, Rt = { type: "removed" };
  class Ct extends s {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: gt++ }), this.uuid = u(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ct.DefaultUp.clone();
      const t2 = new M(), e2 = new ft(), i2 = new A(), n2 = new M(1, 1, 1);
      e2._onChange(function() {
        i2.setFromEuler(e2, false);
      }), i2._onChange(function() {
        e2.setFromQuaternion(i2, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t2 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: i2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new rt() }, normalMatrix: { value: new v() } }), this.matrix = new rt(), this.matrixWorld = new rt(), this.matrixAutoUpdate = Ct.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new mt(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(t2) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t2), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t2) {
      return this.quaternion.premultiply(t2), this;
    }
    setRotationFromAxisAngle(t2, e2) {
      this.quaternion.setFromAxisAngle(t2, e2);
    }
    setRotationFromEuler(t2) {
      this.quaternion.setFromEuler(t2, true);
    }
    setRotationFromMatrix(t2) {
      this.quaternion.setFromRotationMatrix(t2);
    }
    setRotationFromQuaternion(t2) {
      this.quaternion.copy(t2);
    }
    rotateOnAxis(t2, e2) {
      return _t.setFromAxisAngle(t2, e2), this.quaternion.multiply(_t), this;
    }
    rotateOnWorldAxis(t2, e2) {
      return _t.setFromAxisAngle(t2, e2), this.quaternion.premultiply(_t), this;
    }
    rotateX(t2) {
      return this.rotateOnAxis(St, t2);
    }
    rotateY(t2) {
      return this.rotateOnAxis(wt, t2);
    }
    rotateZ(t2) {
      return this.rotateOnAxis(At, t2);
    }
    translateOnAxis(t2, e2) {
      return vt.copy(t2).applyQuaternion(this.quaternion), this.position.add(vt.multiplyScalar(e2)), this;
    }
    translateX(t2) {
      return this.translateOnAxis(St, t2);
    }
    translateY(t2) {
      return this.translateOnAxis(wt, t2);
    }
    translateZ(t2) {
      return this.translateOnAxis(At, t2);
    }
    localToWorld(t2) {
      return t2.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t2) {
      return t2.applyMatrix4(yt.copy(this.matrixWorld).invert());
    }
    lookAt(t2, e2, i2) {
      t2.isVector3 ? xt.copy(t2) : xt.set(t2, e2, i2);
      const n2 = this.parent;
      this.updateWorldMatrix(true, false), bt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? yt.lookAt(bt, xt, this.up) : yt.lookAt(xt, bt, this.up), this.quaternion.setFromRotationMatrix(yt), n2 && (yt.extractRotation(n2.matrixWorld), _t.setFromRotationMatrix(yt), this.quaternion.premultiply(_t.invert()));
    }
    add(t2) {
      if (arguments.length > 1) {
        for (let t3 = 0; t3 < arguments.length; t3++)
          this.add(arguments[t3]);
        return this;
      }
      return t2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t2), this) : (t2 && t2.isObject3D ? (t2.parent !== null && t2.parent.remove(t2), t2.parent = this, this.children.push(t2), t2.dispatchEvent(Mt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t2), this);
    }
    remove(t2) {
      if (arguments.length > 1) {
        for (let t3 = 0; t3 < arguments.length; t3++)
          this.remove(arguments[t3]);
        return this;
      }
      const e2 = this.children.indexOf(t2);
      return e2 !== -1 && (t2.parent = null, this.children.splice(e2, 1), t2.dispatchEvent(Rt)), this;
    }
    removeFromParent() {
      const t2 = this.parent;
      return t2 !== null && t2.remove(this), this;
    }
    clear() {
      for (let t2 = 0; t2 < this.children.length; t2++) {
        const e2 = this.children[t2];
        e2.parent = null, e2.dispatchEvent(Rt);
      }
      return this.children.length = 0, this;
    }
    attach(t2) {
      return this.updateWorldMatrix(true, false), yt.copy(this.matrixWorld).invert(), t2.parent !== null && (t2.parent.updateWorldMatrix(true, false), yt.multiply(t2.parent.matrixWorld)), t2.applyMatrix4(yt), this.add(t2), t2.updateWorldMatrix(false, true), this;
    }
    getObjectById(t2) {
      return this.getObjectByProperty("id", t2);
    }
    getObjectByName(t2) {
      return this.getObjectByProperty("name", t2);
    }
    getObjectByProperty(t2, e2) {
      if (this[t2] === e2)
        return this;
      for (let i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
        const n3 = this.children[i2].getObjectByProperty(t2, e2);
        if (n3 !== void 0)
          return n3;
      }
    }
    getWorldPosition(t2) {
      return this.updateWorldMatrix(true, false), t2.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bt, t2, Tt), t2;
    }
    getWorldScale(t2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bt, Et, t2), t2;
    }
    getWorldDirection(t2) {
      this.updateWorldMatrix(true, false);
      const e2 = this.matrixWorld.elements;
      return t2.set(e2[8], e2[9], e2[10]).normalize();
    }
    raycast() {
    }
    traverse(t2) {
      t2(this);
      const e2 = this.children;
      for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
        e2[i2].traverse(t2);
    }
    traverseVisible(t2) {
      if (this.visible === false)
        return;
      t2(this);
      const e2 = this.children;
      for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
        e2[i2].traverseVisible(t2);
    }
    traverseAncestors(t2) {
      const e2 = this.parent;
      e2 !== null && (t2(e2), e2.traverseAncestors(t2));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(t2) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t2) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t2 = true);
      const e2 = this.children;
      for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
        e2[i2].updateMatrixWorld(t2);
    }
    updateWorldMatrix(t2, e2) {
      const i2 = this.parent;
      if (t2 === true && i2 !== null && i2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e2 === true) {
        const t3 = this.children;
        for (let e3 = 0, i3 = t3.length; e3 < i3; e3++)
          t3[e3].updateWorldMatrix(false, true);
      }
    }
    toJSON(t2) {
      const e2 = t2 === void 0 || typeof t2 == "string", i2 = {};
      e2 && (t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, i2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      const n2 = {};
      function r2(e3, i3) {
        return e3[i3.uuid] === void 0 && (e3[i3.uuid] = i3.toJSON(t2)), i3.uuid;
      }
      if (n2.uuid = this.uuid, n2.type = this.type, this.name !== "" && (n2.name = this.name), this.castShadow === true && (n2.castShadow = true), this.receiveShadow === true && (n2.receiveShadow = true), this.visible === false && (n2.visible = false), this.frustumCulled === false && (n2.frustumCulled = false), this.renderOrder !== 0 && (n2.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(t2).uuid)), this.environment && this.environment.isTexture && (n2.environment = this.environment.toJSON(t2).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n2.geometry = r2(t2.geometries, this.geometry);
        const e3 = this.geometry.parameters;
        if (e3 !== void 0 && e3.shapes !== void 0) {
          const i3 = e3.shapes;
          if (Array.isArray(i3))
            for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
              const n4 = i3[e4];
              r2(t2.shapes, n4);
            }
          else
            r2(t2.shapes, i3);
        }
      }
      if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r2(t2.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), this.material !== void 0)
        if (Array.isArray(this.material)) {
          const e3 = [];
          for (let i3 = 0, n3 = this.material.length; i3 < n3; i3++)
            e3.push(r2(t2.materials, this.material[i3]));
          n2.material = e3;
        } else
          n2.material = r2(t2.materials, this.material);
      if (this.children.length > 0) {
        n2.children = [];
        for (let e3 = 0; e3 < this.children.length; e3++)
          n2.children.push(this.children[e3].toJSON(t2).object);
      }
      if (this.animations.length > 0) {
        n2.animations = [];
        for (let e3 = 0; e3 < this.animations.length; e3++) {
          const i3 = this.animations[e3];
          n2.animations.push(r2(t2.animations, i3));
        }
      }
      if (e2) {
        const e3 = o2(t2.geometries), n3 = o2(t2.materials), r3 = o2(t2.textures), s2 = o2(t2.images), a2 = o2(t2.shapes), l2 = o2(t2.skeletons), h2 = o2(t2.animations);
        e3.length > 0 && (i2.geometries = e3), n3.length > 0 && (i2.materials = n3), r3.length > 0 && (i2.textures = r3), s2.length > 0 && (i2.images = s2), a2.length > 0 && (i2.shapes = a2), l2.length > 0 && (i2.skeletons = l2), h2.length > 0 && (i2.animations = h2);
      }
      return i2.object = n2, i2;
      function o2(t3) {
        const e3 = [];
        for (const i3 in t3) {
          const n3 = t3[i3];
          delete n3.metadata, e3.push(n3);
        }
        return e3;
      }
    }
    clone(t2) {
      return new this.constructor().copy(this, t2);
    }
    copy(t2, e2 = true) {
      if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), e2 === true)
        for (let e3 = 0; e3 < t2.children.length; e3++) {
          const i2 = t2.children[e3];
          this.add(i2.clone());
        }
      return this;
    }
  }
  Ct.DefaultUp = new M(0, 1, 0), Ct.DefaultMatrixAutoUpdate = true, Ct.prototype.isObject3D = true;
  const It = new M(), Pt = new M(), Ot = new M(), Nt = new M(), Lt = new M(), Dt = new M(), Ft = new M(), Bt = new M(), Ut = new M(), kt = new M();
  class Gt {
    constructor(t2 = new M(), e2 = new M(), i2 = new M()) {
      this.a = t2, this.b = e2, this.c = i2;
    }
    static getNormal(t2, e2, i2, n2) {
      n2.subVectors(i2, e2), It.subVectors(t2, e2), n2.cross(It);
      const r2 = n2.lengthSq();
      return r2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(r2)) : n2.set(0, 0, 0);
    }
    static getBarycoord(t2, e2, i2, n2, r2) {
      It.subVectors(n2, e2), Pt.subVectors(i2, e2), Ot.subVectors(t2, e2);
      const o2 = It.dot(It), s2 = It.dot(Pt), a2 = It.dot(Ot), l2 = Pt.dot(Pt), h2 = Pt.dot(Ot), u2 = o2 * l2 - s2 * s2;
      if (u2 === 0)
        return r2.set(-2, -1, -1);
      const c2 = 1 / u2, d2 = (l2 * a2 - s2 * h2) * c2, p2 = (o2 * h2 - s2 * a2) * c2;
      return r2.set(1 - d2 - p2, p2, d2);
    }
    static containsPoint(t2, e2, i2, n2) {
      return this.getBarycoord(t2, e2, i2, n2, Nt), Nt.x >= 0 && Nt.y >= 0 && Nt.x + Nt.y <= 1;
    }
    static getUV(t2, e2, i2, n2, r2, o2, s2, a2) {
      return this.getBarycoord(t2, e2, i2, n2, Nt), a2.set(0, 0), a2.addScaledVector(r2, Nt.x), a2.addScaledVector(o2, Nt.y), a2.addScaledVector(s2, Nt.z), a2;
    }
    static isFrontFacing(t2, e2, i2, n2) {
      return It.subVectors(i2, e2), Pt.subVectors(t2, e2), It.cross(Pt).dot(n2) < 0;
    }
    set(t2, e2, i2) {
      return this.a.copy(t2), this.b.copy(e2), this.c.copy(i2), this;
    }
    setFromPointsAndIndices(t2, e2, i2, n2) {
      return this.a.copy(t2[e2]), this.b.copy(t2[i2]), this.c.copy(t2[n2]), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      return this.a.copy(t2.a), this.b.copy(t2.b), this.c.copy(t2.c), this;
    }
    getArea() {
      return It.subVectors(this.c, this.b), Pt.subVectors(this.a, this.b), 0.5 * It.cross(Pt).length();
    }
    getMidpoint(t2) {
      return t2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t2) {
      return Gt.getNormal(this.a, this.b, this.c, t2);
    }
    getPlane(t2) {
      return t2.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t2, e2) {
      return Gt.getBarycoord(t2, this.a, this.b, this.c, e2);
    }
    getUV(t2, e2, i2, n2, r2) {
      return Gt.getUV(t2, this.a, this.b, this.c, e2, i2, n2, r2);
    }
    containsPoint(t2) {
      return Gt.containsPoint(t2, this.a, this.b, this.c);
    }
    isFrontFacing(t2) {
      return Gt.isFrontFacing(this.a, this.b, this.c, t2);
    }
    intersectsBox(t2) {
      return t2.intersectsTriangle(this);
    }
    closestPointToPoint(t2, e2) {
      const i2 = this.a, n2 = this.b, r2 = this.c;
      let o2, s2;
      Lt.subVectors(n2, i2), Dt.subVectors(r2, i2), Bt.subVectors(t2, i2);
      const a2 = Lt.dot(Bt), l2 = Dt.dot(Bt);
      if (a2 <= 0 && l2 <= 0)
        return e2.copy(i2);
      Ut.subVectors(t2, n2);
      const h2 = Lt.dot(Ut), u2 = Dt.dot(Ut);
      if (h2 >= 0 && u2 <= h2)
        return e2.copy(n2);
      const c2 = a2 * u2 - h2 * l2;
      if (c2 <= 0 && a2 >= 0 && h2 <= 0)
        return o2 = a2 / (a2 - h2), e2.copy(i2).addScaledVector(Lt, o2);
      kt.subVectors(t2, r2);
      const d2 = Lt.dot(kt), p2 = Dt.dot(kt);
      if (p2 >= 0 && d2 <= p2)
        return e2.copy(r2);
      const f2 = d2 * l2 - a2 * p2;
      if (f2 <= 0 && l2 >= 0 && p2 <= 0)
        return s2 = l2 / (l2 - p2), e2.copy(i2).addScaledVector(Dt, s2);
      const m2 = h2 * p2 - d2 * u2;
      if (m2 <= 0 && u2 - h2 >= 0 && d2 - p2 >= 0)
        return Ft.subVectors(r2, n2), s2 = (u2 - h2) / (u2 - h2 + (d2 - p2)), e2.copy(n2).addScaledVector(Ft, s2);
      const g2 = 1 / (m2 + f2 + c2);
      return o2 = f2 * g2, s2 = c2 * g2, e2.copy(i2).addScaledVector(Lt, o2).addScaledVector(Dt, s2);
    }
    equals(t2) {
      return t2.a.equals(this.a) && t2.b.equals(this.b) && t2.c.equals(this.c);
    }
  }
  let Ht = 0;
  class jt extends s {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: Ht++ }), this.uuid = u(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
    }
    onBuild() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t2) {
      if (t2 !== void 0)
        for (const e2 in t2) {
          const i2 = t2[e2];
          if (i2 === void 0) {
            console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
            continue;
          }
          if (e2 === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i2 === 1;
            continue;
          }
          const n2 = this[e2];
          n2 !== void 0 ? n2 && n2.isColor ? n2.set(i2) : n2 && n2.isVector3 && i2 && i2.isVector3 ? n2.copy(i2) : this[e2] = i2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
        }
    }
    toJSON(t2) {
      const e2 = t2 === void 0 || typeof t2 == "string";
      e2 && (t2 = { textures: {}, images: {} });
      const i2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      function n2(t3) {
        const e3 = [];
        for (const i3 in t3) {
          const n3 = t3[i3];
          delete n3.metadata, e3.push(n3);
        }
        return e3;
      }
      if (i2.uuid = this.uuid, i2.type = this.type, this.name !== "" && (i2.name = this.name), this.color && this.color.isColor && (i2.color = this.color.getHex()), this.roughness !== void 0 && (i2.roughness = this.roughness), this.metalness !== void 0 && (i2.metalness = this.metalness), this.sheen && this.sheen.isColor && (i2.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i2.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i2.specular = this.specular.getHex()), this.shininess !== void 0 && (i2.shininess = this.shininess), this.clearcoat !== void 0 && (i2.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i2.clearcoatMap = this.clearcoatMap.toJSON(t2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t2).uuid, i2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i2.map = this.map.toJSON(t2).uuid), this.matcap && this.matcap.isTexture && (i2.matcap = this.matcap.toJSON(t2).uuid), this.alphaMap && this.alphaMap.isTexture && (i2.alphaMap = this.alphaMap.toJSON(t2).uuid), this.lightMap && this.lightMap.isTexture && (i2.lightMap = this.lightMap.toJSON(t2).uuid, i2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i2.aoMap = this.aoMap.toJSON(t2).uuid, i2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i2.bumpMap = this.bumpMap.toJSON(t2).uuid, i2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i2.normalMap = this.normalMap.toJSON(t2).uuid, i2.normalMapType = this.normalMapType, i2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i2.displacementMap = this.displacementMap.toJSON(t2).uuid, i2.displacementScale = this.displacementScale, i2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i2.roughnessMap = this.roughnessMap.toJSON(t2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i2.metalnessMap = this.metalnessMap.toJSON(t2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i2.emissiveMap = this.emissiveMap.toJSON(t2).uuid), this.specularMap && this.specularMap.isTexture && (i2.specularMap = this.specularMap.toJSON(t2).uuid), this.envMap && this.envMap.isTexture && (i2.envMap = this.envMap.toJSON(t2).uuid, this.combine !== void 0 && (i2.combine = this.combine)), this.envMapIntensity !== void 0 && (i2.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i2.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i2.gradientMap = this.gradientMap.toJSON(t2).uuid), this.transmission !== void 0 && (i2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i2.transmissionMap = this.transmissionMap.toJSON(t2).uuid), this.thickness !== void 0 && (i2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i2.thicknessMap = this.thicknessMap.toJSON(t2).uuid), this.attenuationDistance !== void 0 && (i2.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i2.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i2.size = this.size), this.shadowSide !== null && (i2.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i2.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (i2.blending = this.blending), this.side !== 0 && (i2.side = this.side), this.vertexColors && (i2.vertexColors = true), this.opacity < 1 && (i2.opacity = this.opacity), this.transparent === true && (i2.transparent = this.transparent), i2.depthFunc = this.depthFunc, i2.depthTest = this.depthTest, i2.depthWrite = this.depthWrite, i2.colorWrite = this.colorWrite, i2.stencilWrite = this.stencilWrite, i2.stencilWriteMask = this.stencilWriteMask, i2.stencilFunc = this.stencilFunc, i2.stencilRef = this.stencilRef, i2.stencilFuncMask = this.stencilFuncMask, i2.stencilFail = this.stencilFail, i2.stencilZFail = this.stencilZFail, i2.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (i2.rotation = this.rotation), this.polygonOffset === true && (i2.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i2.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (i2.linewidth = this.linewidth), this.dashSize !== void 0 && (i2.dashSize = this.dashSize), this.gapSize !== void 0 && (i2.gapSize = this.gapSize), this.scale !== void 0 && (i2.scale = this.scale), this.dithering === true && (i2.dithering = true), this.alphaTest > 0 && (i2.alphaTest = this.alphaTest), this.alphaToCoverage === true && (i2.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (i2.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (i2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i2.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i2.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i2.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === true && (i2.morphTargets = true), this.morphNormals === true && (i2.morphNormals = true), this.flatShading === true && (i2.flatShading = this.flatShading), this.visible === false && (i2.visible = false), this.toneMapped === false && (i2.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (i2.userData = this.userData), e2) {
        const e3 = n2(t2.textures), r2 = n2(t2.images);
        e3.length > 0 && (i2.textures = e3), r2.length > 0 && (i2.images = r2);
      }
      return i2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      this.name = t2.name, this.fog = t2.fog, this.blending = t2.blending, this.side = t2.side, this.vertexColors = t2.vertexColors, this.opacity = t2.opacity, this.transparent = t2.transparent, this.blendSrc = t2.blendSrc, this.blendDst = t2.blendDst, this.blendEquation = t2.blendEquation, this.blendSrcAlpha = t2.blendSrcAlpha, this.blendDstAlpha = t2.blendDstAlpha, this.blendEquationAlpha = t2.blendEquationAlpha, this.depthFunc = t2.depthFunc, this.depthTest = t2.depthTest, this.depthWrite = t2.depthWrite, this.stencilWriteMask = t2.stencilWriteMask, this.stencilFunc = t2.stencilFunc, this.stencilRef = t2.stencilRef, this.stencilFuncMask = t2.stencilFuncMask, this.stencilFail = t2.stencilFail, this.stencilZFail = t2.stencilZFail, this.stencilZPass = t2.stencilZPass, this.stencilWrite = t2.stencilWrite;
      const e2 = t2.clippingPlanes;
      let i2 = null;
      if (e2 !== null) {
        const t3 = e2.length;
        i2 = new Array(t3);
        for (let n2 = 0; n2 !== t3; ++n2)
          i2[n2] = e2[n2].clone();
      }
      return this.clippingPlanes = i2, this.clipIntersection = t2.clipIntersection, this.clipShadows = t2.clipShadows, this.shadowSide = t2.shadowSide, this.colorWrite = t2.colorWrite, this.precision = t2.precision, this.polygonOffset = t2.polygonOffset, this.polygonOffsetFactor = t2.polygonOffsetFactor, this.polygonOffsetUnits = t2.polygonOffsetUnits, this.dithering = t2.dithering, this.alphaTest = t2.alphaTest, this.alphaToCoverage = t2.alphaToCoverage, this.premultipliedAlpha = t2.premultipliedAlpha, this.visible = t2.visible, this.toneMapped = t2.toneMapped, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t2) {
      t2 === true && this.version++;
    }
  }
  jt.prototype.isMaterial = true;
  const zt = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Vt = { h: 0, s: 0, l: 0 }, Xt = { h: 0, s: 0, l: 0 };
  function Wt(t2, e2, i2) {
    return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t2 + 6 * (e2 - t2) * i2 : i2 < 0.5 ? e2 : i2 < 2 / 3 ? t2 + 6 * (e2 - t2) * (2 / 3 - i2) : t2;
  }
  function Yt(t2) {
    return t2 < 0.04045 ? 0.0773993808 * t2 : Math.pow(0.9478672986 * t2 + 0.0521327014, 2.4);
  }
  function qt(t2) {
    return t2 < 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 0.41666) - 0.055;
  }
  class Zt {
    constructor(t2, e2, i2) {
      return e2 === void 0 && i2 === void 0 ? this.set(t2) : this.setRGB(t2, e2, i2);
    }
    set(t2) {
      return t2 && t2.isColor ? this.copy(t2) : typeof t2 == "number" ? this.setHex(t2) : typeof t2 == "string" && this.setStyle(t2), this;
    }
    setScalar(t2) {
      return this.r = t2, this.g = t2, this.b = t2, this;
    }
    setHex(t2) {
      return t2 = Math.floor(t2), this.r = (t2 >> 16 & 255) / 255, this.g = (t2 >> 8 & 255) / 255, this.b = (255 & t2) / 255, this;
    }
    setRGB(t2, e2, i2) {
      return this.r = t2, this.g = e2, this.b = i2, this;
    }
    setHSL(t2, e2, i2) {
      if (t2 = d(t2, 1), e2 = c(e2, 0, 1), i2 = c(i2, 0, 1), e2 === 0)
        this.r = this.g = this.b = i2;
      else {
        const n2 = i2 <= 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, r2 = 2 * i2 - n2;
        this.r = Wt(r2, n2, t2 + 1 / 3), this.g = Wt(r2, n2, t2), this.b = Wt(r2, n2, t2 - 1 / 3);
      }
      return this;
    }
    setStyle(t2) {
      function e2(e3) {
        e3 !== void 0 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
      }
      let i2;
      if (i2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t2)) {
        let t3;
        const n2 = i2[1], r2 = i2[2];
        switch (n2) {
          case "rgb":
          case "rgba":
            if (t3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
              return this.r = Math.min(255, parseInt(t3[1], 10)) / 255, this.g = Math.min(255, parseInt(t3[2], 10)) / 255, this.b = Math.min(255, parseInt(t3[3], 10)) / 255, e2(t3[4]), this;
            if (t3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
              return this.r = Math.min(100, parseInt(t3[1], 10)) / 100, this.g = Math.min(100, parseInt(t3[2], 10)) / 100, this.b = Math.min(100, parseInt(t3[3], 10)) / 100, e2(t3[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (t3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) {
              const i3 = parseFloat(t3[1]) / 360, n3 = parseInt(t3[2], 10) / 100, r3 = parseInt(t3[3], 10) / 100;
              return e2(t3[4]), this.setHSL(i3, n3, r3);
            }
        }
      } else if (i2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
        const t3 = i2[1], e3 = t3.length;
        if (e3 === 3)
          return this.r = parseInt(t3.charAt(0) + t3.charAt(0), 16) / 255, this.g = parseInt(t3.charAt(1) + t3.charAt(1), 16) / 255, this.b = parseInt(t3.charAt(2) + t3.charAt(2), 16) / 255, this;
        if (e3 === 6)
          return this.r = parseInt(t3.charAt(0) + t3.charAt(1), 16) / 255, this.g = parseInt(t3.charAt(2) + t3.charAt(3), 16) / 255, this.b = parseInt(t3.charAt(4) + t3.charAt(5), 16) / 255, this;
      }
      return t2 && t2.length > 0 ? this.setColorName(t2) : this;
    }
    setColorName(t2) {
      const e2 = zt[t2.toLowerCase()];
      return e2 !== void 0 ? this.setHex(e2) : console.warn("THREE.Color: Unknown color " + t2), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t2) {
      return this.r = t2.r, this.g = t2.g, this.b = t2.b, this;
    }
    copyGammaToLinear(t2, e2 = 2) {
      return this.r = Math.pow(t2.r, e2), this.g = Math.pow(t2.g, e2), this.b = Math.pow(t2.b, e2), this;
    }
    copyLinearToGamma(t2, e2 = 2) {
      const i2 = e2 > 0 ? 1 / e2 : 1;
      return this.r = Math.pow(t2.r, i2), this.g = Math.pow(t2.g, i2), this.b = Math.pow(t2.b, i2), this;
    }
    convertGammaToLinear(t2) {
      return this.copyGammaToLinear(this, t2), this;
    }
    convertLinearToGamma(t2) {
      return this.copyLinearToGamma(this, t2), this;
    }
    copySRGBToLinear(t2) {
      return this.r = Yt(t2.r), this.g = Yt(t2.g), this.b = Yt(t2.b), this;
    }
    copyLinearToSRGB(t2) {
      return this.r = qt(t2.r), this.g = qt(t2.g), this.b = qt(t2.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(t2) {
      const e2 = this.r, i2 = this.g, n2 = this.b, r2 = Math.max(e2, i2, n2), o2 = Math.min(e2, i2, n2);
      let s2, a2;
      const l2 = (o2 + r2) / 2;
      if (o2 === r2)
        s2 = 0, a2 = 0;
      else {
        const t3 = r2 - o2;
        switch (a2 = l2 <= 0.5 ? t3 / (r2 + o2) : t3 / (2 - r2 - o2), r2) {
          case e2:
            s2 = (i2 - n2) / t3 + (i2 < n2 ? 6 : 0);
            break;
          case i2:
            s2 = (n2 - e2) / t3 + 2;
            break;
          case n2:
            s2 = (e2 - i2) / t3 + 4;
        }
        s2 /= 6;
      }
      return t2.h = s2, t2.s = a2, t2.l = l2, t2;
    }
    getStyle() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    }
    offsetHSL(t2, e2, i2) {
      return this.getHSL(Vt), Vt.h += t2, Vt.s += e2, Vt.l += i2, this.setHSL(Vt.h, Vt.s, Vt.l), this;
    }
    add(t2) {
      return this.r += t2.r, this.g += t2.g, this.b += t2.b, this;
    }
    addColors(t2, e2) {
      return this.r = t2.r + e2.r, this.g = t2.g + e2.g, this.b = t2.b + e2.b, this;
    }
    addScalar(t2) {
      return this.r += t2, this.g += t2, this.b += t2, this;
    }
    sub(t2) {
      return this.r = Math.max(0, this.r - t2.r), this.g = Math.max(0, this.g - t2.g), this.b = Math.max(0, this.b - t2.b), this;
    }
    multiply(t2) {
      return this.r *= t2.r, this.g *= t2.g, this.b *= t2.b, this;
    }
    multiplyScalar(t2) {
      return this.r *= t2, this.g *= t2, this.b *= t2, this;
    }
    lerp(t2, e2) {
      return this.r += (t2.r - this.r) * e2, this.g += (t2.g - this.g) * e2, this.b += (t2.b - this.b) * e2, this;
    }
    lerpColors(t2, e2, i2) {
      return this.r = t2.r + (e2.r - t2.r) * i2, this.g = t2.g + (e2.g - t2.g) * i2, this.b = t2.b + (e2.b - t2.b) * i2, this;
    }
    lerpHSL(t2, e2) {
      this.getHSL(Vt), t2.getHSL(Xt);
      const i2 = p(Vt.h, Xt.h, e2), n2 = p(Vt.s, Xt.s, e2), r2 = p(Vt.l, Xt.l, e2);
      return this.setHSL(i2, n2, r2), this;
    }
    equals(t2) {
      return t2.r === this.r && t2.g === this.g && t2.b === this.b;
    }
    fromArray(t2, e2 = 0) {
      return this.r = t2[e2], this.g = t2[e2 + 1], this.b = t2[e2 + 2], this;
    }
    toArray(t2 = [], e2 = 0) {
      return t2[e2] = this.r, t2[e2 + 1] = this.g, t2[e2 + 2] = this.b, t2;
    }
    fromBufferAttribute(t2, e2) {
      return this.r = t2.getX(e2), this.g = t2.getY(e2), this.b = t2.getZ(e2), t2.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
      return this.getHex();
    }
  }
  Zt.NAMES = zt, Zt.prototype.isColor = true, Zt.prototype.r = 1, Zt.prototype.g = 1, Zt.prototype.b = 1;
  class Jt extends jt {
    constructor(t2) {
      super(), this.type = "MeshBasicMaterial", this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this;
    }
  }
  Jt.prototype.isMeshBasicMaterial = true;
  const Kt = new M(), Qt = new g();
  class $t {
    constructor(t2, e2, i2) {
      if (Array.isArray(t2))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = t2, this.itemSize = e2, this.count = t2 !== void 0 ? t2.length / e2 : 0, this.normalized = i2 === true, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(t2) {
      t2 === true && this.version++;
    }
    setUsage(t2) {
      return this.usage = t2, this;
    }
    copy(t2) {
      return this.name = t2.name, this.array = new t2.array.constructor(t2.array), this.itemSize = t2.itemSize, this.count = t2.count, this.normalized = t2.normalized, this.usage = t2.usage, this;
    }
    copyAt(t2, e2, i2) {
      t2 *= this.itemSize, i2 *= e2.itemSize;
      for (let n2 = 0, r2 = this.itemSize; n2 < r2; n2++)
        this.array[t2 + n2] = e2.array[i2 + n2];
      return this;
    }
    copyArray(t2) {
      return this.array.set(t2), this;
    }
    copyColorsArray(t2) {
      const e2 = this.array;
      let i2 = 0;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        let r3 = t2[n2];
        r3 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n2), r3 = new Zt()), e2[i2++] = r3.r, e2[i2++] = r3.g, e2[i2++] = r3.b;
      }
      return this;
    }
    copyVector2sArray(t2) {
      const e2 = this.array;
      let i2 = 0;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        let r3 = t2[n2];
        r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n2), r3 = new g()), e2[i2++] = r3.x, e2[i2++] = r3.y;
      }
      return this;
    }
    copyVector3sArray(t2) {
      const e2 = this.array;
      let i2 = 0;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        let r3 = t2[n2];
        r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n2), r3 = new M()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z;
      }
      return this;
    }
    copyVector4sArray(t2) {
      const e2 = this.array;
      let i2 = 0;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        let r3 = t2[n2];
        r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n2), r3 = new E()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z, e2[i2++] = r3.w;
      }
      return this;
    }
    applyMatrix3(t2) {
      if (this.itemSize === 2)
        for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
          Qt.fromBufferAttribute(this, e2), Qt.applyMatrix3(t2), this.setXY(e2, Qt.x, Qt.y);
      else if (this.itemSize === 3)
        for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
          Kt.fromBufferAttribute(this, e2), Kt.applyMatrix3(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
      return this;
    }
    applyMatrix4(t2) {
      for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
        Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.applyMatrix4(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
      return this;
    }
    applyNormalMatrix(t2) {
      for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
        Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.applyNormalMatrix(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
      return this;
    }
    transformDirection(t2) {
      for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
        Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.transformDirection(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
      return this;
    }
    set(t2, e2 = 0) {
      return this.array.set(t2, e2), this;
    }
    getX(t2) {
      return this.array[t2 * this.itemSize];
    }
    setX(t2, e2) {
      return this.array[t2 * this.itemSize] = e2, this;
    }
    getY(t2) {
      return this.array[t2 * this.itemSize + 1];
    }
    setY(t2, e2) {
      return this.array[t2 * this.itemSize + 1] = e2, this;
    }
    getZ(t2) {
      return this.array[t2 * this.itemSize + 2];
    }
    setZ(t2, e2) {
      return this.array[t2 * this.itemSize + 2] = e2, this;
    }
    getW(t2) {
      return this.array[t2 * this.itemSize + 3];
    }
    setW(t2, e2) {
      return this.array[t2 * this.itemSize + 3] = e2, this;
    }
    setXY(t2, e2, i2) {
      return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this;
    }
    setXYZ(t2, e2, i2, n2) {
      return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this.array[t2 + 2] = n2, this;
    }
    setXYZW(t2, e2, i2, n2, r2) {
      return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this.array[t2 + 2] = n2, this.array[t2 + 3] = r2, this;
    }
    onUpload(t2) {
      return this.onUploadCallback = t2, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      return this.name !== "" && (t2.name = this.name), this.usage !== 35044 && (t2.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (t2.updateRange = this.updateRange), t2;
    }
  }
  $t.prototype.isBufferAttribute = true;
  class te extends $t {
    constructor(t2, e2, i2) {
      super(new Uint16Array(t2), e2, i2);
    }
  }
  class ee extends $t {
    constructor(t2, e2, i2) {
      super(new Int32Array(t2), e2, i2);
    }
  }
  class ie extends $t {
    constructor(t2, e2, i2) {
      super(new Uint32Array(t2), e2, i2);
    }
  }
  (class extends $t {
    constructor(t2, e2, i2) {
      super(new Uint16Array(t2), e2, i2);
    }
  }).prototype.isFloat16BufferAttribute = true;
  class ne extends $t {
    constructor(t2, e2, i2) {
      super(new Float32Array(t2), e2, i2);
    }
  }
  function re(t2) {
    if (t2.length === 0)
      return -1 / 0;
    let e2 = t2[0];
    for (let i2 = 1, n2 = t2.length; i2 < n2; ++i2)
      t2[i2] > e2 && (e2 = t2[i2]);
    return e2;
  }
  let oe = 0;
  const se = new rt(), ae = new Ct(), le = new M(), he = new I(), ue = new I(), ce = new M();
  class de extends s {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: oe++ }), this.uuid = u(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(t2) {
      return Array.isArray(t2) ? this.index = new (re(t2) > 65535 ? ie : te)(t2, 1) : this.index = t2, this;
    }
    getAttribute(t2) {
      return this.attributes[t2];
    }
    setAttribute(t2, e2) {
      return this.attributes[t2] = e2, this;
    }
    deleteAttribute(t2) {
      return delete this.attributes[t2], this;
    }
    hasAttribute(t2) {
      return this.attributes[t2] !== void 0;
    }
    addGroup(t2, e2, i2 = 0) {
      this.groups.push({ start: t2, count: e2, materialIndex: i2 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t2, e2) {
      this.drawRange.start = t2, this.drawRange.count = e2;
    }
    applyMatrix4(t2) {
      const e2 = this.attributes.position;
      e2 !== void 0 && (e2.applyMatrix4(t2), e2.needsUpdate = true);
      const i2 = this.attributes.normal;
      if (i2 !== void 0) {
        const e3 = new v().getNormalMatrix(t2);
        i2.applyNormalMatrix(e3), i2.needsUpdate = true;
      }
      const n2 = this.attributes.tangent;
      return n2 !== void 0 && (n2.transformDirection(t2), n2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t2) {
      return se.makeRotationFromQuaternion(t2), this.applyMatrix4(se), this;
    }
    rotateX(t2) {
      return se.makeRotationX(t2), this.applyMatrix4(se), this;
    }
    rotateY(t2) {
      return se.makeRotationY(t2), this.applyMatrix4(se), this;
    }
    rotateZ(t2) {
      return se.makeRotationZ(t2), this.applyMatrix4(se), this;
    }
    translate(t2, e2, i2) {
      return se.makeTranslation(t2, e2, i2), this.applyMatrix4(se), this;
    }
    scale(t2, e2, i2) {
      return se.makeScale(t2, e2, i2), this.applyMatrix4(se), this;
    }
    lookAt(t2) {
      return ae.lookAt(t2), ae.updateMatrix(), this.applyMatrix4(ae.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(le).negate(), this.translate(le.x, le.y, le.z), this;
    }
    setFromPoints(t2) {
      const e2 = [];
      for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
        const n3 = t2[i2];
        e2.push(n3.x, n3.y, n3.z || 0);
      }
      return this.setAttribute("position", new ne(e2, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new I());
      const t2 = this.attributes.position, e2 = this.morphAttributes.position;
      if (t2 && t2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new M(-1 / 0, -1 / 0, -1 / 0), new M(1 / 0, 1 / 0, 1 / 0));
      if (t2 !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(t2), e2)
          for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
            const i3 = e2[t3];
            he.setFromBufferAttribute(i3), this.morphTargetsRelative ? (ce.addVectors(this.boundingBox.min, he.min), this.boundingBox.expandByPoint(ce), ce.addVectors(this.boundingBox.max, he.max), this.boundingBox.expandByPoint(ce)) : (this.boundingBox.expandByPoint(he.min), this.boundingBox.expandByPoint(he.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Z());
      const t2 = this.attributes.position, e2 = this.morphAttributes.position;
      if (t2 && t2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new M(), 1 / 0);
      if (t2) {
        const i2 = this.boundingSphere.center;
        if (he.setFromBufferAttribute(t2), e2)
          for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) {
            const i4 = e2[t3];
            ue.setFromBufferAttribute(i4), this.morphTargetsRelative ? (ce.addVectors(he.min, ue.min), he.expandByPoint(ce), ce.addVectors(he.max, ue.max), he.expandByPoint(ce)) : (he.expandByPoint(ue.min), he.expandByPoint(ue.max));
          }
        he.getCenter(i2);
        let n2 = 0;
        for (let e3 = 0, r2 = t2.count; e3 < r2; e3++)
          ce.fromBufferAttribute(t2, e3), n2 = Math.max(n2, i2.distanceToSquared(ce));
        if (e2)
          for (let r2 = 0, o2 = e2.length; r2 < o2; r2++) {
            const o3 = e2[r2], s2 = this.morphTargetsRelative;
            for (let e3 = 0, r3 = o3.count; e3 < r3; e3++)
              ce.fromBufferAttribute(o3, e3), s2 && (le.fromBufferAttribute(t2, e3), ce.add(le)), n2 = Math.max(n2, i2.distanceToSquared(ce));
          }
        this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeFaceNormals() {
    }
    computeTangents() {
      const t2 = this.index, e2 = this.attributes;
      if (t2 === null || e2.position === void 0 || e2.normal === void 0 || e2.uv === void 0)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const i2 = t2.array, n2 = e2.position.array, r2 = e2.normal.array, o2 = e2.uv.array, s2 = n2.length / 3;
      e2.tangent === void 0 && this.setAttribute("tangent", new $t(new Float32Array(4 * s2), 4));
      const a2 = e2.tangent.array, l2 = [], h2 = [];
      for (let t3 = 0; t3 < s2; t3++)
        l2[t3] = new M(), h2[t3] = new M();
      const u2 = new M(), c2 = new M(), d2 = new M(), p2 = new g(), f2 = new g(), m2 = new g(), v2 = new M(), _2 = new M();
      function y2(t3, e3, i3) {
        u2.fromArray(n2, 3 * t3), c2.fromArray(n2, 3 * e3), d2.fromArray(n2, 3 * i3), p2.fromArray(o2, 2 * t3), f2.fromArray(o2, 2 * e3), m2.fromArray(o2, 2 * i3), c2.sub(u2), d2.sub(u2), f2.sub(p2), m2.sub(p2);
        const r3 = 1 / (f2.x * m2.y - m2.x * f2.y);
        isFinite(r3) && (v2.copy(c2).multiplyScalar(m2.y).addScaledVector(d2, -f2.y).multiplyScalar(r3), _2.copy(d2).multiplyScalar(f2.x).addScaledVector(c2, -m2.x).multiplyScalar(r3), l2[t3].add(v2), l2[e3].add(v2), l2[i3].add(v2), h2[t3].add(_2), h2[e3].add(_2), h2[i3].add(_2));
      }
      let x2 = this.groups;
      x2.length === 0 && (x2 = [{ start: 0, count: i2.length }]);
      for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
        const e4 = x2[t3], n3 = e4.start;
        for (let t4 = n3, r3 = n3 + e4.count; t4 < r3; t4 += 3)
          y2(i2[t4 + 0], i2[t4 + 1], i2[t4 + 2]);
      }
      const b2 = new M(), T2 = new M(), E2 = new M(), S2 = new M();
      function w2(t3) {
        E2.fromArray(r2, 3 * t3), S2.copy(E2);
        const e3 = l2[t3];
        b2.copy(e3), b2.sub(E2.multiplyScalar(E2.dot(e3))).normalize(), T2.crossVectors(S2, e3);
        const i3 = T2.dot(h2[t3]) < 0 ? -1 : 1;
        a2[4 * t3] = b2.x, a2[4 * t3 + 1] = b2.y, a2[4 * t3 + 2] = b2.z, a2[4 * t3 + 3] = i3;
      }
      for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
        const e4 = x2[t3], n3 = e4.start;
        for (let t4 = n3, r3 = n3 + e4.count; t4 < r3; t4 += 3)
          w2(i2[t4 + 0]), w2(i2[t4 + 1]), w2(i2[t4 + 2]);
      }
    }
    computeVertexNormals() {
      const t2 = this.index, e2 = this.getAttribute("position");
      if (e2 !== void 0) {
        let i2 = this.getAttribute("normal");
        if (i2 === void 0)
          i2 = new $t(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", i2);
        else
          for (let t3 = 0, e3 = i2.count; t3 < e3; t3++)
            i2.setXYZ(t3, 0, 0, 0);
        const n2 = new M(), r2 = new M(), o2 = new M(), s2 = new M(), a2 = new M(), l2 = new M(), h2 = new M(), u2 = new M();
        if (t2)
          for (let c2 = 0, d2 = t2.count; c2 < d2; c2 += 3) {
            const d3 = t2.getX(c2 + 0), p2 = t2.getX(c2 + 1), f2 = t2.getX(c2 + 2);
            n2.fromBufferAttribute(e2, d3), r2.fromBufferAttribute(e2, p2), o2.fromBufferAttribute(e2, f2), h2.subVectors(o2, r2), u2.subVectors(n2, r2), h2.cross(u2), s2.fromBufferAttribute(i2, d3), a2.fromBufferAttribute(i2, p2), l2.fromBufferAttribute(i2, f2), s2.add(h2), a2.add(h2), l2.add(h2), i2.setXYZ(d3, s2.x, s2.y, s2.z), i2.setXYZ(p2, a2.x, a2.y, a2.z), i2.setXYZ(f2, l2.x, l2.y, l2.z);
          }
        else
          for (let t3 = 0, s3 = e2.count; t3 < s3; t3 += 3)
            n2.fromBufferAttribute(e2, t3 + 0), r2.fromBufferAttribute(e2, t3 + 1), o2.fromBufferAttribute(e2, t3 + 2), h2.subVectors(o2, r2), u2.subVectors(n2, r2), h2.cross(u2), i2.setXYZ(t3 + 0, h2.x, h2.y, h2.z), i2.setXYZ(t3 + 1, h2.x, h2.y, h2.z), i2.setXYZ(t3 + 2, h2.x, h2.y, h2.z);
        this.normalizeNormals(), i2.needsUpdate = true;
      }
    }
    merge(t2, e2) {
      if (!t2 || !t2.isBufferGeometry)
        return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t2);
      e2 === void 0 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      const i2 = this.attributes;
      for (const n2 in i2) {
        if (t2.attributes[n2] === void 0)
          continue;
        const r2 = i2[n2].array, o2 = t2.attributes[n2], s2 = o2.array, a2 = o2.itemSize * e2, l2 = Math.min(s2.length, r2.length - a2);
        for (let t3 = 0, e3 = a2; t3 < l2; t3++, e3++)
          r2[e3] = s2[t3];
      }
      return this;
    }
    normalizeNormals() {
      const t2 = this.attributes.normal;
      for (let e2 = 0, i2 = t2.count; e2 < i2; e2++)
        ce.fromBufferAttribute(t2, e2), ce.normalize(), t2.setXYZ(e2, ce.x, ce.y, ce.z);
    }
    toNonIndexed() {
      function t2(t3, e3) {
        const i3 = t3.array, n3 = t3.itemSize, r3 = t3.normalized, o3 = new i3.constructor(e3.length * n3);
        let s2 = 0, a2 = 0;
        for (let r4 = 0, l2 = e3.length; r4 < l2; r4++) {
          s2 = t3.isInterleavedBufferAttribute ? e3[r4] * t3.data.stride + t3.offset : e3[r4] * n3;
          for (let t4 = 0; t4 < n3; t4++)
            o3[a2++] = i3[s2++];
        }
        return new $t(o3, n3, r3);
      }
      if (this.index === null)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const e2 = new de(), i2 = this.index.array, n2 = this.attributes;
      for (const r3 in n2) {
        const o3 = t2(n2[r3], i2);
        e2.setAttribute(r3, o3);
      }
      const r2 = this.morphAttributes;
      for (const n3 in r2) {
        const o3 = [], s2 = r2[n3];
        for (let e3 = 0, n4 = s2.length; e3 < n4; e3++) {
          const n5 = t2(s2[e3], i2);
          o3.push(n5);
        }
        e2.morphAttributes[n3] = o3;
      }
      e2.morphTargetsRelative = this.morphTargetsRelative;
      const o2 = this.groups;
      for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) {
        const i4 = o2[t3];
        e2.addGroup(i4.start, i4.count, i4.materialIndex);
      }
      return e2;
    }
    toJSON() {
      const t2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (t2.uuid = this.uuid, t2.type = this.type, this.name !== "" && (t2.name = this.name), Object.keys(this.userData).length > 0 && (t2.userData = this.userData), this.parameters !== void 0) {
        const e3 = this.parameters;
        for (const i3 in e3)
          e3[i3] !== void 0 && (t2[i3] = e3[i3]);
        return t2;
      }
      t2.data = { attributes: {} };
      const e2 = this.index;
      e2 !== null && (t2.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
      const i2 = this.attributes;
      for (const e3 in i2) {
        const n3 = i2[e3];
        t2.data.attributes[e3] = n3.toJSON(t2.data);
      }
      const n2 = {};
      let r2 = false;
      for (const e3 in this.morphAttributes) {
        const i3 = this.morphAttributes[e3], o3 = [];
        for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
          const n4 = i3[e4];
          o3.push(n4.toJSON(t2.data));
        }
        o3.length > 0 && (n2[e3] = o3, r2 = true);
      }
      r2 && (t2.data.morphAttributes = n2, t2.data.morphTargetsRelative = this.morphTargetsRelative);
      const o2 = this.groups;
      o2.length > 0 && (t2.data.groups = JSON.parse(JSON.stringify(o2)));
      const s2 = this.boundingSphere;
      return s2 !== null && (t2.data.boundingSphere = { center: s2.center.toArray(), radius: s2.radius }), t2;
    }
    clone() {
      return new de().copy(this);
    }
    copy(t2) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const e2 = {};
      this.name = t2.name;
      const i2 = t2.index;
      i2 !== null && this.setIndex(i2.clone(e2));
      const n2 = t2.attributes;
      for (const t3 in n2) {
        const i3 = n2[t3];
        this.setAttribute(t3, i3.clone(e2));
      }
      const r2 = t2.morphAttributes;
      for (const t3 in r2) {
        const i3 = [], n3 = r2[t3];
        for (let t4 = 0, r3 = n3.length; t4 < r3; t4++)
          i3.push(n3[t4].clone(e2));
        this.morphAttributes[t3] = i3;
      }
      this.morphTargetsRelative = t2.morphTargetsRelative;
      const o2 = t2.groups;
      for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
        const e4 = o2[t3];
        this.addGroup(e4.start, e4.count, e4.materialIndex);
      }
      const s2 = t2.boundingBox;
      s2 !== null && (this.boundingBox = s2.clone());
      const a2 = t2.boundingSphere;
      return a2 !== null && (this.boundingSphere = a2.clone()), this.drawRange.start = t2.drawRange.start, this.drawRange.count = t2.drawRange.count, this.userData = t2.userData, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  de.prototype.isBufferGeometry = true;
  const pe = new rt(), fe = new nt(), me = new Z(), ge = new M(), ve = new M(), _e = new M(), ye = new M(), xe = new M(), be = new M(), Te = new M(), Ee = new M(), Se = new M(), we = new g(), Ae = new g(), Me = new g(), Re = new M(), Ce = new M();
  class Ie extends Ct {
    constructor(t2 = new de(), e2 = new Jt()) {
      super(), this.type = "Mesh", this.geometry = t2, this.material = e2, this.updateMorphTargets();
    }
    copy(t2) {
      return super.copy(t2), t2.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t2.morphTargetInfluences.slice()), t2.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t2.morphTargetDictionary)), this.material = t2.material, this.geometry = t2.geometry, this;
    }
    updateMorphTargets() {
      const t2 = this.geometry;
      if (t2.isBufferGeometry) {
        const e2 = t2.morphAttributes, i2 = Object.keys(e2);
        if (i2.length > 0) {
          const t3 = e2[i2[0]];
          if (t3 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
              const i4 = t3[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
            }
          }
        }
      } else {
        const e2 = t2.morphTargets;
        e2 !== void 0 && e2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    raycast(t2, e2) {
      const i2 = this.geometry, n2 = this.material, r2 = this.matrixWorld;
      if (n2 === void 0)
        return;
      if (i2.boundingSphere === null && i2.computeBoundingSphere(), me.copy(i2.boundingSphere), me.applyMatrix4(r2), t2.ray.intersectsSphere(me) === false)
        return;
      if (pe.copy(r2).invert(), fe.copy(t2.ray).applyMatrix4(pe), i2.boundingBox !== null && fe.intersectsBox(i2.boundingBox) === false)
        return;
      let o2;
      if (i2.isBufferGeometry) {
        const r3 = i2.index, s2 = i2.attributes.position, a2 = i2.morphAttributes.position, l2 = i2.morphTargetsRelative, h2 = i2.attributes.uv, u2 = i2.attributes.uv2, c2 = i2.groups, d2 = i2.drawRange;
        if (r3 !== null)
          if (Array.isArray(n2))
            for (let i3 = 0, p2 = c2.length; i3 < p2; i3++) {
              const p3 = c2[i3], f2 = n2[p3.materialIndex];
              for (let i4 = Math.max(p3.start, d2.start), n3 = Math.min(p3.start + p3.count, d2.start + d2.count); i4 < n3; i4 += 3) {
                const n4 = r3.getX(i4), c3 = r3.getX(i4 + 1), d3 = r3.getX(i4 + 2);
                o2 = Pe(this, f2, t2, fe, s2, a2, l2, h2, u2, n4, c3, d3), o2 && (o2.faceIndex = Math.floor(i4 / 3), o2.face.materialIndex = p3.materialIndex, e2.push(o2));
              }
            }
          else {
            for (let i3 = Math.max(0, d2.start), c3 = Math.min(r3.count, d2.start + d2.count); i3 < c3; i3 += 3) {
              const c4 = r3.getX(i3), d3 = r3.getX(i3 + 1), p2 = r3.getX(i3 + 2);
              o2 = Pe(this, n2, t2, fe, s2, a2, l2, h2, u2, c4, d3, p2), o2 && (o2.faceIndex = Math.floor(i3 / 3), e2.push(o2));
            }
          }
        else if (s2 !== void 0)
          if (Array.isArray(n2))
            for (let i3 = 0, r4 = c2.length; i3 < r4; i3++) {
              const r5 = c2[i3], p2 = n2[r5.materialIndex];
              for (let i4 = Math.max(r5.start, d2.start), n3 = Math.min(r5.start + r5.count, d2.start + d2.count); i4 < n3; i4 += 3) {
                o2 = Pe(this, p2, t2, fe, s2, a2, l2, h2, u2, i4, i4 + 1, i4 + 2), o2 && (o2.faceIndex = Math.floor(i4 / 3), o2.face.materialIndex = r5.materialIndex, e2.push(o2));
              }
            }
          else {
            for (let i3 = Math.max(0, d2.start), r4 = Math.min(s2.count, d2.start + d2.count); i3 < r4; i3 += 3) {
              o2 = Pe(this, n2, t2, fe, s2, a2, l2, h2, u2, i3, i3 + 1, i3 + 2), o2 && (o2.faceIndex = Math.floor(i3 / 3), e2.push(o2));
            }
          }
      } else
        i2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  function Pe(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2) {
    ge.fromBufferAttribute(r2, h2), ve.fromBufferAttribute(r2, u2), _e.fromBufferAttribute(r2, c2);
    const d2 = t2.morphTargetInfluences;
    if (e2.morphTargets && o2 && d2) {
      Te.set(0, 0, 0), Ee.set(0, 0, 0), Se.set(0, 0, 0);
      for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
        const e4 = d2[t3], i3 = o2[t3];
        e4 !== 0 && (ye.fromBufferAttribute(i3, h2), xe.fromBufferAttribute(i3, u2), be.fromBufferAttribute(i3, c2), s2 ? (Te.addScaledVector(ye, e4), Ee.addScaledVector(xe, e4), Se.addScaledVector(be, e4)) : (Te.addScaledVector(ye.sub(ge), e4), Ee.addScaledVector(xe.sub(ve), e4), Se.addScaledVector(be.sub(_e), e4)));
      }
      ge.add(Te), ve.add(Ee), _e.add(Se);
    }
    t2.isSkinnedMesh && (t2.boneTransform(h2, ge), t2.boneTransform(u2, ve), t2.boneTransform(c2, _e));
    const p2 = function(t3, e3, i3, n3, r3, o3, s3, a3) {
      let l3;
      if (l3 = e3.side === 1 ? n3.intersectTriangle(s3, o3, r3, true, a3) : n3.intersectTriangle(r3, o3, s3, e3.side !== 2, a3), l3 === null)
        return null;
      Ce.copy(a3), Ce.applyMatrix4(t3.matrixWorld);
      const h3 = i3.ray.origin.distanceTo(Ce);
      return h3 < i3.near || h3 > i3.far ? null : { distance: h3, point: Ce.clone(), object: t3 };
    }(t2, e2, i2, n2, ge, ve, _e, Re);
    if (p2) {
      a2 && (we.fromBufferAttribute(a2, h2), Ae.fromBufferAttribute(a2, u2), Me.fromBufferAttribute(a2, c2), p2.uv = Gt.getUV(Re, ge, ve, _e, we, Ae, Me, new g())), l2 && (we.fromBufferAttribute(l2, h2), Ae.fromBufferAttribute(l2, u2), Me.fromBufferAttribute(l2, c2), p2.uv2 = Gt.getUV(Re, ge, ve, _e, we, Ae, Me, new g()));
      const t3 = { a: h2, b: u2, c: c2, normal: new M(), materialIndex: 0 };
      Gt.getNormal(ge, ve, _e, t3.normal), p2.face = t3;
    }
    return p2;
  }
  Ie.prototype.isMesh = true;
  class Oe extends de {
    constructor(t2 = 1, e2 = 1, i2 = 1, n2 = 1, r2 = 1, o2 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: t2, height: e2, depth: i2, widthSegments: n2, heightSegments: r2, depthSegments: o2 };
      const s2 = this;
      n2 = Math.floor(n2), r2 = Math.floor(r2), o2 = Math.floor(o2);
      const a2 = [], l2 = [], h2 = [], u2 = [];
      let c2 = 0, d2 = 0;
      function p2(t3, e3, i3, n3, r3, o3, p3, f2, m2, g2, v2) {
        const _2 = o3 / m2, y2 = p3 / g2, x2 = o3 / 2, b2 = p3 / 2, T2 = f2 / 2, E2 = m2 + 1, S2 = g2 + 1;
        let w2 = 0, A2 = 0;
        const R2 = new M();
        for (let o4 = 0; o4 < S2; o4++) {
          const s3 = o4 * y2 - b2;
          for (let a3 = 0; a3 < E2; a3++) {
            const c3 = a3 * _2 - x2;
            R2[t3] = c3 * n3, R2[e3] = s3 * r3, R2[i3] = T2, l2.push(R2.x, R2.y, R2.z), R2[t3] = 0, R2[e3] = 0, R2[i3] = f2 > 0 ? 1 : -1, h2.push(R2.x, R2.y, R2.z), u2.push(a3 / m2), u2.push(1 - o4 / g2), w2 += 1;
          }
        }
        for (let t4 = 0; t4 < g2; t4++)
          for (let e4 = 0; e4 < m2; e4++) {
            const i4 = c2 + e4 + E2 * t4, n4 = c2 + e4 + E2 * (t4 + 1), r4 = c2 + (e4 + 1) + E2 * (t4 + 1), o4 = c2 + (e4 + 1) + E2 * t4;
            a2.push(i4, n4, o4), a2.push(n4, r4, o4), A2 += 6;
          }
        s2.addGroup(d2, A2, v2), d2 += A2, c2 += w2;
      }
      p2("z", "y", "x", -1, -1, i2, e2, t2, o2, r2, 0), p2("z", "y", "x", 1, -1, i2, e2, -t2, o2, r2, 1), p2("x", "z", "y", 1, 1, t2, i2, e2, n2, o2, 2), p2("x", "z", "y", 1, -1, t2, i2, -e2, n2, o2, 3), p2("x", "y", "z", 1, -1, t2, e2, i2, n2, r2, 4), p2("x", "y", "z", -1, -1, t2, e2, -i2, n2, r2, 5), this.setIndex(a2), this.setAttribute("position", new ne(l2, 3)), this.setAttribute("normal", new ne(h2, 3)), this.setAttribute("uv", new ne(u2, 2));
    }
    static fromJSON(t2) {
      return new Oe(t2.width, t2.height, t2.depth, t2.widthSegments, t2.heightSegments, t2.depthSegments);
    }
  }
  function Ne(t2) {
    const e2 = {};
    for (const i2 in t2) {
      e2[i2] = {};
      for (const n2 in t2[i2]) {
        const r2 = t2[i2][n2];
        r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? e2[i2][n2] = r2.clone() : Array.isArray(r2) ? e2[i2][n2] = r2.slice() : e2[i2][n2] = r2;
      }
    }
    return e2;
  }
  function Le(t2) {
    const e2 = {};
    for (let i2 = 0; i2 < t2.length; i2++) {
      const n2 = Ne(t2[i2]);
      for (const t3 in n2)
        e2[t3] = n2[t3];
    }
    return e2;
  }
  const De = { clone: Ne, merge: Le };
  class Fe extends jt {
    constructor(t2) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t2 !== void 0 && (t2.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t2));
    }
    copy(t2) {
      return super.copy(t2), this.fragmentShader = t2.fragmentShader, this.vertexShader = t2.vertexShader, this.uniforms = Ne(t2.uniforms), this.defines = Object.assign({}, t2.defines), this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.lights = t2.lights, this.clipping = t2.clipping, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.extensions = Object.assign({}, t2.extensions), this.glslVersion = t2.glslVersion, this;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      e2.glslVersion = this.glslVersion, e2.uniforms = {};
      for (const i3 in this.uniforms) {
        const n2 = this.uniforms[i3].value;
        n2 && n2.isTexture ? e2.uniforms[i3] = { type: "t", value: n2.toJSON(t2).uuid } : n2 && n2.isColor ? e2.uniforms[i3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? e2.uniforms[i3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? e2.uniforms[i3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? e2.uniforms[i3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? e2.uniforms[i3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? e2.uniforms[i3] = { type: "m4", value: n2.toArray() } : e2.uniforms[i3] = { value: n2 };
      }
      Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
      const i2 = {};
      for (const t3 in this.extensions)
        this.extensions[t3] === true && (i2[t3] = true);
      return Object.keys(i2).length > 0 && (e2.extensions = i2), e2;
    }
  }
  Fe.prototype.isShaderMaterial = true;
  class Be extends Ct {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new rt(), this.projectionMatrix = new rt(), this.projectionMatrixInverse = new rt();
    }
    copy(t2, e2) {
      return super.copy(t2, e2), this.matrixWorldInverse.copy(t2.matrixWorldInverse), this.projectionMatrix.copy(t2.projectionMatrix), this.projectionMatrixInverse.copy(t2.projectionMatrixInverse), this;
    }
    getWorldDirection(t2) {
      this.updateWorldMatrix(true, false);
      const e2 = this.matrixWorld.elements;
      return t2.set(-e2[8], -e2[9], -e2[10]).normalize();
    }
    updateMatrixWorld(t2) {
      super.updateMatrixWorld(t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t2, e2) {
      super.updateWorldMatrix(t2, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Be.prototype.isCamera = true;
  class Ue extends Be {
    constructor(t2 = 50, e2 = 1, i2 = 0.1, n2 = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = t2, this.zoom = 1, this.near = i2, this.far = n2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t2, e2) {
      return super.copy(t2, e2), this.fov = t2.fov, this.zoom = t2.zoom, this.near = t2.near, this.far = t2.far, this.focus = t2.focus, this.aspect = t2.aspect, this.view = t2.view === null ? null : Object.assign({}, t2.view), this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this;
    }
    setFocalLength(t2) {
      const e2 = 0.5 * this.getFilmHeight() / t2;
      this.fov = 2 * h * Math.atan(e2), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t2 = Math.tan(0.5 * l * this.fov);
      return 0.5 * this.getFilmHeight() / t2;
    }
    getEffectiveFOV() {
      return 2 * h * Math.atan(Math.tan(0.5 * l * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t2, e2, i2, n2, r2, o2) {
      this.aspect = t2 / e2, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = o2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t2 = this.near;
      let e2 = t2 * Math.tan(0.5 * l * this.fov) / this.zoom, i2 = 2 * e2, n2 = this.aspect * i2, r2 = -0.5 * n2;
      const o2 = this.view;
      if (this.view !== null && this.view.enabled) {
        const t3 = o2.fullWidth, s3 = o2.fullHeight;
        r2 += o2.offsetX * n2 / t3, e2 -= o2.offsetY * i2 / s3, n2 *= o2.width / t3, i2 *= o2.height / s3;
      }
      const s2 = this.filmOffset;
      s2 !== 0 && (r2 += t2 * s2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + n2, e2, e2 - i2, t2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, this.view !== null && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
    }
  }
  Ue.prototype.isPerspectiveCamera = true;
  class ke extends Ct {
    constructor(t2, e2, i2) {
      if (super(), this.type = "CubeCamera", i2.isWebGLCubeRenderTarget !== true)
        return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      this.renderTarget = i2;
      const n2 = new Ue(90, 1, t2, e2);
      n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new M(1, 0, 0)), this.add(n2);
      const r2 = new Ue(90, 1, t2, e2);
      r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new M(-1, 0, 0)), this.add(r2);
      const o2 = new Ue(90, 1, t2, e2);
      o2.layers = this.layers, o2.up.set(0, 0, 1), o2.lookAt(new M(0, 1, 0)), this.add(o2);
      const s2 = new Ue(90, 1, t2, e2);
      s2.layers = this.layers, s2.up.set(0, 0, -1), s2.lookAt(new M(0, -1, 0)), this.add(s2);
      const a2 = new Ue(90, 1, t2, e2);
      a2.layers = this.layers, a2.up.set(0, -1, 0), a2.lookAt(new M(0, 0, 1)), this.add(a2);
      const l2 = new Ue(90, 1, t2, e2);
      l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new M(0, 0, -1)), this.add(l2);
    }
    update(t2, e2) {
      this.parent === null && this.updateMatrixWorld();
      const i2 = this.renderTarget, [n2, r2, o2, s2, a2, l2] = this.children, h2 = t2.xr.enabled, u2 = t2.getRenderTarget();
      t2.xr.enabled = false;
      const c2 = i2.texture.generateMipmaps;
      i2.texture.generateMipmaps = false, t2.setRenderTarget(i2, 0), t2.render(e2, n2), t2.setRenderTarget(i2, 1), t2.render(e2, r2), t2.setRenderTarget(i2, 2), t2.render(e2, o2), t2.setRenderTarget(i2, 3), t2.render(e2, s2), t2.setRenderTarget(i2, 4), t2.render(e2, a2), i2.texture.generateMipmaps = c2, t2.setRenderTarget(i2, 5), t2.render(e2, l2), t2.setRenderTarget(u2), t2.xr.enabled = h2;
    }
  }
  class Ge extends b {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2) {
      super(t2 = t2 !== void 0 ? t2 : [], e2 = e2 !== void 0 ? e2 : 301, i2, n2, r2, o2, s2 = s2 !== void 0 ? s2 : 1022, a2, l2, h2), this._needsFlipEnvMap = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(t2) {
      this.image = t2;
    }
  }
  Ge.prototype.isCubeTexture = true;
  class He extends S {
    constructor(t2, e2, i2) {
      Number.isInteger(e2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e2 = i2), super(t2, t2, e2), e2 = e2 || {}, this.texture = new Ge(void 0, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture.generateMipmaps = e2.generateMipmaps !== void 0 && e2.generateMipmaps, this.texture.minFilter = e2.minFilter !== void 0 ? e2.minFilter : 1006, this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(t2, e2) {
      this.texture.type = e2.type, this.texture.format = 1023, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
      const i2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, n2 = new Oe(5, 5, 5), r2 = new Fe({ name: "CubemapFromEquirect", uniforms: Ne(i2.uniforms), vertexShader: i2.vertexShader, fragmentShader: i2.fragmentShader, side: 1, blending: 0 });
      r2.uniforms.tEquirect.value = e2;
      const o2 = new Ie(n2, r2), s2 = e2.minFilter;
      e2.minFilter === 1008 && (e2.minFilter = 1006);
      return new ke(1, 10, this).update(t2, o2), e2.minFilter = s2, o2.geometry.dispose(), o2.material.dispose(), this;
    }
    clear(t2, e2, i2, n2) {
      const r2 = t2.getRenderTarget();
      for (let r3 = 0; r3 < 6; r3++)
        t2.setRenderTarget(this, r3), t2.clear(e2, i2, n2);
      t2.setRenderTarget(r2);
    }
  }
  He.prototype.isWebGLCubeRenderTarget = true;
  const je = new M(), ze = new M(), Ve = new v();
  class Xe {
    constructor(t2 = new M(1, 0, 0), e2 = 0) {
      this.normal = t2, this.constant = e2;
    }
    set(t2, e2) {
      return this.normal.copy(t2), this.constant = e2, this;
    }
    setComponents(t2, e2, i2, n2) {
      return this.normal.set(t2, e2, i2), this.constant = n2, this;
    }
    setFromNormalAndCoplanarPoint(t2, e2) {
      return this.normal.copy(t2), this.constant = -e2.dot(this.normal), this;
    }
    setFromCoplanarPoints(t2, e2, i2) {
      const n2 = je.subVectors(i2, e2).cross(ze.subVectors(t2, e2)).normalize();
      return this.setFromNormalAndCoplanarPoint(n2, t2), this;
    }
    copy(t2) {
      return this.normal.copy(t2.normal), this.constant = t2.constant, this;
    }
    normalize() {
      const t2 = 1 / this.normal.length();
      return this.normal.multiplyScalar(t2), this.constant *= t2, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t2) {
      return this.normal.dot(t2) + this.constant;
    }
    distanceToSphere(t2) {
      return this.distanceToPoint(t2.center) - t2.radius;
    }
    projectPoint(t2, e2) {
      return e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t2)).add(t2);
    }
    intersectLine(t2, e2) {
      const i2 = t2.delta(je), n2 = this.normal.dot(i2);
      if (n2 === 0)
        return this.distanceToPoint(t2.start) === 0 ? e2.copy(t2.start) : null;
      const r2 = -(t2.start.dot(this.normal) + this.constant) / n2;
      return r2 < 0 || r2 > 1 ? null : e2.copy(i2).multiplyScalar(r2).add(t2.start);
    }
    intersectsLine(t2) {
      const e2 = this.distanceToPoint(t2.start), i2 = this.distanceToPoint(t2.end);
      return e2 < 0 && i2 > 0 || i2 < 0 && e2 > 0;
    }
    intersectsBox(t2) {
      return t2.intersectsPlane(this);
    }
    intersectsSphere(t2) {
      return t2.intersectsPlane(this);
    }
    coplanarPoint(t2) {
      return t2.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t2, e2) {
      const i2 = e2 || Ve.getNormalMatrix(t2), n2 = this.coplanarPoint(je).applyMatrix4(t2), r2 = this.normal.applyMatrix3(i2).normalize();
      return this.constant = -n2.dot(r2), this;
    }
    translate(t2) {
      return this.constant -= t2.dot(this.normal), this;
    }
    equals(t2) {
      return t2.normal.equals(this.normal) && t2.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Xe.prototype.isPlane = true;
  const We = new Z(), Ye = new M();
  class qe {
    constructor(t2 = new Xe(), e2 = new Xe(), i2 = new Xe(), n2 = new Xe(), r2 = new Xe(), o2 = new Xe()) {
      this.planes = [t2, e2, i2, n2, r2, o2];
    }
    set(t2, e2, i2, n2, r2, o2) {
      const s2 = this.planes;
      return s2[0].copy(t2), s2[1].copy(e2), s2[2].copy(i2), s2[3].copy(n2), s2[4].copy(r2), s2[5].copy(o2), this;
    }
    copy(t2) {
      const e2 = this.planes;
      for (let i2 = 0; i2 < 6; i2++)
        e2[i2].copy(t2.planes[i2]);
      return this;
    }
    setFromProjectionMatrix(t2) {
      const e2 = this.planes, i2 = t2.elements, n2 = i2[0], r2 = i2[1], o2 = i2[2], s2 = i2[3], a2 = i2[4], l2 = i2[5], h2 = i2[6], u2 = i2[7], c2 = i2[8], d2 = i2[9], p2 = i2[10], f2 = i2[11], m2 = i2[12], g2 = i2[13], v2 = i2[14], _2 = i2[15];
      return e2[0].setComponents(s2 - n2, u2 - a2, f2 - c2, _2 - m2).normalize(), e2[1].setComponents(s2 + n2, u2 + a2, f2 + c2, _2 + m2).normalize(), e2[2].setComponents(s2 + r2, u2 + l2, f2 + d2, _2 + g2).normalize(), e2[3].setComponents(s2 - r2, u2 - l2, f2 - d2, _2 - g2).normalize(), e2[4].setComponents(s2 - o2, u2 - h2, f2 - p2, _2 - v2).normalize(), e2[5].setComponents(s2 + o2, u2 + h2, f2 + p2, _2 + v2).normalize(), this;
    }
    intersectsObject(t2) {
      const e2 = t2.geometry;
      return e2.boundingSphere === null && e2.computeBoundingSphere(), We.copy(e2.boundingSphere).applyMatrix4(t2.matrixWorld), this.intersectsSphere(We);
    }
    intersectsSprite(t2) {
      return We.center.set(0, 0, 0), We.radius = 0.7071067811865476, We.applyMatrix4(t2.matrixWorld), this.intersectsSphere(We);
    }
    intersectsSphere(t2) {
      const e2 = this.planes, i2 = t2.center, n2 = -t2.radius;
      for (let t3 = 0; t3 < 6; t3++) {
        if (e2[t3].distanceToPoint(i2) < n2)
          return false;
      }
      return true;
    }
    intersectsBox(t2) {
      const e2 = this.planes;
      for (let i2 = 0; i2 < 6; i2++) {
        const n2 = e2[i2];
        if (Ye.x = n2.normal.x > 0 ? t2.max.x : t2.min.x, Ye.y = n2.normal.y > 0 ? t2.max.y : t2.min.y, Ye.z = n2.normal.z > 0 ? t2.max.z : t2.min.z, n2.distanceToPoint(Ye) < 0)
          return false;
      }
      return true;
    }
    containsPoint(t2) {
      const e2 = this.planes;
      for (let i2 = 0; i2 < 6; i2++)
        if (e2[i2].distanceToPoint(t2) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Ze() {
    let t2 = null, e2 = false, i2 = null, n2 = null;
    function r2(e3, o2) {
      i2(e3, o2), n2 = t2.requestAnimationFrame(r2);
    }
    return { start: function() {
      e2 !== true && i2 !== null && (n2 = t2.requestAnimationFrame(r2), e2 = true);
    }, stop: function() {
      t2.cancelAnimationFrame(n2), e2 = false;
    }, setAnimationLoop: function(t3) {
      i2 = t3;
    }, setContext: function(e3) {
      t2 = e3;
    } };
  }
  function Je(t2, e2) {
    const i2 = e2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
    return { get: function(t3) {
      return t3.isInterleavedBufferAttribute && (t3 = t3.data), n2.get(t3);
    }, remove: function(e3) {
      e3.isInterleavedBufferAttribute && (e3 = e3.data);
      const i3 = n2.get(e3);
      i3 && (t2.deleteBuffer(i3.buffer), n2.delete(e3));
    }, update: function(e3, r2) {
      if (e3.isGLBufferAttribute) {
        const t3 = n2.get(e3);
        return void ((!t3 || t3.version < e3.version) && n2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
      }
      e3.isInterleavedBufferAttribute && (e3 = e3.data);
      const o2 = n2.get(e3);
      o2 === void 0 ? n2.set(e3, function(e4, n3) {
        const r3 = e4.array, o3 = e4.usage, s2 = t2.createBuffer();
        t2.bindBuffer(n3, s2), t2.bufferData(n3, r3, o3), e4.onUploadCallback();
        let a2 = 5126;
        return r3 instanceof Float32Array ? a2 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? i2 ? a2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a2 = 5123 : r3 instanceof Int16Array ? a2 = 5122 : r3 instanceof Uint32Array ? a2 = 5125 : r3 instanceof Int32Array ? a2 = 5124 : r3 instanceof Int8Array ? a2 = 5120 : (r3 instanceof Uint8Array || r3 instanceof Uint8ClampedArray) && (a2 = 5121), { buffer: s2, type: a2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
      }(e3, r2)) : o2.version < e3.version && (!function(e4, n3, r3) {
        const o3 = n3.array, s2 = n3.updateRange;
        t2.bindBuffer(r3, e4), s2.count === -1 ? t2.bufferSubData(r3, 0, o3) : (i2 ? t2.bufferSubData(r3, s2.offset * o3.BYTES_PER_ELEMENT, o3, s2.offset, s2.count) : t2.bufferSubData(r3, s2.offset * o3.BYTES_PER_ELEMENT, o3.subarray(s2.offset, s2.offset + s2.count)), s2.count = -1);
      }(o2.buffer, e3, r2), o2.version = e3.version);
    } };
  }
  class Ke extends de {
    constructor(t2 = 1, e2 = 1, i2 = 1, n2 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: t2, height: e2, widthSegments: i2, heightSegments: n2 };
      const r2 = t2 / 2, o2 = e2 / 2, s2 = Math.floor(i2), a2 = Math.floor(n2), l2 = s2 + 1, h2 = a2 + 1, u2 = t2 / s2, c2 = e2 / a2, d2 = [], p2 = [], f2 = [], m2 = [];
      for (let t3 = 0; t3 < h2; t3++) {
        const e3 = t3 * c2 - o2;
        for (let i3 = 0; i3 < l2; i3++) {
          const n3 = i3 * u2 - r2;
          p2.push(n3, -e3, 0), f2.push(0, 0, 1), m2.push(i3 / s2), m2.push(1 - t3 / a2);
        }
      }
      for (let t3 = 0; t3 < a2; t3++)
        for (let e3 = 0; e3 < s2; e3++) {
          const i3 = e3 + l2 * t3, n3 = e3 + l2 * (t3 + 1), r3 = e3 + 1 + l2 * (t3 + 1), o3 = e3 + 1 + l2 * t3;
          d2.push(i3, n3, o3), d2.push(n3, r3, o3);
        }
      this.setIndex(d2), this.setAttribute("position", new ne(p2, 3)), this.setAttribute("normal", new ne(f2, 3)), this.setAttribute("uv", new ne(m2, 2));
    }
    static fromJSON(t2) {
      return new Ke(t2.width, t2.height, t2.widthSegments, t2.heightSegments);
    }
  }
  const Qe = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSNMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform vec3 attenuationColor;\n	uniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, $e = { common: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new v() }, uv2Transform: { value: new v() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new g(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Zt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v() } }, sprite: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, center: { value: new g(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v() } } }, ti = { basic: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.fog]), vertexShader: Qe.meshbasic_vert, fragmentShader: Qe.meshbasic_frag }, lambert: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.fog, $e.lights, { emissive: { value: new Zt(0) } }]), vertexShader: Qe.meshlambert_vert, fragmentShader: Qe.meshlambert_frag }, phong: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) }, specular: { value: new Zt(1118481) }, shininess: { value: 30 } }]), vertexShader: Qe.meshphong_vert, fragmentShader: Qe.meshphong_frag }, standard: { uniforms: Le([$e.common, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.roughnessmap, $e.metalnessmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag }, toon: { uniforms: Le([$e.common, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.gradientmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) } }]), vertexShader: Qe.meshtoon_vert, fragmentShader: Qe.meshtoon_frag }, matcap: { uniforms: Le([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, { matcap: { value: null } }]), vertexShader: Qe.meshmatcap_vert, fragmentShader: Qe.meshmatcap_frag }, points: { uniforms: Le([$e.points, $e.fog]), vertexShader: Qe.points_vert, fragmentShader: Qe.points_frag }, dashed: { uniforms: Le([$e.common, $e.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Qe.linedashed_vert, fragmentShader: Qe.linedashed_frag }, depth: { uniforms: Le([$e.common, $e.displacementmap]), vertexShader: Qe.depth_vert, fragmentShader: Qe.depth_frag }, normal: { uniforms: Le([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, { opacity: { value: 1 } }]), vertexShader: Qe.normal_vert, fragmentShader: Qe.normal_frag }, sprite: { uniforms: Le([$e.sprite, $e.fog]), vertexShader: Qe.sprite_vert, fragmentShader: Qe.sprite_frag }, background: { uniforms: { uvTransform: { value: new v() }, t2D: { value: null } }, vertexShader: Qe.background_vert, fragmentShader: Qe.background_frag }, cube: { uniforms: Le([$e.envmap, { opacity: { value: 1 } }]), vertexShader: Qe.cube_vert, fragmentShader: Qe.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Qe.equirect_vert, fragmentShader: Qe.equirect_frag }, distanceRGBA: { uniforms: Le([$e.common, $e.displacementmap, { referencePosition: { value: new M() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Qe.distanceRGBA_vert, fragmentShader: Qe.distanceRGBA_frag }, shadow: { uniforms: Le([$e.lights, $e.fog, { color: { value: new Zt(0) }, opacity: { value: 1 } }]), vertexShader: Qe.shadow_vert, fragmentShader: Qe.shadow_frag } };
  function ei(t2, e2, i2, n2, r2) {
    const o2 = new Zt(0);
    let s2, a2, l2 = 0, h2 = null, u2 = 0, c2 = null;
    function d2(t3, e3) {
      i2.buffers.color.setClear(t3.r, t3.g, t3.b, e3, r2);
    }
    return { getClearColor: function() {
      return o2;
    }, setClearColor: function(t3, e3 = 1) {
      o2.set(t3), l2 = e3, d2(o2, l2);
    }, getClearAlpha: function() {
      return l2;
    }, setClearAlpha: function(t3) {
      l2 = t3, d2(o2, l2);
    }, render: function(i3, r3) {
      let p2 = false, f2 = r3.isScene === true ? r3.background : null;
      f2 && f2.isTexture && (f2 = e2.get(f2));
      const m2 = t2.xr, g2 = m2.getSession && m2.getSession();
      g2 && g2.environmentBlendMode === "additive" && (f2 = null), f2 === null ? d2(o2, l2) : f2 && f2.isColor && (d2(f2, 1), p2 = true), (t2.autoClear || p2) && t2.clear(t2.autoClearColor, t2.autoClearDepth, t2.autoClearStencil), f2 && (f2.isCubeTexture || f2.mapping === 306) ? (a2 === void 0 && (a2 = new Ie(new Oe(1, 1, 1), new Fe({ name: "BackgroundCubeMaterial", uniforms: Ne(ti.cube.uniforms), vertexShader: ti.cube.vertexShader, fragmentShader: ti.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), a2.geometry.deleteAttribute("uv"), a2.onBeforeRender = function(t3, e3, i4) {
        this.matrixWorld.copyPosition(i4.matrixWorld);
      }, Object.defineProperty(a2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), n2.update(a2)), a2.material.uniforms.envMap.value = f2, a2.material.uniforms.flipEnvMap.value = f2.isCubeTexture && f2._needsFlipEnvMap ? -1 : 1, h2 === f2 && u2 === f2.version && c2 === t2.toneMapping || (a2.material.needsUpdate = true, h2 = f2, u2 = f2.version, c2 = t2.toneMapping), i3.unshift(a2, a2.geometry, a2.material, 0, 0, null)) : f2 && f2.isTexture && (s2 === void 0 && (s2 = new Ie(new Ke(2, 2), new Fe({ name: "BackgroundMaterial", uniforms: Ne(ti.background.uniforms), vertexShader: ti.background.vertexShader, fragmentShader: ti.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), s2.geometry.deleteAttribute("normal"), Object.defineProperty(s2.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), n2.update(s2)), s2.material.uniforms.t2D.value = f2, f2.matrixAutoUpdate === true && f2.updateMatrix(), s2.material.uniforms.uvTransform.value.copy(f2.matrix), h2 === f2 && u2 === f2.version && c2 === t2.toneMapping || (s2.material.needsUpdate = true, h2 = f2, u2 = f2.version, c2 = t2.toneMapping), i3.unshift(s2, s2.geometry, s2.material, 0, 0, null));
    } };
  }
  function ii(t2, e2, i2, n2) {
    const r2 = t2.getParameter(34921), o2 = n2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), s2 = n2.isWebGL2 || o2 !== null, a2 = {}, l2 = d2(null);
    let h2 = l2;
    function u2(e3) {
      return n2.isWebGL2 ? t2.bindVertexArray(e3) : o2.bindVertexArrayOES(e3);
    }
    function c2(e3) {
      return n2.isWebGL2 ? t2.deleteVertexArray(e3) : o2.deleteVertexArrayOES(e3);
    }
    function d2(t3) {
      const e3 = [], i3 = [], n3 = [];
      for (let t4 = 0; t4 < r2; t4++)
        e3[t4] = 0, i3[t4] = 0, n3[t4] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: i3, attributeDivisors: n3, object: t3, attributes: {}, index: null };
    }
    function p2() {
      const t3 = h2.newAttributes;
      for (let e3 = 0, i3 = t3.length; e3 < i3; e3++)
        t3[e3] = 0;
    }
    function f2(t3) {
      m2(t3, 0);
    }
    function m2(i3, r3) {
      const o3 = h2.newAttributes, s3 = h2.enabledAttributes, a3 = h2.attributeDivisors;
      if (o3[i3] = 1, s3[i3] === 0 && (t2.enableVertexAttribArray(i3), s3[i3] = 1), a3[i3] !== r3) {
        (n2.isWebGL2 ? t2 : e2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i3, r3), a3[i3] = r3;
      }
    }
    function g2() {
      const e3 = h2.newAttributes, i3 = h2.enabledAttributes;
      for (let n3 = 0, r3 = i3.length; n3 < r3; n3++)
        i3[n3] !== e3[n3] && (t2.disableVertexAttribArray(n3), i3[n3] = 0);
    }
    function v2(e3, i3, r3, o3, s3, a3) {
      n2.isWebGL2 !== true || r3 !== 5124 && r3 !== 5125 ? t2.vertexAttribPointer(e3, i3, r3, o3, s3, a3) : t2.vertexAttribIPointer(e3, i3, r3, s3, a3);
    }
    function _2() {
      y2(), h2 !== l2 && (h2 = l2, u2(h2.object));
    }
    function y2() {
      l2.geometry = null, l2.program = null, l2.wireframe = false;
    }
    return { setup: function(r3, l3, c3, _3, y3) {
      let x2 = false;
      if (s2) {
        const e3 = function(e4, i3, r4) {
          const s3 = r4.wireframe === true;
          let l4 = a2[e4.id];
          l4 === void 0 && (l4 = {}, a2[e4.id] = l4);
          let h3 = l4[i3.id];
          h3 === void 0 && (h3 = {}, l4[i3.id] = h3);
          let u3 = h3[s3];
          u3 === void 0 && (u3 = d2(n2.isWebGL2 ? t2.createVertexArray() : o2.createVertexArrayOES()), h3[s3] = u3);
          return u3;
        }(_3, c3, l3);
        h2 !== e3 && (h2 = e3, u2(h2.object)), x2 = function(t3, e4) {
          const i3 = h2.attributes, n3 = t3.attributes;
          let r4 = 0;
          for (const t4 in n3) {
            const e5 = i3[t4], o3 = n3[t4];
            if (e5 === void 0)
              return true;
            if (e5.attribute !== o3)
              return true;
            if (e5.data !== o3.data)
              return true;
            r4++;
          }
          return h2.attributesNum !== r4 || h2.index !== e4;
        }(_3, y3), x2 && function(t3, e4) {
          const i3 = {}, n3 = t3.attributes;
          let r4 = 0;
          for (const t4 in n3) {
            const e5 = n3[t4], o3 = {};
            o3.attribute = e5, e5.data && (o3.data = e5.data), i3[t4] = o3, r4++;
          }
          h2.attributes = i3, h2.attributesNum = r4, h2.index = e4;
        }(_3, y3);
      } else {
        const t3 = l3.wireframe === true;
        h2.geometry === _3.id && h2.program === c3.id && h2.wireframe === t3 || (h2.geometry = _3.id, h2.program = c3.id, h2.wireframe = t3, x2 = true);
      }
      r3.isInstancedMesh === true && (x2 = true), y3 !== null && i2.update(y3, 34963), x2 && (!function(r4, o3, s3, a3) {
        if (n2.isWebGL2 === false && (r4.isInstancedMesh || a3.isInstancedBufferGeometry) && e2.get("ANGLE_instanced_arrays") === null)
          return;
        p2();
        const l4 = a3.attributes, h3 = s3.getAttributes(), u3 = o3.defaultAttributeValues;
        for (const e3 in h3) {
          const n3 = h3[e3];
          if (n3 >= 0) {
            const o4 = l4[e3];
            if (o4 !== void 0) {
              const e4 = o4.normalized, r5 = o4.itemSize, s4 = i2.get(o4);
              if (s4 === void 0)
                continue;
              const l5 = s4.buffer, h4 = s4.type, u4 = s4.bytesPerElement;
              if (o4.isInterleavedBufferAttribute) {
                const i3 = o4.data, s5 = i3.stride, c4 = o4.offset;
                i3 && i3.isInstancedInterleavedBuffer ? (m2(n3, i3.meshPerAttribute), a3._maxInstanceCount === void 0 && (a3._maxInstanceCount = i3.meshPerAttribute * i3.count)) : f2(n3), t2.bindBuffer(34962, l5), v2(n3, r5, h4, e4, s5 * u4, c4 * u4);
              } else
                o4.isInstancedBufferAttribute ? (m2(n3, o4.meshPerAttribute), a3._maxInstanceCount === void 0 && (a3._maxInstanceCount = o4.meshPerAttribute * o4.count)) : f2(n3), t2.bindBuffer(34962, l5), v2(n3, r5, h4, e4, 0, 0);
            } else if (e3 === "instanceMatrix") {
              const e4 = i2.get(r4.instanceMatrix);
              if (e4 === void 0)
                continue;
              const o5 = e4.buffer, s4 = e4.type;
              m2(n3 + 0, 1), m2(n3 + 1, 1), m2(n3 + 2, 1), m2(n3 + 3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(n3 + 0, 4, s4, false, 64, 0), t2.vertexAttribPointer(n3 + 1, 4, s4, false, 64, 16), t2.vertexAttribPointer(n3 + 2, 4, s4, false, 64, 32), t2.vertexAttribPointer(n3 + 3, 4, s4, false, 64, 48);
            } else if (e3 === "instanceColor") {
              const e4 = i2.get(r4.instanceColor);
              if (e4 === void 0)
                continue;
              const o5 = e4.buffer, s4 = e4.type;
              m2(n3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(n3, 3, s4, false, 12, 0);
            } else if (u3 !== void 0) {
              const i3 = u3[e3];
              if (i3 !== void 0)
                switch (i3.length) {
                  case 2:
                    t2.vertexAttrib2fv(n3, i3);
                    break;
                  case 3:
                    t2.vertexAttrib3fv(n3, i3);
                    break;
                  case 4:
                    t2.vertexAttrib4fv(n3, i3);
                    break;
                  default:
                    t2.vertexAttrib1fv(n3, i3);
                }
            }
          }
        }
        g2();
      }(r3, l3, c3, _3), y3 !== null && t2.bindBuffer(34963, i2.get(y3).buffer));
    }, reset: _2, resetDefaultState: y2, dispose: function() {
      _2();
      for (const t3 in a2) {
        const e3 = a2[t3];
        for (const t4 in e3) {
          const i3 = e3[t4];
          for (const t5 in i3)
            c2(i3[t5].object), delete i3[t5];
          delete e3[t4];
        }
        delete a2[t3];
      }
    }, releaseStatesOfGeometry: function(t3) {
      if (a2[t3.id] === void 0)
        return;
      const e3 = a2[t3.id];
      for (const t4 in e3) {
        const i3 = e3[t4];
        for (const t5 in i3)
          c2(i3[t5].object), delete i3[t5];
        delete e3[t4];
      }
      delete a2[t3.id];
    }, releaseStatesOfProgram: function(t3) {
      for (const e3 in a2) {
        const i3 = a2[e3];
        if (i3[t3.id] === void 0)
          continue;
        const n3 = i3[t3.id];
        for (const t4 in n3)
          c2(n3[t4].object), delete n3[t4];
        delete i3[t3.id];
      }
    }, initAttributes: p2, enableAttribute: f2, disableUnusedAttributes: g2 };
  }
  function ni(t2, e2, i2, n2) {
    const r2 = n2.isWebGL2;
    let o2;
    this.setMode = function(t3) {
      o2 = t3;
    }, this.render = function(e3, n3) {
      t2.drawArrays(o2, e3, n3), i2.update(n3, o2, 1);
    }, this.renderInstances = function(n3, s2, a2) {
      if (a2 === 0)
        return;
      let l2, h2;
      if (r2)
        l2 = t2, h2 = "drawArraysInstanced";
      else if (l2 = e2.get("ANGLE_instanced_arrays"), h2 = "drawArraysInstancedANGLE", l2 === null)
        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      l2[h2](o2, n3, s2, a2), i2.update(s2, o2, a2);
    };
  }
  function ri(t2, e2, i2) {
    let n2;
    function r2(e3) {
      if (e3 === "highp") {
        if (t2.getShaderPrecisionFormat(35633, 36338).precision > 0 && t2.getShaderPrecisionFormat(35632, 36338).precision > 0)
          return "highp";
        e3 = "mediump";
      }
      return e3 === "mediump" && t2.getShaderPrecisionFormat(35633, 36337).precision > 0 && t2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const o2 = typeof WebGL2RenderingContext != "undefined" && t2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && t2 instanceof WebGL2ComputeRenderingContext;
    let s2 = i2.precision !== void 0 ? i2.precision : "highp";
    const a2 = r2(s2);
    a2 !== s2 && (console.warn("THREE.WebGLRenderer:", s2, "not supported, using", a2, "instead."), s2 = a2);
    const l2 = o2 || e2.has("WEBGL_draw_buffers"), h2 = i2.logarithmicDepthBuffer === true, u2 = t2.getParameter(34930), c2 = t2.getParameter(35660), d2 = t2.getParameter(3379), p2 = t2.getParameter(34076), f2 = t2.getParameter(34921), m2 = t2.getParameter(36347), g2 = t2.getParameter(36348), v2 = t2.getParameter(36349), _2 = c2 > 0, y2 = o2 || e2.has("OES_texture_float");
    return { isWebGL2: o2, drawBuffers: l2, getMaxAnisotropy: function() {
      if (n2 !== void 0)
        return n2;
      if (e2.has("EXT_texture_filter_anisotropic") === true) {
        const i3 = e2.get("EXT_texture_filter_anisotropic");
        n2 = t2.getParameter(i3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else
        n2 = 0;
      return n2;
    }, getMaxPrecision: r2, precision: s2, logarithmicDepthBuffer: h2, maxTextures: u2, maxVertexTextures: c2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: _2, floatFragmentTextures: y2, floatVertexTextures: _2 && y2, maxSamples: o2 ? t2.getParameter(36183) : 0 };
  }
  function oi(t2) {
    const e2 = this;
    let i2 = null, n2 = 0, r2 = false, o2 = false;
    const s2 = new Xe(), a2 = new v(), l2 = { value: null, needsUpdate: false };
    function h2() {
      l2.value !== i2 && (l2.value = i2, l2.needsUpdate = n2 > 0), e2.numPlanes = n2, e2.numIntersection = 0;
    }
    function u2(t3, i3, n3, r3) {
      const o3 = t3 !== null ? t3.length : 0;
      let h3 = null;
      if (o3 !== 0) {
        if (h3 = l2.value, r3 !== true || h3 === null) {
          const e3 = n3 + 4 * o3, r4 = i3.matrixWorldInverse;
          a2.getNormalMatrix(r4), (h3 === null || h3.length < e3) && (h3 = new Float32Array(e3));
          for (let e4 = 0, i4 = n3; e4 !== o3; ++e4, i4 += 4)
            s2.copy(t3[e4]).applyMatrix4(r4, a2), s2.normal.toArray(h3, i4), h3[i4 + 3] = s2.constant;
        }
        l2.value = h3, l2.needsUpdate = true;
      }
      return e2.numPlanes = o3, e2.numIntersection = 0, h3;
    }
    this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t3, e3, o3) {
      const s3 = t3.length !== 0 || e3 || n2 !== 0 || r2;
      return r2 = e3, i2 = u2(t3, o3, 0), n2 = t3.length, s3;
    }, this.beginShadows = function() {
      o2 = true, u2(null);
    }, this.endShadows = function() {
      o2 = false, h2();
    }, this.setState = function(e3, s3, a3) {
      const c2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, f2 = t2.get(e3);
      if (!r2 || c2 === null || c2.length === 0 || o2 && !p2)
        o2 ? u2(null) : h2();
      else {
        const t3 = o2 ? 0 : n2, e4 = 4 * t3;
        let r3 = f2.clippingState || null;
        l2.value = r3, r3 = u2(c2, s3, e4, a3);
        for (let t4 = 0; t4 !== e4; ++t4)
          r3[t4] = i2[t4];
        f2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t3;
      }
    };
  }
  function si(t2) {
    let e2 = /* @__PURE__ */ new WeakMap();
    function i2(t3, e3) {
      return e3 === 303 ? t3.mapping = 301 : e3 === 304 && (t3.mapping = 302), t3;
    }
    function n2(t3) {
      const i3 = t3.target;
      i3.removeEventListener("dispose", n2);
      const r2 = e2.get(i3);
      r2 !== void 0 && (e2.delete(i3), r2.dispose());
    }
    return { get: function(r2) {
      if (r2 && r2.isTexture) {
        const o2 = r2.mapping;
        if (o2 === 303 || o2 === 304) {
          if (e2.has(r2)) {
            return i2(e2.get(r2).texture, r2.mapping);
          }
          {
            const o3 = r2.image;
            if (o3 && o3.height > 0) {
              const s2 = t2.getRenderTarget(), a2 = new He(o3.height / 2);
              return a2.fromEquirectangularTexture(t2, r2), e2.set(r2, a2), t2.setRenderTarget(s2), r2.addEventListener("dispose", n2), i2(a2.texture, r2.mapping);
            }
            return null;
          }
        }
      }
      return r2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function ai(t2) {
    const e2 = {};
    function i2(i3) {
      if (e2[i3] !== void 0)
        return e2[i3];
      let n2;
      switch (i3) {
        case "WEBGL_depth_texture":
          n2 = t2.getExtension("WEBGL_depth_texture") || t2.getExtension("MOZ_WEBGL_depth_texture") || t2.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n2 = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n2 = t2.getExtension("WEBGL_compressed_texture_s3tc") || t2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n2 = t2.getExtension("WEBGL_compressed_texture_pvrtc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n2 = t2.getExtension(i3);
      }
      return e2[i3] = n2, n2;
    }
    return { has: function(t3) {
      return i2(t3) !== null;
    }, init: function(t3) {
      t3.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float");
    }, get: function(t3) {
      const e3 = i2(t3);
      return e3 === null && console.warn("THREE.WebGLRenderer: " + t3 + " extension not supported."), e3;
    } };
  }
  function li(t2, e2, i2, n2) {
    const r2 = {}, o2 = /* @__PURE__ */ new WeakMap();
    function s2(t3) {
      const a3 = t3.target;
      a3.index !== null && e2.remove(a3.index);
      for (const t4 in a3.attributes)
        e2.remove(a3.attributes[t4]);
      a3.removeEventListener("dispose", s2), delete r2[a3.id];
      const l2 = o2.get(a3);
      l2 && (e2.remove(l2), o2.delete(a3)), n2.releaseStatesOfGeometry(a3), a3.isInstancedBufferGeometry === true && delete a3._maxInstanceCount, i2.memory.geometries--;
    }
    function a2(t3) {
      const i3 = [], n3 = t3.index, r3 = t3.attributes.position;
      let s3 = 0;
      if (n3 !== null) {
        const t4 = n3.array;
        s3 = n3.version;
        for (let e3 = 0, n4 = t4.length; e3 < n4; e3 += 3) {
          const n5 = t4[e3 + 0], r4 = t4[e3 + 1], o3 = t4[e3 + 2];
          i3.push(n5, r4, r4, o3, o3, n5);
        }
      } else {
        const t4 = r3.array;
        s3 = r3.version;
        for (let e3 = 0, n4 = t4.length / 3 - 1; e3 < n4; e3 += 3) {
          const t5 = e3 + 0, n5 = e3 + 1, r4 = e3 + 2;
          i3.push(t5, n5, n5, r4, r4, t5);
        }
      }
      const a3 = new (re(i3) > 65535 ? ie : te)(i3, 1);
      a3.version = s3;
      const l2 = o2.get(t3);
      l2 && e2.remove(l2), o2.set(t3, a3);
    }
    return { get: function(t3, e3) {
      return r2[e3.id] === true || (e3.addEventListener("dispose", s2), r2[e3.id] = true, i2.memory.geometries++), e3;
    }, update: function(t3) {
      const i3 = t3.attributes;
      for (const t4 in i3)
        e2.update(i3[t4], 34962);
      const n3 = t3.morphAttributes;
      for (const t4 in n3) {
        const i4 = n3[t4];
        for (let t5 = 0, n4 = i4.length; t5 < n4; t5++)
          e2.update(i4[t5], 34962);
      }
    }, getWireframeAttribute: function(t3) {
      const e3 = o2.get(t3);
      if (e3) {
        const i3 = t3.index;
        i3 !== null && e3.version < i3.version && a2(t3);
      } else
        a2(t3);
      return o2.get(t3);
    } };
  }
  function hi(t2, e2, i2, n2) {
    const r2 = n2.isWebGL2;
    let o2, s2, a2;
    this.setMode = function(t3) {
      o2 = t3;
    }, this.setIndex = function(t3) {
      s2 = t3.type, a2 = t3.bytesPerElement;
    }, this.render = function(e3, n3) {
      t2.drawElements(o2, n3, s2, e3 * a2), i2.update(n3, o2, 1);
    }, this.renderInstances = function(n3, l2, h2) {
      if (h2 === 0)
        return;
      let u2, c2;
      if (r2)
        u2 = t2, c2 = "drawElementsInstanced";
      else if (u2 = e2.get("ANGLE_instanced_arrays"), c2 = "drawElementsInstancedANGLE", u2 === null)
        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      u2[c2](o2, l2, s2, n3 * a2, h2), i2.update(l2, o2, h2);
    };
  }
  function ui(t2) {
    const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
      e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
    }, update: function(t3, i2, n2) {
      switch (e2.calls++, i2) {
        case 4:
          e2.triangles += n2 * (t3 / 3);
          break;
        case 1:
          e2.lines += n2 * (t3 / 2);
          break;
        case 3:
          e2.lines += n2 * (t3 - 1);
          break;
        case 2:
          e2.lines += n2 * t3;
          break;
        case 0:
          e2.points += n2 * t3;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", i2);
      }
    } };
  }
  function ci(t2, e2) {
    return t2[0] - e2[0];
  }
  function di(t2, e2) {
    return Math.abs(e2[1]) - Math.abs(t2[1]);
  }
  function pi(t2) {
    const e2 = {}, i2 = new Float32Array(8), n2 = [];
    for (let t3 = 0; t3 < 8; t3++)
      n2[t3] = [t3, 0];
    return { update: function(r2, o2, s2, a2) {
      const l2 = r2.morphTargetInfluences, h2 = l2 === void 0 ? 0 : l2.length;
      let u2 = e2[o2.id];
      if (u2 === void 0 || u2.length !== h2) {
        u2 = [];
        for (let t3 = 0; t3 < h2; t3++)
          u2[t3] = [t3, 0];
        e2[o2.id] = u2;
      }
      for (let t3 = 0; t3 < h2; t3++) {
        const e3 = u2[t3];
        e3[0] = t3, e3[1] = l2[t3];
      }
      u2.sort(di);
      for (let t3 = 0; t3 < 8; t3++)
        t3 < h2 && u2[t3][1] ? (n2[t3][0] = u2[t3][0], n2[t3][1] = u2[t3][1]) : (n2[t3][0] = Number.MAX_SAFE_INTEGER, n2[t3][1] = 0);
      n2.sort(ci);
      const c2 = s2.morphTargets && o2.morphAttributes.position, d2 = s2.morphNormals && o2.morphAttributes.normal;
      let p2 = 0;
      for (let t3 = 0; t3 < 8; t3++) {
        const e3 = n2[t3], r3 = e3[0], s3 = e3[1];
        r3 !== Number.MAX_SAFE_INTEGER && s3 ? (c2 && o2.getAttribute("morphTarget" + t3) !== c2[r3] && o2.setAttribute("morphTarget" + t3, c2[r3]), d2 && o2.getAttribute("morphNormal" + t3) !== d2[r3] && o2.setAttribute("morphNormal" + t3, d2[r3]), i2[t3] = s3, p2 += s3) : (c2 && o2.hasAttribute("morphTarget" + t3) === true && o2.deleteAttribute("morphTarget" + t3), d2 && o2.hasAttribute("morphNormal" + t3) === true && o2.deleteAttribute("morphNormal" + t3), i2[t3] = 0);
      }
      const f2 = o2.morphTargetsRelative ? 1 : 1 - p2;
      a2.getUniforms().setValue(t2, "morphTargetBaseInfluence", f2), a2.getUniforms().setValue(t2, "morphTargetInfluences", i2);
    } };
  }
  function fi(t2, e2, i2, n2) {
    let r2 = /* @__PURE__ */ new WeakMap();
    function o2(t3) {
      const e3 = t3.target;
      e3.removeEventListener("dispose", o2), i2.remove(e3.instanceMatrix), e3.instanceColor !== null && i2.remove(e3.instanceColor);
    }
    return { update: function(t3) {
      const s2 = n2.render.frame, a2 = t3.geometry, l2 = e2.get(t3, a2);
      return r2.get(l2) !== s2 && (e2.update(l2), r2.set(l2, s2)), t3.isInstancedMesh && (t3.hasEventListener("dispose", o2) === false && t3.addEventListener("dispose", o2), i2.update(t3.instanceMatrix, 34962), t3.instanceColor !== null && i2.update(t3.instanceColor, 34962)), l2;
    }, dispose: function() {
      r2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  ti.physical = { uniforms: Le([ti.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new g(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Zt(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new g() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Zt(0) } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag };
  class mi extends b {
    constructor(t2 = null, e2 = 1, i2 = 1, n2 = 1) {
      super(null), this.image = { data: t2, width: e2, height: i2, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  mi.prototype.isDataTexture2DArray = true;
  class gi extends b {
    constructor(t2 = null, e2 = 1, i2 = 1, n2 = 1) {
      super(null), this.image = { data: t2, width: e2, height: i2, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  gi.prototype.isDataTexture3D = true;
  const vi = new b(), _i = new mi(), yi = new gi(), xi = new Ge(), bi = [], Ti = [], Ei = new Float32Array(16), Si = new Float32Array(9), wi = new Float32Array(4);
  function Ai(t2, e2, i2) {
    const n2 = t2[0];
    if (n2 <= 0 || n2 > 0)
      return t2;
    const r2 = e2 * i2;
    let o2 = bi[r2];
    if (o2 === void 0 && (o2 = new Float32Array(r2), bi[r2] = o2), e2 !== 0) {
      n2.toArray(o2, 0);
      for (let n3 = 1, r3 = 0; n3 !== e2; ++n3)
        r3 += i2, t2[n3].toArray(o2, r3);
    }
    return o2;
  }
  function Mi(t2, e2) {
    if (t2.length !== e2.length)
      return false;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
      if (t2[i2] !== e2[i2])
        return false;
    return true;
  }
  function Ri(t2, e2) {
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
      t2[i2] = e2[i2];
  }
  function Ci(t2, e2) {
    let i2 = Ti[e2];
    i2 === void 0 && (i2 = new Int32Array(e2), Ti[e2] = i2);
    for (let n2 = 0; n2 !== e2; ++n2)
      i2[n2] = t2.allocateTextureUnit();
    return i2;
  }
  function Ii(t2, e2) {
    const i2 = this.cache;
    i2[0] !== e2 && (t2.uniform1f(this.addr, e2), i2[0] = e2);
  }
  function Pi(t2, e2) {
    const i2 = this.cache;
    if (e2.x !== void 0)
      i2[0] === e2.x && i2[1] === e2.y || (t2.uniform2f(this.addr, e2.x, e2.y), i2[0] = e2.x, i2[1] = e2.y);
    else {
      if (Mi(i2, e2))
        return;
      t2.uniform2fv(this.addr, e2), Ri(i2, e2);
    }
  }
  function Oi(t2, e2) {
    const i2 = this.cache;
    if (e2.x !== void 0)
      i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z || (t2.uniform3f(this.addr, e2.x, e2.y, e2.z), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z);
    else if (e2.r !== void 0)
      i2[0] === e2.r && i2[1] === e2.g && i2[2] === e2.b || (t2.uniform3f(this.addr, e2.r, e2.g, e2.b), i2[0] = e2.r, i2[1] = e2.g, i2[2] = e2.b);
    else {
      if (Mi(i2, e2))
        return;
      t2.uniform3fv(this.addr, e2), Ri(i2, e2);
    }
  }
  function Ni(t2, e2) {
    const i2 = this.cache;
    if (e2.x !== void 0)
      i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z && i2[3] === e2.w || (t2.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z, i2[3] = e2.w);
    else {
      if (Mi(i2, e2))
        return;
      t2.uniform4fv(this.addr, e2), Ri(i2, e2);
    }
  }
  function Li(t2, e2) {
    const i2 = this.cache, n2 = e2.elements;
    if (n2 === void 0) {
      if (Mi(i2, e2))
        return;
      t2.uniformMatrix2fv(this.addr, false, e2), Ri(i2, e2);
    } else {
      if (Mi(i2, n2))
        return;
      wi.set(n2), t2.uniformMatrix2fv(this.addr, false, wi), Ri(i2, n2);
    }
  }
  function Di(t2, e2) {
    const i2 = this.cache, n2 = e2.elements;
    if (n2 === void 0) {
      if (Mi(i2, e2))
        return;
      t2.uniformMatrix3fv(this.addr, false, e2), Ri(i2, e2);
    } else {
      if (Mi(i2, n2))
        return;
      Si.set(n2), t2.uniformMatrix3fv(this.addr, false, Si), Ri(i2, n2);
    }
  }
  function Fi(t2, e2) {
    const i2 = this.cache, n2 = e2.elements;
    if (n2 === void 0) {
      if (Mi(i2, e2))
        return;
      t2.uniformMatrix4fv(this.addr, false, e2), Ri(i2, e2);
    } else {
      if (Mi(i2, n2))
        return;
      Ei.set(n2), t2.uniformMatrix4fv(this.addr, false, Ei), Ri(i2, n2);
    }
  }
  function Bi(t2, e2) {
    const i2 = this.cache;
    i2[0] !== e2 && (t2.uniform1i(this.addr, e2), i2[0] = e2);
  }
  function Ui(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform2iv(this.addr, e2), Ri(i2, e2));
  }
  function ki(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform3iv(this.addr, e2), Ri(i2, e2));
  }
  function Gi(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform4iv(this.addr, e2), Ri(i2, e2));
  }
  function Hi(t2, e2) {
    const i2 = this.cache;
    i2[0] !== e2 && (t2.uniform1ui(this.addr, e2), i2[0] = e2);
  }
  function ji(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform2uiv(this.addr, e2), Ri(i2, e2));
  }
  function zi(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform3uiv(this.addr, e2), Ri(i2, e2));
  }
  function Vi(t2, e2) {
    const i2 = this.cache;
    Mi(i2, e2) || (t2.uniform4uiv(this.addr, e2), Ri(i2, e2));
  }
  function Xi(t2, e2, i2) {
    const n2 = this.cache, r2 = i2.allocateTextureUnit();
    n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.safeSetTexture2D(e2 || vi, r2);
  }
  function Wi(t2, e2, i2) {
    const n2 = this.cache, r2 = i2.allocateTextureUnit();
    n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture3D(e2 || yi, r2);
  }
  function Yi(t2, e2, i2) {
    const n2 = this.cache, r2 = i2.allocateTextureUnit();
    n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.safeSetTextureCube(e2 || xi, r2);
  }
  function qi(t2, e2, i2) {
    const n2 = this.cache, r2 = i2.allocateTextureUnit();
    n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2DArray(e2 || _i, r2);
  }
  function Zi(t2, e2) {
    t2.uniform1fv(this.addr, e2);
  }
  function Ji(t2, e2) {
    const i2 = Ai(e2, this.size, 2);
    t2.uniform2fv(this.addr, i2);
  }
  function Ki(t2, e2) {
    const i2 = Ai(e2, this.size, 3);
    t2.uniform3fv(this.addr, i2);
  }
  function Qi(t2, e2) {
    const i2 = Ai(e2, this.size, 4);
    t2.uniform4fv(this.addr, i2);
  }
  function $i(t2, e2) {
    const i2 = Ai(e2, this.size, 4);
    t2.uniformMatrix2fv(this.addr, false, i2);
  }
  function tn(t2, e2) {
    const i2 = Ai(e2, this.size, 9);
    t2.uniformMatrix3fv(this.addr, false, i2);
  }
  function en(t2, e2) {
    const i2 = Ai(e2, this.size, 16);
    t2.uniformMatrix4fv(this.addr, false, i2);
  }
  function nn(t2, e2) {
    t2.uniform1iv(this.addr, e2);
  }
  function rn(t2, e2) {
    t2.uniform2iv(this.addr, e2);
  }
  function on(t2, e2) {
    t2.uniform3iv(this.addr, e2);
  }
  function sn(t2, e2) {
    t2.uniform4iv(this.addr, e2);
  }
  function an(t2, e2) {
    t2.uniform1uiv(this.addr, e2);
  }
  function ln(t2, e2) {
    t2.uniform2uiv(this.addr, e2);
  }
  function hn(t2, e2) {
    t2.uniform3uiv(this.addr, e2);
  }
  function un(t2, e2) {
    t2.uniform4uiv(this.addr, e2);
  }
  function cn(t2, e2, i2) {
    const n2 = e2.length, r2 = Ci(i2, n2);
    t2.uniform1iv(this.addr, r2);
    for (let t3 = 0; t3 !== n2; ++t3)
      i2.safeSetTexture2D(e2[t3] || vi, r2[t3]);
  }
  function dn(t2, e2, i2) {
    const n2 = e2.length, r2 = Ci(i2, n2);
    t2.uniform1iv(this.addr, r2);
    for (let t3 = 0; t3 !== n2; ++t3)
      i2.safeSetTextureCube(e2[t3] || xi, r2[t3]);
  }
  function pn(t2, e2, i2) {
    this.id = t2, this.addr = i2, this.cache = [], this.setValue = function(t3) {
      switch (t3) {
        case 5126:
          return Ii;
        case 35664:
          return Pi;
        case 35665:
          return Oi;
        case 35666:
          return Ni;
        case 35674:
          return Li;
        case 35675:
          return Di;
        case 35676:
          return Fi;
        case 5124:
        case 35670:
          return Bi;
        case 35667:
        case 35671:
          return Ui;
        case 35668:
        case 35672:
          return ki;
        case 35669:
        case 35673:
          return Gi;
        case 5125:
          return Hi;
        case 36294:
          return ji;
        case 36295:
          return zi;
        case 36296:
          return Vi;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Xi;
        case 35679:
        case 36299:
        case 36307:
          return Wi;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Yi;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return qi;
      }
    }(e2.type);
  }
  function fn(t2, e2, i2) {
    this.id = t2, this.addr = i2, this.cache = [], this.size = e2.size, this.setValue = function(t3) {
      switch (t3) {
        case 5126:
          return Zi;
        case 35664:
          return Ji;
        case 35665:
          return Ki;
        case 35666:
          return Qi;
        case 35674:
          return $i;
        case 35675:
          return tn;
        case 35676:
          return en;
        case 5124:
        case 35670:
          return nn;
        case 35667:
        case 35671:
          return rn;
        case 35668:
        case 35672:
          return on;
        case 35669:
        case 35673:
          return sn;
        case 5125:
          return an;
        case 36294:
          return ln;
        case 36295:
          return hn;
        case 36296:
          return un;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return cn;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return dn;
      }
    }(e2.type);
  }
  function mn(t2) {
    this.id = t2, this.seq = [], this.map = {};
  }
  fn.prototype.updateCache = function(t2) {
    const e2 = this.cache;
    t2 instanceof Float32Array && e2.length !== t2.length && (this.cache = new Float32Array(t2.length)), Ri(e2, t2);
  }, mn.prototype.setValue = function(t2, e2, i2) {
    const n2 = this.seq;
    for (let r2 = 0, o2 = n2.length; r2 !== o2; ++r2) {
      const o3 = n2[r2];
      o3.setValue(t2, e2[o3.id], i2);
    }
  };
  const gn = /(\w+)(\])?(\[|\.)?/g;
  function vn(t2, e2) {
    t2.seq.push(e2), t2.map[e2.id] = e2;
  }
  function _n(t2, e2, i2) {
    const n2 = t2.name, r2 = n2.length;
    for (gn.lastIndex = 0; ; ) {
      const o2 = gn.exec(n2), s2 = gn.lastIndex;
      let a2 = o2[1];
      const l2 = o2[2] === "]", h2 = o2[3];
      if (l2 && (a2 |= 0), h2 === void 0 || h2 === "[" && s2 + 2 === r2) {
        vn(i2, h2 === void 0 ? new pn(a2, t2, e2) : new fn(a2, t2, e2));
        break;
      }
      {
        let t3 = i2.map[a2];
        t3 === void 0 && (t3 = new mn(a2), vn(i2, t3)), i2 = t3;
      }
    }
  }
  function yn(t2, e2) {
    this.seq = [], this.map = {};
    const i2 = t2.getProgramParameter(e2, 35718);
    for (let n2 = 0; n2 < i2; ++n2) {
      const i3 = t2.getActiveUniform(e2, n2);
      _n(i3, t2.getUniformLocation(e2, i3.name), this);
    }
  }
  function xn(t2, e2, i2) {
    const n2 = t2.createShader(e2);
    return t2.shaderSource(n2, i2), t2.compileShader(n2), n2;
  }
  yn.prototype.setValue = function(t2, e2, i2, n2) {
    const r2 = this.map[e2];
    r2 !== void 0 && r2.setValue(t2, i2, n2);
  }, yn.prototype.setOptional = function(t2, e2, i2) {
    const n2 = e2[i2];
    n2 !== void 0 && this.setValue(t2, i2, n2);
  }, yn.upload = function(t2, e2, i2, n2) {
    for (let r2 = 0, o2 = e2.length; r2 !== o2; ++r2) {
      const o3 = e2[r2], s2 = i2[o3.id];
      s2.needsUpdate !== false && o3.setValue(t2, s2.value, n2);
    }
  }, yn.seqWithValue = function(t2, e2) {
    const i2 = [];
    for (let n2 = 0, r2 = t2.length; n2 !== r2; ++n2) {
      const r3 = t2[n2];
      r3.id in e2 && i2.push(r3);
    }
    return i2;
  };
  let bn = 0;
  function Tn(t2) {
    switch (t2) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t2), ["Linear", "( value )"];
    }
  }
  function En(t2, e2, i2) {
    const n2 = t2.getShaderParameter(e2, 35713), r2 = t2.getShaderInfoLog(e2).trim();
    if (n2 && r2 === "")
      return "";
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + i2 + "\n" + r2 + function(t3) {
      const e3 = t3.split("\n");
      for (let t4 = 0; t4 < e3.length; t4++)
        e3[t4] = t4 + 1 + ": " + e3[t4];
      return e3.join("\n");
    }(t2.getShaderSource(e2));
  }
  function Sn(t2, e2) {
    const i2 = Tn(e2);
    return "vec4 " + t2 + "( vec4 value ) { return " + i2[0] + "ToLinear" + i2[1] + "; }";
  }
  function wn(t2, e2) {
    const i2 = Tn(e2);
    return "vec4 " + t2 + "( vec4 value ) { return LinearTo" + i2[0] + i2[1] + "; }";
  }
  function An(t2, e2) {
    let i2;
    switch (e2) {
      case 1:
        i2 = "Linear";
        break;
      case 2:
        i2 = "Reinhard";
        break;
      case 3:
        i2 = "OptimizedCineon";
        break;
      case 4:
        i2 = "ACESFilmic";
        break;
      case 5:
        i2 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), i2 = "Linear";
    }
    return "vec3 " + t2 + "( vec3 color ) { return " + i2 + "ToneMapping( color ); }";
  }
  function Mn(t2) {
    return t2 !== "";
  }
  function Rn(t2, e2) {
    return t2.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
  }
  function Cn(t2, e2) {
    return t2.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
  }
  const In = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Pn(t2) {
    return t2.replace(In, On);
  }
  function On(t2, e2) {
    const i2 = Qe[e2];
    if (i2 === void 0)
      throw new Error("Can not resolve #include <" + e2 + ">");
    return Pn(i2);
  }
  const Nn = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Ln = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Dn(t2) {
    return t2.replace(Ln, Bn).replace(Nn, Fn);
  }
  function Fn(t2, e2, i2, n2) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Bn(t2, e2, i2, n2);
  }
  function Bn(t2, e2, i2, n2) {
    let r2 = "";
    for (let t3 = parseInt(e2); t3 < parseInt(i2); t3++)
      r2 += n2.replace(/\[\s*i\s*\]/g, "[ " + t3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t3);
    return r2;
  }
  function Un(t2) {
    let e2 = "precision " + t2.precision + " float;\nprecision " + t2.precision + " int;";
    return t2.precision === "highp" ? e2 += "\n#define HIGH_PRECISION" : t2.precision === "mediump" ? e2 += "\n#define MEDIUM_PRECISION" : t2.precision === "lowp" && (e2 += "\n#define LOW_PRECISION"), e2;
  }
  function kn(t2, e2, i2, n2) {
    const r2 = t2.getContext(), o2 = i2.defines;
    let s2 = i2.vertexShader, a2 = i2.fragmentShader;
    const l2 = function(t3) {
      let e3 = "SHADOWMAP_TYPE_BASIC";
      return t3.shadowMapType === 1 ? e3 = "SHADOWMAP_TYPE_PCF" : t3.shadowMapType === 2 ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : t3.shadowMapType === 3 && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
    }(i2), h2 = function(t3) {
      let e3 = "ENVMAP_TYPE_CUBE";
      if (t3.envMap)
        switch (t3.envMapMode) {
          case 301:
          case 302:
            e3 = "ENVMAP_TYPE_CUBE";
            break;
          case 306:
          case 307:
            e3 = "ENVMAP_TYPE_CUBE_UV";
        }
      return e3;
    }(i2), u2 = function(t3) {
      let e3 = "ENVMAP_MODE_REFLECTION";
      if (t3.envMap)
        switch (t3.envMapMode) {
          case 302:
          case 307:
            e3 = "ENVMAP_MODE_REFRACTION";
        }
      return e3;
    }(i2), c2 = function(t3) {
      let e3 = "ENVMAP_BLENDING_NONE";
      if (t3.envMap)
        switch (t3.combine) {
          case 0:
            e3 = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            e3 = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            e3 = "ENVMAP_BLENDING_ADD";
        }
      return e3;
    }(i2), d2 = t2.gammaFactor > 0 ? t2.gammaFactor : 1, p2 = i2.isWebGL2 ? "" : function(t3) {
      return [t3.extensionDerivatives || t3.envMapCubeUV || t3.bumpMap || t3.tangentSpaceNormalMap || t3.clearcoatNormalMap || t3.flatShading || t3.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t3.extensionFragDepth || t3.logarithmicDepthBuffer) && t3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t3.extensionDrawBuffers && t3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t3.extensionShaderTextureLOD || t3.envMap || t3.transmission > 0) && t3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mn).join("\n");
    }(i2), f2 = function(t3) {
      const e3 = [];
      for (const i3 in t3) {
        const n3 = t3[i3];
        n3 !== false && e3.push("#define " + i3 + " " + n3);
      }
      return e3.join("\n");
    }(o2), m2 = r2.createProgram();
    let g2, v2, _2 = i2.glslVersion ? "#version " + i2.glslVersion + "\n" : "";
    i2.isRawShaderMaterial ? (g2 = [f2].filter(Mn).join("\n"), g2.length > 0 && (g2 += "\n"), v2 = [p2, f2].filter(Mn).join("\n"), v2.length > 0 && (v2 += "\n")) : (g2 = [Un(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.instancing ? "#define USE_INSTANCING" : "", i2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d2, "#define MAX_BONES " + i2.maxBones, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + u2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.displacementMap && i2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.skinning ? "#define USE_SKINNING" : "", i2.useVertexTexture ? "#define BONE_TEXTURE" : "", i2.morphTargets ? "#define USE_MORPHTARGETS" : "", i2.morphNormals && i2.flatShading === false ? "#define USE_MORPHNORMALS" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Mn).join("\n"), v2 = [p2, Un(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.alphaTest ? "#define ALPHATEST " + i2.alphaTest + (i2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d2, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.matcap ? "#define USE_MATCAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + h2 : "", i2.envMap ? "#define " + u2 : "", i2.envMap ? "#define " + c2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.sheen ? "#define USE_SHEEN" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors || i2.instancingColor ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.gradientMap ? "#define USE_GRADIENTMAP" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i2.extensionShaderTextureLOD || i2.envMap) && i2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i2.toneMapping !== 0 ? "#define TONE_MAPPING" : "", i2.toneMapping !== 0 ? Qe.tonemapping_pars_fragment : "", i2.toneMapping !== 0 ? An("toneMapping", i2.toneMapping) : "", i2.dithering ? "#define DITHERING" : "", Qe.encodings_pars_fragment, i2.map ? Sn("mapTexelToLinear", i2.mapEncoding) : "", i2.matcap ? Sn("matcapTexelToLinear", i2.matcapEncoding) : "", i2.envMap ? Sn("envMapTexelToLinear", i2.envMapEncoding) : "", i2.emissiveMap ? Sn("emissiveMapTexelToLinear", i2.emissiveMapEncoding) : "", i2.lightMap ? Sn("lightMapTexelToLinear", i2.lightMapEncoding) : "", wn("linearToOutputTexel", i2.outputEncoding), i2.depthPacking ? "#define DEPTH_PACKING " + i2.depthPacking : "", "\n"].filter(Mn).join("\n")), s2 = Pn(s2), s2 = Rn(s2, i2), s2 = Cn(s2, i2), a2 = Pn(a2), a2 = Rn(a2, i2), a2 = Cn(a2, i2), s2 = Dn(s2), a2 = Dn(a2), i2.isWebGL2 && i2.isRawShaderMaterial !== true && (_2 = "#version 300 es\n", g2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, v2 = ["#define varying in", i2.glslVersion === "300 es" ? "" : "out highp vec4 pc_fragColor;", i2.glslVersion === "300 es" ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v2);
    const y2 = _2 + v2 + a2, x2 = xn(r2, 35633, _2 + g2 + s2), b2 = xn(r2, 35632, y2);
    if (r2.attachShader(m2, x2), r2.attachShader(m2, b2), i2.index0AttributeName !== void 0 ? r2.bindAttribLocation(m2, 0, i2.index0AttributeName) : i2.morphTargets === true && r2.bindAttribLocation(m2, 0, "position"), r2.linkProgram(m2), t2.debug.checkShaderErrors) {
      const t3 = r2.getProgramInfoLog(m2).trim(), e3 = r2.getShaderInfoLog(x2).trim(), i3 = r2.getShaderInfoLog(b2).trim();
      let n3 = true, o3 = true;
      if (r2.getProgramParameter(m2, 35714) === false) {
        n3 = false;
        const e4 = En(r2, x2, "vertex"), i4 = En(r2, b2, "fragment");
        console.error("THREE.WebGLProgram: shader error: ", r2.getError(), "35715", r2.getProgramParameter(m2, 35715), "gl.getProgramInfoLog", t3, e4, i4);
      } else
        t3 !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t3) : e3 !== "" && i3 !== "" || (o3 = false);
      o3 && (this.diagnostics = { runnable: n3, programLog: t3, vertexShader: { log: e3, prefix: g2 }, fragmentShader: { log: i3, prefix: v2 } });
    }
    let T2, E2;
    return r2.deleteShader(x2), r2.deleteShader(b2), this.getUniforms = function() {
      return T2 === void 0 && (T2 = new yn(r2, m2)), T2;
    }, this.getAttributes = function() {
      return E2 === void 0 && (E2 = function(t3, e3) {
        const i3 = {}, n3 = t3.getProgramParameter(e3, 35721);
        for (let r3 = 0; r3 < n3; r3++) {
          const n4 = t3.getActiveAttrib(e3, r3).name;
          i3[n4] = t3.getAttribLocation(e3, n4);
        }
        return i3;
      }(r2, m2)), E2;
    }, this.destroy = function() {
      n2.releaseStatesOfProgram(this), r2.deleteProgram(m2), this.program = void 0;
    }, this.name = i2.shaderName, this.id = bn++, this.cacheKey = e2, this.usedTimes = 1, this.program = m2, this.vertexShader = x2, this.fragmentShader = b2, this;
  }
  function Gn(t2, e2, i2, n2, r2, o2) {
    const s2 = [], a2 = n2.isWebGL2, l2 = n2.logarithmicDepthBuffer, h2 = n2.floatVertexTextures, u2 = n2.maxVertexUniforms, c2 = n2.vertexTextures;
    let d2 = n2.precision;
    const p2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];
    function m2(t3) {
      let e3;
      return t3 && t3.isTexture ? e3 = t3.encoding : t3 && t3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e3 = t3.texture.encoding) : e3 = 3e3, e3;
    }
    return { getParameters: function(r3, s3, f3, g2, v2) {
      const _2 = g2.fog, y2 = r3.isMeshStandardMaterial ? g2.environment : null, x2 = e2.get(r3.envMap || y2), b2 = p2[r3.type], T2 = v2.isSkinnedMesh ? function(t3) {
        const e3 = t3.skeleton.bones;
        if (h2)
          return 1024;
        {
          const t4 = u2, i3 = Math.floor((t4 - 20) / 4), n3 = Math.min(i3, e3.length);
          return n3 < e3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e3.length + " bones. This GPU supports " + n3 + "."), 0) : n3;
        }
      }(v2) : 0;
      let E2, S2;
      if (r3.precision !== null && (d2 = n2.getMaxPrecision(r3.precision), d2 !== r3.precision && console.warn("THREE.WebGLProgram.getParameters:", r3.precision, "not supported, using", d2, "instead.")), b2) {
        const t3 = ti[b2];
        E2 = t3.vertexShader, S2 = t3.fragmentShader;
      } else
        E2 = r3.vertexShader, S2 = r3.fragmentShader;
      const w2 = t2.getRenderTarget();
      return { isWebGL2: a2, shaderID: b2, shaderName: r3.type, vertexShader: E2, fragmentShader: S2, defines: r3.defines, isRawShaderMaterial: r3.isRawShaderMaterial === true, glslVersion: r3.glslVersion, precision: d2, instancing: v2.isInstancedMesh === true, instancingColor: v2.isInstancedMesh === true && v2.instanceColor !== null, supportsVertexTextures: c2, outputEncoding: w2 !== null ? m2(w2.texture) : t2.outputEncoding, map: !!r3.map, mapEncoding: m2(r3.map), matcap: !!r3.matcap, matcapEncoding: m2(r3.matcap), envMap: !!x2, envMapMode: x2 && x2.mapping, envMapEncoding: m2(x2), envMapCubeUV: !!x2 && (x2.mapping === 306 || x2.mapping === 307), lightMap: !!r3.lightMap, lightMapEncoding: m2(r3.lightMap), aoMap: !!r3.aoMap, emissiveMap: !!r3.emissiveMap, emissiveMapEncoding: m2(r3.emissiveMap), bumpMap: !!r3.bumpMap, normalMap: !!r3.normalMap, objectSpaceNormalMap: r3.normalMapType === 1, tangentSpaceNormalMap: r3.normalMapType === 0, clearcoatMap: !!r3.clearcoatMap, clearcoatRoughnessMap: !!r3.clearcoatRoughnessMap, clearcoatNormalMap: !!r3.clearcoatNormalMap, displacementMap: !!r3.displacementMap, roughnessMap: !!r3.roughnessMap, metalnessMap: !!r3.metalnessMap, specularMap: !!r3.specularMap, alphaMap: !!r3.alphaMap, gradientMap: !!r3.gradientMap, sheen: !!r3.sheen, transmission: !!r3.transmission, transmissionMap: !!r3.transmissionMap, thicknessMap: !!r3.thicknessMap, combine: r3.combine, vertexTangents: r3.normalMap && r3.vertexTangents, vertexColors: r3.vertexColors, vertexAlphas: r3.vertexColors === true && v2.geometry && v2.geometry.attributes.color && v2.geometry.attributes.color.itemSize === 4, vertexUvs: !!(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatMap || r3.clearcoatRoughnessMap || r3.clearcoatNormalMap || r3.displacementMap || r3.transmissionMap || r3.thicknessMap), uvsVertexOnly: !(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatNormalMap || r3.transmission || r3.transmissionMap || r3.thicknessMap || !r3.displacementMap), fog: !!_2, useFog: r3.fog, fogExp2: _2 && _2.isFogExp2, flatShading: !!r3.flatShading, sizeAttenuation: r3.sizeAttenuation, logarithmicDepthBuffer: l2, skinning: v2.isSkinnedMesh === true && T2 > 0, maxBones: T2, useVertexTexture: h2, morphTargets: r3.morphTargets, morphNormals: r3.morphNormals, numDirLights: s3.directional.length, numPointLights: s3.point.length, numSpotLights: s3.spot.length, numRectAreaLights: s3.rectArea.length, numHemiLights: s3.hemi.length, numDirLightShadows: s3.directionalShadowMap.length, numPointLightShadows: s3.pointShadowMap.length, numSpotLightShadows: s3.spotShadowMap.length, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: r3.dithering, shadowMapEnabled: t2.shadowMap.enabled && f3.length > 0, shadowMapType: t2.shadowMap.type, toneMapping: r3.toneMapped ? t2.toneMapping : 0, physicallyCorrectLights: t2.physicallyCorrectLights, premultipliedAlpha: r3.premultipliedAlpha, alphaTest: r3.alphaTest, doubleSided: r3.side === 2, flipSided: r3.side === 1, depthPacking: r3.depthPacking !== void 0 && r3.depthPacking, index0AttributeName: r3.index0AttributeName, extensionDerivatives: r3.extensions && r3.extensions.derivatives, extensionFragDepth: r3.extensions && r3.extensions.fragDepth, extensionDrawBuffers: r3.extensions && r3.extensions.drawBuffers, extensionShaderTextureLOD: r3.extensions && r3.extensions.shaderTextureLOD, rendererExtensionFragDepth: a2 || i2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a2 || i2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a2 || i2.has("EXT_shader_texture_lod"), customProgramCacheKey: r3.customProgramCacheKey() };
    }, getProgramCacheKey: function(e3) {
      const i3 = [];
      if (e3.shaderID ? i3.push(e3.shaderID) : (i3.push(e3.fragmentShader), i3.push(e3.vertexShader)), e3.defines !== void 0)
        for (const t3 in e3.defines)
          i3.push(t3), i3.push(e3.defines[t3]);
      if (e3.isRawShaderMaterial === false) {
        for (let t3 = 0; t3 < f2.length; t3++)
          i3.push(e3[f2[t3]]);
        i3.push(t2.outputEncoding), i3.push(t2.gammaFactor);
      }
      return i3.push(e3.customProgramCacheKey), i3.join();
    }, getUniforms: function(t3) {
      const e3 = p2[t3.type];
      let i3;
      if (e3) {
        const t4 = ti[e3];
        i3 = De.clone(t4.uniforms);
      } else
        i3 = t3.uniforms;
      return i3;
    }, acquireProgram: function(e3, i3) {
      let n3;
      for (let t3 = 0, e4 = s2.length; t3 < e4; t3++) {
        const e5 = s2[t3];
        if (e5.cacheKey === i3) {
          n3 = e5, ++n3.usedTimes;
          break;
        }
      }
      return n3 === void 0 && (n3 = new kn(t2, i3, e3, r2), s2.push(n3)), n3;
    }, releaseProgram: function(t3) {
      if (--t3.usedTimes == 0) {
        const e3 = s2.indexOf(t3);
        s2[e3] = s2[s2.length - 1], s2.pop(), t3.destroy();
      }
    }, programs: s2 };
  }
  function Hn() {
    let t2 = /* @__PURE__ */ new WeakMap();
    return { get: function(e2) {
      let i2 = t2.get(e2);
      return i2 === void 0 && (i2 = {}, t2.set(e2, i2)), i2;
    }, remove: function(e2) {
      t2.delete(e2);
    }, update: function(e2, i2, n2) {
      t2.get(e2)[i2] = n2;
    }, dispose: function() {
      t2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function jn(t2, e2) {
    return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program !== e2.program ? t2.program.id - e2.program.id : t2.material.id !== e2.material.id ? t2.material.id - e2.material.id : t2.z !== e2.z ? t2.z - e2.z : t2.id - e2.id;
  }
  function zn(t2, e2) {
    return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.z !== e2.z ? e2.z - t2.z : t2.id - e2.id;
  }
  function Vn(t2) {
    const e2 = [];
    let i2 = 0;
    const n2 = [], r2 = [], o2 = [], s2 = { id: -1 };
    function a2(n3, r3, o3, a3, l2, h2) {
      let u2 = e2[i2];
      const c2 = t2.get(o3);
      return u2 === void 0 ? (u2 = { id: n3.id, object: n3, geometry: r3, material: o3, program: c2.program || s2, groupOrder: a3, renderOrder: n3.renderOrder, z: l2, group: h2 }, e2[i2] = u2) : (u2.id = n3.id, u2.object = n3, u2.geometry = r3, u2.material = o3, u2.program = c2.program || s2, u2.groupOrder = a3, u2.renderOrder = n3.renderOrder, u2.z = l2, u2.group = h2), i2++, u2;
    }
    return { opaque: n2, transmissive: r2, transparent: o2, init: function() {
      i2 = 0, n2.length = 0, r2.length = 0, o2.length = 0;
    }, push: function(t3, e3, i3, s3, l2, h2) {
      const u2 = a2(t3, e3, i3, s3, l2, h2);
      i3.transmission > 0 ? r2.push(u2) : i3.transparent === true ? o2.push(u2) : n2.push(u2);
    }, unshift: function(t3, e3, i3, s3, l2, h2) {
      const u2 = a2(t3, e3, i3, s3, l2, h2);
      i3.transmission > 0 ? r2.unshift(u2) : i3.transparent === true ? o2.unshift(u2) : n2.unshift(u2);
    }, finish: function() {
      for (let t3 = i2, n3 = e2.length; t3 < n3; t3++) {
        const i3 = e2[t3];
        if (i3.id === null)
          break;
        i3.id = null, i3.object = null, i3.geometry = null, i3.material = null, i3.program = null, i3.group = null;
      }
    }, sort: function(t3, e3) {
      n2.length > 1 && n2.sort(t3 || jn), r2.length > 1 && r2.sort(e3 || zn), o2.length > 1 && o2.sort(e3 || zn);
    } };
  }
  function Xn(t2) {
    let e2 = /* @__PURE__ */ new WeakMap();
    return { get: function(i2, n2) {
      let r2;
      return e2.has(i2) === false ? (r2 = new Vn(t2), e2.set(i2, [r2])) : n2 >= e2.get(i2).length ? (r2 = new Vn(t2), e2.get(i2).push(r2)) : r2 = e2.get(i2)[n2], r2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function Wn() {
    const t2 = {};
    return { get: function(e2) {
      if (t2[e2.id] !== void 0)
        return t2[e2.id];
      let i2;
      switch (e2.type) {
        case "DirectionalLight":
          i2 = { direction: new M(), color: new Zt() };
          break;
        case "SpotLight":
          i2 = { position: new M(), direction: new M(), color: new Zt(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          i2 = { position: new M(), color: new Zt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          i2 = { direction: new M(), skyColor: new Zt(), groundColor: new Zt() };
          break;
        case "RectAreaLight":
          i2 = { color: new Zt(), position: new M(), halfWidth: new M(), halfHeight: new M() };
      }
      return t2[e2.id] = i2, i2;
    } };
  }
  let Yn = 0;
  function qn(t2, e2) {
    return (e2.castShadow ? 1 : 0) - (t2.castShadow ? 1 : 0);
  }
  function Zn(t2, e2) {
    const i2 = new Wn(), n2 = function() {
      const t3 = {};
      return { get: function(e3) {
        if (t3[e3.id] !== void 0)
          return t3[e3.id];
        let i3;
        switch (e3.type) {
          case "DirectionalLight":
          case "SpotLight":
            i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g() };
            break;
          case "PointLight":
            i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        }
        return t3[e3.id] = i3, i3;
      } };
    }(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
    for (let t3 = 0; t3 < 9; t3++)
      r2.probe.push(new M());
    const o2 = new M(), s2 = new rt(), a2 = new rt();
    return { setup: function(o3) {
      let s3 = 0, a3 = 0, l2 = 0;
      for (let t3 = 0; t3 < 9; t3++)
        r2.probe[t3].set(0, 0, 0);
      let h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0;
      o3.sort(qn);
      for (let t3 = 0, e3 = o3.length; t3 < e3; t3++) {
        const e4 = o3[t3], v3 = e4.color, _2 = e4.intensity, y2 = e4.distance, x2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
        if (e4.isAmbientLight)
          s3 += v3.r * _2, a3 += v3.g * _2, l2 += v3.b * _2;
        else if (e4.isLightProbe)
          for (let t4 = 0; t4 < 9; t4++)
            r2.probe[t4].addScaledVector(e4.sh.coefficients[t4], _2);
        else if (e4.isDirectionalLight) {
          const t4 = i2.get(e4);
          if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), e4.castShadow) {
            const t5 = e4.shadow, i3 = n2.get(e4);
            i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, r2.directionalShadow[h2] = i3, r2.directionalShadowMap[h2] = x2, r2.directionalShadowMatrix[h2] = e4.shadow.matrix, f2++;
          }
          r2.directional[h2] = t4, h2++;
        } else if (e4.isSpotLight) {
          const t4 = i2.get(e4);
          if (t4.position.setFromMatrixPosition(e4.matrixWorld), t4.color.copy(v3).multiplyScalar(_2), t4.distance = y2, t4.coneCos = Math.cos(e4.angle), t4.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t4.decay = e4.decay, e4.castShadow) {
            const t5 = e4.shadow, i3 = n2.get(e4);
            i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, r2.spotShadow[c2] = i3, r2.spotShadowMap[c2] = x2, r2.spotShadowMatrix[c2] = e4.shadow.matrix, g2++;
          }
          r2.spot[c2] = t4, c2++;
        } else if (e4.isRectAreaLight) {
          const t4 = i2.get(e4);
          t4.color.copy(v3).multiplyScalar(_2), t4.halfWidth.set(0.5 * e4.width, 0, 0), t4.halfHeight.set(0, 0.5 * e4.height, 0), r2.rectArea[d2] = t4, d2++;
        } else if (e4.isPointLight) {
          const t4 = i2.get(e4);
          if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), t4.distance = e4.distance, t4.decay = e4.decay, e4.castShadow) {
            const t5 = e4.shadow, i3 = n2.get(e4);
            i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, i3.shadowCameraNear = t5.camera.near, i3.shadowCameraFar = t5.camera.far, r2.pointShadow[u2] = i3, r2.pointShadowMap[u2] = x2, r2.pointShadowMatrix[u2] = e4.shadow.matrix, m2++;
          }
          r2.point[u2] = t4, u2++;
        } else if (e4.isHemisphereLight) {
          const t4 = i2.get(e4);
          t4.skyColor.copy(e4.color).multiplyScalar(_2), t4.groundColor.copy(e4.groundColor).multiplyScalar(_2), r2.hemi[p2] = t4, p2++;
        }
      }
      d2 > 0 && (e2.isWebGL2 || t2.has("OES_texture_float_linear") === true ? (r2.rectAreaLTC1 = $e.LTC_FLOAT_1, r2.rectAreaLTC2 = $e.LTC_FLOAT_2) : t2.has("OES_texture_half_float_linear") === true ? (r2.rectAreaLTC1 = $e.LTC_HALF_1, r2.rectAreaLTC2 = $e.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = s3, r2.ambient[1] = a3, r2.ambient[2] = l2;
      const v2 = r2.hash;
      v2.directionalLength === h2 && v2.pointLength === u2 && v2.spotLength === c2 && v2.rectAreaLength === d2 && v2.hemiLength === p2 && v2.numDirectionalShadows === f2 && v2.numPointShadows === m2 && v2.numSpotShadows === g2 || (r2.directional.length = h2, r2.spot.length = c2, r2.rectArea.length = d2, r2.point.length = u2, r2.hemi.length = p2, r2.directionalShadow.length = f2, r2.directionalShadowMap.length = f2, r2.pointShadow.length = m2, r2.pointShadowMap.length = m2, r2.spotShadow.length = g2, r2.spotShadowMap.length = g2, r2.directionalShadowMatrix.length = f2, r2.pointShadowMatrix.length = m2, r2.spotShadowMatrix.length = g2, v2.directionalLength = h2, v2.pointLength = u2, v2.spotLength = c2, v2.rectAreaLength = d2, v2.hemiLength = p2, v2.numDirectionalShadows = f2, v2.numPointShadows = m2, v2.numSpotShadows = g2, r2.version = Yn++);
    }, setupView: function(t3, e3) {
      let i3 = 0, n3 = 0, l2 = 0, h2 = 0, u2 = 0;
      const c2 = e3.matrixWorldInverse;
      for (let e4 = 0, d2 = t3.length; e4 < d2; e4++) {
        const d3 = t3[e4];
        if (d3.isDirectionalLight) {
          const t4 = r2.directional[i3];
          t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(c2), i3++;
        } else if (d3.isSpotLight) {
          const t4 = r2.spot[l2];
          t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(c2), l2++;
        } else if (d3.isRectAreaLight) {
          const t4 = r2.rectArea[h2];
          t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), a2.identity(), s2.copy(d3.matrixWorld), s2.premultiply(c2), a2.extractRotation(s2), t4.halfWidth.set(0.5 * d3.width, 0, 0), t4.halfHeight.set(0, 0.5 * d3.height, 0), t4.halfWidth.applyMatrix4(a2), t4.halfHeight.applyMatrix4(a2), h2++;
        } else if (d3.isPointLight) {
          const t4 = r2.point[n3];
          t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), n3++;
        } else if (d3.isHemisphereLight) {
          const t4 = r2.hemi[u2];
          t4.direction.setFromMatrixPosition(d3.matrixWorld), t4.direction.transformDirection(c2), t4.direction.normalize(), u2++;
        }
      }
    }, state: r2 };
  }
  function Jn(t2, e2) {
    const i2 = new Zn(t2, e2), n2 = [], r2 = [];
    return { init: function() {
      n2.length = 0, r2.length = 0;
    }, state: { lightsArray: n2, shadowsArray: r2, lights: i2 }, setupLights: function() {
      i2.setup(n2);
    }, setupLightsView: function(t3) {
      i2.setupView(n2, t3);
    }, pushLight: function(t3) {
      n2.push(t3);
    }, pushShadow: function(t3) {
      r2.push(t3);
    } };
  }
  function Kn(t2, e2) {
    let i2 = /* @__PURE__ */ new WeakMap();
    return { get: function(n2, r2 = 0) {
      let o2;
      return i2.has(n2) === false ? (o2 = new Jn(t2, e2), i2.set(n2, [o2])) : r2 >= i2.get(n2).length ? (o2 = new Jn(t2, e2), i2.get(n2).push(o2)) : o2 = i2.get(n2)[r2], o2;
    }, dispose: function() {
      i2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  class Qn extends jt {
    constructor(t2) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.depthPacking = t2.depthPacking, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this;
    }
  }
  Qn.prototype.isMeshDepthMaterial = true;
  class $n extends jt {
    constructor(t2) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new M(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.referencePosition.copy(t2.referencePosition), this.nearDistance = t2.nearDistance, this.farDistance = t2.farDistance, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this;
    }
  }
  $n.prototype.isMeshDistanceMaterial = true;
  function tr(t2, e2, i2) {
    let n2 = new qe();
    const r2 = new g(), o2 = new g(), s2 = new E(), a2 = [], l2 = [], h2 = {}, u2 = i2.maxTextureSize, c2 = { 0: 1, 1: 0, 2: 2 }, d2 = new Fe({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new g() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p2 = d2.clone();
    p2.defines.HORIZONTAL_PASS = 1;
    const f2 = new de();
    f2.setAttribute("position", new $t(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const m2 = new Ie(f2, d2), v2 = this;
    function _2(i3, n3) {
      const r3 = e2.update(m2);
      d2.uniforms.shadow_pass.value = i3.map.texture, d2.uniforms.resolution.value = i3.mapSize, d2.uniforms.radius.value = i3.radius, t2.setRenderTarget(i3.mapPass), t2.clear(), t2.renderBufferDirect(n3, null, r3, d2, m2, null), p2.uniforms.shadow_pass.value = i3.mapPass.texture, p2.uniforms.resolution.value = i3.mapSize, p2.uniforms.radius.value = i3.radius, t2.setRenderTarget(i3.map), t2.clear(), t2.renderBufferDirect(n3, null, r3, p2, m2, null);
    }
    function y2(t3) {
      const e3 = t3 << 0;
      let i3 = a2[e3];
      return i3 === void 0 && (i3 = new Qn({ depthPacking: 3201, morphTargets: t3 }), a2[e3] = i3), i3;
    }
    function x2(t3) {
      const e3 = t3 << 0;
      let i3 = l2[e3];
      return i3 === void 0 && (i3 = new $n({ morphTargets: t3 }), l2[e3] = i3), i3;
    }
    function b2(e3, i3, n3, r3, o3, s3, a3) {
      let l3 = null, u3 = y2, d3 = e3.customDepthMaterial;
      if (r3.isPointLight === true && (u3 = x2, d3 = e3.customDistanceMaterial), d3 === void 0) {
        let t3 = false;
        n3.morphTargets === true && (t3 = i3.morphAttributes && i3.morphAttributes.position && i3.morphAttributes.position.length > 0), l3 = u3(t3);
      } else
        l3 = d3;
      if (t2.localClippingEnabled && n3.clipShadows === true && n3.clippingPlanes.length !== 0) {
        const t3 = l3.uuid, e4 = n3.uuid;
        let i4 = h2[t3];
        i4 === void 0 && (i4 = {}, h2[t3] = i4);
        let r4 = i4[e4];
        r4 === void 0 && (r4 = l3.clone(), i4[e4] = r4), l3 = r4;
      }
      return l3.visible = n3.visible, l3.wireframe = n3.wireframe, l3.side = a3 === 3 ? n3.shadowSide !== null ? n3.shadowSide : n3.side : n3.shadowSide !== null ? n3.shadowSide : c2[n3.side], l3.clipShadows = n3.clipShadows, l3.clippingPlanes = n3.clippingPlanes, l3.clipIntersection = n3.clipIntersection, l3.wireframeLinewidth = n3.wireframeLinewidth, l3.linewidth = n3.linewidth, r3.isPointLight === true && l3.isMeshDistanceMaterial === true && (l3.referencePosition.setFromMatrixPosition(r3.matrixWorld), l3.nearDistance = o3, l3.farDistance = s3), l3;
    }
    function T2(i3, r3, o3, s3, a3) {
      if (i3.visible === false)
        return;
      if (i3.layers.test(r3.layers) && (i3.isMesh || i3.isLine || i3.isPoints) && (i3.castShadow || i3.receiveShadow && a3 === 3) && (!i3.frustumCulled || n2.intersectsObject(i3))) {
        i3.modelViewMatrix.multiplyMatrices(o3.matrixWorldInverse, i3.matrixWorld);
        const n3 = e2.update(i3), r4 = i3.material;
        if (Array.isArray(r4)) {
          const e3 = n3.groups;
          for (let l4 = 0, h3 = e3.length; l4 < h3; l4++) {
            const h4 = e3[l4], u3 = r4[h4.materialIndex];
            if (u3 && u3.visible) {
              const e4 = b2(i3, n3, u3, s3, o3.near, o3.far, a3);
              t2.renderBufferDirect(o3, null, n3, e4, i3, h4);
            }
          }
        } else if (r4.visible) {
          const e3 = b2(i3, n3, r4, s3, o3.near, o3.far, a3);
          t2.renderBufferDirect(o3, null, n3, e3, i3, null);
        }
      }
      const l3 = i3.children;
      for (let t3 = 0, e3 = l3.length; t3 < e3; t3++)
        T2(l3[t3], r3, o3, s3, a3);
    }
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e3, i3, a3) {
      if (v2.enabled === false)
        return;
      if (v2.autoUpdate === false && v2.needsUpdate === false)
        return;
      if (e3.length === 0)
        return;
      const l3 = t2.getRenderTarget(), h3 = t2.getActiveCubeFace(), c3 = t2.getActiveMipmapLevel(), d3 = t2.state;
      d3.setBlending(0), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
      for (let l4 = 0, h4 = e3.length; l4 < h4; l4++) {
        const h5 = e3[l4], c4 = h5.shadow;
        if (c4 === void 0) {
          console.warn("THREE.WebGLShadowMap:", h5, "has no shadow.");
          continue;
        }
        if (c4.autoUpdate === false && c4.needsUpdate === false)
          continue;
        r2.copy(c4.mapSize);
        const p3 = c4.getFrameExtents();
        if (r2.multiply(p3), o2.copy(c4.mapSize), (r2.x > u2 || r2.y > u2) && (r2.x > u2 && (o2.x = Math.floor(u2 / p3.x), r2.x = o2.x * p3.x, c4.mapSize.x = o2.x), r2.y > u2 && (o2.y = Math.floor(u2 / p3.y), r2.y = o2.y * p3.y, c4.mapSize.y = o2.y)), c4.map === null && !c4.isPointLightShadow && this.type === 3) {
          const t3 = { minFilter: 1006, magFilter: 1006, format: 1023 };
          c4.map = new S(r2.x, r2.y, t3), c4.map.texture.name = h5.name + ".shadowMap", c4.mapPass = new S(r2.x, r2.y, t3), c4.camera.updateProjectionMatrix();
        }
        if (c4.map === null) {
          const t3 = { minFilter: 1003, magFilter: 1003, format: 1023 };
          c4.map = new S(r2.x, r2.y, t3), c4.map.texture.name = h5.name + ".shadowMap", c4.camera.updateProjectionMatrix();
        }
        t2.setRenderTarget(c4.map), t2.clear();
        const f3 = c4.getViewportCount();
        for (let t3 = 0; t3 < f3; t3++) {
          const e4 = c4.getViewport(t3);
          s2.set(o2.x * e4.x, o2.y * e4.y, o2.x * e4.z, o2.y * e4.w), d3.viewport(s2), c4.updateMatrices(h5, t3), n2 = c4.getFrustum(), T2(i3, a3, c4.camera, h5, this.type);
        }
        c4.isPointLightShadow || this.type !== 3 || _2(c4, a3), c4.needsUpdate = false;
      }
      v2.needsUpdate = false, t2.setRenderTarget(l3, h3, c3);
    };
  }
  function er(t2, e2, i2) {
    const n2 = i2.isWebGL2;
    const r2 = new function() {
      let e3 = false;
      const i3 = new E();
      let n3 = null;
      const r3 = new E(0, 0, 0, 0);
      return { setMask: function(i4) {
        n3 === i4 || e3 || (t2.colorMask(i4, i4, i4, i4), n3 = i4);
      }, setLocked: function(t3) {
        e3 = t3;
      }, setClear: function(e4, n4, o3, s3, a3) {
        a3 === true && (e4 *= s3, n4 *= s3, o3 *= s3), i3.set(e4, n4, o3, s3), r3.equals(i3) === false && (t2.clearColor(e4, n4, o3, s3), r3.copy(i3));
      }, reset: function() {
        e3 = false, n3 = null, r3.set(-1, 0, 0, 0);
      } };
    }(), o2 = new function() {
      let e3 = false, i3 = null, n3 = null, r3 = null;
      return { setTest: function(t3) {
        t3 ? U2(2929) : k2(2929);
      }, setMask: function(n4) {
        i3 === n4 || e3 || (t2.depthMask(n4), i3 = n4);
      }, setFunc: function(e4) {
        if (n3 !== e4) {
          if (e4)
            switch (e4) {
              case 0:
                t2.depthFunc(512);
                break;
              case 1:
                t2.depthFunc(519);
                break;
              case 2:
                t2.depthFunc(513);
                break;
              case 3:
                t2.depthFunc(515);
                break;
              case 4:
                t2.depthFunc(514);
                break;
              case 5:
                t2.depthFunc(518);
                break;
              case 6:
                t2.depthFunc(516);
                break;
              case 7:
                t2.depthFunc(517);
                break;
              default:
                t2.depthFunc(515);
            }
          else
            t2.depthFunc(515);
          n3 = e4;
        }
      }, setLocked: function(t3) {
        e3 = t3;
      }, setClear: function(e4) {
        r3 !== e4 && (t2.clearDepth(e4), r3 = e4);
      }, reset: function() {
        e3 = false, i3 = null, n3 = null, r3 = null;
      } };
    }(), s2 = new function() {
      let e3 = false, i3 = null, n3 = null, r3 = null, o3 = null, s3 = null, a3 = null, l3 = null, h3 = null;
      return { setTest: function(t3) {
        e3 || (t3 ? U2(2960) : k2(2960));
      }, setMask: function(n4) {
        i3 === n4 || e3 || (t2.stencilMask(n4), i3 = n4);
      }, setFunc: function(e4, i4, s4) {
        n3 === e4 && r3 === i4 && o3 === s4 || (t2.stencilFunc(e4, i4, s4), n3 = e4, r3 = i4, o3 = s4);
      }, setOp: function(e4, i4, n4) {
        s3 === e4 && a3 === i4 && l3 === n4 || (t2.stencilOp(e4, i4, n4), s3 = e4, a3 = i4, l3 = n4);
      }, setLocked: function(t3) {
        e3 = t3;
      }, setClear: function(e4) {
        h3 !== e4 && (t2.clearStencil(e4), h3 = e4);
      }, reset: function() {
        e3 = false, i3 = null, n3 = null, r3 = null, o3 = null, s3 = null, a3 = null, l3 = null, h3 = null;
      } };
    }();
    let a2 = {}, l2 = null, h2 = {}, u2 = null, c2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, _2 = null, y2 = false, x2 = null, b2 = null, T2 = null, S2 = null, w2 = null;
    const A2 = t2.getParameter(35661);
    let M2 = false, R2 = 0;
    const C2 = t2.getParameter(7938);
    C2.indexOf("WebGL") !== -1 ? (R2 = parseFloat(/^WebGL (\d)/.exec(C2)[1]), M2 = R2 >= 1) : C2.indexOf("OpenGL ES") !== -1 && (R2 = parseFloat(/^OpenGL ES (\d)/.exec(C2)[1]), M2 = R2 >= 2);
    let I2 = null, P2 = {};
    const O2 = t2.getParameter(3088), N2 = t2.getParameter(2978), L2 = new E().fromArray(O2), D2 = new E().fromArray(N2);
    function F2(e3, i3, n3) {
      const r3 = new Uint8Array(4), o3 = t2.createTexture();
      t2.bindTexture(e3, o3), t2.texParameteri(e3, 10241, 9728), t2.texParameteri(e3, 10240, 9728);
      for (let e4 = 0; e4 < n3; e4++)
        t2.texImage2D(i3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, r3);
      return o3;
    }
    const B2 = {};
    function U2(e3) {
      a2[e3] !== true && (t2.enable(e3), a2[e3] = true);
    }
    function k2(e3) {
      a2[e3] !== false && (t2.disable(e3), a2[e3] = false);
    }
    B2[3553] = F2(3553, 3553, 1), B2[34067] = F2(34067, 34069, 6), r2.setClear(0, 0, 0, 1), o2.setClear(1), s2.setClear(0), U2(2929), o2.setFunc(3), z2(false), V2(1), U2(2884), j2(0);
    const G2 = { 100: 32774, 101: 32778, 102: 32779 };
    if (n2)
      G2[103] = 32775, G2[104] = 32776;
    else {
      const t3 = e2.get("EXT_blend_minmax");
      t3 !== null && (G2[103] = t3.MIN_EXT, G2[104] = t3.MAX_EXT);
    }
    const H2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
    function j2(e3, i3, n3, r3, o3, s3, a3, l3) {
      if (e3 !== 0) {
        if (c2 === false && (U2(3042), c2 = true), e3 === 5)
          o3 = o3 || i3, s3 = s3 || n3, a3 = a3 || r3, i3 === p2 && o3 === g2 || (t2.blendEquationSeparate(G2[i3], G2[o3]), p2 = i3, g2 = o3), n3 === f2 && r3 === m2 && s3 === v2 && a3 === _2 || (t2.blendFuncSeparate(H2[n3], H2[r3], H2[s3], H2[a3]), f2 = n3, m2 = r3, v2 = s3, _2 = a3), d2 = e3, y2 = null;
        else if (e3 !== d2 || l3 !== y2) {
          if (p2 === 100 && g2 === 100 || (t2.blendEquation(32774), p2 = 100, g2 = 100), l3)
            switch (e3) {
              case 1:
                t2.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t2.blendFunc(1, 1);
                break;
              case 3:
                t2.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t2.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e3);
            }
          else
            switch (e3) {
              case 1:
                t2.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t2.blendFunc(770, 1);
                break;
              case 3:
                t2.blendFunc(0, 769);
                break;
              case 4:
                t2.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e3);
            }
          f2 = null, m2 = null, v2 = null, _2 = null, d2 = e3, y2 = l3;
        }
      } else
        c2 === true && (k2(3042), c2 = false);
    }
    function z2(e3) {
      x2 !== e3 && (e3 ? t2.frontFace(2304) : t2.frontFace(2305), x2 = e3);
    }
    function V2(e3) {
      e3 !== 0 ? (U2(2884), e3 !== b2 && (e3 === 1 ? t2.cullFace(1029) : e3 === 2 ? t2.cullFace(1028) : t2.cullFace(1032))) : k2(2884), b2 = e3;
    }
    function X2(e3, i3, n3) {
      e3 ? (U2(32823), S2 === i3 && w2 === n3 || (t2.polygonOffset(i3, n3), S2 = i3, w2 = n3)) : k2(32823);
    }
    function W2(e3) {
      e3 === void 0 && (e3 = 33984 + A2 - 1), I2 !== e3 && (t2.activeTexture(e3), I2 = e3);
    }
    return { buffers: { color: r2, depth: o2, stencil: s2 }, enable: U2, disable: k2, bindFramebuffer: function(e3, i3) {
      return i3 === null && l2 !== null && (i3 = l2), h2[e3] !== i3 && (t2.bindFramebuffer(e3, i3), h2[e3] = i3, n2 && (e3 === 36009 && (h2[36160] = i3), e3 === 36160 && (h2[36009] = i3)), true);
    }, bindXRFramebuffer: function(e3) {
      e3 !== l2 && (t2.bindFramebuffer(36160, e3), l2 = e3);
    }, useProgram: function(e3) {
      return u2 !== e3 && (t2.useProgram(e3), u2 = e3, true);
    }, setBlending: j2, setMaterial: function(t3, e3) {
      t3.side === 2 ? k2(2884) : U2(2884);
      let i3 = t3.side === 1;
      e3 && (i3 = !i3), z2(i3), t3.blending === 1 && t3.transparent === false ? j2(0) : j2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), o2.setFunc(t3.depthFunc), o2.setTest(t3.depthTest), o2.setMask(t3.depthWrite), r2.setMask(t3.colorWrite);
      const n3 = t3.stencilWrite;
      s2.setTest(n3), n3 && (s2.setMask(t3.stencilWriteMask), s2.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), s2.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), X2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits), t3.alphaToCoverage === true ? U2(32926) : k2(32926);
    }, setFlipSided: z2, setCullFace: V2, setLineWidth: function(e3) {
      e3 !== T2 && (M2 && t2.lineWidth(e3), T2 = e3);
    }, setPolygonOffset: X2, setScissorTest: function(t3) {
      t3 ? U2(3089) : k2(3089);
    }, activeTexture: W2, bindTexture: function(e3, i3) {
      I2 === null && W2();
      let n3 = P2[I2];
      n3 === void 0 && (n3 = { type: void 0, texture: void 0 }, P2[I2] = n3), n3.type === e3 && n3.texture === i3 || (t2.bindTexture(e3, i3 || B2[e3]), n3.type = e3, n3.texture = i3);
    }, unbindTexture: function() {
      const e3 = P2[I2];
      e3 !== void 0 && e3.type !== void 0 && (t2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        t2.compressedTexImage2D.apply(t2, arguments);
      } catch (t3) {
        console.error("THREE.WebGLState:", t3);
      }
    }, texImage2D: function() {
      try {
        t2.texImage2D.apply(t2, arguments);
      } catch (t3) {
        console.error("THREE.WebGLState:", t3);
      }
    }, texImage3D: function() {
      try {
        t2.texImage3D.apply(t2, arguments);
      } catch (t3) {
        console.error("THREE.WebGLState:", t3);
      }
    }, scissor: function(e3) {
      L2.equals(e3) === false && (t2.scissor(e3.x, e3.y, e3.z, e3.w), L2.copy(e3));
    }, viewport: function(e3) {
      D2.equals(e3) === false && (t2.viewport(e3.x, e3.y, e3.z, e3.w), D2.copy(e3));
    }, reset: function() {
      t2.disable(3042), t2.disable(2884), t2.disable(2929), t2.disable(32823), t2.disable(3089), t2.disable(2960), t2.disable(32926), t2.blendEquation(32774), t2.blendFunc(1, 0), t2.blendFuncSeparate(1, 0, 1, 0), t2.colorMask(true, true, true, true), t2.clearColor(0, 0, 0, 0), t2.depthMask(true), t2.depthFunc(513), t2.clearDepth(1), t2.stencilMask(4294967295), t2.stencilFunc(519, 0, 4294967295), t2.stencilOp(7680, 7680, 7680), t2.clearStencil(0), t2.cullFace(1029), t2.frontFace(2305), t2.polygonOffset(0, 0), t2.activeTexture(33984), t2.bindFramebuffer(36160, null), n2 === true && (t2.bindFramebuffer(36009, null), t2.bindFramebuffer(36008, null)), t2.useProgram(null), t2.lineWidth(1), t2.scissor(0, 0, t2.canvas.width, t2.canvas.height), t2.viewport(0, 0, t2.canvas.width, t2.canvas.height), a2 = {}, I2 = null, P2 = {}, l2 = null, h2 = {}, u2 = null, c2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, _2 = null, y2 = false, x2 = null, b2 = null, T2 = null, S2 = null, w2 = null, L2.set(0, 0, t2.canvas.width, t2.canvas.height), D2.set(0, 0, t2.canvas.width, t2.canvas.height), r2.reset(), o2.reset(), s2.reset();
    } };
  }
  function ir(t2, e2, i2, n2, r2, o2, s2) {
    const a2 = r2.isWebGL2, l2 = r2.maxTextures, h2 = r2.maxCubemapSize, u2 = r2.maxTextureSize, c2 = r2.maxSamples, d2 = /* @__PURE__ */ new WeakMap();
    let p2, g2 = false;
    try {
      g2 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (t3) {
    }
    function v2(t3, e3) {
      return g2 ? new OffscreenCanvas(t3, e3) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function _2(t3, e3, i3, n3) {
      let r3 = 1;
      if ((t3.width > n3 || t3.height > n3) && (r3 = n3 / Math.max(t3.width, t3.height)), r3 < 1 || e3 === true) {
        if (typeof HTMLImageElement != "undefined" && t3 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t3 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t3 instanceof ImageBitmap) {
          const n4 = e3 ? m : Math.floor, o3 = n4(r3 * t3.width), s3 = n4(r3 * t3.height);
          p2 === void 0 && (p2 = v2(o3, s3));
          const a3 = i3 ? v2(o3, s3) : p2;
          a3.width = o3, a3.height = s3;
          return a3.getContext("2d").drawImage(t3, 0, 0, o3, s3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t3.width + "x" + t3.height + ") to (" + o3 + "x" + s3 + ")."), a3;
        }
        return "data" in t3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t3.width + "x" + t3.height + ")."), t3;
      }
      return t3;
    }
    function y2(t3) {
      return f(t3.width) && f(t3.height);
    }
    function x2(t3, e3) {
      return t3.generateMipmaps && e3 && t3.minFilter !== 1003 && t3.minFilter !== 1006;
    }
    function b2(e3, i3, r3, o3, s3 = 1) {
      t2.generateMipmap(e3);
      n2.get(i3).__maxMipLevel = Math.log2(Math.max(r3, o3, s3));
    }
    function T2(i3, n3, r3) {
      if (a2 === false)
        return n3;
      if (i3 !== null) {
        if (t2[i3] !== void 0)
          return t2[i3];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i3 + "'");
      }
      let o3 = n3;
      return n3 === 6403 && (r3 === 5126 && (o3 = 33326), r3 === 5131 && (o3 = 33325), r3 === 5121 && (o3 = 33321)), n3 === 6407 && (r3 === 5126 && (o3 = 34837), r3 === 5131 && (o3 = 34843), r3 === 5121 && (o3 = 32849)), n3 === 6408 && (r3 === 5126 && (o3 = 34836), r3 === 5131 && (o3 = 34842), r3 === 5121 && (o3 = 32856)), o3 !== 33325 && o3 !== 33326 && o3 !== 34842 && o3 !== 34836 || e2.get("EXT_color_buffer_float"), o3;
    }
    function E2(t3) {
      return t3 === 1003 || t3 === 1004 || t3 === 1005 ? 9728 : 9729;
    }
    function S2(e3) {
      const i3 = e3.target;
      i3.removeEventListener("dispose", S2), function(e4) {
        const i4 = n2.get(e4);
        if (i4.__webglInit === void 0)
          return;
        t2.deleteTexture(i4.__webglTexture), n2.remove(e4);
      }(i3), i3.isVideoTexture && d2.delete(i3), s2.memory.textures--;
    }
    function w2(e3) {
      const i3 = e3.target;
      i3.removeEventListener("dispose", w2), function(e4) {
        const i4 = e4.texture, r3 = n2.get(e4), o3 = n2.get(i4);
        if (!e4)
          return;
        o3.__webglTexture !== void 0 && (t2.deleteTexture(o3.__webglTexture), s2.memory.textures--);
        e4.depthTexture && e4.depthTexture.dispose();
        if (e4.isWebGLCubeRenderTarget)
          for (let e5 = 0; e5 < 6; e5++)
            t2.deleteFramebuffer(r3.__webglFramebuffer[e5]), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer[e5]);
        else
          t2.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && t2.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer && t2.deleteRenderbuffer(r3.__webglColorRenderbuffer), r3.__webglDepthRenderbuffer && t2.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
        if (e4.isWebGLMultipleRenderTargets)
          for (let e5 = 0, r4 = i4.length; e5 < r4; e5++) {
            const r5 = n2.get(i4[e5]);
            r5.__webglTexture && (t2.deleteTexture(r5.__webglTexture), s2.memory.textures--), n2.remove(i4[e5]);
          }
        n2.remove(i4), n2.remove(e4);
      }(i3);
    }
    let A2 = 0;
    function M2(t3, e3) {
      const r3 = n2.get(t3);
      if (t3.isVideoTexture && function(t4) {
        const e4 = s2.render.frame;
        d2.get(t4) !== e4 && (d2.set(t4, e4), t4.update());
      }(t3), t3.version > 0 && r3.__version !== t3.version) {
        const i3 = t3.image;
        if (i3 === void 0)
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        else {
          if (i3.complete !== false)
            return void N2(r3, t3, e3);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      i2.activeTexture(33984 + e3), i2.bindTexture(3553, r3.__webglTexture);
    }
    function R2(e3, r3) {
      const s3 = n2.get(e3);
      e3.version > 0 && s3.__version !== e3.version ? function(e4, n3, r4) {
        if (n3.image.length !== 6)
          return;
        O2(e4, n3), i2.activeTexture(33984 + r4), i2.bindTexture(34067, e4.__webglTexture), t2.pixelStorei(37440, n3.flipY), t2.pixelStorei(37441, n3.premultiplyAlpha), t2.pixelStorei(3317, n3.unpackAlignment), t2.pixelStorei(37443, 0);
        const s4 = n3 && (n3.isCompressedTexture || n3.image[0].isCompressedTexture), l3 = n3.image[0] && n3.image[0].isDataTexture, u3 = [];
        for (let t3 = 0; t3 < 6; t3++)
          u3[t3] = s4 || l3 ? l3 ? n3.image[t3].image : n3.image[t3] : _2(n3.image[t3], false, true, h2);
        const c3 = u3[0], d3 = y2(c3) || a2, p3 = o2.convert(n3.format), f2 = o2.convert(n3.type), m2 = T2(n3.internalFormat, p3, f2);
        let g3;
        if (P2(34067, n3, d3), s4) {
          for (let t3 = 0; t3 < 6; t3++) {
            g3 = u3[t3].mipmaps;
            for (let e5 = 0; e5 < g3.length; e5++) {
              const r5 = g3[e5];
              n3.format !== 1023 && n3.format !== 1022 ? p3 !== null ? i2.compressedTexImage2D(34069 + t3, e5, m2, r5.width, r5.height, 0, r5.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i2.texImage2D(34069 + t3, e5, m2, r5.width, r5.height, 0, p3, f2, r5.data);
            }
          }
          e4.__maxMipLevel = g3.length - 1;
        } else {
          g3 = n3.mipmaps;
          for (let t3 = 0; t3 < 6; t3++)
            if (l3) {
              i2.texImage2D(34069 + t3, 0, m2, u3[t3].width, u3[t3].height, 0, p3, f2, u3[t3].data);
              for (let e5 = 0; e5 < g3.length; e5++) {
                const n4 = g3[e5].image[t3].image;
                i2.texImage2D(34069 + t3, e5 + 1, m2, n4.width, n4.height, 0, p3, f2, n4.data);
              }
            } else {
              i2.texImage2D(34069 + t3, 0, m2, p3, f2, u3[t3]);
              for (let e5 = 0; e5 < g3.length; e5++) {
                const n4 = g3[e5];
                i2.texImage2D(34069 + t3, e5 + 1, m2, p3, f2, n4.image[t3]);
              }
            }
          e4.__maxMipLevel = g3.length;
        }
        x2(n3, d3) && b2(34067, n3, c3.width, c3.height);
        e4.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
      }(s3, e3, r3) : (i2.activeTexture(33984 + r3), i2.bindTexture(34067, s3.__webglTexture));
    }
    const C2 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, I2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
    function P2(i3, o3, s3) {
      if (s3 ? (t2.texParameteri(i3, 10242, C2[o3.wrapS]), t2.texParameteri(i3, 10243, C2[o3.wrapT]), i3 !== 32879 && i3 !== 35866 || t2.texParameteri(i3, 32882, C2[o3.wrapR]), t2.texParameteri(i3, 10240, I2[o3.magFilter]), t2.texParameteri(i3, 10241, I2[o3.minFilter])) : (t2.texParameteri(i3, 10242, 33071), t2.texParameteri(i3, 10243, 33071), i3 !== 32879 && i3 !== 35866 || t2.texParameteri(i3, 32882, 33071), o3.wrapS === 1001 && o3.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t2.texParameteri(i3, 10240, E2(o3.magFilter)), t2.texParameteri(i3, 10241, E2(o3.minFilter)), o3.minFilter !== 1003 && o3.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e2.has("EXT_texture_filter_anisotropic") === true) {
        const s4 = e2.get("EXT_texture_filter_anisotropic");
        if (o3.type === 1015 && e2.has("OES_texture_float_linear") === false)
          return;
        if (a2 === false && o3.type === 1016 && e2.has("OES_texture_half_float_linear") === false)
          return;
        (o3.anisotropy > 1 || n2.get(o3).__currentAnisotropy) && (t2.texParameterf(i3, s4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o3.anisotropy, r2.getMaxAnisotropy())), n2.get(o3).__currentAnisotropy = o3.anisotropy);
      }
    }
    function O2(e3, i3) {
      e3.__webglInit === void 0 && (e3.__webglInit = true, i3.addEventListener("dispose", S2), e3.__webglTexture = t2.createTexture(), s2.memory.textures++);
    }
    function N2(e3, n3, r3) {
      let s3 = 3553;
      n3.isDataTexture2DArray && (s3 = 35866), n3.isDataTexture3D && (s3 = 32879), O2(e3, n3), i2.activeTexture(33984 + r3), i2.bindTexture(s3, e3.__webglTexture), t2.pixelStorei(37440, n3.flipY), t2.pixelStorei(37441, n3.premultiplyAlpha), t2.pixelStorei(3317, n3.unpackAlignment), t2.pixelStorei(37443, 0);
      const l3 = function(t3) {
        return !a2 && (t3.wrapS !== 1001 || t3.wrapT !== 1001 || t3.minFilter !== 1003 && t3.minFilter !== 1006);
      }(n3) && y2(n3.image) === false, h3 = _2(n3.image, l3, false, u2), c3 = y2(h3) || a2, d3 = o2.convert(n3.format);
      let p3, f2 = o2.convert(n3.type), m2 = T2(n3.internalFormat, d3, f2);
      P2(s3, n3, c3);
      const g3 = n3.mipmaps;
      if (n3.isDepthTexture)
        m2 = 6402, a2 ? m2 = n3.type === 1015 ? 36012 : n3.type === 1014 ? 33190 : n3.type === 1020 ? 35056 : 33189 : n3.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n3.format === 1026 && m2 === 6402 && n3.type !== 1012 && n3.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = 1012, f2 = o2.convert(n3.type)), n3.format === 1027 && m2 === 6402 && (m2 = 34041, n3.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = 1020, f2 = o2.convert(n3.type))), i2.texImage2D(3553, 0, m2, h3.width, h3.height, 0, d3, f2, null);
      else if (n3.isDataTexture)
        if (g3.length > 0 && c3) {
          for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
            p3 = g3[t3], i2.texImage2D(3553, t3, m2, p3.width, p3.height, 0, d3, f2, p3.data);
          n3.generateMipmaps = false, e3.__maxMipLevel = g3.length - 1;
        } else
          i2.texImage2D(3553, 0, m2, h3.width, h3.height, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
      else if (n3.isCompressedTexture) {
        for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
          p3 = g3[t3], n3.format !== 1023 && n3.format !== 1022 ? d3 !== null ? i2.compressedTexImage2D(3553, t3, m2, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i2.texImage2D(3553, t3, m2, p3.width, p3.height, 0, d3, f2, p3.data);
        e3.__maxMipLevel = g3.length - 1;
      } else if (n3.isDataTexture2DArray)
        i2.texImage3D(35866, 0, m2, h3.width, h3.height, h3.depth, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
      else if (n3.isDataTexture3D)
        i2.texImage3D(32879, 0, m2, h3.width, h3.height, h3.depth, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
      else if (g3.length > 0 && c3) {
        for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
          p3 = g3[t3], i2.texImage2D(3553, t3, m2, d3, f2, p3);
        n3.generateMipmaps = false, e3.__maxMipLevel = g3.length - 1;
      } else
        i2.texImage2D(3553, 0, m2, d3, f2, h3), e3.__maxMipLevel = 0;
      x2(n3, c3) && b2(s3, n3, h3.width, h3.height), e3.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
    }
    function L2(e3, r3, s3, a3, l3) {
      const h3 = o2.convert(s3.format), u3 = o2.convert(s3.type), c3 = T2(s3.internalFormat, h3, u3);
      l3 === 32879 || l3 === 35866 ? i2.texImage3D(l3, 0, c3, r3.width, r3.height, r3.depth, 0, h3, u3, null) : i2.texImage2D(l3, 0, c3, r3.width, r3.height, 0, h3, u3, null), i2.bindFramebuffer(36160, e3), t2.framebufferTexture2D(36160, a3, l3, n2.get(s3).__webglTexture, 0), i2.bindFramebuffer(36160, null);
    }
    function D2(e3, i3, n3) {
      if (t2.bindRenderbuffer(36161, e3), i3.depthBuffer && !i3.stencilBuffer) {
        let r3 = 33189;
        if (n3) {
          const e4 = i3.depthTexture;
          e4 && e4.isDepthTexture && (e4.type === 1015 ? r3 = 36012 : e4.type === 1014 && (r3 = 33190));
          const n4 = B2(i3);
          t2.renderbufferStorageMultisample(36161, n4, r3, i3.width, i3.height);
        } else
          t2.renderbufferStorage(36161, r3, i3.width, i3.height);
        t2.framebufferRenderbuffer(36160, 36096, 36161, e3);
      } else if (i3.depthBuffer && i3.stencilBuffer) {
        if (n3) {
          const e4 = B2(i3);
          t2.renderbufferStorageMultisample(36161, e4, 35056, i3.width, i3.height);
        } else
          t2.renderbufferStorage(36161, 34041, i3.width, i3.height);
        t2.framebufferRenderbuffer(36160, 33306, 36161, e3);
      } else {
        const e4 = i3.isWebGLMultipleRenderTargets === true ? i3.texture[0] : i3.texture, r3 = o2.convert(e4.format), s3 = o2.convert(e4.type), a3 = T2(e4.internalFormat, r3, s3);
        if (n3) {
          const e5 = B2(i3);
          t2.renderbufferStorageMultisample(36161, e5, a3, i3.width, i3.height);
        } else
          t2.renderbufferStorage(36161, a3, i3.width, i3.height);
      }
      t2.bindRenderbuffer(36161, null);
    }
    function F2(e3) {
      const r3 = n2.get(e3), o3 = e3.isWebGLCubeRenderTarget === true;
      if (e3.depthTexture) {
        if (o3)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(e4, r4) {
          if (r4 && r4.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (i2.bindFramebuffer(36160, e4), !r4.depthTexture || !r4.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          n2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), M2(r4.depthTexture, 0);
          const o4 = n2.get(r4.depthTexture).__webglTexture;
          if (r4.depthTexture.format === 1026)
            t2.framebufferTexture2D(36160, 36096, 3553, o4, 0);
          else {
            if (r4.depthTexture.format !== 1027)
              throw new Error("Unknown depthTexture format");
            t2.framebufferTexture2D(36160, 33306, 3553, o4, 0);
          }
        }(r3.__webglFramebuffer, e3);
      } else if (o3) {
        r3.__webglDepthbuffer = [];
        for (let n3 = 0; n3 < 6; n3++)
          i2.bindFramebuffer(36160, r3.__webglFramebuffer[n3]), r3.__webglDepthbuffer[n3] = t2.createRenderbuffer(), D2(r3.__webglDepthbuffer[n3], e3, false);
      } else
        i2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = t2.createRenderbuffer(), D2(r3.__webglDepthbuffer, e3, false);
      i2.bindFramebuffer(36160, null);
    }
    function B2(t3) {
      return a2 && t3.isWebGLMultisampleRenderTarget ? Math.min(c2, t3.samples) : 0;
    }
    let U2 = false, k2 = false;
    this.allocateTextureUnit = function() {
      const t3 = A2;
      return t3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t3 + " texture units while this GPU supports only " + l2), A2 += 1, t3;
    }, this.resetTextureUnits = function() {
      A2 = 0;
    }, this.setTexture2D = M2, this.setTexture2DArray = function(t3, e3) {
      const r3 = n2.get(t3);
      t3.version > 0 && r3.__version !== t3.version ? N2(r3, t3, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(35866, r3.__webglTexture));
    }, this.setTexture3D = function(t3, e3) {
      const r3 = n2.get(t3);
      t3.version > 0 && r3.__version !== t3.version ? N2(r3, t3, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(32879, r3.__webglTexture));
    }, this.setTextureCube = R2, this.setupRenderTarget = function(e3) {
      const l3 = e3.texture, h3 = n2.get(e3), u3 = n2.get(l3);
      e3.addEventListener("dispose", w2), e3.isWebGLMultipleRenderTargets !== true && (u3.__webglTexture = t2.createTexture(), u3.__version = l3.version, s2.memory.textures++);
      const c3 = e3.isWebGLCubeRenderTarget === true, d3 = e3.isWebGLMultipleRenderTargets === true, p3 = e3.isWebGLMultisampleRenderTarget === true, f2 = l3.isDataTexture3D || l3.isDataTexture2DArray, m2 = y2(e3) || a2;
      if (!a2 || l3.format !== 1022 || l3.type !== 1015 && l3.type !== 1016 || (l3.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c3) {
        h3.__webglFramebuffer = [];
        for (let e4 = 0; e4 < 6; e4++)
          h3.__webglFramebuffer[e4] = t2.createFramebuffer();
      } else if (h3.__webglFramebuffer = t2.createFramebuffer(), d3)
        if (r2.drawBuffers) {
          const i3 = e3.texture;
          for (let e4 = 0, r3 = i3.length; e4 < r3; e4++) {
            const r4 = n2.get(i3[e4]);
            r4.__webglTexture === void 0 && (r4.__webglTexture = t2.createTexture(), s2.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      else if (p3)
        if (a2) {
          h3.__webglMultisampledFramebuffer = t2.createFramebuffer(), h3.__webglColorRenderbuffer = t2.createRenderbuffer(), t2.bindRenderbuffer(36161, h3.__webglColorRenderbuffer);
          const n3 = o2.convert(l3.format), r3 = o2.convert(l3.type), s3 = T2(l3.internalFormat, n3, r3), a3 = B2(e3);
          t2.renderbufferStorageMultisample(36161, a3, s3, e3.width, e3.height), i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), t2.framebufferRenderbuffer(36160, 36064, 36161, h3.__webglColorRenderbuffer), t2.bindRenderbuffer(36161, null), e3.depthBuffer && (h3.__webglDepthRenderbuffer = t2.createRenderbuffer(), D2(h3.__webglDepthRenderbuffer, e3, true)), i2.bindFramebuffer(36160, null);
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      if (c3) {
        i2.bindTexture(34067, u3.__webglTexture), P2(34067, l3, m2);
        for (let t3 = 0; t3 < 6; t3++)
          L2(h3.__webglFramebuffer[t3], e3, l3, 36064, 34069 + t3);
        x2(l3, m2) && b2(34067, l3, e3.width, e3.height), i2.bindTexture(34067, null);
      } else if (d3) {
        const t3 = e3.texture;
        for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
          const o4 = t3[r3], s3 = n2.get(o4);
          i2.bindTexture(3553, s3.__webglTexture), P2(3553, o4, m2), L2(h3.__webglFramebuffer, e3, o4, 36064 + r3, 3553), x2(o4, m2) && b2(3553, o4, e3.width, e3.height);
        }
        i2.bindTexture(3553, null);
      } else {
        let t3 = 3553;
        if (f2)
          if (a2) {
            t3 = l3.isDataTexture3D ? 32879 : 35866;
          } else
            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        i2.bindTexture(t3, u3.__webglTexture), P2(t3, l3, m2), L2(h3.__webglFramebuffer, e3, l3, 36064, t3), x2(l3, m2) && b2(t3, l3, e3.width, e3.height, e3.depth), i2.bindTexture(t3, null);
      }
      e3.depthBuffer && F2(e3);
    }, this.updateRenderTargetMipmap = function(t3) {
      const e3 = y2(t3) || a2, r3 = t3.isWebGLMultipleRenderTargets === true ? t3.texture : [t3.texture];
      for (let o3 = 0, s3 = r3.length; o3 < s3; o3++) {
        const s4 = r3[o3];
        if (x2(s4, e3)) {
          const e4 = t3.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = n2.get(s4).__webglTexture;
          i2.bindTexture(e4, r4), b2(e4, s4, t3.width, t3.height), i2.bindTexture(e4, null);
        }
      }
    }, this.updateMultisampleRenderTarget = function(e3) {
      if (e3.isWebGLMultisampleRenderTarget)
        if (a2) {
          const r3 = e3.width, o3 = e3.height;
          let s3 = 16384;
          e3.depthBuffer && (s3 |= 256), e3.stencilBuffer && (s3 |= 1024);
          const a3 = n2.get(e3);
          i2.bindFramebuffer(36008, a3.__webglMultisampledFramebuffer), i2.bindFramebuffer(36009, a3.__webglFramebuffer), t2.blitFramebuffer(0, 0, r3, o3, 0, 0, r3, o3, s3, 9728), i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, a3.__webglMultisampledFramebuffer);
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    }, this.safeSetTexture2D = function(t3, e3) {
      t3 && t3.isWebGLRenderTarget && (U2 === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U2 = true), t3 = t3.texture), M2(t3, e3);
    }, this.safeSetTextureCube = function(t3, e3) {
      t3 && t3.isWebGLCubeRenderTarget && (k2 === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k2 = true), t3 = t3.texture), R2(t3, e3);
    };
  }
  function nr(t2, e2, i2) {
    const n2 = i2.isWebGL2;
    return { convert: function(t3) {
      let i3;
      if (t3 === 1009)
        return 5121;
      if (t3 === 1017)
        return 32819;
      if (t3 === 1018)
        return 32820;
      if (t3 === 1019)
        return 33635;
      if (t3 === 1010)
        return 5120;
      if (t3 === 1011)
        return 5122;
      if (t3 === 1012)
        return 5123;
      if (t3 === 1013)
        return 5124;
      if (t3 === 1014)
        return 5125;
      if (t3 === 1015)
        return 5126;
      if (t3 === 1016)
        return n2 ? 5131 : (i3 = e2.get("OES_texture_half_float"), i3 !== null ? i3.HALF_FLOAT_OES : null);
      if (t3 === 1021)
        return 6406;
      if (t3 === 1022)
        return 6407;
      if (t3 === 1023)
        return 6408;
      if (t3 === 1024)
        return 6409;
      if (t3 === 1025)
        return 6410;
      if (t3 === 1026)
        return 6402;
      if (t3 === 1027)
        return 34041;
      if (t3 === 1028)
        return 6403;
      if (t3 === 1029)
        return 36244;
      if (t3 === 1030)
        return 33319;
      if (t3 === 1031)
        return 33320;
      if (t3 === 1032)
        return 36248;
      if (t3 === 1033)
        return 36249;
      if (t3 === 33776 || t3 === 33777 || t3 === 33778 || t3 === 33779) {
        if (i3 = e2.get("WEBGL_compressed_texture_s3tc"), i3 === null)
          return null;
        if (t3 === 33776)
          return i3.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (t3 === 33777)
          return i3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (t3 === 33778)
          return i3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (t3 === 33779)
          return i3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (t3 === 35840 || t3 === 35841 || t3 === 35842 || t3 === 35843) {
        if (i3 = e2.get("WEBGL_compressed_texture_pvrtc"), i3 === null)
          return null;
        if (t3 === 35840)
          return i3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (t3 === 35841)
          return i3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (t3 === 35842)
          return i3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (t3 === 35843)
          return i3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (t3 === 36196)
        return i3 = e2.get("WEBGL_compressed_texture_etc1"), i3 !== null ? i3.COMPRESSED_RGB_ETC1_WEBGL : null;
      if ((t3 === 37492 || t3 === 37496) && (i3 = e2.get("WEBGL_compressed_texture_etc"), i3 !== null)) {
        if (t3 === 37492)
          return i3.COMPRESSED_RGB8_ETC2;
        if (t3 === 37496)
          return i3.COMPRESSED_RGBA8_ETC2_EAC;
      }
      return t3 === 37808 || t3 === 37809 || t3 === 37810 || t3 === 37811 || t3 === 37812 || t3 === 37813 || t3 === 37814 || t3 === 37815 || t3 === 37816 || t3 === 37817 || t3 === 37818 || t3 === 37819 || t3 === 37820 || t3 === 37821 || t3 === 37840 || t3 === 37841 || t3 === 37842 || t3 === 37843 || t3 === 37844 || t3 === 37845 || t3 === 37846 || t3 === 37847 || t3 === 37848 || t3 === 37849 || t3 === 37850 || t3 === 37851 || t3 === 37852 || t3 === 37853 ? (i3 = e2.get("WEBGL_compressed_texture_astc"), i3 !== null ? t3 : null) : t3 === 36492 ? (i3 = e2.get("EXT_texture_compression_bptc"), i3 !== null ? t3 : null) : t3 === 1020 ? n2 ? 34042 : (i3 = e2.get("WEBGL_depth_texture"), i3 !== null ? i3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    } };
  }
  class rr extends Ue {
    constructor(t2 = []) {
      super(), this.cameras = t2;
    }
  }
  rr.prototype.isArrayCamera = true;
  class or extends Ct {
    constructor() {
      super(), this.type = "Group";
    }
  }
  or.prototype.isGroup = true;
  const sr = { type: "move" };
  class ar {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new or(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new or(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new M(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new M()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new or(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new M(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new M()), this._grip;
    }
    dispatchEvent(t2) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t2), this._grip !== null && this._grip.dispatchEvent(t2), this._hand !== null && this._hand.dispatchEvent(t2), this;
    }
    disconnect(t2) {
      return this.dispatchEvent({ type: "disconnected", data: t2 }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(t2, e2, i2) {
      let n2 = null, r2 = null, o2 = null;
      const s2 = this._targetRay, a2 = this._grip, l2 = this._hand;
      if (t2 && e2.session.visibilityState !== "visible-blurred")
        if (s2 !== null && (n2 = e2.getPose(t2.targetRaySpace, i2), n2 !== null && (s2.matrix.fromArray(n2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale), n2.linearVelocity ? (s2.hasLinearVelocity = true, s2.linearVelocity.copy(n2.linearVelocity)) : s2.hasLinearVelocity = false, n2.angularVelocity ? (s2.hasAngularVelocity = true, s2.angularVelocity.copy(n2.angularVelocity)) : s2.hasAngularVelocity = false, this.dispatchEvent(sr))), l2 && t2.hand) {
          o2 = true;
          for (const n4 of t2.hand.values()) {
            const t3 = e2.getJointPose(n4, i2);
            if (l2.joints[n4.jointName] === void 0) {
              const t4 = new or();
              t4.matrixAutoUpdate = false, t4.visible = false, l2.joints[n4.jointName] = t4, l2.add(t4);
            }
            const r4 = l2.joints[n4.jointName];
            t3 !== null && (r4.matrix.fromArray(t3.transform.matrix), r4.matrix.decompose(r4.position, r4.rotation, r4.scale), r4.jointRadius = t3.radius), r4.visible = t3 !== null;
          }
          const n3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], s3 = n3.position.distanceTo(r3.position), a3 = 0.02, h2 = 5e-3;
          l2.inputState.pinching && s3 > a3 + h2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t2.handedness, target: this })) : !l2.inputState.pinching && s3 <= a3 - h2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t2.handedness, target: this }));
        } else
          a2 !== null && t2.gripSpace && (r2 = e2.getPose(t2.gripSpace, i2), r2 !== null && (a2.matrix.fromArray(r2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), r2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(r2.linearVelocity)) : a2.hasLinearVelocity = false, r2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(r2.angularVelocity)) : a2.hasAngularVelocity = false));
      return s2 !== null && (s2.visible = n2 !== null), a2 !== null && (a2.visible = r2 !== null), l2 !== null && (l2.visible = o2 !== null), this;
    }
  }
  class lr extends s {
    constructor(t2, e2) {
      super();
      const i2 = this, n2 = t2.state;
      let r2 = null, o2 = 1, s2 = null, a2 = "local-floor", l2 = null, h2 = null, u2 = null, c2 = null;
      const d2 = [], p2 = /* @__PURE__ */ new Map(), f2 = new Ue();
      f2.layers.enable(1), f2.viewport = new E();
      const m2 = new Ue();
      m2.layers.enable(2), m2.viewport = new E();
      const g2 = [f2, m2], v2 = new rr();
      v2.layers.enable(1), v2.layers.enable(2);
      let _2 = null, y2 = null;
      function x2(t3) {
        const e3 = p2.get(t3.inputSource);
        e3 && e3.dispatchEvent({ type: t3.type, data: t3.inputSource });
      }
      function b2() {
        p2.forEach(function(t3, e3) {
          t3.disconnect(e3);
        }), p2.clear(), _2 = null, y2 = null, n2.bindXRFramebuffer(null), t2.setRenderTarget(t2.getRenderTarget()), C2.stop(), i2.isPresenting = false, i2.dispatchEvent({ type: "sessionend" });
      }
      function T2(t3) {
        const e3 = r2.inputSources;
        for (let t4 = 0; t4 < d2.length; t4++)
          p2.set(e3[t4], d2[t4]);
        for (let e4 = 0; e4 < t3.removed.length; e4++) {
          const i3 = t3.removed[e4], n3 = p2.get(i3);
          n3 && (n3.dispatchEvent({ type: "disconnected", data: i3 }), p2.delete(i3));
        }
        for (let e4 = 0; e4 < t3.added.length; e4++) {
          const i3 = t3.added[e4], n3 = p2.get(i3);
          n3 && n3.dispatchEvent({ type: "connected", data: i3 });
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t3) {
        let e3 = d2[t3];
        return e3 === void 0 && (e3 = new ar(), d2[t3] = e3), e3.getTargetRaySpace();
      }, this.getControllerGrip = function(t3) {
        let e3 = d2[t3];
        return e3 === void 0 && (e3 = new ar(), d2[t3] = e3), e3.getGripSpace();
      }, this.getHand = function(t3) {
        let e3 = d2[t3];
        return e3 === void 0 && (e3 = new ar(), d2[t3] = e3), e3.getHandSpace();
      }, this.setFramebufferScaleFactor = function(t3) {
        o2 = t3, i2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(t3) {
        a2 = t3, i2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return s2;
      }, this.getSession = function() {
        return r2;
      }, this.setSession = async function(t3) {
        if (r2 = t3, r2 !== null) {
          r2.addEventListener("select", x2), r2.addEventListener("selectstart", x2), r2.addEventListener("selectend", x2), r2.addEventListener("squeeze", x2), r2.addEventListener("squeezestart", x2), r2.addEventListener("squeezeend", x2), r2.addEventListener("end", b2), r2.addEventListener("inputsourceschange", T2);
          const t4 = e2.getContextAttributes();
          if (t4.xrCompatible !== true && await e2.makeXRCompatible(), r2.renderState.layers === void 0) {
            const i3 = { antialias: t4.antialias, alpha: t4.alpha, depth: t4.depth, stencil: t4.stencil, framebufferScaleFactor: o2 }, n3 = new XRWebGLLayer(r2, e2, i3);
            r2.updateRenderState({ baseLayer: n3 });
          } else {
            let i3 = 0;
            t4.depth && (i3 = t4.stencil ? 34041 : 6402);
            const n3 = { colorFormat: t4.alpha ? 6408 : 6407, depthFormat: i3, scaleFactor: o2 };
            h2 = new XRWebGLBinding(r2, e2), c2 = h2.createProjectionLayer(n3), u2 = e2.createFramebuffer(), r2.updateRenderState({ layers: [c2] });
          }
          s2 = await r2.requestReferenceSpace(a2), C2.setContext(r2), C2.start(), i2.isPresenting = true, i2.dispatchEvent({ type: "sessionstart" });
        }
      };
      const S2 = new M(), w2 = new M();
      function A2(t3, e3) {
        e3 === null ? t3.matrixWorld.copy(t3.matrix) : t3.matrixWorld.multiplyMatrices(e3.matrixWorld, t3.matrix), t3.matrixWorldInverse.copy(t3.matrixWorld).invert();
      }
      this.updateCamera = function(t3) {
        if (r2 === null)
          return;
        v2.near = m2.near = f2.near = t3.near, v2.far = m2.far = f2.far = t3.far, _2 === v2.near && y2 === v2.far || (r2.updateRenderState({ depthNear: v2.near, depthFar: v2.far }), _2 = v2.near, y2 = v2.far);
        const e3 = t3.parent, i3 = v2.cameras;
        A2(v2, e3);
        for (let t4 = 0; t4 < i3.length; t4++)
          A2(i3[t4], e3);
        v2.matrixWorld.decompose(v2.position, v2.quaternion, v2.scale), t3.position.copy(v2.position), t3.quaternion.copy(v2.quaternion), t3.scale.copy(v2.scale), t3.matrix.copy(v2.matrix), t3.matrixWorld.copy(v2.matrixWorld);
        const n3 = t3.children;
        for (let t4 = 0, e4 = n3.length; t4 < e4; t4++)
          n3[t4].updateMatrixWorld(true);
        i3.length === 2 ? function(t4, e4, i4) {
          S2.setFromMatrixPosition(e4.matrixWorld), w2.setFromMatrixPosition(i4.matrixWorld);
          const n4 = S2.distanceTo(w2), r3 = e4.projectionMatrix.elements, o3 = i4.projectionMatrix.elements, s3 = r3[14] / (r3[10] - 1), a3 = r3[14] / (r3[10] + 1), l3 = (r3[9] + 1) / r3[5], h3 = (r3[9] - 1) / r3[5], u3 = (r3[8] - 1) / r3[0], c3 = (o3[8] + 1) / o3[0], d3 = s3 * u3, p3 = s3 * c3, f3 = n4 / (-u3 + c3), m3 = f3 * -u3;
          e4.matrixWorld.decompose(t4.position, t4.quaternion, t4.scale), t4.translateX(m3), t4.translateZ(f3), t4.matrixWorld.compose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
          const g3 = s3 + f3, v3 = a3 + f3, _3 = d3 - m3, y3 = p3 + (n4 - m3), x3 = l3 * a3 / v3 * g3, b3 = h3 * a3 / v3 * g3;
          t4.projectionMatrix.makePerspective(_3, y3, x3, b3, g3, v3);
        }(v2, f2, m2) : v2.projectionMatrix.copy(f2.projectionMatrix);
      }, this.getCamera = function() {
        return v2;
      };
      let R2 = null;
      const C2 = new Ze();
      C2.setAnimationLoop(function(t3, i3) {
        if (l2 = i3.getViewerPose(s2), l2 !== null) {
          const t4 = l2.views, i4 = r2.renderState.baseLayer;
          r2.renderState.layers === void 0 && n2.bindXRFramebuffer(i4.framebuffer);
          let o4 = false;
          t4.length !== v2.cameras.length && (v2.cameras.length = 0, o4 = true);
          for (let s3 = 0; s3 < t4.length; s3++) {
            const a3 = t4[s3];
            let l3 = null;
            if (r2.renderState.layers === void 0)
              l3 = i4.getViewport(a3);
            else {
              const t5 = h2.getViewSubImage(c2, a3);
              n2.bindXRFramebuffer(u2), e2.framebufferTexture2D(36160, 36064, 3553, t5.colorTexture, 0), t5.depthStencilTexture !== void 0 && e2.framebufferTexture2D(36160, 36096, 3553, t5.depthStencilTexture, 0), l3 = t5.viewport;
            }
            const d3 = g2[s3];
            d3.matrix.fromArray(a3.transform.matrix), d3.projectionMatrix.fromArray(a3.projectionMatrix), d3.viewport.set(l3.x, l3.y, l3.width, l3.height), s3 === 0 && v2.matrix.copy(d3.matrix), o4 === true && v2.cameras.push(d3);
          }
        }
        const o3 = r2.inputSources;
        for (let t4 = 0; t4 < d2.length; t4++) {
          const e3 = d2[t4], n3 = o3[t4];
          e3.update(n3, i3, s2);
        }
        R2 && R2(t3, i3);
      }), this.setAnimationLoop = function(t3) {
        R2 = t3;
      }, this.dispose = function() {
      };
    }
  }
  function hr(t2) {
    function e2(e3, i3) {
      e3.opacity.value = i3.opacity, i3.color && e3.diffuse.value.copy(i3.color), i3.emissive && e3.emissive.value.copy(i3.emissive).multiplyScalar(i3.emissiveIntensity), i3.map && (e3.map.value = i3.map), i3.alphaMap && (e3.alphaMap.value = i3.alphaMap), i3.specularMap && (e3.specularMap.value = i3.specularMap);
      const n2 = t2.get(i3).envMap;
      if (n2) {
        e3.envMap.value = n2, e3.flipEnvMap.value = n2.isCubeTexture && n2._needsFlipEnvMap ? -1 : 1, e3.reflectivity.value = i3.reflectivity, e3.refractionRatio.value = i3.refractionRatio;
        const r3 = t2.get(n2).__maxMipLevel;
        r3 !== void 0 && (e3.maxMipLevel.value = r3);
      }
      let r2, o2;
      i3.lightMap && (e3.lightMap.value = i3.lightMap, e3.lightMapIntensity.value = i3.lightMapIntensity), i3.aoMap && (e3.aoMap.value = i3.aoMap, e3.aoMapIntensity.value = i3.aoMapIntensity), i3.map ? r2 = i3.map : i3.specularMap ? r2 = i3.specularMap : i3.displacementMap ? r2 = i3.displacementMap : i3.normalMap ? r2 = i3.normalMap : i3.bumpMap ? r2 = i3.bumpMap : i3.roughnessMap ? r2 = i3.roughnessMap : i3.metalnessMap ? r2 = i3.metalnessMap : i3.alphaMap ? r2 = i3.alphaMap : i3.emissiveMap ? r2 = i3.emissiveMap : i3.clearcoatMap ? r2 = i3.clearcoatMap : i3.clearcoatNormalMap ? r2 = i3.clearcoatNormalMap : i3.clearcoatRoughnessMap && (r2 = i3.clearcoatRoughnessMap), r2 !== void 0 && (r2.isWebGLRenderTarget && (r2 = r2.texture), r2.matrixAutoUpdate === true && r2.updateMatrix(), e3.uvTransform.value.copy(r2.matrix)), i3.aoMap ? o2 = i3.aoMap : i3.lightMap && (o2 = i3.lightMap), o2 !== void 0 && (o2.isWebGLRenderTarget && (o2 = o2.texture), o2.matrixAutoUpdate === true && o2.updateMatrix(), e3.uv2Transform.value.copy(o2.matrix));
    }
    function i2(e3, i3) {
      e3.roughness.value = i3.roughness, e3.metalness.value = i3.metalness, i3.roughnessMap && (e3.roughnessMap.value = i3.roughnessMap), i3.metalnessMap && (e3.metalnessMap.value = i3.metalnessMap), i3.emissiveMap && (e3.emissiveMap.value = i3.emissiveMap), i3.bumpMap && (e3.bumpMap.value = i3.bumpMap, e3.bumpScale.value = i3.bumpScale, i3.side === 1 && (e3.bumpScale.value *= -1)), i3.normalMap && (e3.normalMap.value = i3.normalMap, e3.normalScale.value.copy(i3.normalScale), i3.side === 1 && e3.normalScale.value.negate()), i3.displacementMap && (e3.displacementMap.value = i3.displacementMap, e3.displacementScale.value = i3.displacementScale, e3.displacementBias.value = i3.displacementBias);
      t2.get(i3).envMap && (e3.envMapIntensity.value = i3.envMapIntensity);
    }
    return { refreshFogUniforms: function(t3, e3) {
      t3.fogColor.value.copy(e3.color), e3.isFog ? (t3.fogNear.value = e3.near, t3.fogFar.value = e3.far) : e3.isFogExp2 && (t3.fogDensity.value = e3.density);
    }, refreshMaterialUniforms: function(t3, n2, r2, o2, s2) {
      n2.isMeshBasicMaterial ? e2(t3, n2) : n2.isMeshLambertMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
      }(t3, n2)) : n2.isMeshToonMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.gradientMap && (t4.gradientMap.value = e3.gradientMap);
        e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
        e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
        e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      }(t3, n2)) : n2.isMeshPhongMaterial ? (e2(t3, n2), function(t4, e3) {
        t4.specular.value.copy(e3.specular), t4.shininess.value = Math.max(e3.shininess, 1e-4), e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
        e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
        e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      }(t3, n2)) : n2.isMeshStandardMaterial ? (e2(t3, n2), n2.isMeshPhysicalMaterial ? function(t4, e3, n3) {
        i2(t4, e3), t4.reflectivity.value = e3.reflectivity, t4.clearcoat.value = e3.clearcoat, t4.clearcoatRoughness.value = e3.clearcoatRoughness, e3.sheen && t4.sheen.value.copy(e3.sheen);
        e3.clearcoatMap && (t4.clearcoatMap.value = e3.clearcoatMap);
        e3.clearcoatRoughnessMap && (t4.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap);
        e3.clearcoatNormalMap && (t4.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t4.clearcoatNormalMap.value = e3.clearcoatNormalMap, e3.side === 1 && t4.clearcoatNormalScale.value.negate());
        t4.transmission.value = e3.transmission, e3.transmissionMap && (t4.transmissionMap.value = e3.transmissionMap);
        e3.transmission > 0 && (t4.transmissionSamplerMap.value = n3.texture, t4.transmissionSamplerSize.value.set(n3.width, n3.height));
        t4.thickness.value = e3.thickness, e3.thicknessMap && (t4.thicknessMap.value = e3.thicknessMap);
        t4.attenuationDistance.value = e3.attenuationDistance, t4.attenuationColor.value.copy(e3.attenuationColor);
      }(t3, n2, s2) : i2(t3, n2)) : n2.isMeshMatcapMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.matcap && (t4.matcap.value = e3.matcap);
        e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
        e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      }(t3, n2)) : n2.isMeshDepthMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      }(t3, n2)) : n2.isMeshDistanceMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
        t4.referencePosition.value.copy(e3.referencePosition), t4.nearDistance.value = e3.nearDistance, t4.farDistance.value = e3.farDistance;
      }(t3, n2)) : n2.isMeshNormalMaterial ? (e2(t3, n2), function(t4, e3) {
        e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
        e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
        e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      }(t3, n2)) : n2.isLineBasicMaterial ? (function(t4, e3) {
        t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity;
      }(t3, n2), n2.isLineDashedMaterial && function(t4, e3) {
        t4.dashSize.value = e3.dashSize, t4.totalSize.value = e3.dashSize + e3.gapSize, t4.scale.value = e3.scale;
      }(t3, n2)) : n2.isPointsMaterial ? function(t4, e3, i3, n3) {
        t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.size.value = e3.size * i3, t4.scale.value = 0.5 * n3, e3.map && (t4.map.value = e3.map);
        e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
        let r3;
        e3.map ? r3 = e3.map : e3.alphaMap && (r3 = e3.alphaMap);
        r3 !== void 0 && (r3.matrixAutoUpdate === true && r3.updateMatrix(), t4.uvTransform.value.copy(r3.matrix));
      }(t3, n2, r2, o2) : n2.isSpriteMaterial ? function(t4, e3) {
        t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.rotation.value = e3.rotation, e3.map && (t4.map.value = e3.map);
        e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
        let i3;
        e3.map ? i3 = e3.map : e3.alphaMap && (i3 = e3.alphaMap);
        i3 !== void 0 && (i3.matrixAutoUpdate === true && i3.updateMatrix(), t4.uvTransform.value.copy(i3.matrix));
      }(t3, n2) : n2.isShadowMaterial ? (t3.color.value.copy(n2.color), t3.opacity.value = n2.opacity) : n2.isShaderMaterial && (n2.uniformsNeedUpdate = false);
    } };
  }
  function ur(t2 = {}) {
    const e2 = t2.canvas !== void 0 ? t2.canvas : function() {
      const t3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      return t3.style.display = "block", t3;
    }(), i2 = t2.context !== void 0 ? t2.context : null, n2 = t2.alpha !== void 0 && t2.alpha, r2 = t2.depth === void 0 || t2.depth, o2 = t2.stencil === void 0 || t2.stencil, s2 = t2.antialias !== void 0 && t2.antialias, a2 = t2.premultipliedAlpha === void 0 || t2.premultipliedAlpha, l2 = t2.preserveDrawingBuffer !== void 0 && t2.preserveDrawingBuffer, h2 = t2.powerPreference !== void 0 ? t2.powerPreference : "default", u2 = t2.failIfMajorPerformanceCaveat !== void 0 && t2.failIfMajorPerformanceCaveat;
    let c2 = null, d2 = null;
    const p2 = [], f2 = [];
    this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
    const m2 = this;
    let g2 = false, v2 = 0, _2 = 0, y2 = null, x2 = -1, b2 = null;
    const T2 = new E(), A2 = new E();
    let R2 = null, C2 = e2.width, I2 = e2.height, P2 = 1, O2 = null, N2 = null;
    const L2 = new E(0, 0, C2, I2), D2 = new E(0, 0, C2, I2);
    let F2 = false;
    const B2 = [], U2 = new qe();
    let k2 = false, G2 = false, H2 = null;
    const j2 = new rt(), z2 = new M(), V2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function X2() {
      return y2 === null ? P2 : 1;
    }
    let W2, Y2, q2, Z2, J2, K2, Q2, $2, tt2, et2, it2, nt2, ot2, st2, at2, lt2, ht2, ut2, ct2, dt2, pt2, ft2, mt2 = i2;
    function gt2(t3, i3) {
      for (let n3 = 0; n3 < t3.length; n3++) {
        const r3 = t3[n3], o3 = e2.getContext(r3, i3);
        if (o3 !== null)
          return o3;
      }
      return null;
    }
    try {
      const t3 = { alpha: n2, depth: r2, stencil: o2, antialias: s2, premultipliedAlpha: a2, preserveDrawingBuffer: l2, powerPreference: h2, failIfMajorPerformanceCaveat: u2 };
      if (e2.addEventListener("webglcontextlost", yt2, false), e2.addEventListener("webglcontextrestored", xt2, false), mt2 === null) {
        const e3 = ["webgl2", "webgl", "experimental-webgl"];
        if (m2.isWebGL1Renderer === true && e3.shift(), mt2 = gt2(e3, t3), mt2 === null)
          throw gt2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      mt2.getShaderPrecisionFormat === void 0 && (mt2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (t3) {
      throw console.error("THREE.WebGLRenderer: " + t3.message), t3;
    }
    function vt2() {
      W2 = new ai(mt2), Y2 = new ri(mt2, W2, t2), W2.init(Y2), pt2 = new nr(mt2, W2, Y2), q2 = new er(mt2, W2, Y2), B2[0] = 1029, Z2 = new ui(), J2 = new Hn(), K2 = new ir(mt2, W2, q2, J2, Y2, pt2, Z2), Q2 = new si(m2), $2 = new Je(mt2, Y2), ft2 = new ii(mt2, W2, $2, Y2), tt2 = new li(mt2, $2, Z2, ft2), et2 = new fi(mt2, tt2, $2, Z2), ut2 = new pi(mt2), at2 = new oi(J2), it2 = new Gn(m2, Q2, W2, Y2, ft2, at2), nt2 = new hr(J2), ot2 = new Xn(J2), st2 = new Kn(W2, Y2), ht2 = new ei(m2, Q2, q2, et2, a2), lt2 = new tr(m2, et2, Y2), ct2 = new ni(mt2, W2, Z2, Y2), dt2 = new hi(mt2, W2, Z2, Y2), Z2.programs = it2.programs, m2.capabilities = Y2, m2.extensions = W2, m2.properties = J2, m2.renderLists = ot2, m2.shadowMap = lt2, m2.state = q2, m2.info = Z2;
    }
    vt2();
    const _t2 = new lr(m2, mt2);
    function yt2(t3) {
      t3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g2 = true;
    }
    function xt2() {
      console.log("THREE.WebGLRenderer: Context Restored."), g2 = false;
      const t3 = Z2.autoReset, e3 = lt2.enabled, i3 = lt2.autoUpdate, n3 = lt2.needsUpdate, r3 = lt2.type;
      vt2(), Z2.autoReset = t3, lt2.enabled = e3, lt2.autoUpdate = i3, lt2.needsUpdate = n3, lt2.type = r3;
    }
    function bt2(t3) {
      const e3 = t3.target;
      e3.removeEventListener("dispose", bt2), function(t4) {
        (function(t5) {
          const e4 = J2.get(t5).programs;
          e4 !== void 0 && e4.forEach(function(t6) {
            it2.releaseProgram(t6);
          });
        })(t4), J2.remove(t4);
      }(e3);
    }
    this.xr = _t2, this.getContext = function() {
      return mt2;
    }, this.getContextAttributes = function() {
      return mt2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const t3 = W2.get("WEBGL_lose_context");
      t3 && t3.loseContext();
    }, this.forceContextRestore = function() {
      const t3 = W2.get("WEBGL_lose_context");
      t3 && t3.restoreContext();
    }, this.getPixelRatio = function() {
      return P2;
    }, this.setPixelRatio = function(t3) {
      t3 !== void 0 && (P2 = t3, this.setSize(C2, I2, false));
    }, this.getSize = function(t3) {
      return t3.set(C2, I2);
    }, this.setSize = function(t3, i3, n3) {
      _t2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (C2 = t3, I2 = i3, e2.width = Math.floor(t3 * P2), e2.height = Math.floor(i3 * P2), n3 !== false && (e2.style.width = t3 + "px", e2.style.height = i3 + "px"), this.setViewport(0, 0, t3, i3));
    }, this.getDrawingBufferSize = function(t3) {
      return t3.set(C2 * P2, I2 * P2).floor();
    }, this.setDrawingBufferSize = function(t3, i3, n3) {
      C2 = t3, I2 = i3, P2 = n3, e2.width = Math.floor(t3 * n3), e2.height = Math.floor(i3 * n3), this.setViewport(0, 0, t3, i3);
    }, this.getCurrentViewport = function(t3) {
      return t3.copy(T2);
    }, this.getViewport = function(t3) {
      return t3.copy(L2);
    }, this.setViewport = function(t3, e3, i3, n3) {
      t3.isVector4 ? L2.set(t3.x, t3.y, t3.z, t3.w) : L2.set(t3, e3, i3, n3), q2.viewport(T2.copy(L2).multiplyScalar(P2).floor());
    }, this.getScissor = function(t3) {
      return t3.copy(D2);
    }, this.setScissor = function(t3, e3, i3, n3) {
      t3.isVector4 ? D2.set(t3.x, t3.y, t3.z, t3.w) : D2.set(t3, e3, i3, n3), q2.scissor(A2.copy(D2).multiplyScalar(P2).floor());
    }, this.getScissorTest = function() {
      return F2;
    }, this.setScissorTest = function(t3) {
      q2.setScissorTest(F2 = t3);
    }, this.setOpaqueSort = function(t3) {
      O2 = t3;
    }, this.setTransparentSort = function(t3) {
      N2 = t3;
    }, this.getClearColor = function(t3) {
      return t3.copy(ht2.getClearColor());
    }, this.setClearColor = function() {
      ht2.setClearColor.apply(ht2, arguments);
    }, this.getClearAlpha = function() {
      return ht2.getClearAlpha();
    }, this.setClearAlpha = function() {
      ht2.setClearAlpha.apply(ht2, arguments);
    }, this.clear = function(t3, e3, i3) {
      let n3 = 0;
      (t3 === void 0 || t3) && (n3 |= 16384), (e3 === void 0 || e3) && (n3 |= 256), (i3 === void 0 || i3) && (n3 |= 1024), mt2.clear(n3);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      e2.removeEventListener("webglcontextlost", yt2, false), e2.removeEventListener("webglcontextrestored", xt2, false), ot2.dispose(), st2.dispose(), J2.dispose(), Q2.dispose(), et2.dispose(), ft2.dispose(), _t2.dispose(), _t2.removeEventListener("sessionstart", Et2), _t2.removeEventListener("sessionend", St2), H2 && (H2.dispose(), H2 = null), wt2.stop();
    }, this.renderBufferImmediate = function(t3, e3) {
      ft2.initAttributes();
      const i3 = J2.get(t3);
      t3.hasPositions && !i3.position && (i3.position = mt2.createBuffer()), t3.hasNormals && !i3.normal && (i3.normal = mt2.createBuffer()), t3.hasUvs && !i3.uv && (i3.uv = mt2.createBuffer()), t3.hasColors && !i3.color && (i3.color = mt2.createBuffer());
      const n3 = e3.getAttributes();
      t3.hasPositions && (mt2.bindBuffer(34962, i3.position), mt2.bufferData(34962, t3.positionArray, 35048), ft2.enableAttribute(n3.position), mt2.vertexAttribPointer(n3.position, 3, 5126, false, 0, 0)), t3.hasNormals && (mt2.bindBuffer(34962, i3.normal), mt2.bufferData(34962, t3.normalArray, 35048), ft2.enableAttribute(n3.normal), mt2.vertexAttribPointer(n3.normal, 3, 5126, false, 0, 0)), t3.hasUvs && (mt2.bindBuffer(34962, i3.uv), mt2.bufferData(34962, t3.uvArray, 35048), ft2.enableAttribute(n3.uv), mt2.vertexAttribPointer(n3.uv, 2, 5126, false, 0, 0)), t3.hasColors && (mt2.bindBuffer(34962, i3.color), mt2.bufferData(34962, t3.colorArray, 35048), ft2.enableAttribute(n3.color), mt2.vertexAttribPointer(n3.color, 3, 5126, false, 0, 0)), ft2.disableUnusedAttributes(), mt2.drawArrays(4, 0, t3.count), t3.count = 0;
    }, this.renderBufferDirect = function(t3, e3, i3, n3, r3, o3) {
      e3 === null && (e3 = V2);
      const s3 = r3.isMesh && r3.matrixWorld.determinant() < 0, a3 = It2(t3, e3, n3, r3);
      q2.setMaterial(n3, s3);
      let l3 = i3.index;
      const h3 = i3.attributes.position;
      if (l3 === null) {
        if (h3 === void 0 || h3.count === 0)
          return;
      } else if (l3.count === 0)
        return;
      let u3, c3 = 1;
      n3.wireframe === true && (l3 = tt2.getWireframeAttribute(i3), c3 = 2), (n3.morphTargets || n3.morphNormals) && ut2.update(r3, i3, n3, a3), ft2.setup(r3, n3, a3, i3, l3);
      let d3 = ct2;
      l3 !== null && (u3 = $2.get(l3), d3 = dt2, d3.setIndex(u3));
      const p3 = l3 !== null ? l3.count : h3.count, f3 = i3.drawRange.start * c3, m3 = i3.drawRange.count * c3, g3 = o3 !== null ? o3.start * c3 : 0, v3 = o3 !== null ? o3.count * c3 : 1 / 0, _3 = Math.max(f3, g3), y3 = Math.min(p3, f3 + m3, g3 + v3) - 1, x3 = Math.max(0, y3 - _3 + 1);
      if (x3 !== 0) {
        if (r3.isMesh)
          n3.wireframe === true ? (q2.setLineWidth(n3.wireframeLinewidth * X2()), d3.setMode(1)) : d3.setMode(4);
        else if (r3.isLine) {
          let t4 = n3.linewidth;
          t4 === void 0 && (t4 = 1), q2.setLineWidth(t4 * X2()), r3.isLineSegments ? d3.setMode(1) : r3.isLineLoop ? d3.setMode(2) : d3.setMode(3);
        } else
          r3.isPoints ? d3.setMode(0) : r3.isSprite && d3.setMode(4);
        if (r3.isInstancedMesh)
          d3.renderInstances(_3, x3, r3.count);
        else if (i3.isInstancedBufferGeometry) {
          const t4 = Math.min(i3.instanceCount, i3._maxInstanceCount);
          d3.renderInstances(_3, x3, t4);
        } else
          d3.render(_3, x3);
      }
    }, this.compile = function(t3, e3) {
      d2 = st2.get(t3), d2.init(), t3.traverseVisible(function(t4) {
        t4.isLight && t4.layers.test(e3.layers) && (d2.pushLight(t4), t4.castShadow && d2.pushShadow(t4));
      }), d2.setupLights(), t3.traverse(function(e4) {
        const i3 = e4.material;
        if (i3)
          if (Array.isArray(i3))
            for (let n3 = 0; n3 < i3.length; n3++) {
              Rt2(i3[n3], t3, e4);
            }
          else
            Rt2(i3, t3, e4);
      });
    };
    let Tt2 = null;
    function Et2() {
      wt2.stop();
    }
    function St2() {
      wt2.start();
    }
    const wt2 = new Ze();
    function At2(t3, e3, i3) {
      const n3 = e3.isScene === true ? e3.overrideMaterial : null;
      for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
        const o4 = t3[r3], s3 = o4.object, a3 = o4.geometry, l3 = n3 === null ? o4.material : n3, h3 = o4.group;
        if (i3.isArrayCamera) {
          const t4 = i3.cameras;
          for (let i4 = 0, n4 = t4.length; i4 < n4; i4++) {
            const n5 = t4[i4];
            s3.layers.test(n5.layers) && (q2.viewport(T2.copy(n5.viewport)), d2.setupLightsView(n5), Mt2(s3, e3, n5, a3, l3, h3));
          }
        } else
          Mt2(s3, e3, i3, a3, l3, h3);
      }
    }
    function Mt2(t3, e3, i3, n3, r3, o3) {
      if (t3.onBeforeRender(m2, e3, i3, n3, r3, o3), t3.modelViewMatrix.multiplyMatrices(i3.matrixWorldInverse, t3.matrixWorld), t3.normalMatrix.getNormalMatrix(t3.modelViewMatrix), t3.isImmediateRenderObject) {
        const n4 = It2(i3, e3, r3, t3);
        q2.setMaterial(r3), ft2.reset(), function(t4, e4) {
          t4.render(function(t5) {
            m2.renderBufferImmediate(t5, e4);
          });
        }(t3, n4);
      } else
        r3.transparent === true && r3.side === 2 ? (r3.side = 1, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t3, o3), r3.side = 0, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t3, o3), r3.side = 2) : m2.renderBufferDirect(i3, e3, n3, r3, t3, o3);
      t3.onAfterRender(m2, e3, i3, n3, r3, o3);
    }
    function Rt2(t3, e3, i3) {
      e3.isScene !== true && (e3 = V2);
      const n3 = J2.get(t3), r3 = d2.state.lights, o3 = d2.state.shadowsArray, s3 = r3.state.version, a3 = it2.getParameters(t3, r3.state, o3, e3, i3), l3 = it2.getProgramCacheKey(a3);
      let h3 = n3.programs;
      n3.environment = t3.isMeshStandardMaterial ? e3.environment : null, n3.fog = e3.fog, n3.envMap = Q2.get(t3.envMap || n3.environment), h3 === void 0 && (t3.addEventListener("dispose", bt2), h3 = /* @__PURE__ */ new Map(), n3.programs = h3);
      let u3 = h3.get(l3);
      if (u3 !== void 0) {
        if (n3.currentProgram === u3 && n3.lightsStateVersion === s3)
          return Ct2(t3, a3), u3;
      } else
        a3.uniforms = it2.getUniforms(t3), t3.onBuild(a3, m2), t3.onBeforeCompile(a3, m2), u3 = it2.acquireProgram(a3, l3), h3.set(l3, u3), n3.uniforms = a3.uniforms;
      const c3 = n3.uniforms;
      (t3.isShaderMaterial || t3.isRawShaderMaterial) && t3.clipping !== true || (c3.clippingPlanes = at2.uniform), Ct2(t3, a3), n3.needsLights = function(t4) {
        return t4.isMeshLambertMaterial || t4.isMeshToonMaterial || t4.isMeshPhongMaterial || t4.isMeshStandardMaterial || t4.isShadowMaterial || t4.isShaderMaterial && t4.lights === true;
      }(t3), n3.lightsStateVersion = s3, n3.needsLights && (c3.ambientLightColor.value = r3.state.ambient, c3.lightProbe.value = r3.state.probe, c3.directionalLights.value = r3.state.directional, c3.directionalLightShadows.value = r3.state.directionalShadow, c3.spotLights.value = r3.state.spot, c3.spotLightShadows.value = r3.state.spotShadow, c3.rectAreaLights.value = r3.state.rectArea, c3.ltc_1.value = r3.state.rectAreaLTC1, c3.ltc_2.value = r3.state.rectAreaLTC2, c3.pointLights.value = r3.state.point, c3.pointLightShadows.value = r3.state.pointShadow, c3.hemisphereLights.value = r3.state.hemi, c3.directionalShadowMap.value = r3.state.directionalShadowMap, c3.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, c3.spotShadowMap.value = r3.state.spotShadowMap, c3.spotShadowMatrix.value = r3.state.spotShadowMatrix, c3.pointShadowMap.value = r3.state.pointShadowMap, c3.pointShadowMatrix.value = r3.state.pointShadowMatrix);
      const p3 = u3.getUniforms(), f3 = yn.seqWithValue(p3.seq, c3);
      return n3.currentProgram = u3, n3.uniformsList = f3, u3;
    }
    function Ct2(t3, e3) {
      const i3 = J2.get(t3);
      i3.outputEncoding = e3.outputEncoding, i3.instancing = e3.instancing, i3.skinning = e3.skinning, i3.numClippingPlanes = e3.numClippingPlanes, i3.numIntersection = e3.numClipIntersection, i3.vertexAlphas = e3.vertexAlphas;
    }
    function It2(t3, e3, i3, n3) {
      e3.isScene !== true && (e3 = V2), K2.resetTextureUnits();
      const r3 = e3.fog, o3 = i3.isMeshStandardMaterial ? e3.environment : null, s3 = y2 === null ? m2.outputEncoding : y2.texture.encoding, a3 = Q2.get(i3.envMap || o3), l3 = i3.vertexColors === true && n3.geometry && n3.geometry.attributes.color && n3.geometry.attributes.color.itemSize === 4, h3 = J2.get(i3), u3 = d2.state.lights;
      if (k2 === true && (G2 === true || t3 !== b2)) {
        const e4 = t3 === b2 && i3.id === x2;
        at2.setState(i3, t3, e4);
      }
      let c3 = false;
      i3.version === h3.__version ? h3.needsLights && h3.lightsStateVersion !== u3.state.version || h3.outputEncoding !== s3 || n3.isInstancedMesh && h3.instancing === false ? c3 = true : n3.isInstancedMesh || h3.instancing !== true ? n3.isSkinnedMesh && h3.skinning === false ? c3 = true : n3.isSkinnedMesh || h3.skinning !== true ? h3.envMap !== a3 || i3.fog && h3.fog !== r3 ? c3 = true : h3.numClippingPlanes === void 0 || h3.numClippingPlanes === at2.numPlanes && h3.numIntersection === at2.numIntersection ? h3.vertexAlphas !== l3 && (c3 = true) : c3 = true : c3 = true : c3 = true : (c3 = true, h3.__version = i3.version);
      let p3 = h3.currentProgram;
      c3 === true && (p3 = Rt2(i3, e3, n3));
      let f3 = false, g3 = false, v3 = false;
      const _3 = p3.getUniforms(), T3 = h3.uniforms;
      if (q2.useProgram(p3.program) && (f3 = true, g3 = true, v3 = true), i3.id !== x2 && (x2 = i3.id, g3 = true), f3 || b2 !== t3) {
        if (_3.setValue(mt2, "projectionMatrix", t3.projectionMatrix), Y2.logarithmicDepthBuffer && _3.setValue(mt2, "logDepthBufFC", 2 / (Math.log(t3.far + 1) / Math.LN2)), b2 !== t3 && (b2 = t3, g3 = true, v3 = true), i3.isShaderMaterial || i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshStandardMaterial || i3.envMap) {
          const e4 = _3.map.cameraPosition;
          e4 !== void 0 && e4.setValue(mt2, z2.setFromMatrixPosition(t3.matrixWorld));
        }
        (i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshLambertMaterial || i3.isMeshBasicMaterial || i3.isMeshStandardMaterial || i3.isShaderMaterial) && _3.setValue(mt2, "isOrthographic", t3.isOrthographicCamera === true), (i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshLambertMaterial || i3.isMeshBasicMaterial || i3.isMeshStandardMaterial || i3.isShaderMaterial || i3.isShadowMaterial || n3.isSkinnedMesh) && _3.setValue(mt2, "viewMatrix", t3.matrixWorldInverse);
      }
      if (n3.isSkinnedMesh) {
        _3.setOptional(mt2, n3, "bindMatrix"), _3.setOptional(mt2, n3, "bindMatrixInverse");
        const t4 = n3.skeleton;
        t4 && (Y2.floatVertexTextures ? (t4.boneTexture === null && t4.computeBoneTexture(), _3.setValue(mt2, "boneTexture", t4.boneTexture, K2), _3.setValue(mt2, "boneTextureSize", t4.boneTextureSize)) : _3.setOptional(mt2, t4, "boneMatrices"));
      }
      var E2, S2;
      return (g3 || h3.receiveShadow !== n3.receiveShadow) && (h3.receiveShadow = n3.receiveShadow, _3.setValue(mt2, "receiveShadow", n3.receiveShadow)), g3 && (_3.setValue(mt2, "toneMappingExposure", m2.toneMappingExposure), h3.needsLights && (S2 = v3, (E2 = T3).ambientLightColor.needsUpdate = S2, E2.lightProbe.needsUpdate = S2, E2.directionalLights.needsUpdate = S2, E2.directionalLightShadows.needsUpdate = S2, E2.pointLights.needsUpdate = S2, E2.pointLightShadows.needsUpdate = S2, E2.spotLights.needsUpdate = S2, E2.spotLightShadows.needsUpdate = S2, E2.rectAreaLights.needsUpdate = S2, E2.hemisphereLights.needsUpdate = S2), r3 && i3.fog && nt2.refreshFogUniforms(T3, r3), nt2.refreshMaterialUniforms(T3, i3, P2, I2, H2), yn.upload(mt2, h3.uniformsList, T3, K2)), i3.isShaderMaterial && i3.uniformsNeedUpdate === true && (yn.upload(mt2, h3.uniformsList, T3, K2), i3.uniformsNeedUpdate = false), i3.isSpriteMaterial && _3.setValue(mt2, "center", n3.center), _3.setValue(mt2, "modelViewMatrix", n3.modelViewMatrix), _3.setValue(mt2, "normalMatrix", n3.normalMatrix), _3.setValue(mt2, "modelMatrix", n3.matrixWorld), p3;
    }
    wt2.setAnimationLoop(function(t3) {
      Tt2 && Tt2(t3);
    }), typeof window != "undefined" && wt2.setContext(window), this.setAnimationLoop = function(t3) {
      Tt2 = t3, _t2.setAnimationLoop(t3), t3 === null ? wt2.stop() : wt2.start();
    }, _t2.addEventListener("sessionstart", Et2), _t2.addEventListener("sessionend", St2), this.render = function(t3, e3) {
      if (e3 !== void 0 && e3.isCamera !== true)
        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (g2 === true)
        return;
      t3.autoUpdate === true && t3.updateMatrixWorld(), e3.parent === null && e3.updateMatrixWorld(), _t2.enabled === true && _t2.isPresenting === true && (_t2.cameraAutoUpdate === true && _t2.updateCamera(e3), e3 = _t2.getCamera()), t3.isScene === true && t3.onBeforeRender(m2, t3, e3, y2), d2 = st2.get(t3, f2.length), d2.init(), f2.push(d2), j2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), U2.setFromProjectionMatrix(j2), G2 = this.localClippingEnabled, k2 = at2.init(this.clippingPlanes, G2, e3), c2 = ot2.get(t3, p2.length), c2.init(), p2.push(c2), function t4(e4, i4, n4, r4) {
        if (e4.visible === false)
          return;
        if (e4.layers.test(i4.layers)) {
          if (e4.isGroup)
            n4 = e4.renderOrder;
          else if (e4.isLOD)
            e4.autoUpdate === true && e4.update(i4);
          else if (e4.isLight)
            d2.pushLight(e4), e4.castShadow && d2.pushShadow(e4);
          else if (e4.isSprite) {
            if (!e4.frustumCulled || U2.intersectsSprite(e4)) {
              r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2);
              const t5 = et2.update(e4), i5 = e4.material;
              i5.visible && c2.push(e4, t5, i5, n4, z2.z, null);
            }
          } else if (e4.isImmediateRenderObject)
            r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2), c2.push(e4, null, e4.material, n4, z2.z, null);
          else if ((e4.isMesh || e4.isLine || e4.isPoints) && (e4.isSkinnedMesh && e4.skeleton.frame !== Z2.render.frame && (e4.skeleton.update(), e4.skeleton.frame = Z2.render.frame), !e4.frustumCulled || U2.intersectsObject(e4))) {
            r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2);
            const t5 = et2.update(e4), i5 = e4.material;
            if (Array.isArray(i5)) {
              const r5 = t5.groups;
              for (let o5 = 0, s3 = r5.length; o5 < s3; o5++) {
                const s4 = r5[o5], a3 = i5[s4.materialIndex];
                a3 && a3.visible && c2.push(e4, t5, a3, n4, z2.z, s4);
              }
            } else
              i5.visible && c2.push(e4, t5, i5, n4, z2.z, null);
          }
        }
        const o4 = e4.children;
        for (let e5 = 0, s3 = o4.length; e5 < s3; e5++)
          t4(o4[e5], i4, n4, r4);
      }(t3, e3, 0, m2.sortObjects), c2.finish(), m2.sortObjects === true && c2.sort(O2, N2), k2 === true && at2.beginShadows();
      const i3 = d2.state.shadowsArray;
      lt2.render(i3, t3, e3), d2.setupLights(), d2.setupLightsView(e3), k2 === true && at2.endShadows(), this.info.autoReset === true && this.info.reset(), ht2.render(c2, t3);
      const n3 = c2.opaque, r3 = c2.transmissive, o3 = c2.transparent;
      n3.length > 0 && At2(n3, t3, e3), r3.length > 0 && function(t4, e4, i4, n4) {
        if (H2 === null) {
          const t5 = s2 === true && Y2.isWebGL2 === true;
          H2 = new (t5 ? w : S)(1024, 1024, { generateMipmaps: true, type: pt2.convert(1016) !== null ? 1016 : 1009, minFilter: 1008, magFilter: 1003, wrapS: 1001, wrapT: 1001 });
        }
        const r4 = m2.getRenderTarget();
        m2.setRenderTarget(H2), m2.clear();
        const o4 = m2.toneMapping;
        m2.toneMapping = 0, At2(t4, i4, n4), m2.toneMapping = o4, K2.updateMultisampleRenderTarget(H2), K2.updateRenderTargetMipmap(H2), m2.setRenderTarget(r4), At2(e4, i4, n4);
      }(n3, r3, t3, e3), o3.length > 0 && At2(o3, t3, e3), y2 !== null && (K2.updateMultisampleRenderTarget(y2), K2.updateRenderTargetMipmap(y2)), t3.isScene === true && t3.onAfterRender(m2, t3, e3), q2.buffers.depth.setTest(true), q2.buffers.depth.setMask(true), q2.buffers.color.setMask(true), q2.setPolygonOffset(false), ft2.resetDefaultState(), x2 = -1, b2 = null, f2.pop(), d2 = f2.length > 0 ? f2[f2.length - 1] : null, p2.pop(), c2 = p2.length > 0 ? p2[p2.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return v2;
    }, this.getActiveMipmapLevel = function() {
      return _2;
    }, this.getRenderTarget = function() {
      return y2;
    }, this.setRenderTarget = function(t3, e3 = 0, i3 = 0) {
      y2 = t3, v2 = e3, _2 = i3, t3 && J2.get(t3).__webglFramebuffer === void 0 && K2.setupRenderTarget(t3);
      let n3 = null, r3 = false, o3 = false;
      if (t3) {
        const i4 = t3.texture;
        (i4.isDataTexture3D || i4.isDataTexture2DArray) && (o3 = true);
        const s3 = J2.get(t3).__webglFramebuffer;
        t3.isWebGLCubeRenderTarget ? (n3 = s3[e3], r3 = true) : n3 = t3.isWebGLMultisampleRenderTarget ? J2.get(t3).__webglMultisampledFramebuffer : s3, T2.copy(t3.viewport), A2.copy(t3.scissor), R2 = t3.scissorTest;
      } else
        T2.copy(L2).multiplyScalar(P2).floor(), A2.copy(D2).multiplyScalar(P2).floor(), R2 = F2;
      if (q2.bindFramebuffer(36160, n3) && Y2.drawBuffers) {
        let e4 = false;
        if (t3)
          if (t3.isWebGLMultipleRenderTargets) {
            const i4 = t3.texture;
            if (B2.length !== i4.length || B2[0] !== 36064) {
              for (let t4 = 0, e5 = i4.length; t4 < e5; t4++)
                B2[t4] = 36064 + t4;
              B2.length = i4.length, e4 = true;
            }
          } else
            B2.length === 1 && B2[0] === 36064 || (B2[0] = 36064, B2.length = 1, e4 = true);
        else
          B2.length === 1 && B2[0] === 1029 || (B2[0] = 1029, B2.length = 1, e4 = true);
        e4 && (Y2.isWebGL2 ? mt2.drawBuffers(B2) : W2.get("WEBGL_draw_buffers").drawBuffersWEBGL(B2));
      }
      if (q2.viewport(T2), q2.scissor(A2), q2.setScissorTest(R2), r3) {
        const n4 = J2.get(t3.texture);
        mt2.framebufferTexture2D(36160, 36064, 34069 + e3, n4.__webglTexture, i3);
      } else if (o3) {
        const n4 = J2.get(t3.texture), r4 = e3 || 0;
        mt2.framebufferTextureLayer(36160, 36064, n4.__webglTexture, i3 || 0, r4);
      }
    }, this.readRenderTargetPixels = function(t3, e3, i3, n3, r3, o3, s3) {
      if (!t3 || !t3.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let a3 = J2.get(t3).__webglFramebuffer;
      if (t3.isWebGLCubeRenderTarget && s3 !== void 0 && (a3 = a3[s3]), a3) {
        q2.bindFramebuffer(36160, a3);
        try {
          const s4 = t3.texture, a4 = s4.format, l3 = s4.type;
          if (a4 !== 1023 && pt2.convert(a4) !== mt2.getParameter(35739))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const h3 = l3 === 1016 && (W2.has("EXT_color_buffer_half_float") || Y2.isWebGL2 && W2.has("EXT_color_buffer_float"));
          if (!(l3 === 1009 || pt2.convert(l3) === mt2.getParameter(35738) || l3 === 1015 && (Y2.isWebGL2 || W2.has("OES_texture_float") || W2.has("WEBGL_color_buffer_float")) || h3))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          mt2.checkFramebufferStatus(36160) === 36053 ? e3 >= 0 && e3 <= t3.width - n3 && i3 >= 0 && i3 <= t3.height - r3 && mt2.readPixels(e3, i3, n3, r3, pt2.convert(a4), pt2.convert(l3), o3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        } finally {
          const t4 = y2 !== null ? J2.get(y2).__webglFramebuffer : null;
          q2.bindFramebuffer(36160, t4);
        }
      }
    }, this.copyFramebufferToTexture = function(t3, e3, i3 = 0) {
      const n3 = Math.pow(2, -i3), r3 = Math.floor(e3.image.width * n3), o3 = Math.floor(e3.image.height * n3);
      let s3 = pt2.convert(e3.format);
      Y2.isWebGL2 && (s3 === 6407 && (s3 = 32849), s3 === 6408 && (s3 = 32856)), K2.setTexture2D(e3, 0), mt2.copyTexImage2D(3553, i3, s3, t3.x, t3.y, r3, o3, 0), q2.unbindTexture();
    }, this.copyTextureToTexture = function(t3, e3, i3, n3 = 0) {
      const r3 = e3.image.width, o3 = e3.image.height, s3 = pt2.convert(i3.format), a3 = pt2.convert(i3.type);
      K2.setTexture2D(i3, 0), mt2.pixelStorei(37440, i3.flipY), mt2.pixelStorei(37441, i3.premultiplyAlpha), mt2.pixelStorei(3317, i3.unpackAlignment), e3.isDataTexture ? mt2.texSubImage2D(3553, n3, t3.x, t3.y, r3, o3, s3, a3, e3.image.data) : e3.isCompressedTexture ? mt2.compressedTexSubImage2D(3553, n3, t3.x, t3.y, e3.mipmaps[0].width, e3.mipmaps[0].height, s3, e3.mipmaps[0].data) : mt2.texSubImage2D(3553, n3, t3.x, t3.y, s3, a3, e3.image), n3 === 0 && i3.generateMipmaps && mt2.generateMipmap(3553), q2.unbindTexture();
    }, this.copyTextureToTexture3D = function(t3, e3, i3, n3, r3 = 0) {
      if (m2.isWebGL1Renderer)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const o3 = t3.max.x - t3.min.x + 1, s3 = t3.max.y - t3.min.y + 1, a3 = t3.max.z - t3.min.z + 1, l3 = pt2.convert(n3.format), h3 = pt2.convert(n3.type);
      let u3;
      if (n3.isDataTexture3D)
        K2.setTexture3D(n3, 0), u3 = 32879;
      else {
        if (!n3.isDataTexture2DArray)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        K2.setTexture2DArray(n3, 0), u3 = 35866;
      }
      mt2.pixelStorei(37440, n3.flipY), mt2.pixelStorei(37441, n3.premultiplyAlpha), mt2.pixelStorei(3317, n3.unpackAlignment);
      const c3 = mt2.getParameter(3314), d3 = mt2.getParameter(32878), p3 = mt2.getParameter(3316), f3 = mt2.getParameter(3315), g3 = mt2.getParameter(32877), v3 = i3.isCompressedTexture ? i3.mipmaps[0] : i3.image;
      mt2.pixelStorei(3314, v3.width), mt2.pixelStorei(32878, v3.height), mt2.pixelStorei(3316, t3.min.x), mt2.pixelStorei(3315, t3.min.y), mt2.pixelStorei(32877, t3.min.z), i3.isDataTexture || i3.isDataTexture3D ? mt2.texSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, h3, v3.data) : i3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), mt2.compressedTexSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, v3.data)) : mt2.texSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, h3, v3), mt2.pixelStorei(3314, c3), mt2.pixelStorei(32878, d3), mt2.pixelStorei(3316, p3), mt2.pixelStorei(3315, f3), mt2.pixelStorei(32877, g3), r3 === 0 && n3.generateMipmaps && mt2.generateMipmap(u3), q2.unbindTexture();
    }, this.initTexture = function(t3) {
      K2.setTexture2D(t3, 0), q2.unbindTexture();
    }, this.resetState = function() {
      v2 = 0, _2 = 0, y2 = null, q2.reset(), ft2.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  (class extends ur {
  }).prototype.isWebGL1Renderer = true;
  class pr extends Ct {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(t2, e2) {
      return super.copy(t2, e2), t2.background !== null && (this.background = t2.background.clone()), t2.environment !== null && (this.environment = t2.environment.clone()), t2.fog !== null && (this.fog = t2.fog.clone()), t2.overrideMaterial !== null && (this.overrideMaterial = t2.overrideMaterial.clone()), this.autoUpdate = t2.autoUpdate, this.matrixAutoUpdate = t2.matrixAutoUpdate, this;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return this.fog !== null && (e2.object.fog = this.fog.toJSON()), e2;
    }
  }
  pr.prototype.isScene = true;
  class fr {
    constructor(t2, e2) {
      this.array = t2, this.stride = e2, this.count = t2 !== void 0 ? t2.length / e2 : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = u();
    }
    onUploadCallback() {
    }
    set needsUpdate(t2) {
      t2 === true && this.version++;
    }
    setUsage(t2) {
      return this.usage = t2, this;
    }
    copy(t2) {
      return this.array = new t2.array.constructor(t2.array), this.count = t2.count, this.stride = t2.stride, this.usage = t2.usage, this;
    }
    copyAt(t2, e2, i2) {
      t2 *= this.stride, i2 *= e2.stride;
      for (let n2 = 0, r2 = this.stride; n2 < r2; n2++)
        this.array[t2 + n2] = e2.array[i2 + n2];
      return this;
    }
    set(t2, e2 = 0) {
      return this.array.set(t2, e2), this;
    }
    clone(t2) {
      t2.arrayBuffers === void 0 && (t2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = u()), t2.arrayBuffers[this.array.buffer._uuid] === void 0 && (t2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e2 = new this.array.constructor(t2.arrayBuffers[this.array.buffer._uuid]), i2 = new this.constructor(e2, this.stride);
      return i2.setUsage(this.usage), i2;
    }
    onUpload(t2) {
      return this.onUploadCallback = t2, this;
    }
    toJSON(t2) {
      return t2.arrayBuffers === void 0 && (t2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = u()), t2.arrayBuffers[this.array.buffer._uuid] === void 0 && (t2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  }
  fr.prototype.isInterleavedBuffer = true;
  const mr = new M();
  class gr {
    constructor(t2, e2, i2, n2 = false) {
      this.name = "", this.data = t2, this.itemSize = e2, this.offset = i2, this.normalized = n2 === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t2) {
      this.data.needsUpdate = t2;
    }
    applyMatrix4(t2) {
      for (let e2 = 0, i2 = this.data.count; e2 < i2; e2++)
        mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.applyMatrix4(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
      return this;
    }
    applyNormalMatrix(t2) {
      for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
        mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.applyNormalMatrix(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
      return this;
    }
    transformDirection(t2) {
      for (let e2 = 0, i2 = this.count; e2 < i2; e2++)
        mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.transformDirection(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
      return this;
    }
    setX(t2, e2) {
      return this.data.array[t2 * this.data.stride + this.offset] = e2, this;
    }
    setY(t2, e2) {
      return this.data.array[t2 * this.data.stride + this.offset + 1] = e2, this;
    }
    setZ(t2, e2) {
      return this.data.array[t2 * this.data.stride + this.offset + 2] = e2, this;
    }
    setW(t2, e2) {
      return this.data.array[t2 * this.data.stride + this.offset + 3] = e2, this;
    }
    getX(t2) {
      return this.data.array[t2 * this.data.stride + this.offset];
    }
    getY(t2) {
      return this.data.array[t2 * this.data.stride + this.offset + 1];
    }
    getZ(t2) {
      return this.data.array[t2 * this.data.stride + this.offset + 2];
    }
    getW(t2) {
      return this.data.array[t2 * this.data.stride + this.offset + 3];
    }
    setXY(t2, e2, i2) {
      return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this;
    }
    setXYZ(t2, e2, i2, n2) {
      return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this.data.array[t2 + 2] = n2, this;
    }
    setXYZW(t2, e2, i2, n2, r2) {
      return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this.data.array[t2 + 2] = n2, this.data.array[t2 + 3] = r2, this;
    }
    clone(t2) {
      if (t2 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const t3 = [];
        for (let e2 = 0; e2 < this.count; e2++) {
          const i2 = e2 * this.data.stride + this.offset;
          for (let e3 = 0; e3 < this.itemSize; e3++)
            t3.push(this.data.array[i2 + e3]);
        }
        return new $t(new this.array.constructor(t3), this.itemSize, this.normalized);
      }
      return t2.interleavedBuffers === void 0 && (t2.interleavedBuffers = {}), t2.interleavedBuffers[this.data.uuid] === void 0 && (t2.interleavedBuffers[this.data.uuid] = this.data.clone(t2)), new gr(t2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t2) {
      if (t2 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const t3 = [];
        for (let e2 = 0; e2 < this.count; e2++) {
          const i2 = e2 * this.data.stride + this.offset;
          for (let e3 = 0; e3 < this.itemSize; e3++)
            t3.push(this.data.array[i2 + e3]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: t3, normalized: this.normalized };
      }
      return t2.interleavedBuffers === void 0 && (t2.interleavedBuffers = {}), t2.interleavedBuffers[this.data.uuid] === void 0 && (t2.interleavedBuffers[this.data.uuid] = this.data.toJSON(t2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  }
  gr.prototype.isInterleavedBufferAttribute = true;
  class vr extends jt {
    constructor(t2) {
      super(), this.type = "SpriteMaterial", this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.rotation = t2.rotation, this.sizeAttenuation = t2.sizeAttenuation, this;
    }
  }
  let _r;
  vr.prototype.isSpriteMaterial = true;
  const yr = new M(), xr = new M(), br = new M(), Tr = new g(), Er = new g(), Sr = new rt(), wr = new M(), Ar = new M(), Mr = new M(), Rr = new g(), Cr = new g(), Ir = new g();
  class Pr extends Ct {
    constructor(t2) {
      if (super(), this.type = "Sprite", _r === void 0) {
        _r = new de();
        const t3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e2 = new fr(t3, 5);
        _r.setIndex([0, 1, 2, 0, 2, 3]), _r.setAttribute("position", new gr(e2, 3, 0, false)), _r.setAttribute("uv", new gr(e2, 2, 3, false));
      }
      this.geometry = _r, this.material = t2 !== void 0 ? t2 : new vr(), this.center = new g(0.5, 0.5);
    }
    raycast(t2, e2) {
      t2.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), xr.setFromMatrixScale(this.matrixWorld), Sr.copy(t2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t2.camera.matrixWorldInverse, this.matrixWorld), br.setFromMatrixPosition(this.modelViewMatrix), t2.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && xr.multiplyScalar(-br.z);
      const i2 = this.material.rotation;
      let n2, r2;
      i2 !== 0 && (r2 = Math.cos(i2), n2 = Math.sin(i2));
      const o2 = this.center;
      Or(wr.set(-0.5, -0.5, 0), br, o2, xr, n2, r2), Or(Ar.set(0.5, -0.5, 0), br, o2, xr, n2, r2), Or(Mr.set(0.5, 0.5, 0), br, o2, xr, n2, r2), Rr.set(0, 0), Cr.set(1, 0), Ir.set(1, 1);
      let s2 = t2.ray.intersectTriangle(wr, Ar, Mr, false, yr);
      if (s2 === null && (Or(Ar.set(-0.5, 0.5, 0), br, o2, xr, n2, r2), Cr.set(0, 1), s2 = t2.ray.intersectTriangle(wr, Mr, Ar, false, yr), s2 === null))
        return;
      const a2 = t2.ray.origin.distanceTo(yr);
      a2 < t2.near || a2 > t2.far || e2.push({ distance: a2, point: yr.clone(), uv: Gt.getUV(yr, wr, Ar, Mr, Rr, Cr, Ir, new g()), face: null, object: this });
    }
    copy(t2) {
      return super.copy(t2), t2.center !== void 0 && this.center.copy(t2.center), this.material = t2.material, this;
    }
  }
  function Or(t2, e2, i2, n2, r2, o2) {
    Tr.subVectors(t2, i2).addScalar(0.5).multiply(n2), r2 !== void 0 ? (Er.x = o2 * Tr.x - r2 * Tr.y, Er.y = r2 * Tr.x + o2 * Tr.y) : Er.copy(Tr), t2.copy(e2), t2.x += Er.x, t2.y += Er.y, t2.applyMatrix4(Sr);
  }
  Pr.prototype.isSprite = true;
  const Nr = new M(), Lr = new E(), Dr = new E(), Fr = new M(), Br = new rt();
  class Ur extends Ie {
    constructor(t2, e2) {
      super(t2, e2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new rt(), this.bindMatrixInverse = new rt();
    }
    copy(t2) {
      return super.copy(t2), this.bindMode = t2.bindMode, this.bindMatrix.copy(t2.bindMatrix), this.bindMatrixInverse.copy(t2.bindMatrixInverse), this.skeleton = t2.skeleton, this;
    }
    bind(t2, e2) {
      this.skeleton = t2, e2 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t2 = new E(), e2 = this.geometry.attributes.skinWeight;
      for (let i2 = 0, n2 = e2.count; i2 < n2; i2++) {
        t2.x = e2.getX(i2), t2.y = e2.getY(i2), t2.z = e2.getZ(i2), t2.w = e2.getW(i2);
        const n3 = 1 / t2.manhattanLength();
        n3 !== 1 / 0 ? t2.multiplyScalar(n3) : t2.set(1, 0, 0, 0), e2.setXYZW(i2, t2.x, t2.y, t2.z, t2.w);
      }
    }
    updateMatrixWorld(t2) {
      super.updateMatrixWorld(t2), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(t2, e2) {
      const i2 = this.skeleton, n2 = this.geometry;
      Lr.fromBufferAttribute(n2.attributes.skinIndex, t2), Dr.fromBufferAttribute(n2.attributes.skinWeight, t2), Nr.fromBufferAttribute(n2.attributes.position, t2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
      for (let t3 = 0; t3 < 4; t3++) {
        const n3 = Dr.getComponent(t3);
        if (n3 !== 0) {
          const r2 = Lr.getComponent(t3);
          Br.multiplyMatrices(i2.bones[r2].matrixWorld, i2.boneInverses[r2]), e2.addScaledVector(Fr.copy(Nr).applyMatrix4(Br), n3);
        }
      }
      return e2.applyMatrix4(this.bindMatrixInverse);
    }
  }
  Ur.prototype.isSkinnedMesh = true;
  class kr extends Ct {
    constructor() {
      super(), this.type = "Bone";
    }
  }
  kr.prototype.isBone = true;
  class Gr extends b {
    constructor(t2 = null, e2 = 1, i2 = 1, n2, r2, o2, s2, a2, l2 = 1003, h2 = 1003, u2, c2) {
      super(null, o2, s2, a2, l2, h2, n2, r2, u2, c2), this.image = { data: t2, width: e2, height: i2 }, this.magFilter = l2, this.minFilter = h2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  Gr.prototype.isDataTexture = true;
  const Hr = new rt(), jr = new rt(), zr = [], Vr = new Ie();
  class Xr extends Ie {
    constructor(t2, e2, i2) {
      super(t2, e2), this.instanceMatrix = new $t(new Float32Array(16 * i2), 16), this.instanceColor = null, this.count = i2, this.frustumCulled = false;
    }
    copy(t2) {
      return super.copy(t2), this.instanceMatrix.copy(t2.instanceMatrix), t2.instanceColor !== null && (this.instanceColor = t2.instanceColor.clone()), this.count = t2.count, this;
    }
    getColorAt(t2, e2) {
      e2.fromArray(this.instanceColor.array, 3 * t2);
    }
    getMatrixAt(t2, e2) {
      e2.fromArray(this.instanceMatrix.array, 16 * t2);
    }
    raycast(t2, e2) {
      const i2 = this.matrixWorld, n2 = this.count;
      if (Vr.geometry = this.geometry, Vr.material = this.material, Vr.material !== void 0)
        for (let r2 = 0; r2 < n2; r2++) {
          this.getMatrixAt(r2, Hr), jr.multiplyMatrices(i2, Hr), Vr.matrixWorld = jr, Vr.raycast(t2, zr);
          for (let t3 = 0, i3 = zr.length; t3 < i3; t3++) {
            const i4 = zr[t3];
            i4.instanceId = r2, i4.object = this, e2.push(i4);
          }
          zr.length = 0;
        }
    }
    setColorAt(t2, e2) {
      this.instanceColor === null && (this.instanceColor = new $t(new Float32Array(3 * this.count), 3)), e2.toArray(this.instanceColor.array, 3 * t2);
    }
    setMatrixAt(t2, e2) {
      e2.toArray(this.instanceMatrix.array, 16 * t2);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  Xr.prototype.isInstancedMesh = true;
  class Wr extends jt {
    constructor(t2) {
      super(), this.type = "LineBasicMaterial", this.color = new Zt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.linewidth = t2.linewidth, this.linecap = t2.linecap, this.linejoin = t2.linejoin, this.morphTargets = t2.morphTargets, this;
    }
  }
  Wr.prototype.isLineBasicMaterial = true;
  const Yr = new M(), qr = new M(), Zr = new rt(), Jr = new nt(), Kr = new Z();
  class Qr extends Ct {
    constructor(t2 = new de(), e2 = new Wr()) {
      super(), this.type = "Line", this.geometry = t2, this.material = e2, this.updateMorphTargets();
    }
    copy(t2) {
      return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
    }
    computeLineDistances() {
      const t2 = this.geometry;
      if (t2.isBufferGeometry)
        if (t2.index === null) {
          const e2 = t2.attributes.position, i2 = [0];
          for (let t3 = 1, n2 = e2.count; t3 < n2; t3++)
            Yr.fromBufferAttribute(e2, t3 - 1), qr.fromBufferAttribute(e2, t3), i2[t3] = i2[t3 - 1], i2[t3] += Yr.distanceTo(qr);
          t2.setAttribute("lineDistance", new ne(i2, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
    raycast(t2, e2) {
      const i2 = this.geometry, n2 = this.matrixWorld, r2 = t2.params.Line.threshold, o2 = i2.drawRange;
      if (i2.boundingSphere === null && i2.computeBoundingSphere(), Kr.copy(i2.boundingSphere), Kr.applyMatrix4(n2), Kr.radius += r2, t2.ray.intersectsSphere(Kr) === false)
        return;
      Zr.copy(n2).invert(), Jr.copy(t2.ray).applyMatrix4(Zr);
      const s2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2, l2 = new M(), h2 = new M(), u2 = new M(), c2 = new M(), d2 = this.isLineSegments ? 2 : 1;
      if (i2.isBufferGeometry) {
        const n3 = i2.index, r3 = i2.attributes.position;
        if (n3 !== null) {
          for (let i3 = Math.max(0, o2.start), s3 = Math.min(n3.count, o2.start + o2.count) - 1; i3 < s3; i3 += d2) {
            const o3 = n3.getX(i3), s4 = n3.getX(i3 + 1);
            l2.fromBufferAttribute(r3, o3), h2.fromBufferAttribute(r3, s4);
            if (Jr.distanceSqToSegment(l2, h2, c2, u2) > a2)
              continue;
            c2.applyMatrix4(this.matrixWorld);
            const d3 = t2.ray.origin.distanceTo(c2);
            d3 < t2.near || d3 > t2.far || e2.push({ distance: d3, point: u2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
          }
        } else {
          for (let i3 = Math.max(0, o2.start), n4 = Math.min(r3.count, o2.start + o2.count) - 1; i3 < n4; i3 += d2) {
            l2.fromBufferAttribute(r3, i3), h2.fromBufferAttribute(r3, i3 + 1);
            if (Jr.distanceSqToSegment(l2, h2, c2, u2) > a2)
              continue;
            c2.applyMatrix4(this.matrixWorld);
            const n5 = t2.ray.origin.distanceTo(c2);
            n5 < t2.near || n5 > t2.far || e2.push({ distance: n5, point: u2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
          }
        }
      } else
        i2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t2 = this.geometry;
      if (t2.isBufferGeometry) {
        const e2 = t2.morphAttributes, i2 = Object.keys(e2);
        if (i2.length > 0) {
          const t3 = e2[i2[0]];
          if (t3 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
              const i4 = t3[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
            }
          }
        }
      } else {
        const e2 = t2.morphTargets;
        e2 !== void 0 && e2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  Qr.prototype.isLine = true;
  const $r = new M(), to = new M();
  class eo extends Qr {
    constructor(t2, e2) {
      super(t2, e2), this.type = "LineSegments";
    }
    computeLineDistances() {
      const t2 = this.geometry;
      if (t2.isBufferGeometry)
        if (t2.index === null) {
          const e2 = t2.attributes.position, i2 = [];
          for (let t3 = 0, n2 = e2.count; t3 < n2; t3 += 2)
            $r.fromBufferAttribute(e2, t3), to.fromBufferAttribute(e2, t3 + 1), i2[t3] = t3 === 0 ? 0 : i2[t3 - 1], i2[t3 + 1] = i2[t3] + $r.distanceTo(to);
          t2.setAttribute("lineDistance", new ne(i2, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  }
  eo.prototype.isLineSegments = true;
  class io extends Qr {
    constructor(t2, e2) {
      super(t2, e2), this.type = "LineLoop";
    }
  }
  io.prototype.isLineLoop = true;
  class no extends jt {
    constructor(t2) {
      super(), this.type = "PointsMaterial", this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.size = t2.size, this.sizeAttenuation = t2.sizeAttenuation, this.morphTargets = t2.morphTargets, this;
    }
  }
  no.prototype.isPointsMaterial = true;
  const ro = new rt(), oo = new nt(), so = new Z(), ao = new M();
  class lo extends Ct {
    constructor(t2 = new de(), e2 = new no()) {
      super(), this.type = "Points", this.geometry = t2, this.material = e2, this.updateMorphTargets();
    }
    copy(t2) {
      return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
    }
    raycast(t2, e2) {
      const i2 = this.geometry, n2 = this.matrixWorld, r2 = t2.params.Points.threshold, o2 = i2.drawRange;
      if (i2.boundingSphere === null && i2.computeBoundingSphere(), so.copy(i2.boundingSphere), so.applyMatrix4(n2), so.radius += r2, t2.ray.intersectsSphere(so) === false)
        return;
      ro.copy(n2).invert(), oo.copy(t2.ray).applyMatrix4(ro);
      const s2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2;
      if (i2.isBufferGeometry) {
        const r3 = i2.index, s3 = i2.attributes.position;
        if (r3 !== null) {
          for (let i3 = Math.max(0, o2.start), l2 = Math.min(r3.count, o2.start + o2.count); i3 < l2; i3++) {
            const o3 = r3.getX(i3);
            ao.fromBufferAttribute(s3, o3), ho(ao, o3, a2, n2, t2, e2, this);
          }
        } else {
          for (let i3 = Math.max(0, o2.start), r4 = Math.min(s3.count, o2.start + o2.count); i3 < r4; i3++)
            ao.fromBufferAttribute(s3, i3), ho(ao, i3, a2, n2, t2, e2, this);
        }
      } else
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t2 = this.geometry;
      if (t2.isBufferGeometry) {
        const e2 = t2.morphAttributes, i2 = Object.keys(e2);
        if (i2.length > 0) {
          const t3 = e2[i2[0]];
          if (t3 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
              const i4 = t3[e3].name || String(e3);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
            }
          }
        }
      } else {
        const e2 = t2.morphTargets;
        e2 !== void 0 && e2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  function ho(t2, e2, i2, n2, r2, o2, s2) {
    const a2 = oo.distanceSqToPoint(t2);
    if (a2 < i2) {
      const i3 = new M();
      oo.closestPointToPoint(t2, i3), i3.applyMatrix4(n2);
      const l2 = r2.ray.origin.distanceTo(i3);
      if (l2 < r2.near || l2 > r2.far)
        return;
      o2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: i3, index: e2, face: null, object: s2 });
    }
  }
  lo.prototype.isPoints = true;
  (class extends b {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
      super(t2, e2, i2, n2, r2, o2, s2, a2, l2), this.format = s2 !== void 0 ? s2 : 1022, this.minFilter = o2 !== void 0 ? o2 : 1006, this.magFilter = r2 !== void 0 ? r2 : 1006, this.generateMipmaps = false;
      const h2 = this;
      "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
        h2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const t2 = this.image;
      "requestVideoFrameCallback" in t2 === false && t2.readyState >= t2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }).prototype.isVideoTexture = true;
  class uo extends b {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2) {
      super(null, o2, s2, a2, l2, h2, n2, r2, u2, c2), this.image = { width: e2, height: i2 }, this.mipmaps = t2, this.flipY = false, this.generateMipmaps = false;
    }
  }
  uo.prototype.isCompressedTexture = true;
  (class extends b {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
      super(t2, e2, i2, n2, r2, o2, s2, a2, l2), this.needsUpdate = true;
    }
  }).prototype.isCanvasTexture = true;
  (class extends b {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2) {
      if ((h2 = h2 !== void 0 ? h2 : 1026) !== 1026 && h2 !== 1027)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      i2 === void 0 && h2 === 1026 && (i2 = 1012), i2 === void 0 && h2 === 1027 && (i2 = 1020), super(null, n2, r2, o2, s2, a2, h2, i2, l2), this.image = { width: t2, height: e2 }, this.magFilter = s2 !== void 0 ? s2 : 1003, this.minFilter = a2 !== void 0 ? a2 : 1003, this.flipY = false, this.generateMipmaps = false;
    }
  }).prototype.isDepthTexture = true;
  new M(), new M(), new M(), new Gt();
  class co {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t2, e2) {
      const i2 = this.getUtoTmapping(t2);
      return this.getPoint(i2, e2);
    }
    getPoints(t2 = 5) {
      const e2 = [];
      for (let i2 = 0; i2 <= t2; i2++)
        e2.push(this.getPoint(i2 / t2));
      return e2;
    }
    getSpacedPoints(t2 = 5) {
      const e2 = [];
      for (let i2 = 0; i2 <= t2; i2++)
        e2.push(this.getPointAt(i2 / t2));
      return e2;
    }
    getLength() {
      const t2 = this.getLengths();
      return t2[t2.length - 1];
    }
    getLengths(t2 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const e2 = [];
      let i2, n2 = this.getPoint(0), r2 = 0;
      e2.push(0);
      for (let o2 = 1; o2 <= t2; o2++)
        i2 = this.getPoint(o2 / t2), r2 += i2.distanceTo(n2), e2.push(r2), n2 = i2;
      return this.cacheArcLengths = e2, e2;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(t2, e2) {
      const i2 = this.getLengths();
      let n2 = 0;
      const r2 = i2.length;
      let o2;
      o2 = e2 || t2 * i2[r2 - 1];
      let s2, a2 = 0, l2 = r2 - 1;
      for (; a2 <= l2; )
        if (n2 = Math.floor(a2 + (l2 - a2) / 2), s2 = i2[n2] - o2, s2 < 0)
          a2 = n2 + 1;
        else {
          if (!(s2 > 0)) {
            l2 = n2;
            break;
          }
          l2 = n2 - 1;
        }
      if (n2 = l2, i2[n2] === o2)
        return n2 / (r2 - 1);
      const h2 = i2[n2];
      return (n2 + (o2 - h2) / (i2[n2 + 1] - h2)) / (r2 - 1);
    }
    getTangent(t2, e2) {
      let i2 = t2 - 1e-4, n2 = t2 + 1e-4;
      i2 < 0 && (i2 = 0), n2 > 1 && (n2 = 1);
      const r2 = this.getPoint(i2), o2 = this.getPoint(n2), s2 = e2 || (r2.isVector2 ? new g() : new M());
      return s2.copy(o2).sub(r2).normalize(), s2;
    }
    getTangentAt(t2, e2) {
      const i2 = this.getUtoTmapping(t2);
      return this.getTangent(i2, e2);
    }
    computeFrenetFrames(t2, e2) {
      const i2 = new M(), n2 = [], r2 = [], o2 = [], s2 = new M(), a2 = new rt();
      for (let e3 = 0; e3 <= t2; e3++) {
        const i3 = e3 / t2;
        n2[e3] = this.getTangentAt(i3, new M()), n2[e3].normalize();
      }
      r2[0] = new M(), o2[0] = new M();
      let l2 = Number.MAX_VALUE;
      const h2 = Math.abs(n2[0].x), u2 = Math.abs(n2[0].y), d2 = Math.abs(n2[0].z);
      h2 <= l2 && (l2 = h2, i2.set(1, 0, 0)), u2 <= l2 && (l2 = u2, i2.set(0, 1, 0)), d2 <= l2 && i2.set(0, 0, 1), s2.crossVectors(n2[0], i2).normalize(), r2[0].crossVectors(n2[0], s2), o2[0].crossVectors(n2[0], r2[0]);
      for (let e3 = 1; e3 <= t2; e3++) {
        if (r2[e3] = r2[e3 - 1].clone(), o2[e3] = o2[e3 - 1].clone(), s2.crossVectors(n2[e3 - 1], n2[e3]), s2.length() > Number.EPSILON) {
          s2.normalize();
          const t3 = Math.acos(c(n2[e3 - 1].dot(n2[e3]), -1, 1));
          r2[e3].applyMatrix4(a2.makeRotationAxis(s2, t3));
        }
        o2[e3].crossVectors(n2[e3], r2[e3]);
      }
      if (e2 === true) {
        let e3 = Math.acos(c(r2[0].dot(r2[t2]), -1, 1));
        e3 /= t2, n2[0].dot(s2.crossVectors(r2[0], r2[t2])) > 0 && (e3 = -e3);
        for (let i3 = 1; i3 <= t2; i3++)
          r2[i3].applyMatrix4(a2.makeRotationAxis(n2[i3], e3 * i3)), o2[i3].crossVectors(n2[i3], r2[i3]);
      }
      return { tangents: n2, normals: r2, binormals: o2 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t2) {
      return this.arcLengthDivisions = t2.arcLengthDivisions, this;
    }
    toJSON() {
      const t2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return t2.arcLengthDivisions = this.arcLengthDivisions, t2.type = this.type, t2;
    }
    fromJSON(t2) {
      return this.arcLengthDivisions = t2.arcLengthDivisions, this;
    }
  }
  class po extends co {
    constructor(t2 = 0, e2 = 0, i2 = 1, n2 = 1, r2 = 0, o2 = 2 * Math.PI, s2 = false, a2 = 0) {
      super(), this.type = "EllipseCurve", this.aX = t2, this.aY = e2, this.xRadius = i2, this.yRadius = n2, this.aStartAngle = r2, this.aEndAngle = o2, this.aClockwise = s2, this.aRotation = a2;
    }
    getPoint(t2, e2) {
      const i2 = e2 || new g(), n2 = 2 * Math.PI;
      let r2 = this.aEndAngle - this.aStartAngle;
      const o2 = Math.abs(r2) < Number.EPSILON;
      for (; r2 < 0; )
        r2 += n2;
      for (; r2 > n2; )
        r2 -= n2;
      r2 < Number.EPSILON && (r2 = o2 ? 0 : n2), this.aClockwise !== true || o2 || (r2 === n2 ? r2 = -n2 : r2 -= n2);
      const s2 = this.aStartAngle + t2 * r2;
      let a2 = this.aX + this.xRadius * Math.cos(s2), l2 = this.aY + this.yRadius * Math.sin(s2);
      if (this.aRotation !== 0) {
        const t3 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), i3 = a2 - this.aX, n3 = l2 - this.aY;
        a2 = i3 * t3 - n3 * e3 + this.aX, l2 = i3 * e3 + n3 * t3 + this.aY;
      }
      return i2.set(a2, l2);
    }
    copy(t2) {
      return super.copy(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.aX = this.aX, t2.aY = this.aY, t2.xRadius = this.xRadius, t2.yRadius = this.yRadius, t2.aStartAngle = this.aStartAngle, t2.aEndAngle = this.aEndAngle, t2.aClockwise = this.aClockwise, t2.aRotation = this.aRotation, t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
    }
  }
  po.prototype.isEllipseCurve = true;
  class fo extends po {
    constructor(t2, e2, i2, n2, r2, o2) {
      super(t2, e2, i2, i2, n2, r2, o2), this.type = "ArcCurve";
    }
  }
  function mo() {
    let t2 = 0, e2 = 0, i2 = 0, n2 = 0;
    function r2(r3, o2, s2, a2) {
      t2 = r3, e2 = s2, i2 = -3 * r3 + 3 * o2 - 2 * s2 - a2, n2 = 2 * r3 - 2 * o2 + s2 + a2;
    }
    return { initCatmullRom: function(t3, e3, i3, n3, o2) {
      r2(e3, i3, o2 * (i3 - t3), o2 * (n3 - e3));
    }, initNonuniformCatmullRom: function(t3, e3, i3, n3, o2, s2, a2) {
      let l2 = (e3 - t3) / o2 - (i3 - t3) / (o2 + s2) + (i3 - e3) / s2, h2 = (i3 - e3) / s2 - (n3 - e3) / (s2 + a2) + (n3 - i3) / a2;
      l2 *= s2, h2 *= s2, r2(e3, i3, l2, h2);
    }, calc: function(r3) {
      const o2 = r3 * r3;
      return t2 + e2 * r3 + i2 * o2 + n2 * (o2 * r3);
    } };
  }
  fo.prototype.isArcCurve = true;
  const go = new M(), vo = new mo(), _o = new mo(), yo = new mo();
  class xo extends co {
    constructor(t2 = [], e2 = false, i2 = "centripetal", n2 = 0.5) {
      super(), this.type = "CatmullRomCurve3", this.points = t2, this.closed = e2, this.curveType = i2, this.tension = n2;
    }
    getPoint(t2, e2 = new M()) {
      const i2 = e2, n2 = this.points, r2 = n2.length, o2 = (r2 - (this.closed ? 0 : 1)) * t2;
      let s2, a2, l2 = Math.floor(o2), h2 = o2 - l2;
      this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r2) + 1) * r2 : h2 === 0 && l2 === r2 - 1 && (l2 = r2 - 2, h2 = 1), this.closed || l2 > 0 ? s2 = n2[(l2 - 1) % r2] : (go.subVectors(n2[0], n2[1]).add(n2[0]), s2 = go);
      const u2 = n2[l2 % r2], c2 = n2[(l2 + 1) % r2];
      if (this.closed || l2 + 2 < r2 ? a2 = n2[(l2 + 2) % r2] : (go.subVectors(n2[r2 - 1], n2[r2 - 2]).add(n2[r2 - 1]), a2 = go), this.curveType === "centripetal" || this.curveType === "chordal") {
        const t3 = this.curveType === "chordal" ? 0.5 : 0.25;
        let e3 = Math.pow(s2.distanceToSquared(u2), t3), i3 = Math.pow(u2.distanceToSquared(c2), t3), n3 = Math.pow(c2.distanceToSquared(a2), t3);
        i3 < 1e-4 && (i3 = 1), e3 < 1e-4 && (e3 = i3), n3 < 1e-4 && (n3 = i3), vo.initNonuniformCatmullRom(s2.x, u2.x, c2.x, a2.x, e3, i3, n3), _o.initNonuniformCatmullRom(s2.y, u2.y, c2.y, a2.y, e3, i3, n3), yo.initNonuniformCatmullRom(s2.z, u2.z, c2.z, a2.z, e3, i3, n3);
      } else
        this.curveType === "catmullrom" && (vo.initCatmullRom(s2.x, u2.x, c2.x, a2.x, this.tension), _o.initCatmullRom(s2.y, u2.y, c2.y, a2.y, this.tension), yo.initCatmullRom(s2.z, u2.z, c2.z, a2.z, this.tension));
      return i2.set(vo.calc(h2), _o.calc(h2), yo.calc(h2)), i2;
    }
    copy(t2) {
      super.copy(t2), this.points = [];
      for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
        const i3 = t2.points[e2];
        this.points.push(i3.clone());
      }
      return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
    }
    toJSON() {
      const t2 = super.toJSON();
      t2.points = [];
      for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
        const i3 = this.points[e2];
        t2.points.push(i3.toArray());
      }
      return t2.closed = this.closed, t2.curveType = this.curveType, t2.tension = this.tension, t2;
    }
    fromJSON(t2) {
      super.fromJSON(t2), this.points = [];
      for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
        const i3 = t2.points[e2];
        this.points.push(new M().fromArray(i3));
      }
      return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
    }
  }
  function bo(t2, e2, i2, n2, r2) {
    const o2 = 0.5 * (n2 - e2), s2 = 0.5 * (r2 - i2), a2 = t2 * t2;
    return (2 * i2 - 2 * n2 + o2 + s2) * (t2 * a2) + (-3 * i2 + 3 * n2 - 2 * o2 - s2) * a2 + o2 * t2 + i2;
  }
  function To(t2, e2, i2, n2) {
    return function(t3, e3) {
      const i3 = 1 - t3;
      return i3 * i3 * e3;
    }(t2, e2) + function(t3, e3) {
      return 2 * (1 - t3) * t3 * e3;
    }(t2, i2) + function(t3, e3) {
      return t3 * t3 * e3;
    }(t2, n2);
  }
  function Eo(t2, e2, i2, n2, r2) {
    return function(t3, e3) {
      const i3 = 1 - t3;
      return i3 * i3 * i3 * e3;
    }(t2, e2) + function(t3, e3) {
      const i3 = 1 - t3;
      return 3 * i3 * i3 * t3 * e3;
    }(t2, i2) + function(t3, e3) {
      return 3 * (1 - t3) * t3 * t3 * e3;
    }(t2, n2) + function(t3, e3) {
      return t3 * t3 * t3 * e3;
    }(t2, r2);
  }
  xo.prototype.isCatmullRomCurve3 = true;
  class So extends co {
    constructor(t2 = new g(), e2 = new g(), i2 = new g(), n2 = new g()) {
      super(), this.type = "CubicBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = i2, this.v3 = n2;
    }
    getPoint(t2, e2 = new g()) {
      const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2, s2 = this.v3;
      return i2.set(Eo(t2, n2.x, r2.x, o2.x, s2.x), Eo(t2, n2.y, r2.y, o2.y, s2.y)), i2;
    }
    copy(t2) {
      return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
    }
  }
  So.prototype.isCubicBezierCurve = true;
  class wo extends co {
    constructor(t2 = new M(), e2 = new M(), i2 = new M(), n2 = new M()) {
      super(), this.type = "CubicBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = i2, this.v3 = n2;
    }
    getPoint(t2, e2 = new M()) {
      const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2, s2 = this.v3;
      return i2.set(Eo(t2, n2.x, r2.x, o2.x, s2.x), Eo(t2, n2.y, r2.y, o2.y, s2.y), Eo(t2, n2.z, r2.z, o2.z, s2.z)), i2;
    }
    copy(t2) {
      return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
    }
  }
  wo.prototype.isCubicBezierCurve3 = true;
  class Ao extends co {
    constructor(t2 = new g(), e2 = new g()) {
      super(), this.type = "LineCurve", this.v1 = t2, this.v2 = e2;
    }
    getPoint(t2, e2 = new g()) {
      const i2 = e2;
      return t2 === 1 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t2).add(this.v1)), i2;
    }
    getPointAt(t2, e2) {
      return this.getPoint(t2, e2);
    }
    getTangent(t2, e2) {
      const i2 = e2 || new g();
      return i2.copy(this.v2).sub(this.v1).normalize(), i2;
    }
    copy(t2) {
      return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
    }
  }
  Ao.prototype.isLineCurve = true;
  class Mo extends co {
    constructor(t2 = new g(), e2 = new g(), i2 = new g()) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = i2;
    }
    getPoint(t2, e2 = new g()) {
      const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2;
      return i2.set(To(t2, n2.x, r2.x, o2.x), To(t2, n2.y, r2.y, o2.y)), i2;
    }
    copy(t2) {
      return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
    }
  }
  Mo.prototype.isQuadraticBezierCurve = true;
  class Ro extends co {
    constructor(t2 = new M(), e2 = new M(), i2 = new M()) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = i2;
    }
    getPoint(t2, e2 = new M()) {
      const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2;
      return i2.set(To(t2, n2.x, r2.x, o2.x), To(t2, n2.y, r2.y, o2.y), To(t2, n2.z, r2.z, o2.z)), i2;
    }
    copy(t2) {
      return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
    }
  }
  Ro.prototype.isQuadraticBezierCurve3 = true;
  class Co extends co {
    constructor(t2 = []) {
      super(), this.type = "SplineCurve", this.points = t2;
    }
    getPoint(t2, e2 = new g()) {
      const i2 = e2, n2 = this.points, r2 = (n2.length - 1) * t2, o2 = Math.floor(r2), s2 = r2 - o2, a2 = n2[o2 === 0 ? o2 : o2 - 1], l2 = n2[o2], h2 = n2[o2 > n2.length - 2 ? n2.length - 1 : o2 + 1], u2 = n2[o2 > n2.length - 3 ? n2.length - 1 : o2 + 2];
      return i2.set(bo(s2, a2.x, l2.x, h2.x, u2.x), bo(s2, a2.y, l2.y, h2.y, u2.y)), i2;
    }
    copy(t2) {
      super.copy(t2), this.points = [];
      for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
        const i3 = t2.points[e2];
        this.points.push(i3.clone());
      }
      return this;
    }
    toJSON() {
      const t2 = super.toJSON();
      t2.points = [];
      for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
        const i3 = this.points[e2];
        t2.points.push(i3.toArray());
      }
      return t2;
    }
    fromJSON(t2) {
      super.fromJSON(t2), this.points = [];
      for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
        const i3 = t2.points[e2];
        this.points.push(new g().fromArray(i3));
      }
      return this;
    }
  }
  Co.prototype.isSplineCurve = true;
  var Io = Object.freeze({ __proto__: null, ArcCurve: fo, CatmullRomCurve3: xo, CubicBezierCurve: So, CubicBezierCurve3: wo, EllipseCurve: po, LineCurve: Ao, LineCurve3: class extends co {
    constructor(t2 = new M(), e2 = new M()) {
      super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t2, this.v2 = e2;
    }
    getPoint(t2, e2 = new M()) {
      const i2 = e2;
      return t2 === 1 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t2).add(this.v1)), i2;
    }
    getPointAt(t2, e2) {
      return this.getPoint(t2, e2);
    }
    copy(t2) {
      return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
    }
  }, QuadraticBezierCurve: Mo, QuadraticBezierCurve3: Ro, SplineCurve: Co });
  const Po = function(t2, e2, i2 = 2) {
    const n2 = e2 && e2.length, r2 = n2 ? e2[0] * i2 : t2.length;
    let o2 = Oo(t2, 0, r2, i2, true);
    const s2 = [];
    if (!o2 || o2.next === o2.prev)
      return s2;
    let a2, l2, h2, u2, c2, d2, p2;
    if (n2 && (o2 = function(t3, e3, i3, n3) {
      const r3 = [];
      let o3, s3, a3, l3, h3;
      for (o3 = 0, s3 = e3.length; o3 < s3; o3++)
        a3 = e3[o3] * n3, l3 = o3 < s3 - 1 ? e3[o3 + 1] * n3 : t3.length, h3 = Oo(t3, a3, l3, n3, false), h3 === h3.next && (h3.steiner = true), r3.push(zo(h3));
      for (r3.sort(ko), o3 = 0; o3 < r3.length; o3++)
        Go(r3[o3], i3), i3 = No(i3, i3.next);
      return i3;
    }(t2, e2, o2, i2)), t2.length > 80 * i2) {
      a2 = h2 = t2[0], l2 = u2 = t2[1];
      for (let e3 = i2; e3 < r2; e3 += i2)
        c2 = t2[e3], d2 = t2[e3 + 1], c2 < a2 && (a2 = c2), d2 < l2 && (l2 = d2), c2 > h2 && (h2 = c2), d2 > u2 && (u2 = d2);
      p2 = Math.max(h2 - a2, u2 - l2), p2 = p2 !== 0 ? 1 / p2 : 0;
    }
    return Lo(o2, s2, i2, a2, l2, p2), s2;
  };
  function Oo(t2, e2, i2, n2, r2) {
    let o2, s2;
    if (r2 === function(t3, e3, i3, n3) {
      let r3 = 0;
      for (let o3 = e3, s3 = i3 - n3; o3 < i3; o3 += n3)
        r3 += (t3[s3] - t3[o3]) * (t3[o3 + 1] + t3[s3 + 1]), s3 = o3;
      return r3;
    }(t2, e2, i2, n2) > 0)
      for (o2 = e2; o2 < i2; o2 += n2)
        s2 = $o(o2, t2[o2], t2[o2 + 1], s2);
    else
      for (o2 = i2 - n2; o2 >= e2; o2 -= n2)
        s2 = $o(o2, t2[o2], t2[o2 + 1], s2);
    return s2 && Yo(s2, s2.next) && (ts(s2), s2 = s2.next), s2;
  }
  function No(t2, e2) {
    if (!t2)
      return t2;
    e2 || (e2 = t2);
    let i2, n2 = t2;
    do {
      if (i2 = false, n2.steiner || !Yo(n2, n2.next) && Wo(n2.prev, n2, n2.next) !== 0)
        n2 = n2.next;
      else {
        if (ts(n2), n2 = e2 = n2.prev, n2 === n2.next)
          break;
        i2 = true;
      }
    } while (i2 || n2 !== e2);
    return e2;
  }
  function Lo(t2, e2, i2, n2, r2, o2, s2) {
    if (!t2)
      return;
    !s2 && o2 && function(t3, e3, i3, n3) {
      let r3 = t3;
      do {
        r3.z === null && (r3.z = jo(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
      } while (r3 !== t3);
      r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
        let e4, i4, n4, r4, o3, s3, a3, l3, h3 = 1;
        do {
          for (i4 = t4, t4 = null, o3 = null, s3 = 0; i4; ) {
            for (s3++, n4 = i4, a3 = 0, e4 = 0; e4 < h3 && (a3++, n4 = n4.nextZ, n4); e4++)
              ;
            for (l3 = h3; a3 > 0 || l3 > 0 && n4; )
              a3 !== 0 && (l3 === 0 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a3--) : (r4 = n4, n4 = n4.nextZ, l3--), o3 ? o3.nextZ = r4 : t4 = r4, r4.prevZ = o3, o3 = r4;
            i4 = n4;
          }
          o3.nextZ = null, h3 *= 2;
        } while (s3 > 1);
      }(r3);
    }(t2, n2, r2, o2);
    let a2, l2, h2 = t2;
    for (; t2.prev !== t2.next; )
      if (a2 = t2.prev, l2 = t2.next, o2 ? Fo(t2, n2, r2, o2) : Do(t2))
        e2.push(a2.i / i2), e2.push(t2.i / i2), e2.push(l2.i / i2), ts(t2), t2 = l2.next, h2 = l2.next;
      else if ((t2 = l2) === h2) {
        s2 ? s2 === 1 ? Lo(t2 = Bo(No(t2), e2, i2), e2, i2, n2, r2, o2, 2) : s2 === 2 && Uo(t2, e2, i2, n2, r2, o2) : Lo(No(t2), e2, i2, n2, r2, o2, 1);
        break;
      }
  }
  function Do(t2) {
    const e2 = t2.prev, i2 = t2, n2 = t2.next;
    if (Wo(e2, i2, n2) >= 0)
      return false;
    let r2 = t2.next.next;
    for (; r2 !== t2.prev; ) {
      if (Vo(e2.x, e2.y, i2.x, i2.y, n2.x, n2.y, r2.x, r2.y) && Wo(r2.prev, r2, r2.next) >= 0)
        return false;
      r2 = r2.next;
    }
    return true;
  }
  function Fo(t2, e2, i2, n2) {
    const r2 = t2.prev, o2 = t2, s2 = t2.next;
    if (Wo(r2, o2, s2) >= 0)
      return false;
    const a2 = r2.x < o2.x ? r2.x < s2.x ? r2.x : s2.x : o2.x < s2.x ? o2.x : s2.x, l2 = r2.y < o2.y ? r2.y < s2.y ? r2.y : s2.y : o2.y < s2.y ? o2.y : s2.y, h2 = r2.x > o2.x ? r2.x > s2.x ? r2.x : s2.x : o2.x > s2.x ? o2.x : s2.x, u2 = r2.y > o2.y ? r2.y > s2.y ? r2.y : s2.y : o2.y > s2.y ? o2.y : s2.y, c2 = jo(a2, l2, e2, i2, n2), d2 = jo(h2, u2, e2, i2, n2);
    let p2 = t2.prevZ, f2 = t2.nextZ;
    for (; p2 && p2.z >= c2 && f2 && f2.z <= d2; ) {
      if (p2 !== t2.prev && p2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, p2.x, p2.y) && Wo(p2.prev, p2, p2.next) >= 0)
        return false;
      if (p2 = p2.prevZ, f2 !== t2.prev && f2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, f2.x, f2.y) && Wo(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    for (; p2 && p2.z >= c2; ) {
      if (p2 !== t2.prev && p2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, p2.x, p2.y) && Wo(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    for (; f2 && f2.z <= d2; ) {
      if (f2 !== t2.prev && f2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, f2.x, f2.y) && Wo(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    return true;
  }
  function Bo(t2, e2, i2) {
    let n2 = t2;
    do {
      const r2 = n2.prev, o2 = n2.next.next;
      !Yo(r2, o2) && qo(r2, n2, n2.next, o2) && Ko(r2, o2) && Ko(o2, r2) && (e2.push(r2.i / i2), e2.push(n2.i / i2), e2.push(o2.i / i2), ts(n2), ts(n2.next), n2 = t2 = o2), n2 = n2.next;
    } while (n2 !== t2);
    return No(n2);
  }
  function Uo(t2, e2, i2, n2, r2, o2) {
    let s2 = t2;
    do {
      let t3 = s2.next.next;
      for (; t3 !== s2.prev; ) {
        if (s2.i !== t3.i && Xo(s2, t3)) {
          let a2 = Qo(s2, t3);
          return s2 = No(s2, s2.next), a2 = No(a2, a2.next), Lo(s2, e2, i2, n2, r2, o2), void Lo(a2, e2, i2, n2, r2, o2);
        }
        t3 = t3.next;
      }
      s2 = s2.next;
    } while (s2 !== t2);
  }
  function ko(t2, e2) {
    return t2.x - e2.x;
  }
  function Go(t2, e2) {
    if (e2 = function(t3, e3) {
      let i2 = e3;
      const n2 = t3.x, r2 = t3.y;
      let o2, s2 = -1 / 0;
      do {
        if (r2 <= i2.y && r2 >= i2.next.y && i2.next.y !== i2.y) {
          const t4 = i2.x + (r2 - i2.y) * (i2.next.x - i2.x) / (i2.next.y - i2.y);
          if (t4 <= n2 && t4 > s2) {
            if (s2 = t4, t4 === n2) {
              if (r2 === i2.y)
                return i2;
              if (r2 === i2.next.y)
                return i2.next;
            }
            o2 = i2.x < i2.next.x ? i2 : i2.next;
          }
        }
        i2 = i2.next;
      } while (i2 !== e3);
      if (!o2)
        return null;
      if (n2 === s2)
        return o2;
      const a2 = o2, l2 = o2.x, h2 = o2.y;
      let u2, c2 = 1 / 0;
      i2 = o2;
      do {
        n2 >= i2.x && i2.x >= l2 && n2 !== i2.x && Vo(r2 < h2 ? n2 : s2, r2, l2, h2, r2 < h2 ? s2 : n2, r2, i2.x, i2.y) && (u2 = Math.abs(r2 - i2.y) / (n2 - i2.x), Ko(i2, t3) && (u2 < c2 || u2 === c2 && (i2.x > o2.x || i2.x === o2.x && Ho(o2, i2))) && (o2 = i2, c2 = u2)), i2 = i2.next;
      } while (i2 !== a2);
      return o2;
    }(t2, e2)) {
      const i2 = Qo(e2, t2);
      No(e2, e2.next), No(i2, i2.next);
    }
  }
  function Ho(t2, e2) {
    return Wo(t2.prev, t2, e2.prev) < 0 && Wo(e2.next, t2, t2.next) < 0;
  }
  function jo(t2, e2, i2, n2, r2) {
    return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - i2) * r2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
  }
  function zo(t2) {
    let e2 = t2, i2 = t2;
    do {
      (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
    } while (e2 !== t2);
    return i2;
  }
  function Vo(t2, e2, i2, n2, r2, o2, s2, a2) {
    return (r2 - s2) * (e2 - a2) - (t2 - s2) * (o2 - a2) >= 0 && (t2 - s2) * (n2 - a2) - (i2 - s2) * (e2 - a2) >= 0 && (i2 - s2) * (o2 - a2) - (r2 - s2) * (n2 - a2) >= 0;
  }
  function Xo(t2, e2) {
    return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
      let i2 = t3;
      do {
        if (i2.i !== t3.i && i2.next.i !== t3.i && i2.i !== e3.i && i2.next.i !== e3.i && qo(i2, i2.next, t3, e3))
          return true;
        i2 = i2.next;
      } while (i2 !== t3);
      return false;
    }(t2, e2) && (Ko(t2, e2) && Ko(e2, t2) && function(t3, e3) {
      let i2 = t3, n2 = false;
      const r2 = (t3.x + e3.x) / 2, o2 = (t3.y + e3.y) / 2;
      do {
        i2.y > o2 != i2.next.y > o2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (o2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
      } while (i2 !== t3);
      return n2;
    }(t2, e2) && (Wo(t2.prev, t2, e2.prev) || Wo(t2, e2.prev, e2)) || Yo(t2, e2) && Wo(t2.prev, t2, t2.next) > 0 && Wo(e2.prev, e2, e2.next) > 0);
  }
  function Wo(t2, e2, i2) {
    return (e2.y - t2.y) * (i2.x - e2.x) - (e2.x - t2.x) * (i2.y - e2.y);
  }
  function Yo(t2, e2) {
    return t2.x === e2.x && t2.y === e2.y;
  }
  function qo(t2, e2, i2, n2) {
    const r2 = Jo(Wo(t2, e2, i2)), o2 = Jo(Wo(t2, e2, n2)), s2 = Jo(Wo(i2, n2, t2)), a2 = Jo(Wo(i2, n2, e2));
    return r2 !== o2 && s2 !== a2 || (!(r2 !== 0 || !Zo(t2, i2, e2)) || (!(o2 !== 0 || !Zo(t2, n2, e2)) || (!(s2 !== 0 || !Zo(i2, t2, n2)) || !(a2 !== 0 || !Zo(i2, e2, n2)))));
  }
  function Zo(t2, e2, i2) {
    return e2.x <= Math.max(t2.x, i2.x) && e2.x >= Math.min(t2.x, i2.x) && e2.y <= Math.max(t2.y, i2.y) && e2.y >= Math.min(t2.y, i2.y);
  }
  function Jo(t2) {
    return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
  }
  function Ko(t2, e2) {
    return Wo(t2.prev, t2, t2.next) < 0 ? Wo(t2, e2, t2.next) >= 0 && Wo(t2, t2.prev, e2) >= 0 : Wo(t2, e2, t2.prev) < 0 || Wo(t2, t2.next, e2) < 0;
  }
  function Qo(t2, e2) {
    const i2 = new es(t2.i, t2.x, t2.y), n2 = new es(e2.i, e2.x, e2.y), r2 = t2.next, o2 = e2.prev;
    return t2.next = e2, e2.prev = t2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, o2.next = n2, n2.prev = o2, n2;
  }
  function $o(t2, e2, i2, n2) {
    const r2 = new es(t2, e2, i2);
    return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
  }
  function ts(t2) {
    t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
  }
  function es(t2, e2, i2) {
    this.i = t2, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  class is {
    static area(t2) {
      const e2 = t2.length;
      let i2 = 0;
      for (let n2 = e2 - 1, r2 = 0; r2 < e2; n2 = r2++)
        i2 += t2[n2].x * t2[r2].y - t2[r2].x * t2[n2].y;
      return 0.5 * i2;
    }
    static isClockWise(t2) {
      return is.area(t2) < 0;
    }
    static triangulateShape(t2, e2) {
      const i2 = [], n2 = [], r2 = [];
      ns(t2), rs(i2, t2);
      let o2 = t2.length;
      e2.forEach(ns);
      for (let t3 = 0; t3 < e2.length; t3++)
        n2.push(o2), o2 += e2[t3].length, rs(i2, e2[t3]);
      const s2 = Po(i2, n2);
      for (let t3 = 0; t3 < s2.length; t3 += 3)
        r2.push(s2.slice(t3, t3 + 3));
      return r2;
    }
  }
  function ns(t2) {
    const e2 = t2.length;
    e2 > 2 && t2[e2 - 1].equals(t2[0]) && t2.pop();
  }
  function rs(t2, e2) {
    for (let i2 = 0; i2 < e2.length; i2++)
      t2.push(e2[i2].x), t2.push(e2[i2].y);
  }
  class os extends de {
    constructor(t2, e2) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t2, options: e2 }, t2 = Array.isArray(t2) ? t2 : [t2];
      const i2 = this, n2 = [], r2 = [];
      for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) {
        o2(t2[e3]);
      }
      function o2(t3) {
        const o3 = [], s2 = e2.curveSegments !== void 0 ? e2.curveSegments : 12, a2 = e2.steps !== void 0 ? e2.steps : 1;
        let l2 = e2.depth !== void 0 ? e2.depth : 100, h2 = e2.bevelEnabled === void 0 || e2.bevelEnabled, u2 = e2.bevelThickness !== void 0 ? e2.bevelThickness : 6, c2 = e2.bevelSize !== void 0 ? e2.bevelSize : u2 - 2, d2 = e2.bevelOffset !== void 0 ? e2.bevelOffset : 0, p2 = e2.bevelSegments !== void 0 ? e2.bevelSegments : 3;
        const f2 = e2.extrudePath, m2 = e2.UVGenerator !== void 0 ? e2.UVGenerator : ss;
        e2.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l2 = e2.amount);
        let v2, _2, y2, x2, b2, T2 = false;
        f2 && (v2 = f2.getSpacedPoints(a2), T2 = true, h2 = false, _2 = f2.computeFrenetFrames(a2, false), y2 = new M(), x2 = new M(), b2 = new M()), h2 || (p2 = 0, u2 = 0, c2 = 0, d2 = 0);
        const E2 = t3.extractPoints(s2);
        let S2 = E2.shape;
        const w2 = E2.holes;
        if (!is.isClockWise(S2)) {
          S2 = S2.reverse();
          for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
            const e4 = w2[t4];
            is.isClockWise(e4) && (w2[t4] = e4.reverse());
          }
        }
        const A2 = is.triangulateShape(S2, w2), R2 = S2;
        for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
          const e4 = w2[t4];
          S2 = S2.concat(e4);
        }
        function C2(t4, e3, i3) {
          return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(i3).add(t4);
        }
        const I2 = S2.length, P2 = A2.length;
        function O2(t4, e3, i3) {
          let n3, r3, o4;
          const s3 = t4.x - e3.x, a3 = t4.y - e3.y, l3 = i3.x - t4.x, h3 = i3.y - t4.y, u3 = s3 * s3 + a3 * a3, c3 = s3 * h3 - a3 * l3;
          if (Math.abs(c3) > Number.EPSILON) {
            const c4 = Math.sqrt(u3), d3 = Math.sqrt(l3 * l3 + h3 * h3), p3 = e3.x - a3 / c4, f3 = e3.y + s3 / c4, m3 = ((i3.x - h3 / d3 - p3) * h3 - (i3.y + l3 / d3 - f3) * l3) / (s3 * h3 - a3 * l3);
            n3 = p3 + s3 * m3 - t4.x, r3 = f3 + a3 * m3 - t4.y;
            const v3 = n3 * n3 + r3 * r3;
            if (v3 <= 2)
              return new g(n3, r3);
            o4 = Math.sqrt(v3 / 2);
          } else {
            let t5 = false;
            s3 > Number.EPSILON ? l3 > Number.EPSILON && (t5 = true) : s3 < -Number.EPSILON ? l3 < -Number.EPSILON && (t5 = true) : Math.sign(a3) === Math.sign(h3) && (t5 = true), t5 ? (n3 = -a3, r3 = s3, o4 = Math.sqrt(u3)) : (n3 = s3, r3 = a3, o4 = Math.sqrt(u3 / 2));
          }
          return new g(n3 / o4, r3 / o4);
        }
        const N2 = [];
        for (let t4 = 0, e3 = R2.length, i3 = e3 - 1, n3 = t4 + 1; t4 < e3; t4++, i3++, n3++)
          i3 === e3 && (i3 = 0), n3 === e3 && (n3 = 0), N2[t4] = O2(R2[t4], R2[i3], R2[n3]);
        const L2 = [];
        let D2, F2 = N2.concat();
        for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
          const e4 = w2[t4];
          D2 = [];
          for (let t5 = 0, i3 = e4.length, n3 = i3 - 1, r3 = t5 + 1; t5 < i3; t5++, n3++, r3++)
            n3 === i3 && (n3 = 0), r3 === i3 && (r3 = 0), D2[t5] = O2(e4[t5], e4[n3], e4[r3]);
          L2.push(D2), F2 = F2.concat(D2);
        }
        for (let t4 = 0; t4 < p2; t4++) {
          const e3 = t4 / p2, i3 = u2 * Math.cos(e3 * Math.PI / 2), n3 = c2 * Math.sin(e3 * Math.PI / 2) + d2;
          for (let t5 = 0, e4 = R2.length; t5 < e4; t5++) {
            const e5 = C2(R2[t5], N2[t5], n3);
            k2(e5.x, e5.y, -i3);
          }
          for (let t5 = 0, e4 = w2.length; t5 < e4; t5++) {
            const e5 = w2[t5];
            D2 = L2[t5];
            for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
              const r4 = C2(e5[t6], D2[t6], n3);
              k2(r4.x, r4.y, -i3);
            }
          }
        }
        const B2 = c2 + d2;
        for (let t4 = 0; t4 < I2; t4++) {
          const e3 = h2 ? C2(S2[t4], F2[t4], B2) : S2[t4];
          T2 ? (x2.copy(_2.normals[0]).multiplyScalar(e3.x), y2.copy(_2.binormals[0]).multiplyScalar(e3.y), b2.copy(v2[0]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(e3.x, e3.y, 0);
        }
        for (let t4 = 1; t4 <= a2; t4++)
          for (let e3 = 0; e3 < I2; e3++) {
            const i3 = h2 ? C2(S2[e3], F2[e3], B2) : S2[e3];
            T2 ? (x2.copy(_2.normals[t4]).multiplyScalar(i3.x), y2.copy(_2.binormals[t4]).multiplyScalar(i3.y), b2.copy(v2[t4]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(i3.x, i3.y, l2 / a2 * t4);
          }
        for (let t4 = p2 - 1; t4 >= 0; t4--) {
          const e3 = t4 / p2, i3 = u2 * Math.cos(e3 * Math.PI / 2), n3 = c2 * Math.sin(e3 * Math.PI / 2) + d2;
          for (let t5 = 0, e4 = R2.length; t5 < e4; t5++) {
            const e5 = C2(R2[t5], N2[t5], n3);
            k2(e5.x, e5.y, l2 + i3);
          }
          for (let t5 = 0, e4 = w2.length; t5 < e4; t5++) {
            const e5 = w2[t5];
            D2 = L2[t5];
            for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
              const r4 = C2(e5[t6], D2[t6], n3);
              T2 ? k2(r4.x, r4.y + v2[a2 - 1].y, v2[a2 - 1].x + i3) : k2(r4.x, r4.y, l2 + i3);
            }
          }
        }
        function U2(t4, e3) {
          let i3 = t4.length;
          for (; --i3 >= 0; ) {
            const n3 = i3;
            let r3 = i3 - 1;
            r3 < 0 && (r3 = t4.length - 1);
            for (let t5 = 0, i4 = a2 + 2 * p2; t5 < i4; t5++) {
              const i5 = I2 * t5, o4 = I2 * (t5 + 1);
              H2(e3 + n3 + i5, e3 + r3 + i5, e3 + r3 + o4, e3 + n3 + o4);
            }
          }
        }
        function k2(t4, e3, i3) {
          o3.push(t4), o3.push(e3), o3.push(i3);
        }
        function G2(t4, e3, r3) {
          j2(t4), j2(e3), j2(r3);
          const o4 = n2.length / 3, s3 = m2.generateTopUV(i2, n2, o4 - 3, o4 - 2, o4 - 1);
          z2(s3[0]), z2(s3[1]), z2(s3[2]);
        }
        function H2(t4, e3, r3, o4) {
          j2(t4), j2(e3), j2(o4), j2(e3), j2(r3), j2(o4);
          const s3 = n2.length / 3, a3 = m2.generateSideWallUV(i2, n2, s3 - 6, s3 - 3, s3 - 2, s3 - 1);
          z2(a3[0]), z2(a3[1]), z2(a3[3]), z2(a3[1]), z2(a3[2]), z2(a3[3]);
        }
        function j2(t4) {
          n2.push(o3[3 * t4 + 0]), n2.push(o3[3 * t4 + 1]), n2.push(o3[3 * t4 + 2]);
        }
        function z2(t4) {
          r2.push(t4.x), r2.push(t4.y);
        }
        !function() {
          const t4 = n2.length / 3;
          if (h2) {
            let t5 = 0, e3 = I2 * t5;
            for (let t6 = 0; t6 < P2; t6++) {
              const i3 = A2[t6];
              G2(i3[2] + e3, i3[1] + e3, i3[0] + e3);
            }
            t5 = a2 + 2 * p2, e3 = I2 * t5;
            for (let t6 = 0; t6 < P2; t6++) {
              const i3 = A2[t6];
              G2(i3[0] + e3, i3[1] + e3, i3[2] + e3);
            }
          } else {
            for (let t5 = 0; t5 < P2; t5++) {
              const e3 = A2[t5];
              G2(e3[2], e3[1], e3[0]);
            }
            for (let t5 = 0; t5 < P2; t5++) {
              const e3 = A2[t5];
              G2(e3[0] + I2 * a2, e3[1] + I2 * a2, e3[2] + I2 * a2);
            }
          }
          i2.addGroup(t4, n2.length / 3 - t4, 0);
        }(), function() {
          const t4 = n2.length / 3;
          let e3 = 0;
          U2(R2, e3), e3 += R2.length;
          for (let t5 = 0, i3 = w2.length; t5 < i3; t5++) {
            const i4 = w2[t5];
            U2(i4, e3), e3 += i4.length;
          }
          i2.addGroup(t4, n2.length / 3 - t4, 1);
        }();
      }
      this.setAttribute("position", new ne(n2, 3)), this.setAttribute("uv", new ne(r2, 2)), this.computeVertexNormals();
    }
    toJSON() {
      const t2 = super.toJSON();
      return function(t3, e2, i2) {
        if (i2.shapes = [], Array.isArray(t3))
          for (let e3 = 0, n2 = t3.length; e3 < n2; e3++) {
            const n3 = t3[e3];
            i2.shapes.push(n3.uuid);
          }
        else
          i2.shapes.push(t3.uuid);
        e2.extrudePath !== void 0 && (i2.options.extrudePath = e2.extrudePath.toJSON());
        return i2;
      }(this.parameters.shapes, this.parameters.options, t2);
    }
    static fromJSON(t2, e2) {
      const i2 = [];
      for (let n3 = 0, r2 = t2.shapes.length; n3 < r2; n3++) {
        const r3 = e2[t2.shapes[n3]];
        i2.push(r3);
      }
      const n2 = t2.options.extrudePath;
      return n2 !== void 0 && (t2.options.extrudePath = new Io[n2.type]().fromJSON(n2)), new os(i2, t2.options);
    }
  }
  const ss = { generateTopUV: function(t2, e2, i2, n2, r2) {
    const o2 = e2[3 * i2], s2 = e2[3 * i2 + 1], a2 = e2[3 * n2], l2 = e2[3 * n2 + 1], h2 = e2[3 * r2], u2 = e2[3 * r2 + 1];
    return [new g(o2, s2), new g(a2, l2), new g(h2, u2)];
  }, generateSideWallUV: function(t2, e2, i2, n2, r2, o2) {
    const s2 = e2[3 * i2], a2 = e2[3 * i2 + 1], l2 = e2[3 * i2 + 2], h2 = e2[3 * n2], u2 = e2[3 * n2 + 1], c2 = e2[3 * n2 + 2], d2 = e2[3 * r2], p2 = e2[3 * r2 + 1], f2 = e2[3 * r2 + 2], m2 = e2[3 * o2], v2 = e2[3 * o2 + 1], _2 = e2[3 * o2 + 2];
    return Math.abs(a2 - u2) < Math.abs(s2 - h2) ? [new g(s2, 1 - l2), new g(h2, 1 - c2), new g(d2, 1 - f2), new g(m2, 1 - _2)] : [new g(a2, 1 - l2), new g(u2, 1 - c2), new g(p2, 1 - f2), new g(v2, 1 - _2)];
  } };
  class as extends de {
    constructor(t2, e2 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: t2, curveSegments: e2 };
      const i2 = [], n2 = [], r2 = [], o2 = [];
      let s2 = 0, a2 = 0;
      if (Array.isArray(t2) === false)
        l2(t2);
      else
        for (let e3 = 0; e3 < t2.length; e3++)
          l2(t2[e3]), this.addGroup(s2, a2, e3), s2 += a2, a2 = 0;
      function l2(t3) {
        const s3 = n2.length / 3, l3 = t3.extractPoints(e2);
        let h2 = l3.shape;
        const u2 = l3.holes;
        is.isClockWise(h2) === false && (h2 = h2.reverse());
        for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
          const e4 = u2[t4];
          is.isClockWise(e4) === true && (u2[t4] = e4.reverse());
        }
        const c2 = is.triangulateShape(h2, u2);
        for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
          const e4 = u2[t4];
          h2 = h2.concat(e4);
        }
        for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
          const e4 = h2[t4];
          n2.push(e4.x, e4.y, 0), r2.push(0, 0, 1), o2.push(e4.x, e4.y);
        }
        for (let t4 = 0, e3 = c2.length; t4 < e3; t4++) {
          const e4 = c2[t4], n3 = e4[0] + s3, r3 = e4[1] + s3, o3 = e4[2] + s3;
          i2.push(n3, r3, o3), a2 += 3;
        }
      }
      this.setIndex(i2), this.setAttribute("position", new ne(n2, 3)), this.setAttribute("normal", new ne(r2, 3)), this.setAttribute("uv", new ne(o2, 2));
    }
    toJSON() {
      const t2 = super.toJSON();
      return function(t3, e2) {
        if (e2.shapes = [], Array.isArray(t3))
          for (let i2 = 0, n2 = t3.length; i2 < n2; i2++) {
            const n3 = t3[i2];
            e2.shapes.push(n3.uuid);
          }
        else
          e2.shapes.push(t3.uuid);
        return e2;
      }(this.parameters.shapes, t2);
    }
    static fromJSON(t2, e2) {
      const i2 = [];
      for (let n2 = 0, r2 = t2.shapes.length; n2 < r2; n2++) {
        const r3 = e2[t2.shapes[n2]];
        i2.push(r3);
      }
      return new as(i2, t2.curveSegments);
    }
  }
  class ls extends jt {
    constructor(t2) {
      super(), this.type = "ShadowMaterial", this.color = new Zt(0), this.transparent = true, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this;
    }
  }
  ls.prototype.isShadowMaterial = true;
  class hs extends Fe {
    constructor(t2) {
      super(t2), this.type = "RawShaderMaterial";
    }
  }
  hs.prototype.isRawShaderMaterial = true;
  class us extends jt {
    constructor(t2) {
      super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Zt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.vertexTangents = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.defines = { STANDARD: "" }, this.color.copy(t2.color), this.roughness = t2.roughness, this.metalness = t2.metalness, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.roughnessMap = t2.roughnessMap, this.metalnessMap = t2.metalnessMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.envMapIntensity = t2.envMapIntensity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this.vertexTangents = t2.vertexTangents, this;
    }
  }
  us.prototype.isMeshStandardMaterial = true;
  class cs2 extends us {
    constructor(t2) {
      super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new g(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", { get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      }, set: function(t3) {
        this.reflectivity = c(2.5 * (t3 - 1) / (t3 + 1), 0, 1);
      } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Zt(1, 1, 1), this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t2.clearcoat, this.clearcoatMap = t2.clearcoatMap, this.clearcoatRoughness = t2.clearcoatRoughness, this.clearcoatRoughnessMap = t2.clearcoatRoughnessMap, this.clearcoatNormalMap = t2.clearcoatNormalMap, this.clearcoatNormalScale.copy(t2.clearcoatNormalScale), this.reflectivity = t2.reflectivity, t2.sheen ? this.sheen = (this.sheen || new Zt()).copy(t2.sheen) : this.sheen = null, this.transmission = t2.transmission, this.transmissionMap = t2.transmissionMap, this.thickness = t2.thickness, this.thicknessMap = t2.thicknessMap, this.attenuationDistance = t2.attenuationDistance, this.attenuationColor.copy(t2.attenuationColor), this;
    }
  }
  cs2.prototype.isMeshPhysicalMaterial = true;
  class ds extends jt {
    constructor(t2) {
      super(), this.type = "MeshPhongMaterial", this.color = new Zt(16777215), this.specular = new Zt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.specular.copy(t2.specular), this.shininess = t2.shininess, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
    }
  }
  ds.prototype.isMeshPhongMaterial = true;
  class ps extends jt {
    constructor(t2) {
      super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Zt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.gradientMap = t2.gradientMap, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
    }
  }
  ps.prototype.isMeshToonMaterial = true;
  class fs extends jt {
    constructor(t2) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
    }
  }
  fs.prototype.isMeshNormalMaterial = true;
  class ms extends jt {
    constructor(t2) {
      super(), this.type = "MeshLambertMaterial", this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
    }
  }
  ms.prototype.isMeshLambertMaterial = true;
  class gs extends jt {
    constructor(t2) {
      super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Zt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.defines = { MATCAP: "" }, this.color.copy(t2.color), this.matcap = t2.matcap, this.map = t2.map, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
    }
  }
  gs.prototype.isMeshMatcapMaterial = true;
  class vs extends Wr {
    constructor(t2) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t2);
    }
    copy(t2) {
      return super.copy(t2), this.scale = t2.scale, this.dashSize = t2.dashSize, this.gapSize = t2.gapSize, this;
    }
  }
  vs.prototype.isLineDashedMaterial = true;
  const _s = { arraySlice: function(t2, e2, i2) {
    return _s.isTypedArray(t2) ? new t2.constructor(t2.subarray(e2, i2 !== void 0 ? i2 : t2.length)) : t2.slice(e2, i2);
  }, convertArray: function(t2, e2, i2) {
    return !t2 || !i2 && t2.constructor === e2 ? t2 : typeof e2.BYTES_PER_ELEMENT == "number" ? new e2(t2) : Array.prototype.slice.call(t2);
  }, isTypedArray: function(t2) {
    return ArrayBuffer.isView(t2) && !(t2 instanceof DataView);
  }, getKeyframeOrder: function(t2) {
    const e2 = t2.length, i2 = new Array(e2);
    for (let t3 = 0; t3 !== e2; ++t3)
      i2[t3] = t3;
    return i2.sort(function(e3, i3) {
      return t2[e3] - t2[i3];
    }), i2;
  }, sortedArray: function(t2, e2, i2) {
    const n2 = t2.length, r2 = new t2.constructor(n2);
    for (let o2 = 0, s2 = 0; s2 !== n2; ++o2) {
      const n3 = i2[o2] * e2;
      for (let i3 = 0; i3 !== e2; ++i3)
        r2[s2++] = t2[n3 + i3];
    }
    return r2;
  }, flattenJSON: function(t2, e2, i2, n2) {
    let r2 = 1, o2 = t2[0];
    for (; o2 !== void 0 && o2[n2] === void 0; )
      o2 = t2[r2++];
    if (o2 === void 0)
      return;
    let s2 = o2[n2];
    if (s2 !== void 0)
      if (Array.isArray(s2))
        do {
          s2 = o2[n2], s2 !== void 0 && (e2.push(o2.time), i2.push.apply(i2, s2)), o2 = t2[r2++];
        } while (o2 !== void 0);
      else if (s2.toArray !== void 0)
        do {
          s2 = o2[n2], s2 !== void 0 && (e2.push(o2.time), s2.toArray(i2, i2.length)), o2 = t2[r2++];
        } while (o2 !== void 0);
      else
        do {
          s2 = o2[n2], s2 !== void 0 && (e2.push(o2.time), i2.push(s2)), o2 = t2[r2++];
        } while (o2 !== void 0);
  }, subclip: function(t2, e2, i2, n2, r2 = 30) {
    const o2 = t2.clone();
    o2.name = e2;
    const s2 = [];
    for (let t3 = 0; t3 < o2.tracks.length; ++t3) {
      const e3 = o2.tracks[t3], a3 = e3.getValueSize(), l2 = [], h2 = [];
      for (let t4 = 0; t4 < e3.times.length; ++t4) {
        const o3 = e3.times[t4] * r2;
        if (!(o3 < i2 || o3 >= n2)) {
          l2.push(e3.times[t4]);
          for (let i3 = 0; i3 < a3; ++i3)
            h2.push(e3.values[t4 * a3 + i3]);
        }
      }
      l2.length !== 0 && (e3.times = _s.convertArray(l2, e3.times.constructor), e3.values = _s.convertArray(h2, e3.values.constructor), s2.push(e3));
    }
    o2.tracks = s2;
    let a2 = 1 / 0;
    for (let t3 = 0; t3 < o2.tracks.length; ++t3)
      a2 > o2.tracks[t3].times[0] && (a2 = o2.tracks[t3].times[0]);
    for (let t3 = 0; t3 < o2.tracks.length; ++t3)
      o2.tracks[t3].shift(-1 * a2);
    return o2.resetDuration(), o2;
  }, makeClipAdditive: function(t2, e2 = 0, i2 = t2, n2 = 30) {
    n2 <= 0 && (n2 = 30);
    const r2 = i2.tracks.length, o2 = e2 / n2;
    for (let e3 = 0; e3 < r2; ++e3) {
      const n3 = i2.tracks[e3], r3 = n3.ValueTypeName;
      if (r3 === "bool" || r3 === "string")
        continue;
      const s2 = t2.tracks.find(function(t3) {
        return t3.name === n3.name && t3.ValueTypeName === r3;
      });
      if (s2 === void 0)
        continue;
      let a2 = 0;
      const l2 = n3.getValueSize();
      n3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
      let h2 = 0;
      const u2 = s2.getValueSize();
      s2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h2 = u2 / 3);
      const c2 = n3.times.length - 1;
      let d2;
      if (o2 <= n3.times[0]) {
        const t3 = a2, e4 = l2 - a2;
        d2 = _s.arraySlice(n3.values, t3, e4);
      } else if (o2 >= n3.times[c2]) {
        const t3 = c2 * l2 + a2, e4 = t3 + l2 - a2;
        d2 = _s.arraySlice(n3.values, t3, e4);
      } else {
        const t3 = n3.createInterpolant(), e4 = a2, i3 = l2 - a2;
        t3.evaluate(o2), d2 = _s.arraySlice(t3.resultBuffer, e4, i3);
      }
      if (r3 === "quaternion") {
        new A().fromArray(d2).normalize().conjugate().toArray(d2);
      }
      const p2 = s2.times.length;
      for (let t3 = 0; t3 < p2; ++t3) {
        const e4 = t3 * u2 + h2;
        if (r3 === "quaternion")
          A.multiplyQuaternionsFlat(s2.values, e4, d2, 0, s2.values, e4);
        else {
          const t4 = u2 - 2 * h2;
          for (let i3 = 0; i3 < t4; ++i3)
            s2.values[e4 + i3] -= d2[i3];
        }
      }
    }
    return t2.blendMode = 2501, t2;
  } };
  class ys {
    constructor(t2, e2, i2, n2) {
      this.parameterPositions = t2, this._cachedIndex = 0, this.resultBuffer = n2 !== void 0 ? n2 : new e2.constructor(i2), this.sampleValues = e2, this.valueSize = i2, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t2) {
      const e2 = this.parameterPositions;
      let i2 = this._cachedIndex, n2 = e2[i2], r2 = e2[i2 - 1];
      t: {
        e: {
          let o2;
          i: {
            n:
              if (!(t2 < n2)) {
                for (let o3 = i2 + 2; ; ) {
                  if (n2 === void 0) {
                    if (t2 < r2)
                      break n;
                    return i2 = e2.length, this._cachedIndex = i2, this.afterEnd_(i2 - 1, t2, r2);
                  }
                  if (i2 === o3)
                    break;
                  if (r2 = n2, n2 = e2[++i2], t2 < n2)
                    break e;
                }
                o2 = e2.length;
                break i;
              }
            if (t2 >= r2)
              break t;
            {
              const s2 = e2[1];
              t2 < s2 && (i2 = 2, r2 = s2);
              for (let o3 = i2 - 2; ; ) {
                if (r2 === void 0)
                  return this._cachedIndex = 0, this.beforeStart_(0, t2, n2);
                if (i2 === o3)
                  break;
                if (n2 = r2, r2 = e2[--i2 - 1], t2 >= r2)
                  break e;
              }
              o2 = i2, i2 = 0;
            }
          }
          for (; i2 < o2; ) {
            const n3 = i2 + o2 >>> 1;
            t2 < e2[n3] ? o2 = n3 : i2 = n3 + 1;
          }
          if (n2 = e2[i2], r2 = e2[i2 - 1], r2 === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t2, n2);
          if (n2 === void 0)
            return i2 = e2.length, this._cachedIndex = i2, this.afterEnd_(i2 - 1, r2, t2);
        }
        this._cachedIndex = i2, this.intervalChanged_(i2, r2, n2);
      }
      return this.interpolate_(i2, r2, t2, n2);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t2) {
      const e2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = t2 * n2;
      for (let t3 = 0; t3 !== n2; ++t3)
        e2[t3] = i2[r2 + t3];
      return e2;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  ys.prototype.beforeStart_ = ys.prototype.copySampleValue_, ys.prototype.afterEnd_ = ys.prototype.copySampleValue_;
  class xs extends ys {
    constructor(t2, e2, i2, n2) {
      super(t2, e2, i2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
    }
    intervalChanged_(t2, e2, i2) {
      const n2 = this.parameterPositions;
      let r2 = t2 - 2, o2 = t2 + 1, s2 = n2[r2], a2 = n2[o2];
      if (s2 === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            r2 = t2, s2 = 2 * e2 - i2;
            break;
          case 2402:
            r2 = n2.length - 2, s2 = e2 + n2[r2] - n2[r2 + 1];
            break;
          default:
            r2 = t2, s2 = i2;
        }
      if (a2 === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            o2 = t2, a2 = 2 * i2 - e2;
            break;
          case 2402:
            o2 = 1, a2 = i2 + n2[1] - n2[0];
            break;
          default:
            o2 = t2 - 1, a2 = e2;
        }
      const l2 = 0.5 * (i2 - e2), h2 = this.valueSize;
      this._weightPrev = l2 / (e2 - s2), this._weightNext = l2 / (a2 - i2), this._offsetPrev = r2 * h2, this._offsetNext = o2 * h2;
    }
    interpolate_(t2, e2, i2, n2) {
      const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = t2 * s2, l2 = a2 - s2, h2 = this._offsetPrev, u2 = this._offsetNext, c2 = this._weightPrev, d2 = this._weightNext, p2 = (i2 - e2) / (n2 - e2), f2 = p2 * p2, m2 = f2 * p2, g2 = -c2 * m2 + 2 * c2 * f2 - c2 * p2, v2 = (1 + c2) * m2 + (-1.5 - 2 * c2) * f2 + (-0.5 + c2) * p2 + 1, _2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, y2 = d2 * m2 - d2 * f2;
      for (let t3 = 0; t3 !== s2; ++t3)
        r2[t3] = g2 * o2[h2 + t3] + v2 * o2[l2 + t3] + _2 * o2[a2 + t3] + y2 * o2[u2 + t3];
      return r2;
    }
  }
  class bs extends ys {
    constructor(t2, e2, i2, n2) {
      super(t2, e2, i2, n2);
    }
    interpolate_(t2, e2, i2, n2) {
      const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = t2 * s2, l2 = a2 - s2, h2 = (i2 - e2) / (n2 - e2), u2 = 1 - h2;
      for (let t3 = 0; t3 !== s2; ++t3)
        r2[t3] = o2[l2 + t3] * u2 + o2[a2 + t3] * h2;
      return r2;
    }
  }
  class Ts extends ys {
    constructor(t2, e2, i2, n2) {
      super(t2, e2, i2, n2);
    }
    interpolate_(t2) {
      return this.copySampleValue_(t2 - 1);
    }
  }
  class Es {
    constructor(t2, e2, i2, n2) {
      if (t2 === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (e2 === void 0 || e2.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t2);
      this.name = t2, this.times = _s.convertArray(e2, this.TimeBufferType), this.values = _s.convertArray(i2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
    }
    static toJSON(t2) {
      const e2 = t2.constructor;
      let i2;
      if (e2.toJSON !== this.toJSON)
        i2 = e2.toJSON(t2);
      else {
        i2 = { name: t2.name, times: _s.convertArray(t2.times, Array), values: _s.convertArray(t2.values, Array) };
        const e3 = t2.getInterpolation();
        e3 !== t2.DefaultInterpolation && (i2.interpolation = e3);
      }
      return i2.type = t2.ValueTypeName, i2;
    }
    InterpolantFactoryMethodDiscrete(t2) {
      return new Ts(this.times, this.values, this.getValueSize(), t2);
    }
    InterpolantFactoryMethodLinear(t2) {
      return new bs(this.times, this.values, this.getValueSize(), t2);
    }
    InterpolantFactoryMethodSmooth(t2) {
      return new xs(this.times, this.values, this.getValueSize(), t2);
    }
    setInterpolation(t2) {
      let e2;
      switch (t2) {
        case 2300:
          e2 = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e2 = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e2 = this.InterpolantFactoryMethodSmooth;
      }
      if (e2 === void 0) {
        const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (t2 === this.DefaultInterpolation)
            throw new Error(e3);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e3), this;
      }
      return this.createInterpolant = e2, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t2) {
      if (t2 !== 0) {
        const e2 = this.times;
        for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2)
          e2[i2] += t2;
      }
      return this;
    }
    scale(t2) {
      if (t2 !== 1) {
        const e2 = this.times;
        for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2)
          e2[i2] *= t2;
      }
      return this;
    }
    trim(t2, e2) {
      const i2 = this.times, n2 = i2.length;
      let r2 = 0, o2 = n2 - 1;
      for (; r2 !== n2 && i2[r2] < t2; )
        ++r2;
      for (; o2 !== -1 && i2[o2] > e2; )
        --o2;
      if (++o2, r2 !== 0 || o2 !== n2) {
        r2 >= o2 && (o2 = Math.max(o2, 1), r2 = o2 - 1);
        const t3 = this.getValueSize();
        this.times = _s.arraySlice(i2, r2, o2), this.values = _s.arraySlice(this.values, r2 * t3, o2 * t3);
      }
      return this;
    }
    validate() {
      let t2 = true;
      const e2 = this.getValueSize();
      e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t2 = false);
      const i2 = this.times, n2 = this.values, r2 = i2.length;
      r2 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t2 = false);
      let o2 = null;
      for (let e3 = 0; e3 !== r2; e3++) {
        const n3 = i2[e3];
        if (typeof n3 == "number" && isNaN(n3)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, n3), t2 = false;
          break;
        }
        if (o2 !== null && o2 > n3) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, n3, o2), t2 = false;
          break;
        }
        o2 = n3;
      }
      if (n2 !== void 0 && _s.isTypedArray(n2))
        for (let e3 = 0, i3 = n2.length; e3 !== i3; ++e3) {
          const i4 = n2[e3];
          if (isNaN(i4)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, i4), t2 = false;
            break;
          }
        }
      return t2;
    }
    optimize() {
      const t2 = _s.arraySlice(this.times), e2 = _s.arraySlice(this.values), i2 = this.getValueSize(), n2 = this.getInterpolation() === 2302, r2 = t2.length - 1;
      let o2 = 1;
      for (let s2 = 1; s2 < r2; ++s2) {
        let r3 = false;
        const a2 = t2[s2];
        if (a2 !== t2[s2 + 1] && (s2 !== 1 || a2 !== t2[0]))
          if (n2)
            r3 = true;
          else {
            const t3 = s2 * i2, n3 = t3 - i2, o3 = t3 + i2;
            for (let s3 = 0; s3 !== i2; ++s3) {
              const i3 = e2[t3 + s3];
              if (i3 !== e2[n3 + s3] || i3 !== e2[o3 + s3]) {
                r3 = true;
                break;
              }
            }
          }
        if (r3) {
          if (s2 !== o2) {
            t2[o2] = t2[s2];
            const n3 = s2 * i2, r4 = o2 * i2;
            for (let t3 = 0; t3 !== i2; ++t3)
              e2[r4 + t3] = e2[n3 + t3];
          }
          ++o2;
        }
      }
      if (r2 > 0) {
        t2[o2] = t2[r2];
        for (let t3 = r2 * i2, n3 = o2 * i2, s2 = 0; s2 !== i2; ++s2)
          e2[n3 + s2] = e2[t3 + s2];
        ++o2;
      }
      return o2 !== t2.length ? (this.times = _s.arraySlice(t2, 0, o2), this.values = _s.arraySlice(e2, 0, o2 * i2)) : (this.times = t2, this.values = e2), this;
    }
    clone() {
      const t2 = _s.arraySlice(this.times, 0), e2 = _s.arraySlice(this.values, 0), i2 = new this.constructor(this.name, t2, e2);
      return i2.createInterpolant = this.createInterpolant, i2;
    }
  }
  Es.prototype.TimeBufferType = Float32Array, Es.prototype.ValueBufferType = Float32Array, Es.prototype.DefaultInterpolation = 2301;
  class Ss extends Es {
  }
  Ss.prototype.ValueTypeName = "bool", Ss.prototype.ValueBufferType = Array, Ss.prototype.DefaultInterpolation = 2300, Ss.prototype.InterpolantFactoryMethodLinear = void 0, Ss.prototype.InterpolantFactoryMethodSmooth = void 0;
  class ws extends Es {
  }
  ws.prototype.ValueTypeName = "color";
  class As extends Es {
  }
  As.prototype.ValueTypeName = "number";
  class Ms extends ys {
    constructor(t2, e2, i2, n2) {
      super(t2, e2, i2, n2);
    }
    interpolate_(t2, e2, i2, n2) {
      const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = (i2 - e2) / (n2 - e2);
      let l2 = t2 * s2;
      for (let t3 = l2 + s2; l2 !== t3; l2 += 4)
        A.slerpFlat(r2, 0, o2, l2 - s2, o2, l2, a2);
      return r2;
    }
  }
  class Rs extends Es {
    InterpolantFactoryMethodLinear(t2) {
      return new Ms(this.times, this.values, this.getValueSize(), t2);
    }
  }
  Rs.prototype.ValueTypeName = "quaternion", Rs.prototype.DefaultInterpolation = 2301, Rs.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Cs extends Es {
  }
  Cs.prototype.ValueTypeName = "string", Cs.prototype.ValueBufferType = Array, Cs.prototype.DefaultInterpolation = 2300, Cs.prototype.InterpolantFactoryMethodLinear = void 0, Cs.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Is extends Es {
  }
  Is.prototype.ValueTypeName = "vector";
  class Ps {
    constructor(t2, e2 = -1, i2, n2 = 2500) {
      this.name = t2, this.tracks = i2, this.duration = e2, this.blendMode = n2, this.uuid = u(), this.duration < 0 && this.resetDuration();
    }
    static parse(t2) {
      const e2 = [], i2 = t2.tracks, n2 = 1 / (t2.fps || 1);
      for (let t3 = 0, r3 = i2.length; t3 !== r3; ++t3)
        e2.push(Os(i2[t3]).scale(n2));
      const r2 = new this(t2.name, t2.duration, e2, t2.blendMode);
      return r2.uuid = t2.uuid, r2;
    }
    static toJSON(t2) {
      const e2 = [], i2 = t2.tracks, n2 = { name: t2.name, duration: t2.duration, tracks: e2, uuid: t2.uuid, blendMode: t2.blendMode };
      for (let t3 = 0, n3 = i2.length; t3 !== n3; ++t3)
        e2.push(Es.toJSON(i2[t3]));
      return n2;
    }
    static CreateFromMorphTargetSequence(t2, e2, i2, n2) {
      const r2 = e2.length, o2 = [];
      for (let t3 = 0; t3 < r2; t3++) {
        let s2 = [], a2 = [];
        s2.push((t3 + r2 - 1) % r2, t3, (t3 + 1) % r2), a2.push(0, 1, 0);
        const l2 = _s.getKeyframeOrder(s2);
        s2 = _s.sortedArray(s2, 1, l2), a2 = _s.sortedArray(a2, 1, l2), n2 || s2[0] !== 0 || (s2.push(r2), a2.push(a2[0])), o2.push(new As(".morphTargetInfluences[" + e2[t3].name + "]", s2, a2).scale(1 / i2));
      }
      return new this(t2, -1, o2);
    }
    static findByName(t2, e2) {
      let i2 = t2;
      if (!Array.isArray(t2)) {
        const e3 = t2;
        i2 = e3.geometry && e3.geometry.animations || e3.animations;
      }
      for (let t3 = 0; t3 < i2.length; t3++)
        if (i2[t3].name === e2)
          return i2[t3];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t2, e2, i2) {
      const n2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
      for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) {
        const i4 = t2[e3], o3 = i4.name.match(r2);
        if (o3 && o3.length > 1) {
          const t3 = o3[1];
          let e4 = n2[t3];
          e4 || (n2[t3] = e4 = []), e4.push(i4);
        }
      }
      const o2 = [];
      for (const t3 in n2)
        o2.push(this.CreateFromMorphTargetSequence(t3, n2[t3], e2, i2));
      return o2;
    }
    static parseAnimation(t2, e2) {
      if (!t2)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const i2 = function(t3, e3, i3, n3, r3) {
        if (i3.length !== 0) {
          const o3 = [], s3 = [];
          _s.flattenJSON(i3, o3, s3, n3), o3.length !== 0 && r3.push(new t3(e3, o3, s3));
        }
      }, n2 = [], r2 = t2.name || "default", o2 = t2.fps || 30, s2 = t2.blendMode;
      let a2 = t2.length || -1;
      const l2 = t2.hierarchy || [];
      for (let t3 = 0; t3 < l2.length; t3++) {
        const r3 = l2[t3].keys;
        if (r3 && r3.length !== 0)
          if (r3[0].morphTargets) {
            const t4 = {};
            let e3;
            for (e3 = 0; e3 < r3.length; e3++)
              if (r3[e3].morphTargets)
                for (let i3 = 0; i3 < r3[e3].morphTargets.length; i3++)
                  t4[r3[e3].morphTargets[i3]] = -1;
            for (const i3 in t4) {
              const t5 = [], o3 = [];
              for (let n3 = 0; n3 !== r3[e3].morphTargets.length; ++n3) {
                const n4 = r3[e3];
                t5.push(n4.time), o3.push(n4.morphTarget === i3 ? 1 : 0);
              }
              n2.push(new As(".morphTargetInfluence[" + i3 + "]", t5, o3));
            }
            a2 = t4.length * (o2 || 1);
          } else {
            const o3 = ".bones[" + e2[t3].name + "]";
            i2(Is, o3 + ".position", r3, "pos", n2), i2(Rs, o3 + ".quaternion", r3, "rot", n2), i2(Is, o3 + ".scale", r3, "scl", n2);
          }
      }
      if (n2.length === 0)
        return null;
      return new this(r2, a2, n2, s2);
    }
    resetDuration() {
      let t2 = 0;
      for (let e2 = 0, i2 = this.tracks.length; e2 !== i2; ++e2) {
        const i3 = this.tracks[e2];
        t2 = Math.max(t2, i3.times[i3.times.length - 1]);
      }
      return this.duration = t2, this;
    }
    trim() {
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        this.tracks[t2].trim(0, this.duration);
      return this;
    }
    validate() {
      let t2 = true;
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        t2 = t2 && this.tracks[e2].validate();
      return t2;
    }
    optimize() {
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        this.tracks[t2].optimize();
      return this;
    }
    clone() {
      const t2 = [];
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        t2.push(this.tracks[e2].clone());
      return new this.constructor(this.name, this.duration, t2, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function Os(t2) {
    if (t2.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e2 = function(t3) {
      switch (t3.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return As;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Is;
        case "color":
          return ws;
        case "quaternion":
          return Rs;
        case "bool":
        case "boolean":
          return Ss;
        case "string":
          return Cs;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t3);
    }(t2.type);
    if (t2.times === void 0) {
      const e3 = [], i2 = [];
      _s.flattenJSON(t2.keys, e3, i2, "value"), t2.times = e3, t2.values = i2;
    }
    return e2.parse !== void 0 ? e2.parse(t2) : new e2(t2.name, t2.times, t2.values, t2.interpolation);
  }
  const Ns = { enabled: false, files: {}, add: function(t2, e2) {
    this.enabled !== false && (this.files[t2] = e2);
  }, get: function(t2) {
    if (this.enabled !== false)
      return this.files[t2];
  }, remove: function(t2) {
    delete this.files[t2];
  }, clear: function() {
    this.files = {};
  } };
  class Ls {
    constructor(t2, e2, i2) {
      const n2 = this;
      let r2 = false, o2 = 0, s2 = 0, a2 = void 0;
      const l2 = [];
      this.onStart = void 0, this.onLoad = t2, this.onProgress = e2, this.onError = i2, this.itemStart = function(t3) {
        s2++, r2 === false && n2.onStart !== void 0 && n2.onStart(t3, o2, s2), r2 = true;
      }, this.itemEnd = function(t3) {
        o2++, n2.onProgress !== void 0 && n2.onProgress(t3, o2, s2), o2 === s2 && (r2 = false, n2.onLoad !== void 0 && n2.onLoad());
      }, this.itemError = function(t3) {
        n2.onError !== void 0 && n2.onError(t3);
      }, this.resolveURL = function(t3) {
        return a2 ? a2(t3) : t3;
      }, this.setURLModifier = function(t3) {
        return a2 = t3, this;
      }, this.addHandler = function(t3, e3) {
        return l2.push(t3, e3), this;
      }, this.removeHandler = function(t3) {
        const e3 = l2.indexOf(t3);
        return e3 !== -1 && l2.splice(e3, 2), this;
      }, this.getHandler = function(t3) {
        for (let e3 = 0, i3 = l2.length; e3 < i3; e3 += 2) {
          const i4 = l2[e3], n3 = l2[e3 + 1];
          if (i4.global && (i4.lastIndex = 0), i4.test(t3))
            return n3;
        }
        return null;
      };
    }
  }
  const Ds = new Ls();
  class Fs {
    constructor(t2) {
      this.manager = t2 !== void 0 ? t2 : Ds, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(t2, e2) {
      const i2 = this;
      return new Promise(function(n2, r2) {
        i2.load(t2, n2, e2, r2);
      });
    }
    parse() {
    }
    setCrossOrigin(t2) {
      return this.crossOrigin = t2, this;
    }
    setWithCredentials(t2) {
      return this.withCredentials = t2, this;
    }
    setPath(t2) {
      return this.path = t2, this;
    }
    setResourcePath(t2) {
      return this.resourcePath = t2, this;
    }
    setRequestHeader(t2) {
      return this.requestHeader = t2, this;
    }
  }
  const Bs = {};
  class Us extends Fs {
    constructor(t2) {
      super(t2);
    }
    load(t2, e2, i2, n2) {
      t2 === void 0 && (t2 = ""), this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
      const r2 = this, o2 = Ns.get(t2);
      if (o2 !== void 0)
        return r2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), r2.manager.itemEnd(t2);
        }, 0), o2;
      if (Bs[t2] !== void 0)
        return void Bs[t2].push({ onLoad: e2, onProgress: i2, onError: n2 });
      const s2 = t2.match(/^data:(.*?)(;base64)?,(.*)$/);
      let a2;
      if (s2) {
        const i3 = s2[1], o3 = !!s2[2];
        let a3 = s2[3];
        a3 = decodeURIComponent(a3), o3 && (a3 = atob(a3));
        try {
          let n3;
          const o4 = (this.responseType || "").toLowerCase();
          switch (o4) {
            case "arraybuffer":
            case "blob":
              const t3 = new Uint8Array(a3.length);
              for (let e4 = 0; e4 < a3.length; e4++)
                t3[e4] = a3.charCodeAt(e4);
              n3 = o4 === "blob" ? new Blob([t3.buffer], { type: i3 }) : t3.buffer;
              break;
            case "document":
              const e3 = new DOMParser();
              n3 = e3.parseFromString(a3, i3);
              break;
            case "json":
              n3 = JSON.parse(a3);
              break;
            default:
              n3 = a3;
          }
          setTimeout(function() {
            e2 && e2(n3), r2.manager.itemEnd(t2);
          }, 0);
        } catch (e3) {
          setTimeout(function() {
            n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }, 0);
        }
      } else {
        Bs[t2] = [], Bs[t2].push({ onLoad: e2, onProgress: i2, onError: n2 }), a2 = new XMLHttpRequest(), a2.open("GET", t2, true), a2.addEventListener("load", function(e3) {
          const i3 = this.response, n3 = Bs[t2];
          if (delete Bs[t2], this.status === 200 || this.status === 0) {
            this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ns.add(t2, i3);
            for (let t3 = 0, e4 = n3.length; t3 < e4; t3++) {
              const e5 = n3[t3];
              e5.onLoad && e5.onLoad(i3);
            }
            r2.manager.itemEnd(t2);
          } else {
            for (let t3 = 0, i4 = n3.length; t3 < i4; t3++) {
              const i5 = n3[t3];
              i5.onError && i5.onError(e3);
            }
            r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }
        }, false), a2.addEventListener("progress", function(e3) {
          const i3 = Bs[t2];
          for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
            const n4 = i3[t3];
            n4.onProgress && n4.onProgress(e3);
          }
        }, false), a2.addEventListener("error", function(e3) {
          const i3 = Bs[t2];
          delete Bs[t2];
          for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
            const n4 = i3[t3];
            n4.onError && n4.onError(e3);
          }
          r2.manager.itemError(t2), r2.manager.itemEnd(t2);
        }, false), a2.addEventListener("abort", function(e3) {
          const i3 = Bs[t2];
          delete Bs[t2];
          for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
            const n4 = i3[t3];
            n4.onError && n4.onError(e3);
          }
          r2.manager.itemError(t2), r2.manager.itemEnd(t2);
        }, false), this.responseType !== void 0 && (a2.responseType = this.responseType), this.withCredentials !== void 0 && (a2.withCredentials = this.withCredentials), a2.overrideMimeType && a2.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (const t3 in this.requestHeader)
          a2.setRequestHeader(t3, this.requestHeader[t3]);
        a2.send(null);
      }
      return r2.manager.itemStart(t2), a2;
    }
    setResponseType(t2) {
      return this.responseType = t2, this;
    }
    setMimeType(t2) {
      return this.mimeType = t2, this;
    }
  }
  class ks extends Fs {
    constructor(t2) {
      super(t2);
    }
    load(t2, e2, i2, n2) {
      this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
      const r2 = this, o2 = Ns.get(t2);
      if (o2 !== void 0)
        return r2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), r2.manager.itemEnd(t2);
        }, 0), o2;
      const s2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function a2() {
        s2.removeEventListener("load", a2, false), s2.removeEventListener("error", l2, false), Ns.add(t2, this), e2 && e2(this), r2.manager.itemEnd(t2);
      }
      function l2(e3) {
        s2.removeEventListener("load", a2, false), s2.removeEventListener("error", l2, false), n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
      }
      return s2.addEventListener("load", a2, false), s2.addEventListener("error", l2, false), t2.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s2.crossOrigin = this.crossOrigin), r2.manager.itemStart(t2), s2.src = t2, s2;
    }
  }
  class Gs extends Fs {
    constructor(t2) {
      super(t2);
    }
    load(t2, e2, i2, n2) {
      const r2 = new Ge(), o2 = new ks(this.manager);
      o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path);
      let s2 = 0;
      function a2(i3) {
        o2.load(t2[i3], function(t3) {
          r2.images[i3] = t3, s2++, s2 === 6 && (r2.needsUpdate = true, e2 && e2(r2));
        }, void 0, n2);
      }
      for (let e3 = 0; e3 < t2.length; ++e3)
        a2(e3);
      return r2;
    }
  }
  class Hs extends Fs {
    constructor(t2) {
      super(t2);
    }
    load(t2, e2, i2, n2) {
      const r2 = new b(), o2 = new ks(this.manager);
      return o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path), o2.load(t2, function(i3) {
        r2.image = i3;
        const n3 = t2.search(/\.jpe?g($|\?)/i) > 0 || t2.search(/^data\:image\/jpeg/) === 0;
        r2.format = n3 ? 1022 : 1023, r2.needsUpdate = true, e2 !== void 0 && e2(r2);
      }, i2, n2), r2;
    }
  }
  class js extends co {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(t2) {
      this.curves.push(t2);
    }
    closePath() {
      const t2 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
      t2.equals(e2) || this.curves.push(new Ao(e2, t2));
    }
    getPoint(t2) {
      const e2 = t2 * this.getLength(), i2 = this.getCurveLengths();
      let n2 = 0;
      for (; n2 < i2.length; ) {
        if (i2[n2] >= e2) {
          const t3 = i2[n2] - e2, r2 = this.curves[n2], o2 = r2.getLength(), s2 = o2 === 0 ? 0 : 1 - t3 / o2;
          return r2.getPointAt(s2);
        }
        n2++;
      }
      return null;
    }
    getLength() {
      const t2 = this.getCurveLengths();
      return t2[t2.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const t2 = [];
      let e2 = 0;
      for (let i2 = 0, n2 = this.curves.length; i2 < n2; i2++)
        e2 += this.curves[i2].getLength(), t2.push(e2);
      return this.cacheLengths = t2, t2;
    }
    getSpacedPoints(t2 = 40) {
      const e2 = [];
      for (let i2 = 0; i2 <= t2; i2++)
        e2.push(this.getPoint(i2 / t2));
      return this.autoClose && e2.push(e2[0]), e2;
    }
    getPoints(t2 = 12) {
      const e2 = [];
      let i2;
      for (let n2 = 0, r2 = this.curves; n2 < r2.length; n2++) {
        const o2 = r2[n2], s2 = o2 && o2.isEllipseCurve ? 2 * t2 : o2 && (o2.isLineCurve || o2.isLineCurve3) ? 1 : o2 && o2.isSplineCurve ? t2 * o2.points.length : t2, a2 = o2.getPoints(s2);
        for (let t3 = 0; t3 < a2.length; t3++) {
          const n3 = a2[t3];
          i2 && i2.equals(n3) || (e2.push(n3), i2 = n3);
        }
      }
      return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
    }
    copy(t2) {
      super.copy(t2), this.curves = [];
      for (let e2 = 0, i2 = t2.curves.length; e2 < i2; e2++) {
        const i3 = t2.curves[e2];
        this.curves.push(i3.clone());
      }
      return this.autoClose = t2.autoClose, this;
    }
    toJSON() {
      const t2 = super.toJSON();
      t2.autoClose = this.autoClose, t2.curves = [];
      for (let e2 = 0, i2 = this.curves.length; e2 < i2; e2++) {
        const i3 = this.curves[e2];
        t2.curves.push(i3.toJSON());
      }
      return t2;
    }
    fromJSON(t2) {
      super.fromJSON(t2), this.autoClose = t2.autoClose, this.curves = [];
      for (let e2 = 0, i2 = t2.curves.length; e2 < i2; e2++) {
        const i3 = t2.curves[e2];
        this.curves.push(new Io[i3.type]().fromJSON(i3));
      }
      return this;
    }
  }
  class zs extends js {
    constructor(t2) {
      super(), this.type = "Path", this.currentPoint = new g(), t2 && this.setFromPoints(t2);
    }
    setFromPoints(t2) {
      this.moveTo(t2[0].x, t2[0].y);
      for (let e2 = 1, i2 = t2.length; e2 < i2; e2++)
        this.lineTo(t2[e2].x, t2[e2].y);
      return this;
    }
    moveTo(t2, e2) {
      return this.currentPoint.set(t2, e2), this;
    }
    lineTo(t2, e2) {
      const i2 = new Ao(this.currentPoint.clone(), new g(t2, e2));
      return this.curves.push(i2), this.currentPoint.set(t2, e2), this;
    }
    quadraticCurveTo(t2, e2, i2, n2) {
      const r2 = new Mo(this.currentPoint.clone(), new g(t2, e2), new g(i2, n2));
      return this.curves.push(r2), this.currentPoint.set(i2, n2), this;
    }
    bezierCurveTo(t2, e2, i2, n2, r2, o2) {
      const s2 = new So(this.currentPoint.clone(), new g(t2, e2), new g(i2, n2), new g(r2, o2));
      return this.curves.push(s2), this.currentPoint.set(r2, o2), this;
    }
    splineThru(t2) {
      const e2 = [this.currentPoint.clone()].concat(t2), i2 = new Co(e2);
      return this.curves.push(i2), this.currentPoint.copy(t2[t2.length - 1]), this;
    }
    arc(t2, e2, i2, n2, r2, o2) {
      const s2 = this.currentPoint.x, a2 = this.currentPoint.y;
      return this.absarc(t2 + s2, e2 + a2, i2, n2, r2, o2), this;
    }
    absarc(t2, e2, i2, n2, r2, o2) {
      return this.absellipse(t2, e2, i2, i2, n2, r2, o2), this;
    }
    ellipse(t2, e2, i2, n2, r2, o2, s2, a2) {
      const l2 = this.currentPoint.x, h2 = this.currentPoint.y;
      return this.absellipse(t2 + l2, e2 + h2, i2, n2, r2, o2, s2, a2), this;
    }
    absellipse(t2, e2, i2, n2, r2, o2, s2, a2) {
      const l2 = new po(t2, e2, i2, n2, r2, o2, s2, a2);
      if (this.curves.length > 0) {
        const t3 = l2.getPoint(0);
        t3.equals(this.currentPoint) || this.lineTo(t3.x, t3.y);
      }
      this.curves.push(l2);
      const h2 = l2.getPoint(1);
      return this.currentPoint.copy(h2), this;
    }
    copy(t2) {
      return super.copy(t2), this.currentPoint.copy(t2.currentPoint), this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.currentPoint = this.currentPoint.toArray(), t2;
    }
    fromJSON(t2) {
      return super.fromJSON(t2), this.currentPoint.fromArray(t2.currentPoint), this;
    }
  }
  class Vs extends zs {
    constructor(t2) {
      super(t2), this.uuid = u(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(t2) {
      const e2 = [];
      for (let i2 = 0, n2 = this.holes.length; i2 < n2; i2++)
        e2[i2] = this.holes[i2].getPoints(t2);
      return e2;
    }
    extractPoints(t2) {
      return { shape: this.getPoints(t2), holes: this.getPointsHoles(t2) };
    }
    copy(t2) {
      super.copy(t2), this.holes = [];
      for (let e2 = 0, i2 = t2.holes.length; e2 < i2; e2++) {
        const i3 = t2.holes[e2];
        this.holes.push(i3.clone());
      }
      return this;
    }
    toJSON() {
      const t2 = super.toJSON();
      t2.uuid = this.uuid, t2.holes = [];
      for (let e2 = 0, i2 = this.holes.length; e2 < i2; e2++) {
        const i3 = this.holes[e2];
        t2.holes.push(i3.toJSON());
      }
      return t2;
    }
    fromJSON(t2) {
      super.fromJSON(t2), this.uuid = t2.uuid, this.holes = [];
      for (let e2 = 0, i2 = t2.holes.length; e2 < i2; e2++) {
        const i3 = t2.holes[e2];
        this.holes.push(new zs().fromJSON(i3));
      }
      return this;
    }
  }
  class Xs extends Ct {
    constructor(t2, e2 = 1) {
      super(), this.type = "Light", this.color = new Zt(t2), this.intensity = e2;
    }
    dispose() {
    }
    copy(t2) {
      return super.copy(t2), this.color.copy(t2.color), this.intensity = t2.intensity, this;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, this.groundColor !== void 0 && (e2.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e2.object.distance = this.distance), this.angle !== void 0 && (e2.object.angle = this.angle), this.decay !== void 0 && (e2.object.decay = this.decay), this.penumbra !== void 0 && (e2.object.penumbra = this.penumbra), this.shadow !== void 0 && (e2.object.shadow = this.shadow.toJSON()), e2;
    }
  }
  Xs.prototype.isLight = true;
  class Ws extends Xs {
    constructor(t2, e2, i2) {
      super(t2, i2), this.type = "HemisphereLight", this.position.copy(Ct.DefaultUp), this.updateMatrix(), this.groundColor = new Zt(e2);
    }
    copy(t2) {
      return Xs.prototype.copy.call(this, t2), this.groundColor.copy(t2.groundColor), this;
    }
  }
  Ws.prototype.isHemisphereLight = true;
  const Ys = new rt(), qs = new M(), Zs = new M();
  class Js {
    constructor(t2) {
      this.camera = t2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new g(512, 512), this.map = null, this.mapPass = null, this.matrix = new rt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new qe(), this._frameExtents = new g(1, 1), this._viewportCount = 1, this._viewports = [new E(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t2) {
      const e2 = this.camera, i2 = this.matrix;
      qs.setFromMatrixPosition(t2.matrixWorld), e2.position.copy(qs), Zs.setFromMatrixPosition(t2.target.matrixWorld), e2.lookAt(Zs), e2.updateMatrixWorld(), Ys.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ys), i2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i2.multiply(e2.projectionMatrix), i2.multiply(e2.matrixWorldInverse);
    }
    getViewport(t2) {
      return this._viewports[t2];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t2) {
      return this.camera = t2.camera.clone(), this.bias = t2.bias, this.radius = t2.radius, this.mapSize.copy(t2.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t2 = {};
      return this.bias !== 0 && (t2.bias = this.bias), this.normalBias !== 0 && (t2.normalBias = this.normalBias), this.radius !== 1 && (t2.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t2.mapSize = this.mapSize.toArray()), t2.camera = this.camera.toJSON(false).object, delete t2.camera.matrix, t2;
    }
  }
  class Ks extends Js {
    constructor() {
      super(new Ue(50, 1, 0.5, 500)), this.focus = 1;
    }
    updateMatrices(t2) {
      const e2 = this.camera, i2 = 2 * h * t2.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, r2 = t2.distance || e2.far;
      i2 === e2.fov && n2 === e2.aspect && r2 === e2.far || (e2.fov = i2, e2.aspect = n2, e2.far = r2, e2.updateProjectionMatrix()), super.updateMatrices(t2);
    }
    copy(t2) {
      return super.copy(t2), this.focus = t2.focus, this;
    }
  }
  Ks.prototype.isSpotLightShadow = true;
  class Qs extends Xs {
    constructor(t2, e2, i2 = 0, n2 = Math.PI / 3, r2 = 0, o2 = 1) {
      super(t2, e2), this.type = "SpotLight", this.position.copy(Ct.DefaultUp), this.updateMatrix(), this.target = new Ct(), this.distance = i2, this.angle = n2, this.penumbra = r2, this.decay = o2, this.shadow = new Ks();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t2) {
      this.intensity = t2 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t2) {
      return super.copy(t2), this.distance = t2.distance, this.angle = t2.angle, this.penumbra = t2.penumbra, this.decay = t2.decay, this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
    }
  }
  Qs.prototype.isSpotLight = true;
  const $s = new rt(), ta = new M(), ea = new M();
  class ia extends Js {
    constructor() {
      super(new Ue(90, 1, 0.5, 500)), this._frameExtents = new g(4, 2), this._viewportCount = 6, this._viewports = [new E(2, 1, 1, 1), new E(0, 1, 1, 1), new E(3, 1, 1, 1), new E(1, 1, 1, 1), new E(3, 0, 1, 1), new E(1, 0, 1, 1)], this._cubeDirections = [new M(1, 0, 0), new M(-1, 0, 0), new M(0, 0, 1), new M(0, 0, -1), new M(0, 1, 0), new M(0, -1, 0)], this._cubeUps = [new M(0, 1, 0), new M(0, 1, 0), new M(0, 1, 0), new M(0, 1, 0), new M(0, 0, 1), new M(0, 0, -1)];
    }
    updateMatrices(t2, e2 = 0) {
      const i2 = this.camera, n2 = this.matrix, r2 = t2.distance || i2.far;
      r2 !== i2.far && (i2.far = r2, i2.updateProjectionMatrix()), ta.setFromMatrixPosition(t2.matrixWorld), i2.position.copy(ta), ea.copy(i2.position), ea.add(this._cubeDirections[e2]), i2.up.copy(this._cubeUps[e2]), i2.lookAt(ea), i2.updateMatrixWorld(), n2.makeTranslation(-ta.x, -ta.y, -ta.z), $s.multiplyMatrices(i2.projectionMatrix, i2.matrixWorldInverse), this._frustum.setFromProjectionMatrix($s);
    }
  }
  ia.prototype.isPointLightShadow = true;
  class na extends Xs {
    constructor(t2, e2, i2 = 0, n2 = 1) {
      super(t2, e2), this.type = "PointLight", this.distance = i2, this.decay = n2, this.shadow = new ia();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t2) {
      this.intensity = t2 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t2) {
      return super.copy(t2), this.distance = t2.distance, this.decay = t2.decay, this.shadow = t2.shadow.clone(), this;
    }
  }
  na.prototype.isPointLight = true;
  class ra extends Be {
    constructor(t2 = -1, e2 = 1, i2 = 1, n2 = -1, r2 = 0.1, o2 = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t2, this.right = e2, this.top = i2, this.bottom = n2, this.near = r2, this.far = o2, this.updateProjectionMatrix();
    }
    copy(t2, e2) {
      return super.copy(t2, e2), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.near = t2.near, this.far = t2.far, this.zoom = t2.zoom, this.view = t2.view === null ? null : Object.assign({}, t2.view), this;
    }
    setViewOffset(t2, e2, i2, n2, r2, o2) {
      this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = o2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t2 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), i2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
      let r2 = i2 - t2, o2 = i2 + t2, s2 = n2 + e2, a2 = n2 - e2;
      if (this.view !== null && this.view.enabled) {
        const t3 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r2 += t3 * this.view.offsetX, o2 = r2 + t3 * this.view.width, s2 -= e3 * this.view.offsetY, a2 = s2 - e3 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r2, o2, s2, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, this.view !== null && (e2.object.view = Object.assign({}, this.view)), e2;
    }
  }
  ra.prototype.isOrthographicCamera = true;
  class oa extends Js {
    constructor() {
      super(new ra(-5, 5, 5, -5, 0.5, 500));
    }
  }
  oa.prototype.isDirectionalLightShadow = true;
  class sa extends Xs {
    constructor(t2, e2) {
      super(t2, e2), this.type = "DirectionalLight", this.position.copy(Ct.DefaultUp), this.updateMatrix(), this.target = new Ct(), this.shadow = new oa();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t2) {
      return super.copy(t2), this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
    }
  }
  sa.prototype.isDirectionalLight = true;
  class aa extends Xs {
    constructor(t2, e2) {
      super(t2, e2), this.type = "AmbientLight";
    }
  }
  aa.prototype.isAmbientLight = true;
  class la extends Xs {
    constructor(t2, e2, i2 = 10, n2 = 10) {
      super(t2, e2), this.type = "RectAreaLight", this.width = i2, this.height = n2;
    }
    copy(t2) {
      return super.copy(t2), this.width = t2.width, this.height = t2.height, this;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.object.width = this.width, e2.object.height = this.height, e2;
    }
  }
  la.prototype.isRectAreaLight = true;
  class ha {
    constructor() {
      this.coefficients = [];
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients.push(new M());
    }
    set(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].copy(t2[e2]);
      return this;
    }
    zero() {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].set(0, 0, 0);
      return this;
    }
    getAt(t2, e2) {
      const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = this.coefficients;
      return e2.copy(o2[0]).multiplyScalar(0.282095), e2.addScaledVector(o2[1], 0.488603 * n2), e2.addScaledVector(o2[2], 0.488603 * r2), e2.addScaledVector(o2[3], 0.488603 * i2), e2.addScaledVector(o2[4], i2 * n2 * 1.092548), e2.addScaledVector(o2[5], n2 * r2 * 1.092548), e2.addScaledVector(o2[6], 0.315392 * (3 * r2 * r2 - 1)), e2.addScaledVector(o2[7], i2 * r2 * 1.092548), e2.addScaledVector(o2[8], 0.546274 * (i2 * i2 - n2 * n2)), e2;
    }
    getIrradianceAt(t2, e2) {
      const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = this.coefficients;
      return e2.copy(o2[0]).multiplyScalar(0.886227), e2.addScaledVector(o2[1], 1.023328 * n2), e2.addScaledVector(o2[2], 1.023328 * r2), e2.addScaledVector(o2[3], 1.023328 * i2), e2.addScaledVector(o2[4], 0.858086 * i2 * n2), e2.addScaledVector(o2[5], 0.858086 * n2 * r2), e2.addScaledVector(o2[6], 0.743125 * r2 * r2 - 0.247708), e2.addScaledVector(o2[7], 0.858086 * i2 * r2), e2.addScaledVector(o2[8], 0.429043 * (i2 * i2 - n2 * n2)), e2;
    }
    add(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].add(t2.coefficients[e2]);
      return this;
    }
    addScaledSH(t2, e2) {
      for (let i2 = 0; i2 < 9; i2++)
        this.coefficients[i2].addScaledVector(t2.coefficients[i2], e2);
      return this;
    }
    scale(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].multiplyScalar(t2);
      return this;
    }
    lerp(t2, e2) {
      for (let i2 = 0; i2 < 9; i2++)
        this.coefficients[i2].lerp(t2.coefficients[i2], e2);
      return this;
    }
    equals(t2) {
      for (let e2 = 0; e2 < 9; e2++)
        if (!this.coefficients[e2].equals(t2.coefficients[e2]))
          return false;
      return true;
    }
    copy(t2) {
      return this.set(t2.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t2, e2 = 0) {
      const i2 = this.coefficients;
      for (let n2 = 0; n2 < 9; n2++)
        i2[n2].fromArray(t2, e2 + 3 * n2);
      return this;
    }
    toArray(t2 = [], e2 = 0) {
      const i2 = this.coefficients;
      for (let n2 = 0; n2 < 9; n2++)
        i2[n2].toArray(t2, e2 + 3 * n2);
      return t2;
    }
    static getBasisAt(t2, e2) {
      const i2 = t2.x, n2 = t2.y, r2 = t2.z;
      e2[0] = 0.282095, e2[1] = 0.488603 * n2, e2[2] = 0.488603 * r2, e2[3] = 0.488603 * i2, e2[4] = 1.092548 * i2 * n2, e2[5] = 1.092548 * n2 * r2, e2[6] = 0.315392 * (3 * r2 * r2 - 1), e2[7] = 1.092548 * i2 * r2, e2[8] = 0.546274 * (i2 * i2 - n2 * n2);
    }
  }
  ha.prototype.isSphericalHarmonics3 = true;
  class ua extends Xs {
    constructor(t2 = new ha(), e2 = 1) {
      super(void 0, e2), this.sh = t2;
    }
    copy(t2) {
      return super.copy(t2), this.sh.copy(t2.sh), this;
    }
    fromJSON(t2) {
      return this.intensity = t2.intensity, this.sh.fromArray(t2.sh), this;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.object.sh = this.sh.toArray(), e2;
    }
  }
  ua.prototype.isLightProbe = true;
  class ca {
    static decodeText(t2) {
      if (typeof TextDecoder != "undefined")
        return new TextDecoder().decode(t2);
      let e2 = "";
      for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
        e2 += String.fromCharCode(t2[i2]);
      try {
        return decodeURIComponent(escape(e2));
      } catch (t3) {
        return e2;
      }
    }
    static extractUrlBase(t2) {
      const e2 = t2.lastIndexOf("/");
      return e2 === -1 ? "./" : t2.substr(0, e2 + 1);
    }
  }
  class da extends de {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(t2) {
      return super.copy(t2), this.instanceCount = t2.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t2 = super.toJSON(this);
      return t2.instanceCount = this.instanceCount, t2.isInstancedBufferGeometry = true, t2;
    }
  }
  da.prototype.isInstancedBufferGeometry = true;
  class pa extends $t {
    constructor(t2, e2, i2, n2 = 1) {
      typeof i2 == "number" && (n2 = i2, i2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t2, e2, i2), this.meshPerAttribute = n2;
    }
    copy(t2) {
      return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
    }
    toJSON() {
      const t2 = super.toJSON();
      return t2.meshPerAttribute = this.meshPerAttribute, t2.isInstancedBufferAttribute = true, t2;
    }
  }
  pa.prototype.isInstancedBufferAttribute = true;
  (class extends Fs {
    constructor(t2) {
      super(t2), typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(t2) {
      return this.options = t2, this;
    }
    load(t2, e2, i2, n2) {
      t2 === void 0 && (t2 = ""), this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
      const r2 = this, o2 = Ns.get(t2);
      if (o2 !== void 0)
        return r2.manager.itemStart(t2), setTimeout(function() {
          e2 && e2(o2), r2.manager.itemEnd(t2);
        }, 0), o2;
      const s2 = {};
      s2.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", s2.headers = this.requestHeader, fetch(t2, s2).then(function(t3) {
        return t3.blob();
      }).then(function(t3) {
        return createImageBitmap(t3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
      }).then(function(i3) {
        Ns.add(t2, i3), e2 && e2(i3), r2.manager.itemEnd(t2);
      }).catch(function(e3) {
        n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
      }), r2.manager.itemStart(t2);
    }
  }).prototype.isImageBitmapLoader = true;
  let va;
  const _a = function() {
    return va === void 0 && (va = new (window.AudioContext || window.webkitAudioContext)()), va;
  };
  class ya extends Fs {
    constructor(t2) {
      super(t2);
    }
    load(t2, e2, i2, n2) {
      const r2 = this, o2 = new Us(this.manager);
      o2.setResponseType("arraybuffer"), o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(t2, function(i3) {
        try {
          const t3 = i3.slice(0);
          _a().decodeAudioData(t3, function(t4) {
            e2(t4);
          });
        } catch (e3) {
          n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t2);
        }
      }, i2, n2);
    }
  }
  (class extends ua {
    constructor(t2, e2, i2 = 1) {
      super(void 0, i2);
      const n2 = new Zt().set(t2), r2 = new Zt().set(e2), o2 = new M(n2.r, n2.g, n2.b), s2 = new M(r2.r, r2.g, r2.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(o2).add(s2).multiplyScalar(a2), this.sh.coefficients[1].copy(o2).sub(s2).multiplyScalar(l2);
    }
  }).prototype.isHemisphereLightProbe = true;
  (class extends ua {
    constructor(t2, e2 = 1) {
      super(void 0, e2);
      const i2 = new Zt().set(t2);
      this.sh.coefficients[0].set(i2.r, i2.g, i2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }).prototype.isAmbientLightProbe = true;
  class xa extends Ct {
    constructor(t2) {
      super(), this.type = "Audio", this.listener = t2, this.context = t2.context, this.gain = this.context.createGain(), this.gain.connect(t2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(t2) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t2, this.connect(), this;
    }
    setMediaElementSource(t2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t2), this.connect(), this;
    }
    setMediaStreamSource(t2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t2), this.connect(), this;
    }
    setBuffer(t2) {
      return this.buffer = t2, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(t2 = 0) {
      if (this.isPlaying === true)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (this.hasPlaybackControl === false)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t2;
      const e2 = this.context.createBufferSource();
      return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl !== false)
        return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (this.hasPlaybackControl !== false)
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
          this.filters[t2 - 1].connect(this.filters[t2]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
          this.filters[t2 - 1].disconnect(this.filters[t2]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(t2) {
      return t2 || (t2 = []), this._connected === true ? (this.disconnect(), this.filters = t2.slice(), this.connect()) : this.filters = t2.slice(), this;
    }
    setDetune(t2) {
      if (this.detune = t2, this.source.detune !== void 0)
        return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(t2) {
      return this.setFilters(t2 ? [t2] : []);
    }
    setPlaybackRate(t2) {
      if (this.hasPlaybackControl !== false)
        return this.playbackRate = t2, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(t2) {
      if (this.hasPlaybackControl !== false)
        return this.loop = t2, this.isPlaying === true && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(t2) {
      return this.loopStart = t2, this;
    }
    setLoopEnd(t2) {
      return this.loopEnd = t2, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(t2) {
      return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
    }
  }
  class ba {
    constructor(t2, e2, i2) {
      let n2, r2, o2;
      switch (this.binding = t2, this.valueSize = i2, e2) {
        case "quaternion":
          n2 = this._slerp, r2 = this._slerpAdditive, o2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i2), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          n2 = this._select, r2 = this._select, o2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i2);
          break;
        default:
          n2 = this._lerp, r2 = this._lerpAdditive, o2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i2);
      }
      this._mixBufferRegion = n2, this._mixBufferRegionAdditive = r2, this._setIdentity = o2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(t2, e2) {
      const i2 = this.buffer, n2 = this.valueSize, r2 = t2 * n2 + n2;
      let o2 = this.cumulativeWeight;
      if (o2 === 0) {
        for (let t3 = 0; t3 !== n2; ++t3)
          i2[r2 + t3] = i2[t3];
        o2 = e2;
      } else {
        o2 += e2;
        const t3 = e2 / o2;
        this._mixBufferRegion(i2, r2, 0, t3, n2);
      }
      this.cumulativeWeight = o2;
    }
    accumulateAdditive(t2) {
      const e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e2, n2, 0, t2, i2), this.cumulativeWeightAdditive += t2;
    }
    apply(t2) {
      const e2 = this.valueSize, i2 = this.buffer, n2 = t2 * e2 + e2, r2 = this.cumulativeWeight, o2 = this.cumulativeWeightAdditive, s2 = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
        const t3 = e2 * this._origIndex;
        this._mixBufferRegion(i2, n2, t3, 1 - r2, e2);
      }
      o2 > 0 && this._mixBufferRegionAdditive(i2, n2, this._addIndex * e2, 1, e2);
      for (let t3 = e2, r3 = e2 + e2; t3 !== r3; ++t3)
        if (i2[t3] !== i2[t3 + e2]) {
          s2.setValue(i2, n2);
          break;
        }
    }
    saveOriginalState() {
      const t2 = this.binding, e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._origIndex;
      t2.getValue(e2, n2);
      for (let t3 = i2, r2 = n2; t3 !== r2; ++t3)
        e2[t3] = e2[n2 + t3 % i2];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const t2 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t2);
    }
    _setAdditiveIdentityNumeric() {
      const t2 = this._addIndex * this.valueSize, e2 = t2 + this.valueSize;
      for (let i2 = t2; i2 < e2; i2++)
        this.buffer[i2] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const t2 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
      for (let i2 = 0; i2 < this.valueSize; i2++)
        this.buffer[e2 + i2] = this.buffer[t2 + i2];
    }
    _select(t2, e2, i2, n2, r2) {
      if (n2 >= 0.5)
        for (let n3 = 0; n3 !== r2; ++n3)
          t2[e2 + n3] = t2[i2 + n3];
    }
    _slerp(t2, e2, i2, n2) {
      A.slerpFlat(t2, e2, t2, e2, t2, i2, n2);
    }
    _slerpAdditive(t2, e2, i2, n2, r2) {
      const o2 = this._workIndex * r2;
      A.multiplyQuaternionsFlat(t2, o2, t2, e2, t2, i2), A.slerpFlat(t2, e2, t2, e2, t2, o2, n2);
    }
    _lerp(t2, e2, i2, n2, r2) {
      const o2 = 1 - n2;
      for (let s2 = 0; s2 !== r2; ++s2) {
        const r3 = e2 + s2;
        t2[r3] = t2[r3] * o2 + t2[i2 + s2] * n2;
      }
    }
    _lerpAdditive(t2, e2, i2, n2, r2) {
      for (let o2 = 0; o2 !== r2; ++o2) {
        const r3 = e2 + o2;
        t2[r3] = t2[r3] + t2[i2 + o2] * n2;
      }
    }
  }
  const Ta = new RegExp("[\\[\\]\\.:\\/]", "g"), Ea = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Sa = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), wa = /(WCOD+)?/.source.replace("WCOD", Ea), Aa = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ma = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ra = new RegExp("^" + Sa + wa + Aa + Ma + "$"), Ca = ["material", "materials", "bones"];
  class Ia {
    constructor(t2, e2, i2) {
      this.path = e2, this.parsedPath = i2 || Ia.parseTrackName(e2), this.node = Ia.findNode(t2, this.parsedPath.nodeName) || t2, this.rootNode = t2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(t2, e2, i2) {
      return t2 && t2.isAnimationObjectGroup ? new Ia.Composite(t2, e2, i2) : new Ia(t2, e2, i2);
    }
    static sanitizeNodeName(t2) {
      return t2.replace(/\s/g, "_").replace(Ta, "");
    }
    static parseTrackName(t2) {
      const e2 = Ra.exec(t2);
      if (!e2)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t2);
      const i2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, n2 = i2.nodeName && i2.nodeName.lastIndexOf(".");
      if (n2 !== void 0 && n2 !== -1) {
        const t3 = i2.nodeName.substring(n2 + 1);
        Ca.indexOf(t3) !== -1 && (i2.nodeName = i2.nodeName.substring(0, n2), i2.objectName = t3);
      }
      if (i2.propertyName === null || i2.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t2);
      return i2;
    }
    static findNode(t2, e2) {
      if (!e2 || e2 === "" || e2 === "." || e2 === -1 || e2 === t2.name || e2 === t2.uuid)
        return t2;
      if (t2.skeleton) {
        const i2 = t2.skeleton.getBoneByName(e2);
        if (i2 !== void 0)
          return i2;
      }
      if (t2.children) {
        const i2 = function(t3) {
          for (let n3 = 0; n3 < t3.length; n3++) {
            const r2 = t3[n3];
            if (r2.name === e2 || r2.uuid === e2)
              return r2;
            const o2 = i2(r2.children);
            if (o2)
              return o2;
          }
          return null;
        }, n2 = i2(t2.children);
        if (n2)
          return n2;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(t2, e2) {
      t2[e2] = this.node[this.propertyName];
    }
    _getValue_array(t2, e2) {
      const i2 = this.resolvedProperty;
      for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
        t2[e2++] = i2[n2];
    }
    _getValue_arrayElement(t2, e2) {
      t2[e2] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t2, e2) {
      this.resolvedProperty.toArray(t2, e2);
    }
    _setValue_direct(t2, e2) {
      this.targetObject[this.propertyName] = t2[e2];
    }
    _setValue_direct_setNeedsUpdate(t2, e2) {
      this.targetObject[this.propertyName] = t2[e2], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t2, e2) {
      this.targetObject[this.propertyName] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(t2, e2) {
      const i2 = this.resolvedProperty;
      for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
        i2[n2] = t2[e2++];
    }
    _setValue_array_setNeedsUpdate(t2, e2) {
      const i2 = this.resolvedProperty;
      for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
        i2[n2] = t2[e2++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t2, e2) {
      const i2 = this.resolvedProperty;
      for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
        i2[n2] = t2[e2++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(t2, e2) {
      this.resolvedProperty[this.propertyIndex] = t2[e2];
    }
    _setValue_arrayElement_setNeedsUpdate(t2, e2) {
      this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t2, e2) {
      this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(t2, e2) {
      this.resolvedProperty.fromArray(t2, e2);
    }
    _setValue_fromArray_setNeedsUpdate(t2, e2) {
      this.resolvedProperty.fromArray(t2, e2), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t2, e2) {
      this.resolvedProperty.fromArray(t2, e2), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(t2, e2) {
      this.bind(), this.getValue(t2, e2);
    }
    _setValue_unbound(t2, e2) {
      this.bind(), this.setValue(t2, e2);
    }
    bind() {
      let t2 = this.node;
      const e2 = this.parsedPath, i2 = e2.objectName, n2 = e2.propertyName;
      let r2 = e2.propertyIndex;
      if (t2 || (t2 = Ia.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t2)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (i2) {
        let n3 = e2.objectIndex;
        switch (i2) {
          case "materials":
            if (!t2.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t2.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t2 = t2.material.materials;
            break;
          case "bones":
            if (!t2.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t2 = t2.skeleton.bones;
            for (let e3 = 0; e3 < t2.length; e3++)
              if (t2[e3].name === n3) {
                n3 = e3;
                break;
              }
            break;
          default:
            if (t2[i2] === void 0)
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t2 = t2[i2];
        }
        if (n3 !== void 0) {
          if (t2[n3] === void 0)
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t2);
          t2 = t2[n3];
        }
      }
      const o2 = t2[n2];
      if (o2 === void 0) {
        const i3 = e2.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i3 + "." + n2 + " but it wasn't found.", t2);
      }
      let s2 = this.Versioning.None;
      this.targetObject = t2, t2.needsUpdate !== void 0 ? s2 = this.Versioning.NeedsUpdate : t2.matrixWorldNeedsUpdate !== void 0 && (s2 = this.Versioning.MatrixWorldNeedsUpdate);
      let a2 = this.BindingType.Direct;
      if (r2 !== void 0) {
        if (n2 === "morphTargetInfluences") {
          if (!t2.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t2.geometry.isBufferGeometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          if (!t2.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          t2.morphTargetDictionary[r2] !== void 0 && (r2 = t2.morphTargetDictionary[r2]);
        }
        a2 = this.BindingType.ArrayElement, this.resolvedProperty = o2, this.propertyIndex = r2;
      } else
        o2.fromArray !== void 0 && o2.toArray !== void 0 ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = o2) : Array.isArray(o2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = o2) : this.propertyName = n2;
      this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][s2];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  Ia.Composite = class {
    constructor(t2, e2, i2) {
      const n2 = i2 || Ia.parseTrackName(e2);
      this._targetGroup = t2, this._bindings = t2.subscribe_(e2, n2);
    }
    getValue(t2, e2) {
      this.bind();
      const i2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[i2];
      n2 !== void 0 && n2.getValue(t2, e2);
    }
    setValue(t2, e2) {
      const i2 = this._bindings;
      for (let n2 = this._targetGroup.nCachedObjects_, r2 = i2.length; n2 !== r2; ++n2)
        i2[n2].setValue(t2, e2);
    }
    bind() {
      const t2 = this._bindings;
      for (let e2 = this._targetGroup.nCachedObjects_, i2 = t2.length; e2 !== i2; ++e2)
        t2[e2].bind();
    }
    unbind() {
      const t2 = this._bindings;
      for (let e2 = this._targetGroup.nCachedObjects_, i2 = t2.length; e2 !== i2; ++e2)
        t2[e2].unbind();
    }
  }, Ia.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ia.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ia.prototype.GetterByBindingType = [Ia.prototype._getValue_direct, Ia.prototype._getValue_array, Ia.prototype._getValue_arrayElement, Ia.prototype._getValue_toArray], Ia.prototype.SetterByBindingTypeAndVersioning = [[Ia.prototype._setValue_direct, Ia.prototype._setValue_direct_setNeedsUpdate, Ia.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_array, Ia.prototype._setValue_array_setNeedsUpdate, Ia.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_arrayElement, Ia.prototype._setValue_arrayElement_setNeedsUpdate, Ia.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_fromArray, Ia.prototype._setValue_fromArray_setNeedsUpdate, Ia.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class Pa {
    constructor(t2, e2, i2 = null, n2 = e2.blendMode) {
      this._mixer = t2, this._clip = e2, this._localRoot = i2, this.blendMode = n2;
      const r2 = e2.tracks, o2 = r2.length, s2 = new Array(o2), a2 = { endingStart: 2400, endingEnd: 2400 };
      for (let t3 = 0; t3 !== o2; ++t3) {
        const e3 = r2[t3].createInterpolant(null);
        s2[t3] = e3, e3.settings = a2;
      }
      this._interpolantSettings = a2, this._interpolants = s2, this._propertyBindings = new Array(o2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(t2) {
      return this._startTime = t2, this;
    }
    setLoop(t2, e2) {
      return this.loop = t2, this.repetitions = e2, this;
    }
    setEffectiveWeight(t2) {
      return this.weight = t2, this._effectiveWeight = this.enabled ? t2 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(t2) {
      return this._scheduleFading(t2, 0, 1);
    }
    fadeOut(t2) {
      return this._scheduleFading(t2, 1, 0);
    }
    crossFadeFrom(t2, e2, i2) {
      if (t2.fadeOut(e2), this.fadeIn(e2), i2) {
        const i3 = this._clip.duration, n2 = t2._clip.duration, r2 = n2 / i3, o2 = i3 / n2;
        t2.warp(1, r2, e2), this.warp(o2, 1, e2);
      }
      return this;
    }
    crossFadeTo(t2, e2, i2) {
      return t2.crossFadeFrom(this, e2, i2);
    }
    stopFading() {
      const t2 = this._weightInterpolant;
      return t2 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
    }
    setEffectiveTimeScale(t2) {
      return this.timeScale = t2, this._effectiveTimeScale = this.paused ? 0 : t2, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(t2) {
      return this.timeScale = this._clip.duration / t2, this.stopWarping();
    }
    syncWith(t2) {
      return this.time = t2.time, this.timeScale = t2.timeScale, this.stopWarping();
    }
    halt(t2) {
      return this.warp(this._effectiveTimeScale, 0, t2);
    }
    warp(t2, e2, i2) {
      const n2 = this._mixer, r2 = n2.time, o2 = this.timeScale;
      let s2 = this._timeScaleInterpolant;
      s2 === null && (s2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = s2);
      const a2 = s2.parameterPositions, l2 = s2.sampleValues;
      return a2[0] = r2, a2[1] = r2 + i2, l2[0] = t2 / o2, l2[1] = e2 / o2, this;
    }
    stopWarping() {
      const t2 = this._timeScaleInterpolant;
      return t2 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(t2, e2, i2, n2) {
      if (!this.enabled)
        return void this._updateWeight(t2);
      const r2 = this._startTime;
      if (r2 !== null) {
        const n3 = (t2 - r2) * i2;
        if (n3 < 0 || i2 === 0)
          return;
        this._startTime = null, e2 = i2 * n3;
      }
      e2 *= this._updateTimeScale(t2);
      const o2 = this._updateTime(e2), s2 = this._updateWeight(t2);
      if (s2 > 0) {
        const t3 = this._interpolants, e3 = this._propertyBindings;
        switch (this.blendMode) {
          case 2501:
            for (let i3 = 0, n3 = t3.length; i3 !== n3; ++i3)
              t3[i3].evaluate(o2), e3[i3].accumulateAdditive(s2);
            break;
          case 2500:
          default:
            for (let i3 = 0, r3 = t3.length; i3 !== r3; ++i3)
              t3[i3].evaluate(o2), e3[i3].accumulate(n2, s2);
        }
      }
    }
    _updateWeight(t2) {
      let e2 = 0;
      if (this.enabled) {
        e2 = this.weight;
        const i2 = this._weightInterpolant;
        if (i2 !== null) {
          const n2 = i2.evaluate(t2)[0];
          e2 *= n2, t2 > i2.parameterPositions[1] && (this.stopFading(), n2 === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = e2, e2;
    }
    _updateTimeScale(t2) {
      let e2 = 0;
      if (!this.paused) {
        e2 = this.timeScale;
        const i2 = this._timeScaleInterpolant;
        if (i2 !== null) {
          e2 *= i2.evaluate(t2)[0], t2 > i2.parameterPositions[1] && (this.stopWarping(), e2 === 0 ? this.paused = true : this.timeScale = e2);
        }
      }
      return this._effectiveTimeScale = e2, e2;
    }
    _updateTime(t2) {
      const e2 = this._clip.duration, i2 = this.loop;
      let n2 = this.time + t2, r2 = this._loopCount;
      const o2 = i2 === 2202;
      if (t2 === 0)
        return r2 === -1 ? n2 : o2 && (1 & r2) == 1 ? e2 - n2 : n2;
      if (i2 === 2200) {
        r2 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        t: {
          if (n2 >= e2)
            n2 = e2;
          else {
            if (!(n2 < 0)) {
              this.time = n2;
              break t;
            }
            n2 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 < 0 ? -1 : 1 });
        }
      } else {
        if (r2 === -1 && (t2 >= 0 ? (r2 = 0, this._setEndings(true, this.repetitions === 0, o2)) : this._setEndings(this.repetitions === 0, true, o2)), n2 >= e2 || n2 < 0) {
          const i3 = Math.floor(n2 / e2);
          n2 -= e2 * i3, r2 += Math.abs(i3);
          const s2 = this.repetitions - r2;
          if (s2 <= 0)
            this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = t2 > 0 ? e2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 > 0 ? 1 : -1 });
          else {
            if (s2 === 1) {
              const e3 = t2 < 0;
              this._setEndings(e3, !e3, o2);
            } else
              this._setEndings(false, false, o2);
            this._loopCount = r2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i3 });
          }
        } else
          this.time = n2;
        if (o2 && (1 & r2) == 1)
          return e2 - n2;
      }
      return n2;
    }
    _setEndings(t2, e2, i2) {
      const n2 = this._interpolantSettings;
      i2 ? (n2.endingStart = 2401, n2.endingEnd = 2401) : (n2.endingStart = t2 ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n2.endingEnd = e2 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    }
    _scheduleFading(t2, e2, i2) {
      const n2 = this._mixer, r2 = n2.time;
      let o2 = this._weightInterpolant;
      o2 === null && (o2 = n2._lendControlInterpolant(), this._weightInterpolant = o2);
      const s2 = o2.parameterPositions, a2 = o2.sampleValues;
      return s2[0] = r2, a2[0] = e2, s2[1] = r2 + t2, a2[1] = i2, this;
    }
  }
  (class extends s {
    constructor(t2) {
      super(), this._root = t2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(t2, e2) {
      const i2 = t2._localRoot || this._root, n2 = t2._clip.tracks, r2 = n2.length, o2 = t2._propertyBindings, s2 = t2._interpolants, a2 = i2.uuid, l2 = this._bindingsByRootAndName;
      let h2 = l2[a2];
      h2 === void 0 && (h2 = {}, l2[a2] = h2);
      for (let t3 = 0; t3 !== r2; ++t3) {
        const r3 = n2[t3], l3 = r3.name;
        let u2 = h2[l3];
        if (u2 !== void 0)
          o2[t3] = u2;
        else {
          if (u2 = o2[t3], u2 !== void 0) {
            u2._cacheIndex === null && (++u2.referenceCount, this._addInactiveBinding(u2, a2, l3));
            continue;
          }
          const n3 = e2 && e2._propertyBindings[t3].binding.parsedPath;
          u2 = new ba(Ia.create(i2, l3, n3), r3.ValueTypeName, r3.getValueSize()), ++u2.referenceCount, this._addInactiveBinding(u2, a2, l3), o2[t3] = u2;
        }
        s2[t3].resultBuffer = u2.buffer;
      }
    }
    _activateAction(t2) {
      if (!this._isActiveAction(t2)) {
        if (t2._cacheIndex === null) {
          const e3 = (t2._localRoot || this._root).uuid, i2 = t2._clip.uuid, n2 = this._actionsByClip[i2];
          this._bindAction(t2, n2 && n2.knownActions[0]), this._addInactiveAction(t2, i2, e3);
        }
        const e2 = t2._propertyBindings;
        for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
          const i3 = e2[t3];
          i3.useCount++ == 0 && (this._lendBinding(i3), i3.saveOriginalState());
        }
        this._lendAction(t2);
      }
    }
    _deactivateAction(t2) {
      if (this._isActiveAction(t2)) {
        const e2 = t2._propertyBindings;
        for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
          const i3 = e2[t3];
          --i3.useCount == 0 && (i3.restoreOriginalState(), this._takeBackBinding(i3));
        }
        this._takeBackAction(t2);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const t2 = this;
      this.stats = { actions: { get total() {
        return t2._actions.length;
      }, get inUse() {
        return t2._nActiveActions;
      } }, bindings: { get total() {
        return t2._bindings.length;
      }, get inUse() {
        return t2._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return t2._controlInterpolants.length;
      }, get inUse() {
        return t2._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(t2) {
      const e2 = t2._cacheIndex;
      return e2 !== null && e2 < this._nActiveActions;
    }
    _addInactiveAction(t2, e2, i2) {
      const n2 = this._actions, r2 = this._actionsByClip;
      let o2 = r2[e2];
      if (o2 === void 0)
        o2 = { knownActions: [t2], actionByRoot: {} }, t2._byClipCacheIndex = 0, r2[e2] = o2;
      else {
        const e3 = o2.knownActions;
        t2._byClipCacheIndex = e3.length, e3.push(t2);
      }
      t2._cacheIndex = n2.length, n2.push(t2), o2.actionByRoot[i2] = t2;
    }
    _removeInactiveAction(t2) {
      const e2 = this._actions, i2 = e2[e2.length - 1], n2 = t2._cacheIndex;
      i2._cacheIndex = n2, e2[n2] = i2, e2.pop(), t2._cacheIndex = null;
      const r2 = t2._clip.uuid, o2 = this._actionsByClip, s2 = o2[r2], a2 = s2.knownActions, l2 = a2[a2.length - 1], h2 = t2._byClipCacheIndex;
      l2._byClipCacheIndex = h2, a2[h2] = l2, a2.pop(), t2._byClipCacheIndex = null;
      delete s2.actionByRoot[(t2._localRoot || this._root).uuid], a2.length === 0 && delete o2[r2], this._removeInactiveBindingsForAction(t2);
    }
    _removeInactiveBindingsForAction(t2) {
      const e2 = t2._propertyBindings;
      for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
        const i3 = e2[t3];
        --i3.referenceCount == 0 && this._removeInactiveBinding(i3);
      }
    }
    _lendAction(t2) {
      const e2 = this._actions, i2 = t2._cacheIndex, n2 = this._nActiveActions++, r2 = e2[n2];
      t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
    }
    _takeBackAction(t2) {
      const e2 = this._actions, i2 = t2._cacheIndex, n2 = --this._nActiveActions, r2 = e2[n2];
      t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
    }
    _addInactiveBinding(t2, e2, i2) {
      const n2 = this._bindingsByRootAndName, r2 = this._bindings;
      let o2 = n2[e2];
      o2 === void 0 && (o2 = {}, n2[e2] = o2), o2[i2] = t2, t2._cacheIndex = r2.length, r2.push(t2);
    }
    _removeInactiveBinding(t2) {
      const e2 = this._bindings, i2 = t2.binding, n2 = i2.rootNode.uuid, r2 = i2.path, o2 = this._bindingsByRootAndName, s2 = o2[n2], a2 = e2[e2.length - 1], l2 = t2._cacheIndex;
      a2._cacheIndex = l2, e2[l2] = a2, e2.pop(), delete s2[r2], Object.keys(s2).length === 0 && delete o2[n2];
    }
    _lendBinding(t2) {
      const e2 = this._bindings, i2 = t2._cacheIndex, n2 = this._nActiveBindings++, r2 = e2[n2];
      t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
    }
    _takeBackBinding(t2) {
      const e2 = this._bindings, i2 = t2._cacheIndex, n2 = --this._nActiveBindings, r2 = e2[n2];
      t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
    }
    _lendControlInterpolant() {
      const t2 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
      let i2 = t2[e2];
      return i2 === void 0 && (i2 = new bs(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i2.__cacheIndex = e2, t2[e2] = i2), i2;
    }
    _takeBackControlInterpolant(t2) {
      const e2 = this._controlInterpolants, i2 = t2.__cacheIndex, n2 = --this._nActiveControlInterpolants, r2 = e2[n2];
      t2.__cacheIndex = n2, e2[n2] = t2, r2.__cacheIndex = i2, e2[i2] = r2;
    }
    clipAction(t2, e2, i2) {
      const n2 = e2 || this._root, r2 = n2.uuid;
      let o2 = typeof t2 == "string" ? Ps.findByName(n2, t2) : t2;
      const s2 = o2 !== null ? o2.uuid : t2, a2 = this._actionsByClip[s2];
      let l2 = null;
      if (i2 === void 0 && (i2 = o2 !== null ? o2.blendMode : 2500), a2 !== void 0) {
        const t3 = a2.actionByRoot[r2];
        if (t3 !== void 0 && t3.blendMode === i2)
          return t3;
        l2 = a2.knownActions[0], o2 === null && (o2 = l2._clip);
      }
      if (o2 === null)
        return null;
      const h2 = new Pa(this, o2, e2, i2);
      return this._bindAction(h2, l2), this._addInactiveAction(h2, s2, r2), h2;
    }
    existingAction(t2, e2) {
      const i2 = e2 || this._root, n2 = i2.uuid, r2 = typeof t2 == "string" ? Ps.findByName(i2, t2) : t2, o2 = r2 ? r2.uuid : t2, s2 = this._actionsByClip[o2];
      return s2 !== void 0 && s2.actionByRoot[n2] || null;
    }
    stopAllAction() {
      const t2 = this._actions;
      for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2)
        t2[e2].stop();
      return this;
    }
    update(t2) {
      t2 *= this.timeScale;
      const e2 = this._actions, i2 = this._nActiveActions, n2 = this.time += t2, r2 = Math.sign(t2), o2 = this._accuIndex ^= 1;
      for (let s3 = 0; s3 !== i2; ++s3) {
        e2[s3]._update(n2, t2, r2, o2);
      }
      const s2 = this._bindings, a2 = this._nActiveBindings;
      for (let t3 = 0; t3 !== a2; ++t3)
        s2[t3].apply(o2);
      return this;
    }
    setTime(t2) {
      this.time = 0;
      for (let t3 = 0; t3 < this._actions.length; t3++)
        this._actions[t3].time = 0;
      return this.update(t2);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(t2) {
      const e2 = this._actions, i2 = t2.uuid, n2 = this._actionsByClip, r2 = n2[i2];
      if (r2 !== void 0) {
        const t3 = r2.knownActions;
        for (let i3 = 0, n3 = t3.length; i3 !== n3; ++i3) {
          const n4 = t3[i3];
          this._deactivateAction(n4);
          const r3 = n4._cacheIndex, o2 = e2[e2.length - 1];
          n4._cacheIndex = null, n4._byClipCacheIndex = null, o2._cacheIndex = r3, e2[r3] = o2, e2.pop(), this._removeInactiveBindingsForAction(n4);
        }
        delete n2[i2];
      }
    }
    uncacheRoot(t2) {
      const e2 = t2.uuid, i2 = this._actionsByClip;
      for (const t3 in i2) {
        const n3 = i2[t3].actionByRoot[e2];
        n3 !== void 0 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
      }
      const n2 = this._bindingsByRootAndName[e2];
      if (n2 !== void 0)
        for (const t3 in n2) {
          const e3 = n2[t3];
          e3.restoreOriginalState(), this._removeInactiveBinding(e3);
        }
    }
    uncacheAction(t2, e2) {
      const i2 = this.existingAction(t2, e2);
      i2 !== null && (this._deactivateAction(i2), this._removeInactiveAction(i2));
    }
  }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  (class extends fr {
    constructor(t2, e2, i2 = 1) {
      super(t2, e2), this.meshPerAttribute = i2;
    }
    copy(t2) {
      return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
    }
    clone(t2) {
      const e2 = super.clone(t2);
      return e2.meshPerAttribute = this.meshPerAttribute, e2;
    }
    toJSON(t2) {
      const e2 = super.toJSON(t2);
      return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
    }
  }).prototype.isInstancedInterleavedBuffer = true;
  new g();
  new M();
  new M();
  (class extends Ct {
    constructor(t2) {
      super(), this.material = t2, this.render = function() {
      }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
    }
  }).prototype.isImmediateRenderObject = true;
  const Ba = new M(), Ua = new rt(), ka = new rt();
  const Ga = new Float32Array(1);
  new Int32Array(Ga.buffer);
  const Ha = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ja = 5 + Ha.length, za = new Jt({ side: 1, depthWrite: false, depthTest: false });
  new Ie(new Oe(), za), Ya();
  function Ya() {
    const t2 = [], e2 = [], i2 = [];
    let n2 = 8;
    for (let r2 = 0; r2 < ja; r2++) {
      const o2 = Math.pow(2, n2);
      e2.push(o2);
      let s2 = 1 / o2;
      r2 > 4 ? s2 = Ha[r2 - 8 + 4 - 1] : r2 == 0 && (s2 = 0), i2.push(s2);
      const a2 = 1 / (o2 - 1), l2 = -a2 / 2, h2 = 1 + a2 / 2, u2 = [l2, l2, h2, l2, h2, h2, l2, l2, h2, h2, l2, h2], c2 = 6, d2 = 6, p2 = 3, f2 = 2, m2 = 1, g2 = new Float32Array(p2 * d2 * c2), v2 = new Float32Array(f2 * d2 * c2), _2 = new Float32Array(m2 * d2 * c2);
      for (let t3 = 0; t3 < c2; t3++) {
        const e3 = t3 % 3 * 2 / 3 - 1, i3 = t3 > 2 ? 0 : -1, n3 = [e3, i3, 0, e3 + 2 / 3, i3, 0, e3 + 2 / 3, i3 + 1, 0, e3, i3, 0, e3 + 2 / 3, i3 + 1, 0, e3, i3 + 1, 0];
        g2.set(n3, p2 * d2 * t3), v2.set(u2, f2 * d2 * t3);
        const r3 = [t3, t3, t3, t3, t3, t3];
        _2.set(r3, m2 * d2 * t3);
      }
      const y2 = new de();
      y2.setAttribute("position", new $t(g2, p2)), y2.setAttribute("uv", new $t(v2, f2)), y2.setAttribute("faceIndex", new $t(_2, m2)), t2.push(y2), n2 > 4 && n2--;
    }
    return { _lodPlanes: t2, _sizeLods: e2, _sigmas: i2 };
  }
  co.create = function(t2, e2) {
    return console.log("THREE.Curve.create() has been deprecated"), t2.prototype = Object.create(co.prototype), t2.prototype.constructor = t2, t2.prototype.getPoint = e2, t2;
  }, zs.prototype.fromPoints = function(t2) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t2);
  }, class extends eo {
    constructor(t2 = 10, e2 = 10, i2 = 4473924, n2 = 8947848) {
      i2 = new Zt(i2), n2 = new Zt(n2);
      const r2 = e2 / 2, o2 = t2 / e2, s2 = t2 / 2, a2 = [], l2 = [];
      for (let t3 = 0, h3 = 0, u2 = -s2; t3 <= e2; t3++, u2 += o2) {
        a2.push(-s2, 0, u2, s2, 0, u2), a2.push(u2, 0, -s2, u2, 0, s2);
        const e3 = t3 === r2 ? i2 : n2;
        e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3;
      }
      const h2 = new de();
      h2.setAttribute("position", new ne(a2, 3)), h2.setAttribute("color", new ne(l2, 3));
      super(h2, new Wr({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
    }
  }.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  }, class extends eo {
    constructor(t2) {
      const e2 = function t3(e3) {
        const i3 = [];
        e3 && e3.isBone && i3.push(e3);
        for (let n3 = 0; n3 < e3.children.length; n3++)
          i3.push.apply(i3, t3(e3.children[n3]));
        return i3;
      }(t2), i2 = new de(), n2 = [], r2 = [], o2 = new Zt(0, 0, 1), s2 = new Zt(0, 1, 0);
      for (let t3 = 0; t3 < e2.length; t3++) {
        const i3 = e2[t3];
        i3.parent && i3.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), r2.push(o2.r, o2.g, o2.b), r2.push(s2.r, s2.g, s2.b));
      }
      i2.setAttribute("position", new ne(n2, 3)), i2.setAttribute("color", new ne(r2, 3));
      super(i2, new Wr({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t2, this.bones = e2, this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(t2) {
      const e2 = this.bones, i2 = this.geometry, n2 = i2.getAttribute("position");
      ka.copy(this.root.matrixWorld).invert();
      for (let t3 = 0, i3 = 0; t3 < e2.length; t3++) {
        const r2 = e2[t3];
        r2.parent && r2.parent.isBone && (Ua.multiplyMatrices(ka, r2.matrixWorld), Ba.setFromMatrixPosition(Ua), n2.setXYZ(i3, Ba.x, Ba.y, Ba.z), Ua.multiplyMatrices(ka, r2.parent.matrixWorld), Ba.setFromMatrixPosition(Ua), n2.setXYZ(i3 + 1, Ba.x, Ba.y, Ba.z), i3 += 2);
      }
      i2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t2);
    }
  }.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  }, Fs.prototype.extractUrlBase = function(t2) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ca.extractUrlBase(t2);
  }, Fs.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } }, I.prototype.center = function(t2) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
  }, I.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, I.prototype.isIntersectionBox = function(t2) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
  }, I.prototype.isIntersectionSphere = function(t2) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
  }, I.prototype.size = function(t2) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t2);
  }, Z.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, qe.prototype.setFromMatrix = function(t2) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t2);
  }, v.prototype.flattenToArrayOffset = function(t2, e2) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
  }, v.prototype.multiplyVector3 = function(t2) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
  }, v.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, v.prototype.applyToBufferAttribute = function(t2) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
  }, v.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }, v.prototype.getInverse = function(t2) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
  }, rt.prototype.extractPosition = function(t2) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t2);
  }, rt.prototype.flattenToArrayOffset = function(t2, e2) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
  }, rt.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new M().setFromMatrixColumn(this, 3);
  }, rt.prototype.setRotationFromQuaternion = function(t2) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t2);
  }, rt.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, rt.prototype.multiplyVector3 = function(t2) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
  }, rt.prototype.multiplyVector4 = function(t2) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
  }, rt.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, rt.prototype.rotateAxis = function(t2) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t2.transformDirection(this);
  }, rt.prototype.crossVector = function(t2) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
  }, rt.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, rt.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, rt.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, rt.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, rt.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, rt.prototype.applyToBufferAttribute = function(t2) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
  }, rt.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, rt.prototype.makeFrustum = function(t2, e2, i2, n2, r2, o2) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t2, e2, n2, i2, r2, o2);
  }, rt.prototype.getInverse = function(t2) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
  }, Xe.prototype.isIntersectionLine = function(t2) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t2);
  }, A.prototype.multiplyVector3 = function(t2) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t2.applyQuaternion(this);
  }, A.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }, nt.prototype.isIntersectionBox = function(t2) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
  }, nt.prototype.isIntersectionPlane = function(t2) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t2);
  }, nt.prototype.isIntersectionSphere = function(t2) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
  }, Gt.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  }, Gt.prototype.barycoordFromPoint = function(t2, e2) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t2, e2);
  }, Gt.prototype.midpoint = function(t2) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t2);
  }, Gt.prototypenormal = function(t2) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t2);
  }, Gt.prototype.plane = function(t2) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t2);
  }, Gt.barycoordFromPoint = function(t2, e2, i2, n2, r2) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Gt.getBarycoord(t2, e2, i2, n2, r2);
  }, Gt.normal = function(t2, e2, i2, n2) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Gt.getNormal(t2, e2, i2, n2);
  }, Vs.prototype.extractAllPoints = function(t2) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t2);
  }, Vs.prototype.extrude = function(t2) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new os(this, t2);
  }, Vs.prototype.makeGeometry = function(t2) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new as(this, t2);
  }, g.prototype.fromAttribute = function(t2, e2, i2) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
  }, g.prototype.distanceToManhattan = function(t2) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
  }, g.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, M.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, M.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, M.prototype.getPositionFromMatrix = function(t2) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t2);
  }, M.prototype.getScaleFromMatrix = function(t2) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t2);
  }, M.prototype.getColumnFromMatrix = function(t2, e2) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e2, t2);
  }, M.prototype.applyProjection = function(t2) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t2);
  }, M.prototype.fromAttribute = function(t2, e2, i2) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
  }, M.prototype.distanceToManhattan = function(t2) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
  }, M.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, E.prototype.fromAttribute = function(t2, e2, i2) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
  }, E.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, Ct.prototype.getChildByName = function(t2) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t2);
  }, Ct.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, Ct.prototype.translate = function(t2, e2) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e2, t2);
  }, Ct.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, Ct.prototype.applyMatrix = function(t2) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
  }, Object.defineProperties(Ct.prototype, { eulerOrder: { get: function() {
    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
  }, set: function(t2) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t2;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } }), Ie.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }, Object.defineProperties(Ie.prototype, { drawMode: { get: function() {
    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } }), Ur.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }, Ue.prototype.setLens = function(t2, e2) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e2 !== void 0 && (this.filmGauge = e2), this.setFocalLength(t2);
  }, Object.defineProperties(Xs.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t2;
  } }, shadowCameraLeft: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t2;
  } }, shadowCameraRight: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t2;
  } }, shadowCameraTop: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t2;
  } }, shadowCameraBottom: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t2;
  } }, shadowCameraNear: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t2;
  } }, shadowCameraFar: { set: function(t2) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t2;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(t2) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t2;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(t2) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t2;
  } }, shadowMapHeight: { set: function(t2) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t2;
  } } }), Object.defineProperties($t.prototype, { length: { get: function() {
    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
  } }, dynamic: { get: function() {
    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === 35048;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
  } } }), $t.prototype.setDynamic = function(t2) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t2 === true ? 35048 : 35044), this;
  }, $t.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, $t.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, de.prototype.addIndex = function(t2) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t2);
  }, de.prototype.addAttribute = function(t2, e2) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e2 && e2.isBufferAttribute || e2 && e2.isInterleavedBufferAttribute ? t2 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e2), this) : this.setAttribute(t2, e2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t2, new $t(arguments[1], arguments[2])));
  }, de.prototype.addDrawCall = function(t2, e2, i2) {
    i2 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t2, e2);
  }, de.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  }, de.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, de.prototype.removeAttribute = function(t2) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t2);
  }, de.prototype.applyMatrix = function(t2) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
  }, Object.defineProperties(de.prototype, { drawcalls: { get: function() {
    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
  } }, offsets: { get: function() {
    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
  } } }), fr.prototype.setDynamic = function(t2) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t2 === true ? 35048 : 35044), this;
  }, fr.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, os.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  }, os.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  }, os.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  }, pr.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }, Object.defineProperties(jt.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    return console.warn("THREE.Material: .wrapRGB has been removed."), new Zt();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(t2) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t2 === 1;
  } }, stencilMask: { get: function() {
    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
  }, set: function(t2) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t2;
  } } }), Object.defineProperties(Fe.prototype, { derivatives: { get: function() {
    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
  }, set: function(t2) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t2;
  } } }), ur.prototype.clearTarget = function(t2, e2, i2, n2) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t2), this.clear(e2, i2, n2);
  }, ur.prototype.animate = function(t2) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t2);
  }, ur.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  }, ur.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  }, ur.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  }, ur.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  }, ur.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  }, ur.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  }, ur.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  }, ur.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, ur.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, ur.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  }, ur.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  }, ur.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  }, ur.prototype.enableScissorTest = function(t2) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t2);
  }, ur.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, ur.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, ur.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, ur.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, ur.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }, ur.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  }, ur.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  }, ur.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  }, ur.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }, ur.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }, Object.defineProperties(ur.prototype, { shadowMapEnabled: { get: function() {
    return this.shadowMap.enabled;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t2;
  } }, shadowMapType: { get: function() {
    return this.shadowMap.type;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t2;
  } }, shadowMapCullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  } }, context: { get: function() {
    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
  } }, vr: { get: function() {
    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
  } }, gammaInput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  } }, gammaOutput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t2 === true ? 3001 : 3e3;
  } }, toneMappingWhitePoint: { get: function() {
    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
  } } }), Object.defineProperties(tr.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  } }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } }), Object.defineProperties(S.prototype, { wrapS: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t2;
  } }, wrapT: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t2;
  } }, magFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t2;
  } }, minFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t2;
  } }, anisotropy: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t2;
  } }, offset: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t2;
  } }, repeat: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t2;
  } }, format: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t2;
  } }, type: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t2;
  } }, generateMipmaps: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
  }, set: function(t2) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t2;
  } } }), xa.prototype.load = function(t2) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e2 = this;
    return new ya().load(t2, function(t3) {
      e2.setBuffer(t3);
    }), this;
  }, ke.prototype.updateCubeMap = function(t2, e2) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t2, e2);
  }, ke.prototype.clear = function(t2, e2, i2, n2) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t2, e2, i2, n2);
  }, y.crossOrigin = void 0, y.loadTexture = function(t2, e2, i2, n2) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const r2 = new Hs();
    r2.setCrossOrigin(this.crossOrigin);
    const o2 = r2.load(t2, i2, void 0, n2);
    return e2 && (o2.mapping = e2), o2;
  }, y.loadTextureCube = function(t2, e2, i2, n2) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const r2 = new Gs();
    r2.setCrossOrigin(this.crossOrigin);
    const o2 = r2.load(t2, i2, void 0, n2);
    return e2 && (o2.mapping = e2), o2;
  }, y.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, y.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "130" } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "130");
  var qa = i(6), Za = i.n(qa), Ja = i(33), Ka = i.n(Ja), Qa = i(11), $a = i.n(Qa);
  class tl {
    constructor() {
      this.camera = new ra(10, 10, 10, 10), this.camera.position.z = 100, this.camera.position.x = 0, this.camera.position.y = 0;
    }
    focus(t2, e2) {
      t2.position.z = 50;
    }
    updateAspect(t2, e2) {
      this.camera.left = -1 * t2 / 2, this.camera.right = t2 / 2, this.camera.top = e2 / 2, this.camera.bottom = -1 * e2 / 2, this.camera.updateProjectionMatrix();
    }
  }
  const el = { linear: (t2, e2, i2, n2) => i2 * t2 / n2 + e2, easeIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 + e2, strongEaseIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 * t2 * t2 * t2 + e2, strongEaseOut: (t2, e2, i2, n2) => i2 * ((t2 = t2 / n2 - 1) * t2 * t2 * t2 * t2 + 1) + e2, sineaseIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 * t2 + e2, sineaseOut: (t2, e2, i2, n2) => i2 * ((t2 = t2 / n2 - 1) * t2 * t2 + 1) + e2 }, il = new b();
  class nl {
    constructor() {
      this.camera = new tl(), this.mesh = new Ie(), this.material = null, this.geometry = null;
    }
    applyOptions(t2) {
    }
    addObjects(t2) {
      this.mesh.position.z = 50, t2.add(this.mesh);
    }
    setSize(t2, e2) {
      this.camera.updateAspect(t2, e2), this.geometry = new Ke(t2, e2, 1, 1), this.material = new Fe({ fragmentShader: this.fragmentShader, vertexShader: "\nvarying vec2 vUv;\nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n" }), this.material.uniforms = { width: { value: t2 }, height: { value: e2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.applyOptions(this.options), this.mesh.geometry = this.geometry, this.mesh.material = this.material;
    }
    setPrevTexture(t2) {
      this.material.uniforms.texturePrev.value = t2;
    }
    setNextTexture(t2) {
      this.material.uniforms.textureNext.value = t2;
    }
    updateAnimation(t2) {
      this.material.uniforms.timePercent.value = t2;
    }
    dispose() {
      var t2, e2;
      (t2 = this.geometry) === null || t2 === void 0 || t2.dispose(), (e2 = this.material) === null || e2 === void 0 || e2.dispose();
    }
  }
  var rl = i(72), ol = i.n(rl), sl = i(73), al = i.n(sl);
  var ll = i(74), hl = i.n(ll);
  var ul = i(75), cl = i.n(ul);
  var dl = i(76), pl = i.n(dl);
  var fl = i(77), ml = i.n(fl);
  var gl = i(78), vl = i.n(gl);
  var _l = i(79), yl = i.n(_l);
  var xl = i(80), bl = i.n(xl);
  var Tl = i(81), El = i.n(Tl);
  var Sl = i(82), wl = i.n(Sl);
  var Al = i(83), Ml = i.n(Al);
  var Rl = i(84), Cl = i.n(Rl);
  var Il = i(85), Pl = i.n(Il);
  class Ol {
    constructor() {
      this.camera = new Ue(60, 1, 1, 2e3), this.camera.position.z = 1e3, this.camera.position.x = 0, this.camera.position.y = 0;
    }
    updateAspect(t2, e2) {
      this.camera.aspect = t2 / e2, this.camera.updateProjectionMatrix();
    }
    focus(t2, e2) {
      const i2 = 0.5 * e2 / Math.tan(Math.PI / 6);
      t2.position.z = 1e3 - i2;
    }
  }
  class Nl {
    constructor() {
      this.prevTexture = il, this.nextTexture = il, this.geometry = new de(), this.material = null, this.camera = new Ol(), this.mesh = new Ie(), this.textureWidth = 0, this.textureHeight = 0;
    }
    horizontalSegments() {
      return Math.ceil(this.verticalSegments * this.textureWidth / this.textureHeight);
    }
    applyOptions(t2) {
      this.options = t2;
    }
    initMesh(t2, e2) {
      const i2 = [], n2 = [], r2 = [], o2 = this.verticalSegments, s2 = this.horizontalSegments(), a2 = t2 / 2, l2 = e2 / 2, h2 = t2 / s2, u2 = e2 / o2, c2 = this.extraAttributes(), d2 = Object.keys(c2), p2 = d2.reduce((t3, e3) => (t3[e3] = [], t3), {});
      for (let t3 = 0; t3 < o2; t3++) {
        const e3 = t3 * u2 - l2;
        for (let i3 = 0; i3 < s2; i3++) {
          const l3 = i3 * h2 - a2;
          n2.push(l3, -e3, 0), r2.push(1 * i3 / s2, 1 - 1 * t3 / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3 + h2, -e3, 0), r2.push(1 * (i3 + 1) / s2, 1 - 1 * t3 / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3, -e3 - u2, 0), r2.push(1 * i3 / s2, 1 - 1 * (t3 + 1) / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3 + h2, -e3 - u2, 0), r2.push(1 * (i3 + 1) / s2, 1 - 1 * (t3 + 1) / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3)));
        }
      }
      for (let t3 = 0; t3 < o2 * s2; t3++) {
        const e3 = 4 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3;
        i2.push(n3, e3, o3), i2.push(e3, r3, o3);
      }
      return this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(r2), 2)), d2.forEach((t3) => {
        const { threeType: e3, jsType: i3, itemSize: n3 } = c2[t3];
        this.geometry.setAttribute(t3, new e3(new i3(p2[t3]), n3));
      }), { verticalSegments: o2, horizontalSegments: s2, segmentWidth: h2, segmentHeight: u2 };
    }
    setSize(t2, e2) {
      this.textureWidth = t2, this.textureHeight = e2, this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.material = new Fe({ fragmentShader: this.fragmentShader, vertexShader: this.vertexShader, side: 2 }), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material;
      const { verticalSegments: i2, horizontalSegments: n2, segmentWidth: r2, segmentHeight: o2 } = this.initMesh(t2, e2);
      this.material.uniforms = { segmentWidth: { value: r2 }, segmentHeight: { value: o2 }, verticalSegments: { value: i2 }, horizontalSegments: { value: n2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.applyOptions(this.options);
    }
    setPrevTexture(t2) {
      this.prevTexture = t2, this.material.uniforms.texturePrev.value = t2;
    }
    setNextTexture(t2) {
      this.nextTexture = t2, this.material.uniforms.textureNext.value = t2;
    }
    addObjects(t2) {
      t2.add(this.mesh);
    }
    updateAnimation(t2) {
      this.material.uniforms.timePercent.value = t2;
    }
    dispose() {
      var t2, e2;
      (t2 = this.geometry) === null || t2 === void 0 || t2.dispose(), (e2 = this.material) === null || e2 === void 0 || e2.dispose();
    }
  }
  var Ll = i(86), Dl = i.n(Ll), Fl = i(87), Bl = i.n(Fl);
  var Ul = i(88), kl = i.n(Ul), Gl = i(89), Hl = i.n(Gl);
  var jl = i(90), zl = i.n(jl), Vl = i(91), Xl = i.n(Vl);
  var Wl = i(92), Yl = i.n(Wl), ql = i(93), Zl = i.n(ql);
  var Jl = i(94), Kl = i.n(Jl), Ql = i(95), $l = i.n(Ql);
  var th = i(96), eh = i.n(th), ih = i(97), nh = i.n(ih);
  class rh extends Nl {
    constructor() {
      super(...arguments), this.duration = 1250, this.options = [], this.fragmentShader = nh.a, this.vertexShader = eh.a, this.verticalSegments = 100;
    }
    addObjects(t2) {
      t2.add(this.mesh), t2.background = this.nextTexture;
    }
    extraAttributes() {
      return {};
    }
    applyOptions(t2) {
      super.applyOptions(t2);
      const e2 = this.options.find((t3) => t3.name === "invX");
      this.material.uniforms.option = { value: (e2 == null ? void 0 : e2.value) ? Number(e2.value) : 0 };
    }
  }
  var oh = i(98), sh = i.n(oh), ah = i(99), lh = i.n(ah);
  var hh = i(100), uh = i.n(hh);
  var ch = i(101), dh = i.n(ch);
  var ph = i(102), fh = i.n(ph);
  var mh = i(103), gh = i.n(mh), vh = i(104), _h = i.n(vh);
  var yh = i(105), xh = i.n(yh);
  var bh = i(46), Th = i.n(bh), Eh = i(47), Sh = i.n(Eh);
  var wh = i(106), Ah = i.n(wh), Mh = i(107), Rh = i.n(Mh);
  const Ch = { RandomLines: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = al.a, this.options = [{ name: "dir", value: "horz" }];
    }
    genRandomLines() {
      let t2 = [1];
      for (let e3 = 20; e3--; ) {
        let e4 = t2.sort((t3, e5) => e5 - t3)[0], i2 = t2.indexOf(e4), n2 = Math.random(), r2 = e4 * n2, o2 = e4 * (1 - n2);
        t2.splice(i2, 1), t2.push(r2, o2);
      }
      let e2 = t2.length;
      for (; e2; ) {
        let i2 = Math.floor(Math.random() * e2--);
        [t2[i2], t2[e2]] = [t2[e2], t2[i2]];
      }
      return t2;
    }
    applyOptions(t2) {
      var e2, i2;
      super.applyOptions(t2), this.material.uniforms.direction = { value: ((i2 = (e2 = this.options) === null || e2 === void 0 ? void 0 : e2[0]) === null || i2 === void 0 ? void 0 : i2.value) === "horz" ? 0 : 1 };
    }
    setSize(t2, e2) {
      super.setSize(t2, e2), this.material.uniforms.lines = { value: this.genRandomLines() }, this.material.vertexShader = ol.a;
    }
  }, Shape: class extends nl {
    constructor() {
      super(...arguments), this.duration = 800, this.fragmentShader = hl.a, this.options = [];
    }
  }, Ripples: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1400, this.fragmentShader = cl.a, this.options = [{ name: "dir", value: "center" }], this.optionsMap = { center: 0, ru: 1, lu: 2, ld: 3, rd: 4 };
    }
    applyOptions(t2) {
      var e2, i2;
      super.applyOptions(t2);
      const n2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 = this.optionsMap) === null || e2 === void 0 ? void 0 : e2[(i2 = n2 == null ? void 0 : n2.value) !== null && i2 !== void 0 ? i2 : "center"] };
    }
  }, Erase: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = pl.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3 };
    }
    applyOptions(t2) {
      var e2, i2;
      super.applyOptions(t2);
      const n2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 = this.optionsMap) === null || e2 === void 0 ? void 0 : e2[(i2 = n2 == null ? void 0 : n2.value) !== null && i2 !== void 0 ? i2 : this.defaultDir] };
    }
  }, Dissolve: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1200, this.fragmentShader = ml.a, this.options = [], this.dissolveIndices = {};
    }
    random40() {
      return Math.ceil(40 * Math.random());
    }
    setSize(t2, e2) {
      super.setSize(t2, e2);
      for (let t3 = 0; t3 < 1600; t3++) {
        let t4 = this.random40(), e3 = this.random40();
        for (; this.dissolveIndices[`${t4}_${e3}`] !== void 0; )
          t4 = this.random40(), e3 = this.random40();
        this.dissolveIndices[`${t4}_${e3}`] = 0;
      }
      this.material.uniforms.dissolveTexture = { value: this.genDissolveToTexture() };
    }
    genDissolveToTexture() {
      var t2 = new Uint8Array(4800);
      for (let e2 = 0; e2 < 1600; e2++) {
        const i2 = e2 % 40 + 1, n2 = Math.floor(e2 / 40) + 1, r2 = 3 * e2;
        this.dissolveIndices[`${i2}_${n2}`] === 0 ? (t2[r2] = 0, t2[r2 + 1] = 0, t2[r2 + 2] = 0) : (t2[r2] = 255, t2[r2 + 1] = 255, t2[r2 + 2] = 255);
      }
      return new Gr(t2, 40, 40, 1022);
    }
    updateAnimation(t2) {
      const e2 = 1600 * t2 - Object.keys(this.dissolveIndices).filter((t3) => this.dissolveIndices[t3] === 1).length;
      for (let t3 = 0; t3 < e2; t3++) {
        const t4 = Object.keys(this.dissolveIndices).filter((t5) => this.dissolveIndices[t5] === 0), e3 = Math.ceil(Math.random() * t4.length) - 1;
        this.dissolveIndices[t4[e3]] = 1;
      }
      this.material.uniforms.dissolveTexture.value = this.genDissolveToTexture();
    }
  }, Smooth: class extends nl {
    constructor() {
      super(...arguments), this.duration = 2e3, this.fragmentShader = vl.a, this.options = [];
    }
  }, FadeInOut: class extends nl {
    constructor() {
      super(...arguments), this.duration = 700, this.fragmentShader = yl.a, this.options = [];
    }
    applyOptions(t2) {
      super.applyOptions(t2);
      const e2 = this.options.find((t3) => t3.name === "thruBlk");
      this.material.uniforms.option = { value: (e2 == null ? void 0 : e2.value) === "1" ? 1 : 0 };
    }
  }, Push: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = bl.a, this.options = [], this.optionsMap = { u: 0, r: 1, d: 2, l: 3 };
    }
    applyOptions(t2) {
      var e2, i2;
      super.applyOptions(t2);
      const n2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 = this.optionsMap) === null || e2 === void 0 ? void 0 : e2[(i2 = n2 == null ? void 0 : n2.value) !== null && i2 !== void 0 ? i2 : "l"] };
    }
  }, Separation: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1500, this.fragmentShader = El.a, this.options = [];
    }
    applyOptions(t2) {
      super.applyOptions(t2);
      const e2 = this.options.find((t3) => t3.name === "orient"), i2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.orient = { value: (e2 == null ? void 0 : e2.value) === "vert" }, this.material.uniforms.direction = { value: (i2 == null ? void 0 : i2.value) === "in" };
    }
  }, Display: class extends nl {
    constructor() {
      super(...arguments), this.duration = 3400, this.fragmentShader = wl.a, this.options = [];
    }
    applyOptions(t2) {
      const e2 = this.options.find((t3) => t3.name === "dir"), i2 = this.options.find((t3) => t3.name === "thruBlk");
      this.material.uniforms.direction = { value: (e2 == null ? void 0 : e2.value) === "r" }, this.material.uniforms.thruBlk = { value: (i2 == null ? void 0 : i2.value) === "1" };
    }
  }, Uncover: class extends nl {
    constructor() {
      super(...arguments), this.duration = 750, this.fragmentShader = Ml.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3, ld: 4, lu: 5, rd: 6, ru: 7 }, this.selfOptionsList = [{ x: -1, y: 0 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }];
    }
    applyOptions(t2) {
      var e2;
      super.applyOptions(t2);
      const i2 = this.options.find((t3) => t3.name === "dir"), n2 = this.optionsMap[(e2 = i2 == null ? void 0 : i2.value) !== null && e2 !== void 0 ? e2 : this.defaultDir], r2 = this.selfOptionsList[n2];
      this.material.uniforms.optionX = { value: r2.x }, this.material.uniforms.optionY = { value: r2.y };
    }
  }, Cover: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = Cl.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3, ld: 4, lu: 5, rd: 6, ru: 7 }, this.selfOptionsList = [{ x: -1, y: 0 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }];
    }
    applyOptions(t2) {
      var e2;
      super.applyOptions(t2);
      const i2 = this.options.find((t3) => t3.name === "dir"), n2 = this.optionsMap[(e2 = i2 == null ? void 0 : i2.value) !== null && e2 !== void 0 ? e2 : this.defaultDir], r2 = this.selfOptionsList[n2];
      this.material.uniforms.optionX = { value: r2.x }, this.material.uniforms.optionY = { value: r2.y };
    }
  }, Flash: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = Pl.a, this.options = [];
    }
  }, Checkerboard: class extends Nl {
    constructor() {
      super(...arguments), this.duration = 2500, this.options = [{ name: "dir", value: "horz" }], this.fragmentShader = Bl.a, this.vertexShader = Dl.a, this.vIndex = "", this.delay = 0, this.verticalSegments = 5;
    }
    extraAttributes() {
      return { times: { threeType: ne, jsType: Float32Array, itemSize: 1, generator: (t2, e2) => (this.vIndex !== `${t2}${e2}` && (this.delay = 0.3 * Math.random(), this.vIndex = `${t2}${e2}`), [this.delay]) }, segment: { threeType: ne, jsType: Float32Array, itemSize: 2, generator: (t2, e2) => [e2, t2] }, option: { threeType: ee, jsType: Int32Array, itemSize: 1, generator: () => [this.options.find((t2) => t2.name === "dir" && t2.value === "horz") ? 0 : 1] } };
    }
  }, Vortex: class {
    constructor() {
      this.duration = 4e3, this.geometry = new de(), this.material = new Fe({ fragmentShader: Hl.a, vertexShader: kl.a, side: 2 }), this.camera = new Ol(), this.mesh = new Ie();
    }
    initData(t2, e2) {
      const i2 = [], n2 = [], r2 = [], o2 = [], s2 = [], a2 = [], l2 = Math.ceil(124 * t2 / e2), h2 = t2 / 2, u2 = e2 / 2, c2 = t2 / l2, d2 = e2 / 124;
      for (let t3 = 0; t3 < 124; t3++) {
        const e3 = t3 * d2 - u2;
        for (let i3 = 0; i3 < l2; i3++) {
          const u3 = i3 * c2 - h2, p2 = Math.ceil((i3 + 1) / ((l2 + 1) / 12)), f2 = 0.4 / p2, m2 = (p2 - 1) * f2 + Math.random() * f2;
          n2.push(u3, -e3, 0), o2.push(1 * i3 / l2, 1 - 1 * t3 / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3 + c2, -e3, 0), o2.push(1 * (i3 + 1) / l2, 1 - 1 * t3 / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3, -e3 - d2, 0), o2.push(1 * i3 / l2, 1 - 1 * (t3 + 1) / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3 + c2, -e3 - d2, 0), o2.push(1 * (i3 + 1) / l2, 1 - 1 * (t3 + 1) / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2);
        }
      }
      for (let t3 = 0; t3 < 124 * l2; t3++) {
        const e3 = 4 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3;
        i2.push(n3, e3, o3), i2.push(e3, r3, o3);
      }
      return this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("normal", new ne(r2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(o2), 2)), this.geometry.setAttribute("segment", new ne(new Float32Array(s2), 2)), this.geometry.setAttribute("times", new ne(new Float32Array(a2), 1)), { verticalSegments: 124, horizontalSegments: l2, segmentWidth: c2, segmentHeight: d2 };
    }
    setSize(t2, e2) {
      const { verticalSegments: i2, horizontalSegments: n2, segmentWidth: r2, segmentHeight: o2 } = this.initData(t2, e2);
      this.material.uniforms = { duration: { value: this.duration }, segmentWidth: { value: r2 }, segmentHeight: { value: o2 }, verticalSegments: { value: i2 }, horizontalSegments: { value: n2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.geometry = this.geometry;
      new ds({ side: 2, vertexColors: true }).wireframe = true, this.material.transparent = true, this.mesh.material = this.material;
    }
    setPrevTexture(t2) {
      this.material.uniforms.texturePrev.value = t2;
    }
    setNextTexture(t2) {
      this.material.uniforms.textureNext.value = t2;
    }
    addObjects(t2) {
      t2.add(this.mesh);
    }
    updateAnimation(t2) {
      this.material.uniforms.timePercent.value = t2;
    }
    dispose() {
      var t2, e2;
      (t2 = this.geometry) === null || t2 === void 0 || t2.dispose(), (e2 = this.material) === null || e2 === void 0 || e2.dispose();
    }
  }, WindowShades: class {
    constructor() {
      this.duration = 1600, this.geometry = new de(), this.material = new Fe({ fragmentShader: Xl.a, vertexShader: zl.a, side: 2 }), this.horizontalSegments = 16, this.meshToCameraDistance = 0, this.camera = new Ol(), this.mesh = new Ie();
    }
    initData(t2, e2) {
      const i2 = [], n2 = [], r2 = [], o2 = [], s2 = [], a2 = [], l2 = t2 / 2, h2 = e2 / 2, u2 = t2 / this.horizontalSegments;
      for (let t3 = 0; t3 < this.horizontalSegments; t3++) {
        const e3 = Math.abs(t3 - Math.ceil(this.horizontalSegments / 2)) * (0.3 / Math.ceil(this.horizontalSegments / 2)), i3 = t3 * u2 - l2;
        n2.push(i3, h2, 0), r2.push(0), o2.push(t3 / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, 0), r2.push(0), o2.push((t3 + 1) / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3, -1 * h2, 0), r2.push(0), o2.push(t3 / this.horizontalSegments, 0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, 0), o2.push((t3 + 1) / this.horizontalSegments, 0), r2.push(0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, 0), r2.push(1), o2.push(t3 / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, -1 * u2), r2.push(1), o2.push((t3 + 1) / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, 0), r2.push(1), o2.push(t3 / this.horizontalSegments, 0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, -1 * u2), o2.push((t3 + 1) / this.horizontalSegments, 0), r2.push(1), s2.push(t3), a2.push(e3);
      }
      for (let t3 = 0; t3 < this.horizontalSegments; t3++) {
        const e3 = 8 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3, s3 = e3 + 4, a3 = e3 + 5, l3 = e3 + 6, h3 = e3 + 7;
        i2.push(n3, e3, o3), i2.push(e3, r3, o3), i2.push(a3, s3, h3), i2.push(s3, l3, h3);
      }
      this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(o2), 2)), this.geometry.setAttribute("index", new ne(new Float32Array(s2), 1)), this.geometry.setAttribute("type", new ne(new Float32Array(r2), 1)), this.geometry.setAttribute("delay", new ne(new Float32Array(a2), 1));
    }
    setPrevTexture(t2) {
      this.material.uniforms.texturePrev.value = t2;
    }
    setNextTexture(t2) {
      this.material.uniforms.textureNext.value = t2;
    }
    setSize(t2, e2) {
      this.initData(t2, e2), this.material.uniforms = { segments: { value: this.horizontalSegments }, segmentWidth: { value: t2 / this.horizontalSegments }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.meshToCameraDistance = 0.5 * e2 / Math.tan(Math.PI / 6), this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material;
    }
    addObjects(t2) {
      t2.add(this.mesh);
    }
    updateAnimation(t2) {
      this.material.uniforms.timePercent.value = t2;
    }
    dispose() {
      var t2, e2;
      (t2 = this.geometry) === null || t2 === void 0 || t2.dispose(), (e2 = this.material) === null || e2 === void 0 || e2.dispose();
    }
  }, Curtain: class extends Nl {
    constructor() {
      super(...arguments), this.duration = 6e3, this.options = [], this.fragmentShader = Zl.a, this.vertexShader = Yl.a, this.verticalSegments = 100;
    }
    extraAttributes() {
      return { isLeft: { threeType: ne, jsType: Float32Array, itemSize: 1, generator: (t2, e2) => [e2 < this.horizontalSegments() / 2 ? 1 : 0] } };
    }
    addObjects(t2) {
      super.addObjects(t2), this.mesh.position.z += 20, t2.background = this.nextTexture;
    }
  }, Fall: class extends Nl {
    constructor() {
      super(...arguments), this.zCurveLimit = 100, this.duration = 2e3, this.options = [{ name: "invX", value: "0" }], this.verticalSegments = 100, this.fragmentShader = $l.a, this.vertexShader = Kl.a;
    }
    extraAttributes() {
      return {};
    }
    setSize(t2, e2) {
      var i2;
      super.setSize(t2, e2);
      const n2 = this.options.find((t3) => t3.name === "invX");
      this.material.uniforms.zCurveLimit = { value: this.zCurveLimit }, this.material.uniforms.aCoefficient = { value: this.zCurveLimit / (this.textureHeight / 2 * (this.textureHeight / 2)) }, this.material.uniforms.option = { value: (i2 = n2 == null ? void 0 : n2.value) !== null && i2 !== void 0 ? i2 : 0 };
    }
    addObjects(t2) {
      t2.add(this.mesh), t2.background = this.nextTexture;
    }
    updateAnimation(t2) {
      this.material.uniforms.timePercent.value = t2;
    }
  }, Suspension: class extends rh {
    constructor() {
      super(...arguments), this.duration = 2e3, this.fragmentShader = lh.a, this.vertexShader = sh.a;
    }
    addObjects(t2) {
      t2.add(this.mesh), t2.background = this.prevTexture;
    }
  }, Clock: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = uh.a, this.options = [];
    }
  }, Combing: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = dh.a, this.options = [];
    }
    applyOptions(t2) {
      super.applyOptions(t2);
      const e2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 == null ? void 0 : e2.value) === "vert" ? 1 : 0 };
    }
  }, Scale: class extends nl {
    constructor() {
      super(...arguments), this.duration = 900, this.fragmentShader = fh.a, this.options = [];
    }
    applyOptions(t2) {
      super.applyOptions(t2);
      const e2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 == null ? void 0 : e2.value) === "in" ? 0 : 1 };
    }
  }, PeelOff: rh, Flip: class extends Nl {
    constructor() {
      super(...arguments), this.duration = 1250, this.options = [], this.fragmentShader = _h.a, this.vertexShader = gh.a, this.verticalSegments = 1;
    }
    extraAttributes() {
      return {};
    }
    applyOptions(t2) {
      const e2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 == null ? void 0 : e2.value) === "l" ? 1 : 0 };
    }
  }, Strips: class extends nl {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = xh.a, this.options = [], this.defaultDir = "lu", this.optionsMap = { [this.defaultDir]: 0, ld: 1, rd: 2, ru: 3 };
    }
    applyOptions(t2) {
      var e2, i2;
      super.applyOptions(t2);
      const n2 = this.options.find((t3) => t3.name === "dir");
      this.material.uniforms.option = { value: (e2 = this.optionsMap) === null || e2 === void 0 ? void 0 : e2[(i2 = n2 == null ? void 0 : n2.value) !== null && i2 !== void 0 ? i2 : this.defaultDir] };
    }
  }, Gallery: class {
    constructor() {
      this.camera = new Ol(), this.duration = 1600, this.options = [], this.gap = 10, this.group = new or(), this.prevMesh = new Ie(), this.nextMesh = new Ie(), this.width = 100, this.height = 100, this.prevMaterial = new Fe({ vertexShader: Th.a, fragmentShader: Sh.a, side: 2, uniforms: { galleryTexture: { value: il }, galleryHeight: { value: 1 } } }), this.nextMaterial = new Fe({ vertexShader: Th.a, fragmentShader: Sh.a, side: 2, uniforms: { galleryTexture: { value: il }, galleryHeight: { value: 1 } } });
    }
    get isRight() {
      const t2 = this.options.find((t3) => t3.name === "dir");
      return !t2 || t2.value === "r";
    }
    addObjects(t2) {
      this.group.add(this.prevMesh), this.group.add(this.nextMesh), t2.add(this.group);
    }
    dispose() {
      this.prevMaterial.dispose(), this.nextMaterial.dispose(), this.prevMesh.geometry.dispose(), this.nextMesh.geometry.dispose();
    }
    setNextTexture(t2) {
      this.nextMaterial.uniforms.galleryTexture.value = t2, this.nextMesh.material = this.nextMaterial;
    }
    setPrevTexture(t2) {
      this.prevMaterial.uniforms.galleryTexture.value = t2, this.prevMesh.material = this.prevMaterial;
    }
    setSize(t2, e2) {
      this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2), this.width = t2, this.height = e2, this.gap = this.width / 20, this.prevMaterial.uniforms.galleryHeight.value = e2, this.nextMaterial.uniforms.galleryHeight.value = e2;
      const i2 = new Ke(t2, 1.2 * e2 + 8, 1, 1);
      this.prevMesh.geometry = i2;
      const n2 = new Ke(t2, 1.2 * e2 + 8, 1, 1);
      this.nextMesh.geometry = n2, this.nextMesh.position.z = this.prevMesh.position.z, this.isRight ? this.nextMesh.position.x = t2 + this.gap : this.nextMesh.position.x = -1 * (t2 + this.gap);
    }
    updateAnimation(t2) {
      if (t2 < 0.3) {
        const e2 = t2 / 0.3;
        this.isRight ? (this.group.position.z = 0.25 * this.height * -1 * e2, this.group.rotation.y = Math.PI / 12 * -1 * e2) : (this.group.position.z = 0.25 * this.height * -1 * e2, this.group.rotation.y = Math.PI / 12 * e2);
      } else if (t2 >= 0.3 && t2 < 0.7) {
        const e2 = (t2 - 0.3) / 0.4;
        this.isRight ? (this.group.position.z = -1 * (0.25 * this.height + 0.55 * this.height * e2), this.group.position.x = -1 * (this.width + this.gap) * e2) : (this.group.position.z = -1 * (0.25 * this.height + 0.55 * this.height * e2), this.group.position.x = (this.width + this.gap) * e2);
      } else {
        const e2 = (t2 - 0.7) / 0.3;
        this.isRight ? (this.group.position.x = -1 * (this.width + this.gap), this.group.position.z = 0.8 * this.height * -1 * (1 - e2), this.group.rotation.y = Math.PI / 12 * -1 * (1 - e2)) : (this.group.position.x = this.width + this.gap, this.group.position.z = 0.8 * this.height * -1 * (1 - e2), this.group.rotation.y = Math.PI / 12 * (1 - e2));
      }
    }
  }, Switch: class {
    constructor() {
      this.camera = new Ol(), this.duration = 6e3, this.options = [], this.prevMesh = new Ie(), this.nextMesh = new Ie(), this.width = 100, this.height = 100, this.depth = 1, this.prevDepth = 1;
    }
    addObjects(t2) {
      t2.add(this.prevMesh), t2.add(this.nextMesh);
    }
    dispose() {
      Array.isArray(this.prevMesh.material) ? this.prevMesh.material.forEach((t2) => t2.dispose()) : this.prevMesh.material.dispose(), this.prevMesh.geometry.dispose(), Array.isArray(this.nextMesh.material) ? this.nextMesh.material.forEach((t2) => t2.dispose()) : this.nextMesh.material.dispose(), this.nextMesh.geometry.dispose();
    }
    setNextTexture(t2) {
      const e2 = new Jt({ map: t2 });
      this.nextMesh.material = e2;
    }
    setPrevTexture(t2) {
      const e2 = new Jt({ map: t2 });
      this.prevMesh.material = e2;
    }
    setSize(t2, e2) {
      this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2), this.width = t2, this.height = e2, this.depth = e2 / 2;
      const i2 = new Ke(t2, e2, 1, 1);
      this.prevMesh.geometry = i2;
      const n2 = new Ke(t2, e2, 1, 1);
      this.nextMesh.geometry = n2, this.prevDepth = this.prevMesh.position.z;
    }
    updateAnimation(t2) {
      const e2 = this.options.find((t3) => t3.name === "dir");
      if (t2 < 0.5) {
        const e3 = t2 / 0.5;
        this.prevMesh.position.x = this.width / 2 * e3, this.prevMesh.rotation.y = -Math.PI / 10 * e3, this.nextMesh.position.x = -this.width / 2 * e3, this.nextMesh.rotation.y = Math.PI / 10 * e3, this.nextMesh.position.z = this.prevDepth - this.depth * (1 - e3);
      } else {
        const e3 = (t2 - 0.5) / 0.5;
        this.prevMesh.position.x = this.width / 2 * (1 - e3), this.prevMesh.rotation.y = -Math.PI / 10 * (1 - e3), this.prevMesh.position.z = this.prevDepth - this.depth * e3, this.nextMesh.position.x = -this.width / 2 * (1 - e3), this.nextMesh.rotation.y = Math.PI / 10 * (1 - e3);
      }
      if (e2 && e2.value === "l")
        if (t2 < 0.5) {
          const e3 = t2 / 0.5;
          this.prevMesh.position.x = -this.width / 2 * e3, this.prevMesh.rotation.y = Math.PI / 10 * e3, this.nextMesh.position.x = this.width / 2 * e3, this.nextMesh.rotation.y = -Math.PI / 10 * e3;
        } else {
          const e3 = (t2 - 0.5) / 0.5;
          this.prevMesh.position.x = -this.width / 2 * (1 - e3), this.prevMesh.rotation.y = Math.PI / 10 * (1 - e3), this.nextMesh.position.x = this.width / 2 * (1 - e3), this.nextMesh.rotation.y = -Math.PI / 10 * (1 - e3);
        }
    }
  }, Prism: class {
    constructor() {
      this.camera = new Ol(), this.duration = 6e3, this.preset = null, this.presetZ = 0, this.mesh = new Ie(), this.width = 100, this.height = 100;
    }
    addObjects(t2) {
      this.mesh.geometry = this.box, t2.add(this.mesh);
    }
    dispose() {
      Array.isArray(this.mesh.material) ? this.mesh.material.forEach((t2) => t2.dispose()) : this.mesh.material.dispose(), this.mesh.geometry.dispose();
    }
    setNextTexture(t2) {
      const e2 = Array.isArray(this.mesh.material) ? this.mesh.material : [];
      e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), this.mesh.material = e2;
    }
    setPrevTexture(t2) {
      const e2 = Array.isArray(this.mesh.material) ? this.mesh.material : [];
      e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), this.mesh.material = e2;
    }
    setSize(t2, e2) {
      this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.position.z -= t2 / 2, this.width = t2, this.height = e2, this.box = new Oe(t2, e2, t2, 1, 1, 1), this.mesh.geometry = this.box;
    }
    updateAnimation(t2) {
      this.preset === null && (this.preset = t2 > 0 ? 0 : Math.PI / 2, this.presetZ = this.mesh.position.z);
      const e2 = Math.PI / 2 * t2, i2 = (Math.sqrt(2) - 1) * (this.width / 2);
      this.mesh.rotation.y = this.preset + e2, this.mesh.position.z = t2 <= 0.5 ? this.presetZ - t2 / 0.5 * i2 : this.presetZ - (1 - (t2 - 0.5) / 0.5) * i2;
    }
  }, Doors: class {
    constructor() {
      this.camera = new Ol(), this.duration = 1600, this.options = [], this.width = 100, this.preMaterial = new Fe({ fragmentShader: Rh.a, vertexShader: Ah.a, uniforms: { prevTexture: { value: il }, timePercent: { value: 0 }, offset: { value: 0 } } }), this.prevGeometry = new de(), this.prevMesh = new Ie(), this.nextMesh = new Ie();
    }
    addObjects(t2) {
      this.prevMesh.material = this.preMaterial, this.prevMesh.geometry = this.prevGeometry, this.prevMesh.material.transparent = true, t2.add(this.prevMesh), t2.add(this.nextMesh);
    }
    setNextTexture(t2) {
      this.nextMesh.material = new Jt({ map: t2 });
    }
    setPrevTexture(t2) {
      this.preMaterial.uniforms.prevTexture.value = t2;
    }
    setSize(t2, e2) {
      this.width = t2, this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2);
      const i2 = t2 / 2, n2 = e2 / 2;
      this.preMaterial.uniforms.offset.value = t2 / 2, this.prevGeometry.setIndex([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
      const r2 = this.options.find((t3) => t3.name === "dir"), o2 = r2 && r2.value === "vert" ? 0 : 1;
      this.preMaterial.uniforms.option = { value: o2 }, o2 === 1 ? (this.prevGeometry.setAttribute("position", new ne([-i2, n2, 0, -i2, 0, 0, i2, n2, 0, -i2, 0, 0, i2, 0, 0, i2, n2, 0, -i2, 0, 0, -i2, -n2, 0, i2, 0, 0, -i2, -n2, 0, i2, -n2, 0, i2, 0, 0], 3)), this.prevGeometry.setAttribute("uv", new ne([0, 1, 0, 0.5, 1, 1, 0, 0.5, 1, 0.5, 1, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 1, 0, 1, 0.5], 2))) : (this.prevGeometry.setAttribute("position", new ne([-i2, n2, 0, -i2, -n2, 0, 0, n2, 0, -i2, -n2, 0, 0, -n2, 0, 0, n2, 0, 0, n2, 0, 0, -n2, 0, i2, n2, 0, 0, -n2, 0, i2, -n2, 0, i2, n2, 0], 3)), this.prevGeometry.setAttribute("uv", new ne([0, 1, 0, 0, 0.5, 1, 0, 0, 0.5, 0, 0.5, 1, 0.5, 1, 0.5, 0, 1, 1, 0.5, 0, 1, 0, 1, 1], 2))), this.prevGeometry.setAttribute("left", new ne([1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], 1)), this.nextMesh.geometry = new Ke(t2, e2, 1, 1), this.nextMesh.position.z = this.prevMesh.position.z - t2 / 4;
    }
    updateAnimation(t2) {
      this.preMaterial.uniforms.timePercent.value = t2, this.nextMesh.position.z = this.prevMesh.position.z - (1 - t2) * (this.width / 4);
    }
    dispose() {
    }
  } };
  class Ih {
    constructor() {
      this.startTime = 0, this.lastTime = 0, this.lastFPSTime = 0, this.renderingDuration = 16, this.reverse = false, this.scene = new pr(), this.delay = 0, this.easeFn = el.linear, this.preset = null, this.onTransactionEnd = () => {
      }, this.isTransactionStartApplied = false, this.prevTexture = null, this.nextTexture = null, this.animationId = null, this.config = null, this.renderer = new ur({ alpha: true, premultipliedAlpha: true }), this.isPlaying = false, this.animate = (t2 = -1) => {
        var e2, i2, n2;
        if (!this.fps(t2))
          return void (this.animationId = window.requestAnimationFrame(this.animate));
        this.renderer.clear(), t2 > this.delay && this.lastTime === 0 && (this.lastTime = t2, this.startTime = t2);
        let r2 = 0;
        this.lastTime > 0 && r2 < 1 && (r2 = this.easeFn(t2 - this.startTime, 0, 1, (i2 = (e2 = this.preset) === null || e2 === void 0 ? void 0 : e2.duration) !== null && i2 !== void 0 ? i2 : 0)), r2 > 1 && (r2 = 1), (n2 = this.preset) === null || n2 === void 0 || n2.updateAnimation(this.reverse ? 1 - r2 : r2), this.rerender(), this.isTransactionStartApplied || (this.isTransactionStartApplied = true), r2 < 1 ? this.animationId = window.requestAnimationFrame(this.animate) : this.onTransactionEnd();
      };
    }
    initPlayer(t2) {
      this.config = t2, this.reverse = t2.reverse, t2.delay && Number.isInteger(t2.delay) && (this.delay = t2.delay), t2.easeFn && (this.easeFn = el[t2.easeFn]), t2.maxFPS && Number.isInteger(t2.maxFPS) && t2.maxFPS > 0 && (this.renderingDuration = Math.ceil(1e3 / t2.maxFPS)), this.startTime = 0, this.lastTime = 0, this.scene.clear(), this.renderer.shadowMap.enabled = true, this.renderer.autoClear = false, this.renderer.setClearColor(t2.clearColor || 0), this.isTransactionStartApplied = false, this.renderer.setSize(t2.stageWidth, t2.stageHeight), this.preset = new Ch[t2.presetType](), t2.options && (this.preset.options = t2.options), t2.duration && Number.isInteger(t2.duration) && (this.preset.duration = t2.duration), this.preset.setSize(t2.stageWidth, t2.stageHeight);
    }
    setPrevTexture(t2) {
      var e2, i2, n2, r2;
      t2.needsUpdate = true, this.reverse ? (this.nextTexture = t2, (e2 = this.preset) === null || e2 === void 0 || e2.setNextTexture(t2)) : (this.prevTexture = t2, (i2 = this.preset) === null || i2 === void 0 || i2.setPrevTexture(t2)), (n2 = this.preset) === null || n2 === void 0 || n2.addObjects(this.scene), (r2 = this.preset) === null || r2 === void 0 || r2.updateAnimation(this.reverse ? 1 : 0), this.rerender();
    }
    setNextTexture(t2) {
      var e2, i2;
      t2.needsUpdate = true, this.reverse ? (this.prevTexture = t2, (e2 = this.preset) === null || e2 === void 0 || e2.setPrevTexture(t2)) : (this.nextTexture = t2, (i2 = this.preset) === null || i2 === void 0 || i2.setNextTexture(t2));
    }
    play() {
      return new Promise((t2) => {
        this.onTransactionEnd = t2, this.animate(), this.isPlaying = true;
      });
    }
    rerender() {
      var t2;
      this.renderer.clear(), ((t2 = this.preset) === null || t2 === void 0 ? void 0 : t2.camera.camera) && this.renderer.render(this.scene, this.preset.camera.camera);
    }
    fps(t2) {
      if (t2 <= 0)
        return true;
      if (this.lastFPSTime < 0)
        return this.lastFPSTime = t2, true;
      return t2 - this.lastFPSTime >= this.renderingDuration && (this.lastFPSTime = t2, true);
    }
    skip() {
      var t2;
      (t2 = this.preset) === null || t2 === void 0 || t2.updateAnimation(this.reverse ? 0 : 1), this.rerender(), this.dispose(), this.onTransactionEnd();
    }
    dispose() {
      var t2, e2, i2;
      window.cancelAnimationFrame(this.animationId), this.renderer.clear(), this.isPlaying = false, (t2 = this.preset) === null || t2 === void 0 || t2.dispose(), (e2 = this.prevTexture) === null || e2 === void 0 || e2.dispose(), (i2 = this.nextTexture) === null || i2 === void 0 || i2.dispose();
      for (let t3 = this.scene.children.length - 1; t3 >= 0; t3--) {
        const e3 = this.scene.children[t3];
        this.scene.remove(e3);
      }
      this.scene.background = null;
    }
    destroy() {
      this.dispose(), this.renderer.forceContextLoss(), this.renderer.dispose();
    }
  }
  i(139);
  var Ph = i(3), Oh = i(5);
  Oh.c.mixin({ accessible: false, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: false, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: true, renderId: -1 });
  var Nh = function() {
    function t2(t3) {
      this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Ph.isMobile.tablet || Ph.isMobile.phone) && this.createTouchHook();
      var e2 = document.createElement("div");
      e2.style.width = "100px", e2.style.height = "100px", e2.style.position = "absolute", e2.style.top = "0px", e2.style.left = "0px", e2.style.zIndex = 2 .toString(), this.div = e2, this.renderer = t3, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    return Object.defineProperty(t2.prototype, "isActive", { get: function() {
      return this._isActive;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isMobileAccessibility", { get: function() {
      return this._isMobileAccessibility;
    }, enumerable: false, configurable: true }), t2.prototype.createTouchHook = function() {
      var t3 = this, e2 = document.createElement("button");
      e2.style.width = "1px", e2.style.height = "1px", e2.style.position = "absolute", e2.style.top = "-1000px", e2.style.left = "-1000px", e2.style.zIndex = 2 .toString(), e2.style.backgroundColor = "#FF0000", e2.title = "select to enable accessibility for this content", e2.addEventListener("focus", function() {
        t3._isMobileAccessibility = true, t3.activate(), t3.destroyTouchHook();
      }), document.body.appendChild(e2), this._hookDiv = e2;
    }, t2.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, t2.prototype.activate = function() {
      var t3;
      this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this.renderer.on("postrender", this.update, this), (t3 = this.renderer.view.parentNode) === null || t3 === void 0 || t3.appendChild(this.div));
    }, t2.prototype.deactivate = function() {
      var t3;
      this._isActive && !this._isMobileAccessibility && (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this.renderer.off("postrender", this.update), (t3 = this.div.parentNode) === null || t3 === void 0 || t3.removeChild(this.div));
    }, t2.prototype.updateAccessibleObjects = function(t3) {
      if (t3.visible && t3.accessibleChildren) {
        t3.accessible && t3.interactive && (t3._accessibleActive || this.addChild(t3), t3.renderId = this.renderId);
        var e2 = t3.children;
        if (e2)
          for (var i2 = 0; i2 < e2.length; i2++)
            this.updateAccessibleObjects(e2[i2]);
      }
    }, t2.prototype.update = function() {
      var t3 = performance.now();
      if (!(Ph.isMobile.android.device && t3 < this.androidUpdateCount) && (this.androidUpdateCount = t3 + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e2 = this.renderer.view.getBoundingClientRect(), i2 = e2.left, n2 = e2.top, r2 = e2.width, o2 = e2.height, s2 = this.renderer, a2 = s2.width, l2 = s2.height, h2 = s2.resolution, u2 = r2 / a2 * h2, c2 = o2 / l2 * h2, d2 = this.div;
        d2.style.left = i2 + "px", d2.style.top = n2 + "px", d2.style.width = a2 + "px", d2.style.height = l2 + "px";
        for (var p2 = 0; p2 < this.children.length; p2++) {
          var f2 = this.children[p2];
          if (f2.renderId !== this.renderId)
            f2._accessibleActive = false, Object(Ph.removeItems)(this.children, p2, 1), this.div.removeChild(f2._accessibleDiv), this.pool.push(f2._accessibleDiv), f2._accessibleDiv = null, p2--;
          else {
            d2 = f2._accessibleDiv;
            var m2 = f2.hitArea, g2 = f2.worldTransform;
            f2.hitArea ? (d2.style.left = (g2.tx + m2.x * g2.a) * u2 + "px", d2.style.top = (g2.ty + m2.y * g2.d) * c2 + "px", d2.style.width = m2.width * g2.a * u2 + "px", d2.style.height = m2.height * g2.d * c2 + "px") : (m2 = f2.getBounds(), this.capHitArea(m2), d2.style.left = m2.x * u2 + "px", d2.style.top = m2.y * c2 + "px", d2.style.width = m2.width * u2 + "px", d2.style.height = m2.height * c2 + "px", d2.title !== f2.accessibleTitle && f2.accessibleTitle !== null && (d2.title = f2.accessibleTitle), d2.getAttribute("aria-label") !== f2.accessibleHint && f2.accessibleHint !== null && d2.setAttribute("aria-label", f2.accessibleHint)), f2.accessibleTitle === d2.title && f2.tabIndex === d2.tabIndex || (d2.title = f2.accessibleTitle, d2.tabIndex = f2.tabIndex, this.debug && this.updateDebugHTML(d2));
          }
        }
        this.renderId++;
      }
    }, t2.prototype.updateDebugHTML = function(t3) {
      t3.innerHTML = "type: " + t3.type + "</br> title : " + t3.title + "</br> tabIndex: " + t3.tabIndex;
    }, t2.prototype.capHitArea = function(t3) {
      t3.x < 0 && (t3.width += t3.x, t3.x = 0), t3.y < 0 && (t3.height += t3.y, t3.y = 0);
      var e2 = this.renderer, i2 = e2.width, n2 = e2.height;
      t3.x + t3.width > i2 && (t3.width = i2 - t3.x), t3.y + t3.height > n2 && (t3.height = n2 - t3.y);
    }, t2.prototype.addChild = function(t3) {
      var e2 = this.pool.pop();
      e2 || ((e2 = document.createElement("button")).style.width = "100px", e2.style.height = "100px", e2.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e2.style.position = "absolute", e2.style.zIndex = 2 .toString(), e2.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e2.setAttribute("aria-live", "off") : e2.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e2.setAttribute("aria-relevant", "additions") : e2.setAttribute("aria-relevant", "text"), e2.addEventListener("click", this._onClick.bind(this)), e2.addEventListener("focus", this._onFocus.bind(this)), e2.addEventListener("focusout", this._onFocusOut.bind(this))), e2.style.pointerEvents = t3.accessiblePointerEvents, e2.type = t3.accessibleType, t3.accessibleTitle && t3.accessibleTitle !== null ? e2.title = t3.accessibleTitle : t3.accessibleHint && t3.accessibleHint !== null || (e2.title = "displayObject " + t3.tabIndex), t3.accessibleHint && t3.accessibleHint !== null && e2.setAttribute("aria-label", t3.accessibleHint), this.debug && this.updateDebugHTML(e2), t3._accessibleActive = true, t3._accessibleDiv = e2, e2.displayObject = t3, this.children.push(t3), this.div.appendChild(t3._accessibleDiv), t3._accessibleDiv.tabIndex = t3.tabIndex;
    }, t2.prototype._onClick = function(t3) {
      var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
      e2.dispatchEvent(i2, "click", n2), e2.dispatchEvent(i2, "pointertap", n2), e2.dispatchEvent(i2, "tap", n2);
    }, t2.prototype._onFocus = function(t3) {
      t3.target.getAttribute("aria-live") || t3.target.setAttribute("aria-live", "assertive");
      var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
      e2.dispatchEvent(i2, "mouseover", n2);
    }, t2.prototype._onFocusOut = function(t3) {
      t3.target.getAttribute("aria-live") || t3.target.setAttribute("aria-live", "polite");
      var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
      e2.dispatchEvent(i2, "mouseout", n2);
    }, t2.prototype._onKeyDown = function(t3) {
      t3.keyCode === 9 && this.activate();
    }, t2.prototype._onMouseMove = function(t3) {
      t3.movementX === 0 && t3.movementY === 0 || this.deactivate();
    }, t2.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, t2;
  }(), Lh = i(1), Dh = i(7), Fh = function() {
    function t2() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Lh.g(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = false, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(t2.prototype, "pointerId", { get: function() {
      return this.identifier;
    }, enumerable: false, configurable: true }), t2.prototype.getLocalPosition = function(t3, e2, i2) {
      return t3.worldTransform.applyInverse(i2 || this.global, e2);
    }, t2.prototype.copyEvent = function(t3) {
      "isPrimary" in t3 && t3.isPrimary && (this.isPrimary = true), this.button = "button" in t3 && t3.button;
      var e2 = "buttons" in t3 && t3.buttons;
      this.buttons = Number.isInteger(e2) ? e2 : "which" in t3 && t3.which, this.width = "width" in t3 && t3.width, this.height = "height" in t3 && t3.height, this.tiltX = "tiltX" in t3 && t3.tiltX, this.tiltY = "tiltY" in t3 && t3.tiltY, this.pointerType = "pointerType" in t3 && t3.pointerType, this.pressure = "pressure" in t3 && t3.pressure, this.rotationAngle = "rotationAngle" in t3 && t3.rotationAngle, this.twist = "twist" in t3 && t3.twist || 0, this.tangentialPressure = "tangentialPressure" in t3 && t3.tangentialPressure || 0;
    }, t2.prototype.reset = function() {
      this.isPrimary = false;
    }, t2;
  }(), Bh = function(t2, e2) {
    return (Bh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Uh = function() {
    function t2() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return t2.prototype.stopPropagation = function() {
      this.stopped = true, this.stopPropagationHint = true, this.stopsPropagatingAt = this.currentTarget;
    }, t2.prototype.reset = function() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.currentTarget = null, this.target = null;
    }, t2;
  }(), kh = function() {
    function t2(e2) {
      this._pointerId = e2, this._flags = t2.FLAGS.NONE;
    }
    return t2.prototype._doSet = function(t3, e2) {
      this._flags = e2 ? this._flags | t3 : this._flags & ~t3;
    }, Object.defineProperty(t2.prototype, "pointerId", { get: function() {
      return this._pointerId;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "flags", { get: function() {
      return this._flags;
    }, set: function(t3) {
      this._flags = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "none", { get: function() {
      return this._flags === t2.FLAGS.NONE;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "over", { get: function() {
      return (this._flags & t2.FLAGS.OVER) != 0;
    }, set: function(e2) {
      this._doSet(t2.FLAGS.OVER, e2);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "rightDown", { get: function() {
      return (this._flags & t2.FLAGS.RIGHT_DOWN) != 0;
    }, set: function(e2) {
      this._doSet(t2.FLAGS.RIGHT_DOWN, e2);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "leftDown", { get: function() {
      return (this._flags & t2.FLAGS.LEFT_DOWN) != 0;
    }, set: function(e2) {
      this._doSet(t2.FLAGS.LEFT_DOWN, e2);
    }, enumerable: false, configurable: true }), t2.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }), t2;
  }(), Gh = function() {
    function t2() {
      this._tempPoint = new Lh.g();
    }
    return t2.prototype.recursiveFindHit = function(t3, e2, i2, n2, r2) {
      if (!e2 || !e2.visible)
        return false;
      var o2 = t3.data.global, s2 = false, a2 = r2 = e2.interactive || r2, l2 = true;
      if (e2.hitArea ? (n2 && (e2.worldTransform.applyInverse(o2, this._tempPoint), e2.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s2 = true : (n2 = false, l2 = false)), a2 = false) : e2._mask && n2 && (e2._mask.containsPoint && e2._mask.containsPoint(o2) || (n2 = false)), l2 && e2.interactiveChildren && e2.children)
        for (var h2 = e2.children, u2 = h2.length - 1; u2 >= 0; u2--) {
          var c2 = h2[u2], d2 = this.recursiveFindHit(t3, c2, i2, n2, a2);
          if (d2) {
            if (!c2.parent)
              continue;
            a2 = false, d2 && (t3.target && (n2 = false), s2 = true);
          }
        }
      return r2 && (n2 && !t3.target && !e2.hitArea && e2.containsPoint && e2.containsPoint(o2) && (s2 = true), e2.interactive && (s2 && !t3.target && (t3.target = e2), i2 && i2(t3, e2, !!s2))), s2;
    }, t2.prototype.findHit = function(t3, e2, i2, n2) {
      this.recursiveFindHit(t3, e2, i2, n2, false);
    }, t2;
  }(), Hh = { interactive: false, interactiveChildren: true, hitArea: null, get buttonMode() {
    return this.cursor === "pointer";
  }, set buttonMode(t2) {
    t2 ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  }, cursor: null, get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  }, _trackedPointers: void 0 };
  Oh.c.mixin(Hh);
  var jh = { target: null, data: { global: null } }, zh = function(t2) {
    function e2(e3, i2) {
      var n2 = t2.call(this) || this;
      return i2 = i2 || {}, n2.renderer = e3, n2.autoPreventDefault = i2.autoPreventDefault === void 0 || i2.autoPreventDefault, n2.interactionFrequency = i2.interactionFrequency || 10, n2.mouse = new Fh(), n2.mouse.identifier = 1, n2.mouse.global.set(-999999), n2.activeInteractionData = {}, n2.activeInteractionData[1] = n2.mouse, n2.interactionDataPool = [], n2.eventData = new Uh(), n2.interactionDOMElement = null, n2.moveWhenInside = false, n2.eventsAdded = false, n2.tickerAdded = false, n2.mouseOverRenderer = !("PointerEvent" in globalThis), n2.supportsTouchEvents = "ontouchstart" in globalThis, n2.supportsPointerEvents = !!globalThis.PointerEvent, n2.onPointerUp = n2.onPointerUp.bind(n2), n2.processPointerUp = n2.processPointerUp.bind(n2), n2.onPointerCancel = n2.onPointerCancel.bind(n2), n2.processPointerCancel = n2.processPointerCancel.bind(n2), n2.onPointerDown = n2.onPointerDown.bind(n2), n2.processPointerDown = n2.processPointerDown.bind(n2), n2.onPointerMove = n2.onPointerMove.bind(n2), n2.processPointerMove = n2.processPointerMove.bind(n2), n2.onPointerOut = n2.onPointerOut.bind(n2), n2.processPointerOverOut = n2.processPointerOverOut.bind(n2), n2.onPointerOver = n2.onPointerOver.bind(n2), n2.cursorStyles = { default: "inherit", pointer: "pointer" }, n2.currentCursorMode = null, n2.cursor = null, n2.resolution = 1, n2.delayedEvents = [], n2.search = new Gh(), n2._tempDisplayObject = new Oh.d(), n2._eventListenerOptions = { capture: true, passive: false }, n2._useSystemTicker = i2.useSystemTicker === void 0 || i2.useSystemTicker, n2.setTargetElement(n2.renderer.view, n2.renderer.resolution), n2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Bh(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), Object.defineProperty(e2.prototype, "useSystemTicker", { get: function() {
      return this._useSystemTicker;
    }, set: function(t3) {
      this._useSystemTicker = t3, t3 ? this.addTickerListener() : this.removeTickerListener();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "lastObjectRendered", { get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    }, enumerable: false, configurable: true }), e2.prototype.hitTest = function(t3, e3) {
      return jh.target = null, jh.data.global = t3, e3 || (e3 = this.lastObjectRendered), this.processInteractive(jh, e3, null, true), jh.target;
    }, e2.prototype.setTargetElement = function(t3, e3) {
      e3 === void 0 && (e3 = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t3, this.resolution = e3, this.addEvents(), this.addTickerListener();
    }, e2.prototype.addTickerListener = function() {
      !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (Dh.a.system.add(this.tickerUpdate, this, Dh.c.INTERACTION), this.tickerAdded = true);
    }, e2.prototype.removeTickerListener = function() {
      this.tickerAdded && (Dh.a.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
    }, e2.prototype.addEvents = function() {
      if (!this.eventsAdded && this.interactionDOMElement) {
        var t3 = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t3.msContentZooming = "none", t3.msTouchAction = "none") : this.supportsPointerEvents && (t3.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = true;
      }
    }, e2.prototype.removeEvents = function() {
      if (this.eventsAdded && this.interactionDOMElement) {
        var t3 = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t3.msContentZooming = "", t3.msTouchAction = "") : this.supportsPointerEvents && (t3.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = false;
      }
    }, e2.prototype.tickerUpdate = function(t3) {
      this._deltaTime += t3, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update());
    }, e2.prototype.update = function() {
      if (this.interactionDOMElement)
        if (this._didMove)
          this._didMove = false;
        else {
          for (var t3 in this.cursor = null, this.activeInteractionData)
            if (this.activeInteractionData.hasOwnProperty(t3)) {
              var e3 = this.activeInteractionData[t3];
              if (e3.originalEvent && e3.pointerType !== "touch") {
                var i2 = this.configureInteractionEventForDOMEvent(this.eventData, e3.originalEvent, e3);
                this.processInteractive(i2, this.lastObjectRendered, this.processPointerOverOut, true);
              }
            }
          this.setCursorMode(this.cursor);
        }
    }, e2.prototype.setCursorMode = function(t3) {
      t3 = t3 || "default";
      var e3 = true;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e3 = false), this.currentCursorMode !== t3) {
        this.currentCursorMode = t3;
        var i2 = this.cursorStyles[t3];
        if (i2)
          switch (typeof i2) {
            case "string":
              e3 && (this.interactionDOMElement.style.cursor = i2);
              break;
            case "function":
              i2(t3);
              break;
            case "object":
              e3 && Object.assign(this.interactionDOMElement.style, i2);
          }
        else
          e3 && typeof t3 == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t3) && (this.interactionDOMElement.style.cursor = t3);
      }
    }, e2.prototype.dispatchEvent = function(t3, e3, i2) {
      i2.stopPropagationHint && t3 !== i2.stopsPropagatingAt || (i2.currentTarget = t3, i2.type = e3, t3.emit(e3, i2), t3[e3] && t3[e3](i2));
    }, e2.prototype.delayDispatchEvent = function(t3, e3, i2) {
      this.delayedEvents.push({ displayObject: t3, eventString: e3, eventData: i2 });
    }, e2.prototype.mapPositionToPoint = function(t3, e3, i2) {
      var n2;
      n2 = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: this.interactionDOMElement.width, height: this.interactionDOMElement.height, left: 0, top: 0 };
      var r2 = 1 / this.resolution;
      t3.x = (e3 - n2.left) * (this.interactionDOMElement.width / n2.width) * r2, t3.y = (i2 - n2.top) * (this.interactionDOMElement.height / n2.height) * r2;
    }, e2.prototype.processInteractive = function(t3, e3, i2, n2) {
      var r2 = this.search.findHit(t3, e3, i2, n2), o2 = this.delayedEvents;
      if (!o2.length)
        return r2;
      t3.stopPropagationHint = false;
      var s2 = o2.length;
      this.delayedEvents = [];
      for (var a2 = 0; a2 < s2; a2++) {
        var l2 = o2[a2], h2 = l2.displayObject, u2 = l2.eventString, c2 = l2.eventData;
        c2.stopsPropagatingAt === h2 && (c2.stopPropagationHint = true), this.dispatchEvent(h2, u2, c2);
      }
      return r2;
    }, e2.prototype.onPointerDown = function(t3) {
      if (!this.supportsTouchEvents || t3.pointerType !== "touch") {
        var e3 = this.normalizeToPointerData(t3);
        if (this.autoPreventDefault && e3[0].isNormalized)
          (t3.cancelable || !("cancelable" in t3)) && t3.preventDefault();
        for (var i2 = e3.length, n2 = 0; n2 < i2; n2++) {
          var r2 = e3[n2], o2 = this.getInteractionDataForPointerId(r2), s2 = this.configureInteractionEventForDOMEvent(this.eventData, r2, o2);
          if (s2.data.originalEvent = t3, this.processInteractive(s2, this.lastObjectRendered, this.processPointerDown, true), this.emit("pointerdown", s2), r2.pointerType === "touch")
            this.emit("touchstart", s2);
          else if (r2.pointerType === "mouse" || r2.pointerType === "pen") {
            var a2 = r2.button === 2;
            this.emit(a2 ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, e2.prototype.processPointerDown = function(t3, e3, i2) {
      var n2 = t3.data, r2 = t3.data.identifier;
      if (i2) {
        if (e3.trackedPointers[r2] || (e3.trackedPointers[r2] = new kh(r2)), this.dispatchEvent(e3, "pointerdown", t3), n2.pointerType === "touch")
          this.dispatchEvent(e3, "touchstart", t3);
        else if (n2.pointerType === "mouse" || n2.pointerType === "pen") {
          var o2 = n2.button === 2;
          o2 ? e3.trackedPointers[r2].rightDown = true : e3.trackedPointers[r2].leftDown = true, this.dispatchEvent(e3, o2 ? "rightdown" : "mousedown", t3);
        }
      }
    }, e2.prototype.onPointerComplete = function(t3, e3, i2) {
      for (var n2 = this.normalizeToPointerData(t3), r2 = n2.length, o2 = t3.target !== this.interactionDOMElement ? "outside" : "", s2 = 0; s2 < r2; s2++) {
        var a2 = n2[s2], l2 = this.getInteractionDataForPointerId(a2), h2 = this.configureInteractionEventForDOMEvent(this.eventData, a2, l2);
        if (h2.data.originalEvent = t3, this.processInteractive(h2, this.lastObjectRendered, i2, e3 || !o2), this.emit(e3 ? "pointercancel" : "pointerup" + o2, h2), a2.pointerType === "mouse" || a2.pointerType === "pen") {
          var u2 = a2.button === 2;
          this.emit(u2 ? "rightup" + o2 : "mouseup" + o2, h2);
        } else
          a2.pointerType === "touch" && (this.emit(e3 ? "touchcancel" : "touchend" + o2, h2), this.releaseInteractionDataForPointerId(a2.pointerId));
      }
    }, e2.prototype.onPointerCancel = function(t3) {
      this.supportsTouchEvents && t3.pointerType === "touch" || this.onPointerComplete(t3, true, this.processPointerCancel);
    }, e2.prototype.processPointerCancel = function(t3, e3) {
      var i2 = t3.data, n2 = t3.data.identifier;
      e3.trackedPointers[n2] !== void 0 && (delete e3.trackedPointers[n2], this.dispatchEvent(e3, "pointercancel", t3), i2.pointerType === "touch" && this.dispatchEvent(e3, "touchcancel", t3));
    }, e2.prototype.onPointerUp = function(t3) {
      this.supportsTouchEvents && t3.pointerType === "touch" || this.onPointerComplete(t3, false, this.processPointerUp);
    }, e2.prototype.processPointerUp = function(t3, e3, i2) {
      var n2 = t3.data, r2 = t3.data.identifier, o2 = e3.trackedPointers[r2], s2 = n2.pointerType === "touch", a2 = n2.pointerType === "mouse" || n2.pointerType === "pen", l2 = false;
      if (a2) {
        var h2 = n2.button === 2, u2 = kh.FLAGS, c2 = h2 ? u2.RIGHT_DOWN : u2.LEFT_DOWN, d2 = o2 !== void 0 && o2.flags & c2;
        i2 ? (this.dispatchEvent(e3, h2 ? "rightup" : "mouseup", t3), d2 && (this.dispatchEvent(e3, h2 ? "rightclick" : "click", t3), l2 = true)) : d2 && this.dispatchEvent(e3, h2 ? "rightupoutside" : "mouseupoutside", t3), o2 && (h2 ? o2.rightDown = false : o2.leftDown = false);
      }
      i2 ? (this.dispatchEvent(e3, "pointerup", t3), s2 && this.dispatchEvent(e3, "touchend", t3), o2 && (a2 && !l2 || this.dispatchEvent(e3, "pointertap", t3), s2 && (this.dispatchEvent(e3, "tap", t3), o2.over = false))) : o2 && (this.dispatchEvent(e3, "pointerupoutside", t3), s2 && this.dispatchEvent(e3, "touchendoutside", t3)), o2 && o2.none && delete e3.trackedPointers[r2];
    }, e2.prototype.onPointerMove = function(t3) {
      if (!this.supportsTouchEvents || t3.pointerType !== "touch") {
        var e3 = this.normalizeToPointerData(t3);
        e3[0].pointerType !== "mouse" && e3[0].pointerType !== "pen" || (this._didMove = true, this.cursor = null);
        for (var i2 = e3.length, n2 = 0; n2 < i2; n2++) {
          var r2 = e3[n2], o2 = this.getInteractionDataForPointerId(r2), s2 = this.configureInteractionEventForDOMEvent(this.eventData, r2, o2);
          s2.data.originalEvent = t3, this.processInteractive(s2, this.lastObjectRendered, this.processPointerMove, true), this.emit("pointermove", s2), r2.pointerType === "touch" && this.emit("touchmove", s2), r2.pointerType !== "mouse" && r2.pointerType !== "pen" || this.emit("mousemove", s2);
        }
        e3[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, e2.prototype.processPointerMove = function(t3, e3, i2) {
      var n2 = t3.data, r2 = n2.pointerType === "touch", o2 = n2.pointerType === "mouse" || n2.pointerType === "pen";
      o2 && this.processPointerOverOut(t3, e3, i2), this.moveWhenInside && !i2 || (this.dispatchEvent(e3, "pointermove", t3), r2 && this.dispatchEvent(e3, "touchmove", t3), o2 && this.dispatchEvent(e3, "mousemove", t3));
    }, e2.prototype.onPointerOut = function(t3) {
      if (!this.supportsTouchEvents || t3.pointerType !== "touch") {
        var e3 = this.normalizeToPointerData(t3)[0];
        e3.pointerType === "mouse" && (this.mouseOverRenderer = false, this.setCursorMode(null));
        var i2 = this.getInteractionDataForPointerId(e3), n2 = this.configureInteractionEventForDOMEvent(this.eventData, e3, i2);
        n2.data.originalEvent = e3, this.processInteractive(n2, this.lastObjectRendered, this.processPointerOverOut, false), this.emit("pointerout", n2), e3.pointerType === "mouse" || e3.pointerType === "pen" ? this.emit("mouseout", n2) : this.releaseInteractionDataForPointerId(i2.identifier);
      }
    }, e2.prototype.processPointerOverOut = function(t3, e3, i2) {
      var n2 = t3.data, r2 = t3.data.identifier, o2 = n2.pointerType === "mouse" || n2.pointerType === "pen", s2 = e3.trackedPointers[r2];
      i2 && !s2 && (s2 = e3.trackedPointers[r2] = new kh(r2)), s2 !== void 0 && (i2 && this.mouseOverRenderer ? (s2.over || (s2.over = true, this.delayDispatchEvent(e3, "pointerover", t3), o2 && this.delayDispatchEvent(e3, "mouseover", t3)), o2 && this.cursor === null && (this.cursor = e3.cursor)) : s2.over && (s2.over = false, this.dispatchEvent(e3, "pointerout", this.eventData), o2 && this.dispatchEvent(e3, "mouseout", t3), s2.none && delete e3.trackedPointers[r2]));
    }, e2.prototype.onPointerOver = function(t3) {
      var e3 = this.normalizeToPointerData(t3)[0], i2 = this.getInteractionDataForPointerId(e3), n2 = this.configureInteractionEventForDOMEvent(this.eventData, e3, i2);
      n2.data.originalEvent = e3, e3.pointerType === "mouse" && (this.mouseOverRenderer = true), this.emit("pointerover", n2), e3.pointerType !== "mouse" && e3.pointerType !== "pen" || this.emit("mouseover", n2);
    }, e2.prototype.getInteractionDataForPointerId = function(t3) {
      var e3, i2 = t3.pointerId;
      return i2 === 1 || t3.pointerType === "mouse" ? e3 = this.mouse : this.activeInteractionData[i2] ? e3 = this.activeInteractionData[i2] : ((e3 = this.interactionDataPool.pop() || new Fh()).identifier = i2, this.activeInteractionData[i2] = e3), e3.copyEvent(t3), e3;
    }, e2.prototype.releaseInteractionDataForPointerId = function(t3) {
      var e3 = this.activeInteractionData[t3];
      e3 && (delete this.activeInteractionData[t3], e3.reset(), this.interactionDataPool.push(e3));
    }, e2.prototype.configureInteractionEventForDOMEvent = function(t3, e3, i2) {
      return t3.data = i2, this.mapPositionToPoint(i2.global, e3.clientX, e3.clientY), e3.pointerType === "touch" && (e3.globalX = i2.global.x, e3.globalY = i2.global.y), i2.originalEvent = e3, t3.reset(), t3;
    }, e2.prototype.normalizeToPointerData = function(t3) {
      var e3 = [];
      if (this.supportsTouchEvents && t3 instanceof TouchEvent)
        for (var i2 = 0, n2 = t3.changedTouches.length; i2 < n2; i2++) {
          var r2 = t3.changedTouches[i2];
          r2.button === void 0 && (r2.button = t3.touches.length ? 1 : 0), r2.buttons === void 0 && (r2.buttons = t3.touches.length ? 1 : 0), r2.isPrimary === void 0 && (r2.isPrimary = t3.touches.length === 1 && t3.type === "touchstart"), r2.width === void 0 && (r2.width = r2.radiusX || 1), r2.height === void 0 && (r2.height = r2.radiusY || 1), r2.tiltX === void 0 && (r2.tiltX = 0), r2.tiltY === void 0 && (r2.tiltY = 0), r2.pointerType === void 0 && (r2.pointerType = "touch"), r2.pointerId === void 0 && (r2.pointerId = r2.identifier || 0), r2.pressure === void 0 && (r2.pressure = r2.force || 0.5), r2.twist === void 0 && (r2.twist = 0), r2.tangentialPressure === void 0 && (r2.tangentialPressure = 0), r2.layerX === void 0 && (r2.layerX = r2.offsetX = r2.clientX), r2.layerY === void 0 && (r2.layerY = r2.offsetY = r2.clientY), r2.isNormalized = true, e3.push(r2);
        }
      else if (globalThis.MouseEvent && (!(t3 instanceof MouseEvent) || this.supportsPointerEvents && t3 instanceof globalThis.PointerEvent))
        e3.push(t3);
      else {
        var o2 = t3;
        o2.isPrimary === void 0 && (o2.isPrimary = true), o2.width === void 0 && (o2.width = 1), o2.height === void 0 && (o2.height = 1), o2.tiltX === void 0 && (o2.tiltX = 0), o2.tiltY === void 0 && (o2.tiltY = 0), o2.pointerType === void 0 && (o2.pointerType = "mouse"), o2.pointerId === void 0 && (o2.pointerId = 1), o2.pressure === void 0 && (o2.pressure = 0.5), o2.twist === void 0 && (o2.twist = 0), o2.tangentialPressure === void 0 && (o2.tangentialPressure = 0), o2.isNormalized = true, e3.push(o2);
      }
      return e3;
    }, e2.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, e2;
  }(Ph.EventEmitter), Vh = i(2), Xh = function() {
    function t2(e2) {
      var i2 = this;
      this.stage = new Oh.b(), e2 = Object.assign({ forceCanvas: false }, e2), this.renderer = Object(Vh.y)(e2), t2._plugins.forEach(function(t3) {
        t3.init.call(i2, e2);
      });
    }
    return t2.registerPlugin = function(e2) {
      t2._plugins.push(e2);
    }, t2.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(t2.prototype, "view", { get: function() {
      return this.renderer.view;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "screen", { get: function() {
      return this.renderer.screen;
    }, enumerable: false, configurable: true }), t2.prototype.destroy = function(e2, i2) {
      var n2 = this, r2 = t2._plugins.slice(0);
      r2.reverse(), r2.forEach(function(t3) {
        t3.destroy.call(n2);
      }), this.stage.destroy(i2), this.stage = null, this.renderer.destroy(e2), this.renderer = null;
    }, t2._plugins = [], t2;
  }(), Wh = function() {
    function t2() {
    }
    return t2.init = function(t3) {
      var e2 = this;
      Object.defineProperty(this, "resizeTo", { set: function(t4) {
        globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = t4, t4 && (globalThis.addEventListener("resize", this.queueResize), this.resize());
      }, get: function() {
        return this._resizeTo;
      } }), this.queueResize = function() {
        e2._resizeTo && (e2.cancelResize(), e2._resizeId = requestAnimationFrame(function() {
          return e2.resize();
        }));
      }, this.cancelResize = function() {
        e2._resizeId && (cancelAnimationFrame(e2._resizeId), e2._resizeId = null);
      }, this.resize = function() {
        if (e2._resizeTo) {
          var t4, i2;
          if (e2.cancelResize(), e2._resizeTo === globalThis.window)
            t4 = globalThis.innerWidth, i2 = globalThis.innerHeight;
          else {
            var n2 = e2._resizeTo;
            t4 = n2.clientWidth, i2 = n2.clientHeight;
          }
          e2.renderer.resize(t4, i2);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t3.resizeTo || null;
    }, t2.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, t2;
  }();
  Xh.registerPlugin(Wh);
  /*!
   * @pixi/extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var Yh = /iPhone/i, qh = /iPod/i, Zh = /iPad/i, Jh = /\biOS-universal(?:.+)Mac\b/i, Kh = /\bAndroid(?:.+)Mobile\b/i, Qh = /Android/i, $h = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, tu = /Silk/i, eu = /Windows Phone/i, iu = /\bWindows(?:.+)ARM\b/i, nu = /BlackBerry/i, ru = /BB10/i, ou = /Opera Mini/i, su = /\b(CriOS|Chrome)(?:.+)Mobile/i, au = /Mobile(?:.+)Firefox\b/i, lu = function(t2) {
    return t2 !== void 0 && t2.platform === "MacIntel" && typeof t2.maxTouchPoints == "number" && t2.maxTouchPoints > 1 && typeof MSStream == "undefined";
  };
  /*!
   * @pixi/settings - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var hu, uu, cu, du, pu, fu, mu, gu, vu, _u, yu, xu, bu, Tu, Eu, Su, wu, Au, Mu, Ru = function(t2) {
    var e2 = { userAgent: "", platform: "", maxTouchPoints: 0 };
    t2 || typeof navigator == "undefined" ? typeof t2 == "string" ? e2.userAgent = t2 : t2 && t2.userAgent && (e2 = { userAgent: t2.userAgent, platform: t2.platform, maxTouchPoints: t2.maxTouchPoints || 0 }) : e2 = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 };
    var i2 = e2.userAgent, n2 = i2.split("[FBAN");
    n2[1] !== void 0 && (i2 = n2[0]), (n2 = i2.split("Twitter"))[1] !== void 0 && (i2 = n2[0]);
    var r2 = function(t3) {
      return function(e3) {
        return e3.test(t3);
      };
    }(i2), o2 = { apple: { phone: r2(Yh) && !r2(eu), ipod: r2(qh), tablet: !r2(Yh) && (r2(Zh) || lu(e2)) && !r2(eu), universal: r2(Jh), device: (r2(Yh) || r2(qh) || r2(Zh) || r2(Jh) || lu(e2)) && !r2(eu) }, amazon: { phone: r2($h), tablet: !r2($h) && r2(tu), device: r2($h) || r2(tu) }, android: { phone: !r2(eu) && r2($h) || !r2(eu) && r2(Kh), tablet: !r2(eu) && !r2($h) && !r2(Kh) && (r2(tu) || r2(Qh)), device: !r2(eu) && (r2($h) || r2(tu) || r2(Kh) || r2(Qh)) || r2(/\bokhttp\b/i) }, windows: { phone: r2(eu), tablet: r2(iu), device: r2(eu) || r2(iu) }, other: { blackberry: r2(nu), blackberry10: r2(ru), opera: r2(ou), firefox: r2(au), chrome: r2(su), device: r2(nu) || r2(ru) || r2(ou) || r2(au) || r2(su) }, any: false, phone: false, tablet: false };
    return o2.any = o2.apple.device || o2.android.device || o2.windows.device || o2.other.device, o2.phone = o2.apple.phone || o2.android.phone || o2.windows.phone, o2.tablet = o2.apple.tablet || o2.android.tablet || o2.windows.tablet, o2;
  }(globalThis.navigator);
  !function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(hu || (hu = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(uu || (uu = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(cu || (cu = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(du || (du = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(pu || (pu = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(fu || (fu = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(mu || (mu = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(gu || (gu = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(vu || (vu = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(_u || (_u = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(yu || (yu = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(xu || (xu = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(bu || (bu = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(Tu || (Tu = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(Eu || (Eu = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(Su || (Su = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(wu || (wu = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(Au || (Au = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(Mu || (Mu = {}));
  var Cu = {
    MIPMAP_TEXTURES: xu.POW2,
    ANISOTROPIC_LEVEL: 0,
    RESOLUTION: 1,
    FILTER_RESOLUTION: 1,
    FILTER_MULTISAMPLE: Au.NONE,
    SPRITE_MAX_TEXTURES: function(t2) {
      var e2 = true;
      if (Ru.tablet || Ru.phone) {
        var i2;
        if (Ru.apple.device) {
          if (i2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/))
            parseInt(i2[1], 10) < 11 && (e2 = false);
        }
        if (Ru.android.device) {
          if (i2 = navigator.userAgent.match(/Android\s([0-9.]*)/))
            parseInt(i2[1], 10) < 7 && (e2 = false);
        }
      }
      return e2 ? t2 : 4;
    }(32),
    SPRITE_BATCH_SIZE: 4096,
    RENDER_OPTIONS: { view: null, antialias: false, autoDensity: false, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: true, clearBeforeRender: true, preserveDrawingBuffer: false, width: 800, height: 600, legacy: false },
    GC_MODE: Eu.AUTO,
    GC_MAX_IDLE: 3600,
    GC_MAX_CHECK_COUNT: 600,
    WRAP_MODE: yu.CLAMP,
    SCALE_MODE: _u.LINEAR,
    PRECISION_VERTEX: Su.HIGH,
    PRECISION_FRAGMENT: Ru.apple.device ? Su.HIGH : Su.MEDIUM,
    CAN_UPLOAD_SAME_BUFFER: !Ru.apple.device,
    CREATE_IMAGE_BITMAP: false,
    ROUND_PIXELS: false,
    SORTABLE_CHILDREN: false
  }, Iu = function() {
    function t2() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return t2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, t2.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, t2.prototype.getRectangle = function(t3) {
      return this.minX > this.maxX || this.minY > this.maxY ? Lh.j.EMPTY : ((t3 = t3 || new Lh.j(0, 0, 1, 1)).x = this.minX, t3.y = this.minY, t3.width = this.maxX - this.minX, t3.height = this.maxY - this.minY, t3);
    }, t2.prototype.addPoint = function(t3) {
      this.minX = Math.min(this.minX, t3.x), this.maxX = Math.max(this.maxX, t3.x), this.minY = Math.min(this.minY, t3.y), this.maxY = Math.max(this.maxY, t3.y);
    }, t2.prototype.addPointMatrix = function(t3, e2) {
      var i2 = t3.a, n2 = t3.b, r2 = t3.c, o2 = t3.d, s2 = t3.tx, a2 = t3.ty, l2 = i2 * e2.x + r2 * e2.y + s2, h2 = n2 * e2.x + o2 * e2.y + a2;
      this.minX = Math.min(this.minX, l2), this.maxX = Math.max(this.maxX, l2), this.minY = Math.min(this.minY, h2), this.maxY = Math.max(this.maxY, h2);
    }, t2.prototype.addQuad = function(t3) {
      var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY, o2 = t3[0], s2 = t3[1];
      e2 = o2 < e2 ? o2 : e2, i2 = s2 < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[2]) < e2 ? o2 : e2, i2 = (s2 = t3[3]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[4]) < e2 ? o2 : e2, i2 = (s2 = t3[5]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[6]) < e2 ? o2 : e2, i2 = (s2 = t3[7]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, this.minX = e2, this.minY = i2, this.maxX = n2, this.maxY = r2;
    }, t2.prototype.addFrame = function(t3, e2, i2, n2, r2) {
      this.addFrameMatrix(t3.worldTransform, e2, i2, n2, r2);
    }, t2.prototype.addFrameMatrix = function(t3, e2, i2, n2, r2) {
      var o2 = t3.a, s2 = t3.b, a2 = t3.c, l2 = t3.d, h2 = t3.tx, u2 = t3.ty, c2 = this.minX, d2 = this.minY, p2 = this.maxX, f2 = this.maxY, m2 = o2 * e2 + a2 * i2 + h2, g2 = s2 * e2 + l2 * i2 + u2;
      c2 = m2 < c2 ? m2 : c2, d2 = g2 < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * i2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * i2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * e2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * e2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, this.minX = c2, this.minY = d2, this.maxX = p2, this.maxY = f2;
    }, t2.prototype.addVertexData = function(t3, e2, i2) {
      for (var n2 = this.minX, r2 = this.minY, o2 = this.maxX, s2 = this.maxY, a2 = e2; a2 < i2; a2 += 2) {
        var l2 = t3[a2], h2 = t3[a2 + 1];
        n2 = l2 < n2 ? l2 : n2, r2 = h2 < r2 ? h2 : r2, o2 = l2 > o2 ? l2 : o2, s2 = h2 > s2 ? h2 : s2;
      }
      this.minX = n2, this.minY = r2, this.maxX = o2, this.maxY = s2;
    }, t2.prototype.addVertices = function(t3, e2, i2, n2) {
      this.addVerticesMatrix(t3.worldTransform, e2, i2, n2);
    }, t2.prototype.addVerticesMatrix = function(t3, e2, i2, n2, r2, o2) {
      r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = r2);
      for (var s2 = t3.a, a2 = t3.b, l2 = t3.c, h2 = t3.d, u2 = t3.tx, c2 = t3.ty, d2 = this.minX, p2 = this.minY, f2 = this.maxX, m2 = this.maxY, g2 = i2; g2 < n2; g2 += 2) {
        var v2 = e2[g2], _2 = e2[g2 + 1], y2 = s2 * v2 + l2 * _2 + u2, x2 = h2 * _2 + a2 * v2 + c2;
        d2 = Math.min(d2, y2 - r2), f2 = Math.max(f2, y2 + r2), p2 = Math.min(p2, x2 - o2), m2 = Math.max(m2, x2 + o2);
      }
      this.minX = d2, this.minY = p2, this.maxX = f2, this.maxY = m2;
    }, t2.prototype.addBounds = function(t3) {
      var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY;
      this.minX = t3.minX < e2 ? t3.minX : e2, this.minY = t3.minY < i2 ? t3.minY : i2, this.maxX = t3.maxX > n2 ? t3.maxX : n2, this.maxY = t3.maxY > r2 ? t3.maxY : r2;
    }, t2.prototype.addBoundsMask = function(t3, e2) {
      var i2 = t3.minX > e2.minX ? t3.minX : e2.minX, n2 = t3.minY > e2.minY ? t3.minY : e2.minY, r2 = t3.maxX < e2.maxX ? t3.maxX : e2.maxX, o2 = t3.maxY < e2.maxY ? t3.maxY : e2.maxY;
      if (i2 <= r2 && n2 <= o2) {
        var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
        this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
      }
    }, t2.prototype.addBoundsMatrix = function(t3, e2) {
      this.addFrameMatrix(e2, t3.minX, t3.minY, t3.maxX, t3.maxY);
    }, t2.prototype.addBoundsArea = function(t3, e2) {
      var i2 = t3.minX > e2.x ? t3.minX : e2.x, n2 = t3.minY > e2.y ? t3.minY : e2.y, r2 = t3.maxX < e2.x + e2.width ? t3.maxX : e2.x + e2.width, o2 = t3.maxY < e2.y + e2.height ? t3.maxY : e2.y + e2.height;
      if (i2 <= r2 && n2 <= o2) {
        var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
        this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
      }
    }, t2.prototype.pad = function(t3, e2) {
      t3 === void 0 && (t3 = 0), e2 === void 0 && (e2 = t3), this.isEmpty() || (this.minX -= t3, this.maxX += t3, this.minY -= e2, this.maxY += e2);
    }, t2.prototype.addFramePad = function(t3, e2, i2, n2, r2, o2) {
      t3 -= r2, e2 -= o2, i2 += r2, n2 += o2, this.minX = this.minX < t3 ? this.minX : t3, this.maxX = this.maxX > i2 ? this.maxX : i2, this.minY = this.minY < e2 ? this.minY : e2, this.maxY = this.maxY > n2 ? this.maxY : n2;
    }, t2;
  }(), Pu = function(t2, e2) {
    return (Pu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function Ou(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    Pu(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var Nu, Lu, Du, Fu, Bu, Uu, ku, Gu, Hu, ju, zu, Vu, Xu, Wu, Yu, qu, Zu, Ju, Ku, Qu = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.tempDisplayObjectParent = null, e3.transform = new Lh.m(), e3.alpha = 1, e3.visible = true, e3.renderable = true, e3.cullable = false, e3.cullArea = null, e3.parent = null, e3.worldAlpha = 1, e3._lastSortedIndex = 0, e3._zIndex = 0, e3.filterArea = null, e3.filters = null, e3._enabledFilters = null, e3._bounds = new Iu(), e3._localBounds = null, e3._boundsID = 0, e3._boundsRect = null, e3._localBoundsRect = null, e3._mask = null, e3._maskRefCount = 0, e3._destroyed = false, e3.isSprite = false, e3.isMask = false, e3;
    }
    return Ou(e2, t2), e2.mixin = function(t3) {
      for (var i2 = Object.keys(t3), n2 = 0; n2 < i2.length; ++n2) {
        var r2 = i2[n2];
        Object.defineProperty(e2.prototype, r2, Object.getOwnPropertyDescriptor(t3, r2));
      }
    }, Object.defineProperty(e2.prototype, "destroyed", { get: function() {
      return this._destroyed;
    }, enumerable: false, configurable: true }), e2.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, e2.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, e2.prototype.getBounds = function(t3, e3) {
      return t3 || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e3 || (this._boundsRect || (this._boundsRect = new Lh.j()), e3 = this._boundsRect), this._bounds.getRectangle(e3);
    }, e2.prototype.getLocalBounds = function(t3) {
      t3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), t3 = this._localBoundsRect), this._localBounds || (this._localBounds = new Iu());
      var e3 = this.transform, i2 = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var n2 = this._bounds, r2 = this._boundsID;
      this._bounds = this._localBounds;
      var o2 = this.getBounds(false, t3);
      return this.parent = i2, this.transform = e3, this._bounds = n2, this._bounds.updateID += this._boundsID - r2, o2;
    }, e2.prototype.toGlobal = function(t3, e3, i2) {
      return i2 === void 0 && (i2 = false), i2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t3, e3);
    }, e2.prototype.toLocal = function(t3, e3, i2, n2) {
      return e3 && (t3 = e3.toGlobal(t3, i2, n2)), n2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t3, i2);
    }, e2.prototype.setParent = function(t3) {
      if (!t3 || !t3.addChild)
        throw new Error("setParent: Argument must be a Container");
      return t3.addChild(this), t3;
    }, e2.prototype.setTransform = function(t3, e3, i2, n2, r2, o2, s2, a2, l2) {
      return t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = 0), i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = 1), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = 0), s2 === void 0 && (s2 = 0), a2 === void 0 && (a2 = 0), l2 === void 0 && (l2 = 0), this.position.x = t3, this.position.y = e3, this.scale.x = i2 || 1, this.scale.y = n2 || 1, this.rotation = r2, this.skew.x = o2, this.skew.y = s2, this.pivot.x = a2, this.pivot.y = l2, this;
    }, e2.prototype.destroy = function(t3) {
      this.parent && this.parent.removeChild(this), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(e2.prototype, "_tempDisplayObjectParent", { get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new $u()), this.tempDisplayObjectParent;
    }, enumerable: false, configurable: true }), e2.prototype.enableTempParent = function() {
      var t3 = this.parent;
      return this.parent = this._tempDisplayObjectParent, t3;
    }, e2.prototype.disableTempParent = function(t3) {
      this.parent = t3;
    }, Object.defineProperty(e2.prototype, "x", { get: function() {
      return this.position.x;
    }, set: function(t3) {
      this.transform.position.x = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "y", { get: function() {
      return this.position.y;
    }, set: function(t3) {
      this.transform.position.y = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldTransform", { get: function() {
      return this.transform.worldTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "localTransform", { get: function() {
      return this.transform.localTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "position", { get: function() {
      return this.transform.position;
    }, set: function(t3) {
      this.transform.position.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scale", { get: function() {
      return this.transform.scale;
    }, set: function(t3) {
      this.transform.scale.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "pivot", { get: function() {
      return this.transform.pivot;
    }, set: function(t3) {
      this.transform.pivot.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "skew", { get: function() {
      return this.transform.skew;
    }, set: function(t3) {
      this.transform.skew.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotation", { get: function() {
      return this.transform.rotation;
    }, set: function(t3) {
      this.transform.rotation = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "angle", { get: function() {
      return this.transform.rotation * Lh.i;
    }, set: function(t3) {
      this.transform.rotation = t3 * Lh.b;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "zIndex", { get: function() {
      return this._zIndex;
    }, set: function(t3) {
      this._zIndex = t3, this.parent && (this.parent.sortDirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldVisible", { get: function() {
      var t3 = this;
      do {
        if (!t3.visible)
          return false;
        t3 = t3.parent;
      } while (t3);
      return true;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mask", { get: function() {
      return this._mask;
    }, set: function(t3) {
      if (this._mask !== t3) {
        var e3;
        if (this._mask)
          (e3 = this._mask.maskObject || this._mask)._maskRefCount--, e3._maskRefCount === 0 && (e3.renderable = true, e3.isMask = false);
        if (this._mask = t3, this._mask)
          (e3 = this._mask.maskObject || this._mask)._maskRefCount === 0 && (e3.renderable = false, e3.isMask = true), e3._maskRefCount++;
      }
    }, enumerable: false, configurable: true }), e2;
  }(Ph.EventEmitter), $u = function(t2) {
    function e2() {
      var e3 = t2 !== null && t2.apply(this, arguments) || this;
      return e3.sortDirty = null, e3;
    }
    return Ou(e2, t2), e2;
  }(Qu);
  function tc(t2, e2) {
    return t2.zIndex === e2.zIndex ? t2._lastSortedIndex - e2._lastSortedIndex : t2.zIndex - e2.zIndex;
  }
  Qu.prototype.displayObjectUpdateTransform = Qu.prototype.updateTransform, function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(Nu || (Nu = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(Lu || (Lu = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(Du || (Du = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(Fu || (Fu = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(Bu || (Bu = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(Uu || (Uu = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(ku || (ku = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(Gu || (Gu = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(Hu || (Hu = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(ju || (ju = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(zu || (zu = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(Vu || (Vu = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(Xu || (Xu = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(Wu || (Wu = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(Yu || (Yu = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(qu || (qu = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(Zu || (Zu = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(Ju || (Ju = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(Ku || (Ku = {}));
  var ec = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.children = [], e3.sortableChildren = Cu.SORTABLE_CHILDREN, e3.sortDirty = false, e3;
    }
    return Ou(e2, t2), e2.prototype.onChildrenChange = function(t3) {
    }, e2.prototype.addChild = function() {
      for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++)
        e3[i2] = t3[i2];
      if (e3.length > 1)
        for (var n2 = 0; n2 < e3.length; n2++)
          this.addChild(e3[n2]);
      else {
        var r2 = e3[0];
        r2.parent && r2.parent.removeChild(r2), r2.parent = this, this.sortDirty = true, r2.transform._parentID = -1, this.children.push(r2), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r2, this, this.children.length - 1), r2.emit("added", this);
      }
      return e3[0];
    }, e2.prototype.addChildAt = function(t3, e3) {
      if (e3 < 0 || e3 > this.children.length)
        throw new Error(t3 + "addChildAt: The index " + e3 + " supplied is out of bounds " + this.children.length);
      return t3.parent && t3.parent.removeChild(t3), t3.parent = this, this.sortDirty = true, t3.transform._parentID = -1, this.children.splice(e3, 0, t3), this._boundsID++, this.onChildrenChange(e3), t3.emit("added", this), this.emit("childAdded", t3, this, e3), t3;
    }, e2.prototype.swapChildren = function(t3, e3) {
      if (t3 !== e3) {
        var i2 = this.getChildIndex(t3), n2 = this.getChildIndex(e3);
        this.children[i2] = e3, this.children[n2] = t3, this.onChildrenChange(i2 < n2 ? i2 : n2);
      }
    }, e2.prototype.getChildIndex = function(t3) {
      var e3 = this.children.indexOf(t3);
      if (e3 === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return e3;
    }, e2.prototype.setChildIndex = function(t3, e3) {
      if (e3 < 0 || e3 >= this.children.length)
        throw new Error("The index " + e3 + " supplied is out of bounds " + this.children.length);
      var i2 = this.getChildIndex(t3);
      Object(Ph.removeItems)(this.children, i2, 1), this.children.splice(e3, 0, t3), this.onChildrenChange(e3);
    }, e2.prototype.getChildAt = function(t3) {
      if (t3 < 0 || t3 >= this.children.length)
        throw new Error("getChildAt: Index (" + t3 + ") does not exist.");
      return this.children[t3];
    }, e2.prototype.removeChild = function() {
      for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++)
        e3[i2] = t3[i2];
      if (e3.length > 1)
        for (var n2 = 0; n2 < e3.length; n2++)
          this.removeChild(e3[n2]);
      else {
        var r2 = e3[0], o2 = this.children.indexOf(r2);
        if (o2 === -1)
          return null;
        r2.parent = null, r2.transform._parentID = -1, Object(Ph.removeItems)(this.children, o2, 1), this._boundsID++, this.onChildrenChange(o2), r2.emit("removed", this), this.emit("childRemoved", r2, this, o2);
      }
      return e3[0];
    }, e2.prototype.removeChildAt = function(t3) {
      var e3 = this.getChildAt(t3);
      return e3.parent = null, e3.transform._parentID = -1, Object(Ph.removeItems)(this.children, t3, 1), this._boundsID++, this.onChildrenChange(t3), e3.emit("removed", this), this.emit("childRemoved", e3, this, t3), e3;
    }, e2.prototype.removeChildren = function(t3, e3) {
      t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = this.children.length);
      var i2, n2 = t3, r2 = e3 - n2;
      if (r2 > 0 && r2 <= e3) {
        i2 = this.children.splice(n2, r2);
        for (var o2 = 0; o2 < i2.length; ++o2)
          i2[o2].parent = null, i2[o2].transform && (i2[o2].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(t3);
        for (o2 = 0; o2 < i2.length; ++o2)
          i2[o2].emit("removed", this), this.emit("childRemoved", i2[o2], this, o2);
        return i2;
      }
      if (r2 === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, e2.prototype.sortChildren = function() {
      for (var t3 = false, e3 = 0, i2 = this.children.length; e3 < i2; ++e3) {
        var n2 = this.children[e3];
        n2._lastSortedIndex = e3, t3 || n2.zIndex === 0 || (t3 = true);
      }
      t3 && this.children.length > 1 && this.children.sort(tc), this.sortDirty = false;
    }, e2.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var t3 = 0, e3 = this.children.length; t3 < e3; ++t3) {
        var i2 = this.children[t3];
        i2.visible && i2.updateTransform();
      }
    }, e2.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var t3 = 0; t3 < this.children.length; t3++) {
        var e3 = this.children[t3];
        if (e3.visible && e3.renderable)
          if (e3.calculateBounds(), e3._mask) {
            var i2 = e3._mask.maskObject || e3._mask;
            i2.calculateBounds(), this._bounds.addBoundsMask(e3._bounds, i2._bounds);
          } else
            e3.filterArea ? this._bounds.addBoundsArea(e3._bounds, e3.filterArea) : this._bounds.addBounds(e3._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, e2.prototype.getLocalBounds = function(e3, i2) {
      i2 === void 0 && (i2 = false);
      var n2 = t2.prototype.getLocalBounds.call(this, e3);
      if (!i2)
        for (var r2 = 0, o2 = this.children.length; r2 < o2; ++r2) {
          var s2 = this.children[r2];
          s2.visible && s2.updateTransform();
        }
      return n2;
    }, e2.prototype._calculateBounds = function() {
    }, e2.prototype._renderWithCulling = function(t3) {
      var i2 = t3.renderTexture.sourceFrame;
      if (i2.width > 0 && i2.height > 0) {
        var n2, r2;
        if (this.cullArea ? (n2 = this.cullArea, r2 = this.worldTransform) : this._render !== e2.prototype._render && (n2 = this.getBounds(true)), n2 && i2.intersects(n2, r2))
          this._render(t3);
        else if (this.cullArea)
          return;
        for (var o2 = 0, s2 = this.children.length; o2 < s2; ++o2) {
          var a2 = this.children[o2], l2 = a2.cullable;
          a2.cullable = l2 || !this.cullArea, a2.render(t3), a2.cullable = l2;
        }
      }
    }, e2.prototype.render = function(t3) {
      if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(t3);
        else if (this.cullable)
          this._renderWithCulling(t3);
        else {
          this._render(t3);
          for (var e3 = 0, i2 = this.children.length; e3 < i2; ++e3)
            this.children[e3].render(t3);
        }
    }, e2.prototype.renderAdvanced = function(t3) {
      var e3 = this.filters, i2 = this._mask;
      if (e3) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var n2 = 0; n2 < e3.length; n2++)
          e3[n2].enabled && this._enabledFilters.push(e3[n2]);
      }
      var r2 = e3 && this._enabledFilters && this._enabledFilters.length || i2 && (!i2.isMaskData || i2.enabled && (i2.autoDetect || i2.type !== Zu.NONE));
      if (r2 && t3.batch.flush(), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.push(this, this._enabledFilters), i2 && t3.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(t3);
      else {
        this._render(t3);
        n2 = 0;
        for (var o2 = this.children.length; n2 < o2; ++n2)
          this.children[n2].render(t3);
      }
      r2 && t3.batch.flush(), i2 && t3.mask.pop(this), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.pop();
    }, e2.prototype._render = function(t3) {
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this), this.sortDirty = false;
      var i2 = typeof e3 == "boolean" ? e3 : e3 && e3.children, n2 = this.removeChildren(0, this.children.length);
      if (i2)
        for (var r2 = 0; r2 < n2.length; ++r2)
          n2[r2].destroy(e3);
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.scale.x * this.getLocalBounds().width;
    }, set: function(t3) {
      var e3 = this.getLocalBounds().width;
      this.scale.x = e3 !== 0 ? t3 / e3 : 1, this._width = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.scale.y * this.getLocalBounds().height;
    }, set: function(t3) {
      var e3 = this.getLocalBounds().height;
      this.scale.y = e3 !== 0 ? t3 / e3 : 1, this._height = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Qu);
  ec.prototype.containerUpdateTransform = ec.prototype.updateTransform;
  var ic = new Lh.j(), nc = function() {
    function t2(t3) {
      this.renderer = t3;
    }
    return t2.prototype.image = function(t3, e2, i2) {
      var n2 = new Image();
      return n2.src = this.base64(t3, e2, i2), n2;
    }, t2.prototype.base64 = function(t3, e2, i2) {
      return this.canvas(t3).toDataURL(e2, i2);
    }, t2.prototype.canvas = function(e2) {
      var i2, n2, r2, o2 = this.renderer, s2 = false, a2 = false;
      e2 && (e2 instanceof Vh.p ? r2 = e2 : (r2 = this.renderer.generateTexture(e2), a2 = true)), r2 ? (i2 = r2.baseTexture.resolution, n2 = r2.frame, s2 = false, o2.renderTexture.bind(r2)) : (i2 = this.renderer.resolution, s2 = true, (n2 = ic).width = this.renderer.width, n2.height = this.renderer.height, o2.renderTexture.bind(null));
      var l2 = Math.floor(n2.width * i2 + 1e-4), h2 = Math.floor(n2.height * i2 + 1e-4), u2 = new Ph.CanvasRenderTarget(l2, h2, 1), c2 = new Uint8Array(4 * l2 * h2), d2 = o2.gl;
      d2.readPixels(n2.x * i2, n2.y * i2, l2, h2, d2.RGBA, d2.UNSIGNED_BYTE, c2);
      var p2 = u2.context.getImageData(0, 0, l2, h2);
      if (t2.arrayPostDivide(c2, p2.data), u2.context.putImageData(p2, 0, 0), s2) {
        var f2 = new Ph.CanvasRenderTarget(u2.width, u2.height, 1);
        f2.context.scale(1, -1), f2.context.drawImage(u2.canvas, 0, -h2), u2.destroy(), u2 = f2;
      }
      return a2 && r2.destroy(true), u2.canvas;
    }, t2.prototype.pixels = function(e2, i2) {
      var n2, r2, o2, s2 = this.renderer, a2 = false;
      e2 && (e2 instanceof Vh.p ? o2 = e2 : e2 instanceof Qu && (o2 = this.renderer.generateTexture(e2), a2 = true)), o2 ? i2 ? (n2 = i2.resolution, r2 = o2.frame, s2.renderTexture.bind(o2)) : (n2 = o2.baseTexture.resolution, r2 = o2.frame, s2.renderTexture.bind(o2)) : i2 ? (n2 = i2.resolution, (r2 = ic).width = i2.width, r2.height = i2.height, s2.renderTexture.bind(null)) : (n2 = s2.resolution, (r2 = ic).width = s2.width, r2.height = s2.height, s2.renderTexture.bind(null));
      var l2 = r2.width * n2, h2 = r2.height * n2, u2 = new Uint8Array(4 * l2 * h2), c2 = s2.gl;
      return c2.readPixels(r2.x * n2, r2.y * n2, l2, h2, c2.RGBA, c2.UNSIGNED_BYTE, u2), a2 && o2.destroy(true), t2.arrayPostDivide(u2, u2), u2;
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2.arrayPostDivide = function(t3, e2) {
      for (var i2 = 0; i2 < t3.length; i2 += 4) {
        var n2 = e2[i2 + 3] = t3[i2 + 3];
        n2 !== 0 ? (e2[i2] = Math.round(Math.min(255 * t3[i2] / n2, 255)), e2[i2 + 1] = Math.round(Math.min(255 * t3[i2 + 1] / n2, 255)), e2[i2 + 2] = Math.round(Math.min(255 * t3[i2 + 2] / n2, 255))) : (e2[i2] = t3[i2], e2[i2 + 1] = t3[i2 + 1], e2[i2 + 2] = t3[i2 + 2]);
      }
    }, t2;
  }(), rc = function() {
    function t2(t3, e2, i2) {
      e2 === void 0 && (e2 = false), this._fn = t3, this._once = e2, this._thisArg = i2, this._next = this._prev = this._owner = null;
    }
    return t2.prototype.detach = function() {
      return this._owner !== null && (this._owner.detach(this), true);
    }, t2;
  }();
  function oc(t2, e2) {
    return t2._head ? (t2._tail._next = e2, e2._prev = t2._tail, t2._tail = e2) : (t2._head = e2, t2._tail = e2), e2._owner = t2, e2;
  }
  var sc, ac = function() {
    function t2() {
      this._head = this._tail = void 0;
    }
    return t2.prototype.handlers = function(t3) {
      t3 === void 0 && (t3 = false);
      var e2 = this._head;
      if (t3)
        return !!e2;
      for (var i2 = []; e2; )
        i2.push(e2), e2 = e2._next;
      return i2;
    }, t2.prototype.has = function(t3) {
      if (!(t3 instanceof rc))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t3._owner === this;
    }, t2.prototype.dispatch = function() {
      for (var t3 = arguments, e2 = [], i2 = 0; i2 < arguments.length; i2++)
        e2[i2] = t3[i2];
      var n2 = this._head;
      if (!n2)
        return false;
      for (; n2; )
        n2._once && this.detach(n2), n2._fn.apply(n2._thisArg, e2), n2 = n2._next;
      return true;
    }, t2.prototype.add = function(t3, e2) {
      if (e2 === void 0 && (e2 = null), typeof t3 != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return oc(this, new rc(t3, false, e2));
    }, t2.prototype.once = function(t3, e2) {
      if (e2 === void 0 && (e2 = null), typeof t3 != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return oc(this, new rc(t3, true, e2));
    }, t2.prototype.detach = function(t3) {
      if (!(t3 instanceof rc))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t3._owner !== this || (t3._prev && (t3._prev._next = t3._next), t3._next && (t3._next._prev = t3._prev), t3 === this._head ? (this._head = t3._next, t3._next === null && (this._tail = null)) : t3 === this._tail && (this._tail = t3._prev, this._tail._next = null), t3._owner = null), this;
    }, t2.prototype.detachAll = function() {
      var t3 = this._head;
      if (!t3)
        return this;
      for (this._head = this._tail = null; t3; )
        t3._owner = null, t3 = t3._next;
      return this;
    }, t2;
  }();
  function lc(t2, e2) {
    e2 = e2 || {};
    for (var i2 = { key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, n2 = i2.parser[e2.strictMode ? "strict" : "loose"].exec(t2), r2 = {}, o2 = 14; o2--; )
      r2[i2.key[o2]] = n2[o2] || "";
    return r2[i2.q.name] = {}, r2[i2.key[12]].replace(i2.q.parser, function(t3, e3, n3) {
      e3 && (r2[i2.q.name][e3] = n3);
    }), r2;
  }
  var hc = null;
  function uc() {
  }
  function cc(t2, e2, i2) {
    e2 && e2.indexOf(".") === 0 && (e2 = e2.substring(1)), e2 && (t2[e2] = i2);
  }
  function dc(t2) {
    return t2.toString().replace("object ", "");
  }
  var pc = function() {
    function t2(e2, i2, n2) {
      if (this._dequeue = uc, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof e2 != "string" || typeof i2 != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      n2 = n2 || {}, this._flags = 0, this._setFlag(t2.STATUS_FLAGS.DATA_URL, i2.indexOf("data:") === 0), this.name = e2, this.url = i2, this.extension = this._getExtension(), this.data = null, this.crossOrigin = n2.crossOrigin === true ? "anonymous" : n2.crossOrigin, this.timeout = n2.timeout || 0, this.loadType = n2.loadType || this._determineLoadType(), this.xhrType = n2.xhrType, this.metadata = n2.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t2.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = uc, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new ac(), this.onProgress = new ac(), this.onComplete = new ac(), this.onAfterMiddleware = new ac();
    }
    return t2.setExtensionLoadType = function(e2, i2) {
      cc(t2._loadTypeMap, e2, i2);
    }, t2.setExtensionXhrType = function(e2, i2) {
      cc(t2._xhrTypeMap, e2, i2);
    }, Object.defineProperty(t2.prototype, "isDataUrl", { get: function() {
      return this._hasFlag(t2.STATUS_FLAGS.DATA_URL);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isComplete", { get: function() {
      return this._hasFlag(t2.STATUS_FLAGS.COMPLETE);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isLoading", { get: function() {
      return this._hasFlag(t2.STATUS_FLAGS.LOADING);
    }, enumerable: false, configurable: true }), t2.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, t2.prototype.abort = function(e2) {
      if (!this.error) {
        if (this.error = new Error(e2), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = t2.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, t2.prototype.load = function(e2) {
      var i2 = this;
      if (!this.isLoading)
        if (this.isComplete)
          e2 && setTimeout(function() {
            return e2(i2);
          }, 1);
        else
          switch (e2 && this.onComplete.once(e2), this._setFlag(t2.STATUS_FLAGS.LOADING, true), this.onStart.dispatch(this), this.crossOrigin !== false && typeof this.crossOrigin == "string" || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
            case t2.LOAD_TYPE.IMAGE:
              this.type = t2.TYPE.IMAGE, this._loadElement("image");
              break;
            case t2.LOAD_TYPE.AUDIO:
              this.type = t2.TYPE.AUDIO, this._loadSourceElement("audio");
              break;
            case t2.LOAD_TYPE.VIDEO:
              this.type = t2.TYPE.VIDEO, this._loadSourceElement("video");
              break;
            case t2.LOAD_TYPE.XHR:
            default:
              sc === void 0 && (sc = !(!globalThis.XDomainRequest || "withCredentials" in new XMLHttpRequest())), sc && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          }
    }, t2.prototype._hasFlag = function(t3) {
      return (this._flags & t3) != 0;
    }, t2.prototype._setFlag = function(t3, e2) {
      this._flags = e2 ? this._flags | t3 : this._flags & ~t3;
    }, t2.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, false), this.data.removeEventListener("load", this._boundComplete, false), this.data.removeEventListener("progress", this._boundOnProgress, false), this.data.removeEventListener("canplaythrough", this._boundComplete, false)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, false), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false), this.xhr.removeEventListener("progress", this._boundOnProgress, false), this.xhr.removeEventListener("load", this._boundXhrOnLoad, false)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, t2.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(t2.STATUS_FLAGS.COMPLETE, true), this._setFlag(t2.STATUS_FLAGS.LOADING, false), this.onComplete.dispatch(this);
    }, t2.prototype._loadElement = function(t3) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t3 === "image" && globalThis.Image !== void 0 ? this.data = new Image() : this.data = document.createElement(t3), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, t2.prototype._loadSourceElement = function(t3) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t3 === "audio" && globalThis.Audio !== void 0 ? this.data = new Audio() : this.data = document.createElement(t3), this.data !== null) {
        if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
          if (navigator.isCocoonJS)
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          else if (Array.isArray(this.url))
            for (var e2 = this.metadata.mimeType, i2 = 0; i2 < this.url.length; ++i2)
              this.data.appendChild(this._createSource(t3, this.url[i2], Array.isArray(e2) ? e2[i2] : e2));
          else {
            e2 = this.metadata.mimeType;
            this.data.appendChild(this._createSource(t3, this.url, Array.isArray(e2) ? e2[0] : e2));
          }
        this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.data.addEventListener("canplaythrough", this._boundComplete, false), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
      } else
        this.abort("Unsupported element: " + t3);
    }, t2.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var e2 = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (e2.withCredentials = true), e2.open("GET", this.url, true), e2.timeout = this.timeout, this.xhrType === t2.XHR_RESPONSE_TYPE.JSON || this.xhrType === t2.XHR_RESPONSE_TYPE.DOCUMENT ? e2.responseType = t2.XHR_RESPONSE_TYPE.TEXT : e2.responseType = this.xhrType, e2.addEventListener("error", this._boundXhrOnError, false), e2.addEventListener("timeout", this._boundXhrOnTimeout, false), e2.addEventListener("abort", this._boundXhrOnAbort, false), e2.addEventListener("progress", this._boundOnProgress, false), e2.addEventListener("load", this._boundXhrOnLoad, false), e2.send();
    }, t2.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t3 = this.xhr = new globalThis.XDomainRequest();
      t3.timeout = this.timeout || 5e3, t3.onerror = this._boundXhrOnError, t3.ontimeout = this._boundXhrOnTimeout, t3.onprogress = this._boundOnProgress, t3.onload = this._boundXhrOnLoad, t3.open("GET", this.url, true), setTimeout(function() {
        return t3.send();
      }, 1);
    }, t2.prototype._createSource = function(t3, e2, i2) {
      i2 || (i2 = t3 + "/" + this._getExtension(e2));
      var n2 = document.createElement("source");
      return n2.src = e2, n2.type = i2, n2;
    }, t2.prototype._onError = function(t3) {
      this.abort("Failed to load element using: " + t3.target.nodeName);
    }, t2.prototype._onProgress = function(t3) {
      t3 && t3.lengthComputable && this.onProgress.dispatch(this, t3.loaded / t3.total);
    }, t2.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, t2.prototype._xhrOnError = function() {
      var t3 = this.xhr;
      this.abort(dc(t3) + " Request failed. Status: " + t3.status + ', text: "' + t3.statusText + '"');
    }, t2.prototype._xhrOnTimeout = function() {
      var t3 = this.xhr;
      this.abort(dc(t3) + " Request timed out.");
    }, t2.prototype._xhrOnAbort = function() {
      var t3 = this.xhr;
      this.abort(dc(t3) + " Request was aborted by the user.");
    }, t2.prototype._xhrOnLoad = function() {
      var e2 = this.xhr, i2 = "", n2 = e2.status === void 0 ? 200 : e2.status;
      if (e2.responseType !== "" && e2.responseType !== "text" && e2.responseType !== void 0 || (i2 = e2.responseText), n2 === 0 && (i2.length > 0 || e2.responseType === t2.XHR_RESPONSE_TYPE.BUFFER) ? n2 = 200 : n2 === 1223 && (n2 = 204), (n2 / 100 | 0) === 2) {
        if (this.xhrType === t2.XHR_RESPONSE_TYPE.TEXT)
          this.data = i2, this.type = t2.TYPE.TEXT;
        else if (this.xhrType === t2.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(i2), this.type = t2.TYPE.JSON;
          } catch (t3) {
            return void this.abort("Error trying to parse loaded json: " + t3);
          }
        else if (this.xhrType === t2.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var r2 = new DOMParser();
              this.data = r2.parseFromString(i2, "text/xml");
            } else {
              var o2 = document.createElement("div");
              o2.innerHTML = i2, this.data = o2;
            }
            this.type = t2.TYPE.XML;
          } catch (t3) {
            return void this.abort("Error trying to parse loaded xml: " + t3);
          }
        else
          this.data = e2.response || i2;
        this.complete();
      } else
        this.abort("[" + e2.status + "] " + e2.statusText + ": " + e2.responseURL);
    }, t2.prototype._determineCrossOrigin = function(t3, e2) {
      if (t3.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      e2 = e2 || globalThis.location, hc || (hc = document.createElement("a")), hc.href = t3;
      var i2 = lc(hc.href, { strictMode: true }), n2 = !i2.port && e2.port === "" || i2.port === e2.port, r2 = i2.protocol ? i2.protocol + ":" : "";
      return i2.host === e2.hostname && n2 && r2 === e2.protocol ? "" : "anonymous";
    }, t2.prototype._determineXhrType = function() {
      return t2._xhrTypeMap[this.extension] || t2.XHR_RESPONSE_TYPE.TEXT;
    }, t2.prototype._determineLoadType = function() {
      return t2._loadTypeMap[this.extension] || t2.LOAD_TYPE.XHR;
    }, t2.prototype._getExtension = function(t3) {
      t3 === void 0 && (t3 = this.url);
      var e2 = "";
      if (this.isDataUrl) {
        var i2 = t3.indexOf("/");
        e2 = t3.substring(i2 + 1, t3.indexOf(";", i2));
      } else {
        var n2 = t3.indexOf("?"), r2 = t3.indexOf("#"), o2 = Math.min(n2 > -1 ? n2 : t3.length, r2 > -1 ? r2 : t3.length);
        e2 = (t3 = t3.substring(0, o2)).substring(t3.lastIndexOf(".") + 1);
      }
      return e2.toLowerCase();
    }, t2.prototype._getMimeFromXhrType = function(e2) {
      switch (e2) {
        case t2.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case t2.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case t2.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case t2.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case t2.XHR_RESPONSE_TYPE.DEFAULT:
        case t2.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, t2;
  }();
  function fc() {
  }
  function mc(t2) {
    return function() {
      for (var e2 = arguments, i2 = [], n2 = 0; n2 < arguments.length; n2++)
        i2[n2] = e2[n2];
      if (t2 === null)
        throw new Error("Callback was already called.");
      var r2 = t2;
      t2 = null, r2.apply(this, i2);
    };
  }
  !function(t2) {
    var e2, i2, n2, r2;
    (e2 = t2.STATUS_FLAGS || (t2.STATUS_FLAGS = {}))[e2.NONE = 0] = "NONE", e2[e2.DATA_URL = 1] = "DATA_URL", e2[e2.COMPLETE = 2] = "COMPLETE", e2[e2.LOADING = 4] = "LOADING", (i2 = t2.TYPE || (t2.TYPE = {}))[i2.UNKNOWN = 0] = "UNKNOWN", i2[i2.JSON = 1] = "JSON", i2[i2.XML = 2] = "XML", i2[i2.IMAGE = 3] = "IMAGE", i2[i2.AUDIO = 4] = "AUDIO", i2[i2.VIDEO = 5] = "VIDEO", i2[i2.TEXT = 6] = "TEXT", (n2 = t2.LOAD_TYPE || (t2.LOAD_TYPE = {}))[n2.XHR = 1] = "XHR", n2[n2.IMAGE = 2] = "IMAGE", n2[n2.AUDIO = 3] = "AUDIO", n2[n2.VIDEO = 4] = "VIDEO", (r2 = t2.XHR_RESPONSE_TYPE || (t2.XHR_RESPONSE_TYPE = {})).DEFAULT = "text", r2.BUFFER = "arraybuffer", r2.BLOB = "blob", r2.DOCUMENT = "document", r2.JSON = "json", r2.TEXT = "text", t2._loadTypeMap = { gif: t2.LOAD_TYPE.IMAGE, png: t2.LOAD_TYPE.IMAGE, bmp: t2.LOAD_TYPE.IMAGE, jpg: t2.LOAD_TYPE.IMAGE, jpeg: t2.LOAD_TYPE.IMAGE, tif: t2.LOAD_TYPE.IMAGE, tiff: t2.LOAD_TYPE.IMAGE, webp: t2.LOAD_TYPE.IMAGE, tga: t2.LOAD_TYPE.IMAGE, svg: t2.LOAD_TYPE.IMAGE, "svg+xml": t2.LOAD_TYPE.IMAGE, mp3: t2.LOAD_TYPE.AUDIO, ogg: t2.LOAD_TYPE.AUDIO, wav: t2.LOAD_TYPE.AUDIO, mp4: t2.LOAD_TYPE.VIDEO, webm: t2.LOAD_TYPE.VIDEO }, t2._xhrTypeMap = { xhtml: t2.XHR_RESPONSE_TYPE.DOCUMENT, html: t2.XHR_RESPONSE_TYPE.DOCUMENT, htm: t2.XHR_RESPONSE_TYPE.DOCUMENT, xml: t2.XHR_RESPONSE_TYPE.DOCUMENT, tmx: t2.XHR_RESPONSE_TYPE.DOCUMENT, svg: t2.XHR_RESPONSE_TYPE.DOCUMENT, tsx: t2.XHR_RESPONSE_TYPE.DOCUMENT, gif: t2.XHR_RESPONSE_TYPE.BLOB, png: t2.XHR_RESPONSE_TYPE.BLOB, bmp: t2.XHR_RESPONSE_TYPE.BLOB, jpg: t2.XHR_RESPONSE_TYPE.BLOB, jpeg: t2.XHR_RESPONSE_TYPE.BLOB, tif: t2.XHR_RESPONSE_TYPE.BLOB, tiff: t2.XHR_RESPONSE_TYPE.BLOB, webp: t2.XHR_RESPONSE_TYPE.BLOB, tga: t2.XHR_RESPONSE_TYPE.BLOB, json: t2.XHR_RESPONSE_TYPE.JSON, text: t2.XHR_RESPONSE_TYPE.TEXT, txt: t2.XHR_RESPONSE_TYPE.TEXT, ttf: t2.XHR_RESPONSE_TYPE.BUFFER, otf: t2.XHR_RESPONSE_TYPE.BUFFER }, t2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  }(pc || (pc = {}));
  var gc = function(t2, e2) {
    this.data = t2, this.callback = e2;
  }, vc = function() {
    function t2(t3, e2) {
      var i2 = this;
      if (e2 === void 0 && (e2 = 1), this.workers = 0, this.saturated = fc, this.unsaturated = fc, this.empty = fc, this.drain = fc, this.error = fc, this.started = false, this.paused = false, this._tasks = [], this._insert = function(t4, e3, n2) {
        if (n2 && typeof n2 != "function")
          throw new Error("task callback must be a function");
        if (i2.started = true, t4 == null && i2.idle())
          setTimeout(function() {
            return i2.drain();
          }, 1);
        else {
          var r2 = new gc(t4, typeof n2 == "function" ? n2 : fc);
          e3 ? i2._tasks.unshift(r2) : i2._tasks.push(r2), setTimeout(i2.process, 1);
        }
      }, this.process = function() {
        for (; !i2.paused && i2.workers < i2.concurrency && i2._tasks.length; ) {
          var t4 = i2._tasks.shift();
          i2._tasks.length === 0 && i2.empty(), i2.workers += 1, i2.workers === i2.concurrency && i2.saturated(), i2._worker(t4.data, mc(i2._next(t4)));
        }
      }, this._worker = t3, e2 === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e2, this.buffer = e2 / 4;
    }
    return t2.prototype._next = function(t3) {
      var e2 = this;
      return function() {
        for (var i2 = arguments, n2 = [], r2 = 0; r2 < arguments.length; r2++)
          n2[r2] = i2[r2];
        e2.workers -= 1, t3.callback.apply(t3, n2), n2[0] != null && e2.error(n2[0], t3.data), e2.workers <= e2.concurrency - e2.buffer && e2.unsaturated(), e2.idle() && e2.drain(), e2.process();
      };
    }, t2.prototype.push = function(t3, e2) {
      this._insert(t3, false, e2);
    }, t2.prototype.kill = function() {
      this.workers = 0, this.drain = fc, this.started = false, this._tasks = [];
    }, t2.prototype.unshift = function(t3, e2) {
      this._insert(t3, true, e2);
    }, t2.prototype.length = function() {
      return this._tasks.length;
    }, t2.prototype.running = function() {
      return this.workers;
    }, t2.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, t2.prototype.pause = function() {
      this.paused !== true && (this.paused = true);
    }, t2.prototype.resume = function() {
      if (this.paused !== false) {
        this.paused = false;
        for (var t3 = 1; t3 <= this.concurrency; t3++)
          this.process();
      }
    }, t2.eachSeries = function(t3, e2, i2, n2) {
      var r2 = 0, o2 = t3.length;
      !function s2(a2) {
        a2 || r2 === o2 ? i2 && i2(a2) : n2 ? setTimeout(function() {
          e2(t3[r2++], s2);
        }, 1) : e2(t3[r2++], s2);
      }();
    }, t2.queue = function(e2, i2) {
      return new t2(e2, i2);
    }, t2;
  }(), _c = /(#[\w-]+)?$/, yc = function() {
    function t2(e2, i2) {
      var n2 = this;
      e2 === void 0 && (e2 = ""), i2 === void 0 && (i2 = 10), this.progress = 0, this.loading = false, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t3, e3) {
        return n2._loadResource(t3, e3);
      }, this.resources = {}, this.baseUrl = e2, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t3, e3) {
        return n2._loadResource(t3, e3);
      }, this._queue = vc.queue(this._boundLoadResource, i2), this._queue.pause(), this.resources = {}, this.onProgress = new ac(), this.onError = new ac(), this.onLoad = new ac(), this.onStart = new ac(), this.onComplete = new ac();
      for (var r2 = 0; r2 < t2._plugins.length; ++r2) {
        var o2 = t2._plugins[r2], s2 = o2.pre, a2 = o2.use;
        s2 && this.pre(s2), a2 && this.use(a2);
      }
      this._protected = false;
    }
    return t2.prototype._add = function(t3, e2, i2, n2) {
      if (this.loading && (!i2 || !i2.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t3])
        throw new Error('Resource named "' + t3 + '" already exists.');
      if (e2 = this._prepareUrl(e2), this.resources[t3] = new pc(t3, e2, i2), typeof n2 == "function" && this.resources[t3].onAfterMiddleware.once(n2), this.loading) {
        for (var r2 = i2.parentResource, o2 = [], s2 = 0; s2 < r2.children.length; ++s2)
          r2.children[s2].isComplete || o2.push(r2.children[s2]);
        var a2 = r2.progressChunk * (o2.length + 1) / (o2.length + 2);
        r2.children.push(this.resources[t3]), r2.progressChunk = a2;
        for (s2 = 0; s2 < o2.length; ++s2)
          o2[s2].progressChunk = a2;
        this.resources[t3].progressChunk = a2;
      }
      return this._queue.push(this.resources[t3]), this;
    }, t2.prototype.pre = function(t3) {
      return this._beforeMiddleware.push(t3), this;
    }, t2.prototype.use = function(t3) {
      return this._afterMiddleware.push(t3), this;
    }, t2.prototype.reset = function() {
      for (var t3 in this.progress = 0, this.loading = false, this._queue.kill(), this._queue.pause(), this.resources) {
        var e2 = this.resources[t3];
        e2._onLoadBinding && e2._onLoadBinding.detach(), e2.isLoading && e2.abort("loader reset");
      }
      return this.resources = {}, this;
    }, t2.prototype.load = function(t3) {
      if (typeof t3 == "function" && this.onComplete.once(t3), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e2 = 100 / this._queue._tasks.length, i2 = 0; i2 < this._queue._tasks.length; ++i2)
          this._queue._tasks[i2].data.progressChunk = e2;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(t2.prototype, "concurrency", { get: function() {
      return this._queue.concurrency;
    }, set: function(t3) {
      this._queue.concurrency = t3;
    }, enumerable: false, configurable: true }), t2.prototype._prepareUrl = function(t3) {
      var e2, i2 = lc(t3, { strictMode: true });
      if (e2 = i2.protocol || !i2.path || t3.indexOf("//") === 0 ? t3 : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t3.charAt(0) !== "/" ? this.baseUrl + "/" + t3 : this.baseUrl + t3, this.defaultQueryString) {
        var n2 = _c.exec(e2)[0];
        (e2 = e2.slice(0, e2.length - n2.length)).indexOf("?") !== -1 ? e2 += "&" + this.defaultQueryString : e2 += "?" + this.defaultQueryString, e2 += n2;
      }
      return e2;
    }, t2.prototype._loadResource = function(t3, e2) {
      var i2 = this;
      t3._dequeue = e2, vc.eachSeries(this._beforeMiddleware, function(e3, n2) {
        e3.call(i2, t3, function() {
          n2(t3.isComplete ? {} : null);
        });
      }, function() {
        t3.isComplete ? i2._onLoad(t3) : (t3._onLoadBinding = t3.onComplete.once(i2._onLoad, i2), t3.load());
      }, true);
    }, t2.prototype._onStart = function() {
      this.progress = 0, this.loading = true, this.onStart.dispatch(this);
    }, t2.prototype._onComplete = function() {
      this.progress = 100, this.loading = false, this.onComplete.dispatch(this, this.resources);
    }, t2.prototype._onLoad = function(t3) {
      var e2 = this;
      t3._onLoadBinding = null, this._resourcesParsing.push(t3), t3._dequeue(), vc.eachSeries(this._afterMiddleware, function(i2, n2) {
        i2.call(e2, t3, n2);
      }, function() {
        t3.onAfterMiddleware.dispatch(t3), e2.progress = Math.min(100, e2.progress + t3.progressChunk), e2.onProgress.dispatch(e2, t3), t3.error ? e2.onError.dispatch(t3.error, e2, t3) : e2.onLoad.dispatch(e2, t3), e2._resourcesParsing.splice(e2._resourcesParsing.indexOf(t3), 1), e2._queue.idle() && e2._resourcesParsing.length === 0 && e2._onComplete();
      }, true);
    }, t2.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(t2, "shared", { get: function() {
      var e2 = t2._shared;
      return e2 || ((e2 = new t2())._protected = true, t2._shared = e2), e2;
    }, enumerable: false, configurable: true }), t2.registerPlugin = function(e2) {
      return t2._plugins.push(e2), e2.add && e2.add(), t2;
    }, t2._plugins = [], t2;
  }();
  yc.prototype.add = function(t2, e2, i2, n2) {
    if (Array.isArray(t2)) {
      for (var r2 = 0; r2 < t2.length; ++r2)
        this.add(t2[r2]);
      return this;
    }
    if (typeof t2 == "object" && (i2 = t2, n2 = e2 || i2.callback || i2.onComplete, e2 = i2.url, t2 = i2.name || i2.key || i2.url), typeof e2 != "string" && (n2 = i2, i2 = e2, e2 = t2), typeof e2 != "string")
      throw new Error("No url passed to add resource to loader.");
    return typeof i2 == "function" && (n2 = i2, i2 = null), this._add(t2, e2, i2, n2);
  };
  var xc = function() {
    function t2() {
    }
    return t2.init = function(t3) {
      t3 = Object.assign({ sharedLoader: false }, t3), this.loader = t3.sharedLoader ? yc.shared : new yc();
    }, t2.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, t2;
  }(), bc = function() {
    function t2() {
    }
    return t2.add = function() {
      pc.setExtensionLoadType("svg", pc.LOAD_TYPE.XHR), pc.setExtensionXhrType("svg", pc.XHR_RESPONSE_TYPE.TEXT);
    }, t2.use = function(t3, e2) {
      if (!t3.data || t3.type !== pc.TYPE.IMAGE && t3.extension !== "svg")
        e2();
      else {
        var i2 = t3.data, n2 = t3.url, r2 = t3.name, o2 = t3.metadata;
        Vh.t.fromLoader(i2, n2, r2, o2).then(function(i3) {
          t3.texture = i3, e2();
        }).catch(e2);
      }
    }, t2;
  }();
  yc.registerPlugin({ use: function(t2, e2) {
    if (t2.data) {
      if (t2.xhr && t2.xhrType === pc.XHR_RESPONSE_TYPE.BLOB)
        if (self.Blob && typeof t2.data != "string") {
          if (t2.data.type.indexOf("image") === 0) {
            var i2 = globalThis.URL || globalThis.webkitURL, n2 = i2.createObjectURL(t2.data);
            return t2.blob = t2.data, t2.data = new Image(), t2.data.src = n2, t2.type = pc.TYPE.IMAGE, void (t2.data.onload = function() {
              i2.revokeObjectURL(n2), t2.data.onload = null, e2();
            });
          }
        } else {
          var r2 = t2.xhr.getResponseHeader("content-type");
          if (r2 && r2.indexOf("image") === 0)
            return t2.data = new Image(), t2.data.src = "data:" + r2 + ";base64," + function(t3) {
              for (var e3 = "", i3 = 0; i3 < t3.length; ) {
                for (var n3 = [0, 0, 0], r3 = [0, 0, 0, 0], o2 = 0; o2 < n3.length; ++o2)
                  i3 < t3.length ? n3[o2] = 255 & t3.charCodeAt(i3++) : n3[o2] = 0;
                switch (r3[0] = n3[0] >> 2, r3[1] = (3 & n3[0]) << 4 | n3[1] >> 4, r3[2] = (15 & n3[1]) << 2 | n3[2] >> 6, r3[3] = 63 & n3[2], i3 - (t3.length - 1)) {
                  case 2:
                    r3[3] = 64, r3[2] = 64;
                    break;
                  case 1:
                    r3[3] = 64;
                }
                for (o2 = 0; o2 < r3.length; ++o2)
                  e3 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(r3[o2]);
              }
              return e3;
            }(t2.xhr.responseText), t2.type = pc.TYPE.IMAGE, void (t2.data.onload = function() {
              t2.data.onload = null, e2();
            });
        }
      e2();
    } else
      e2();
  } }), yc.registerPlugin(bc);
  var Tc, Ec, Sc = i(0);
  /*!
   * @pixi/compressed-textures - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/compressed-textures is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  !function(t2) {
    t2[t2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t2[t2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t2[t2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t2[t2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t2[t2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t2[t2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t2[t2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t2[t2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t2[t2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", t2[t2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t2[t2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t2[t2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t2[t2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t2[t2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t2[t2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t2[t2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t2[t2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t2[t2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t2[t2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t2[t2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  }(Ec || (Ec = {}));
  var wc = ((Tc = {})[Ec.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, Tc[Ec.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, Tc[Ec.COMPRESSED_R11_EAC] = 0.5, Tc[Ec.COMPRESSED_SIGNED_R11_EAC] = 0.5, Tc[Ec.COMPRESSED_RG11_EAC] = 1, Tc[Ec.COMPRESSED_SIGNED_RG11_EAC] = 1, Tc[Ec.COMPRESSED_RGB8_ETC2] = 0.5, Tc[Ec.COMPRESSED_RGBA8_ETC2_EAC] = 1, Tc[Ec.COMPRESSED_SRGB8_ETC2] = 0.5, Tc[Ec.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Tc[Ec.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Tc[Ec.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Tc[Ec.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, Tc[Ec.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, Tc[Ec.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, Tc[Ec.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, Tc[Ec.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, Tc[Ec.COMPRESSED_RGB_ATC_WEBGL] = 0.5, Tc[Ec.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Tc[Ec.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, Tc), Ac = function(t2, e2) {
    return (Ac = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function Mc(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    Ac(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  function Rc(t2, e2) {
    var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
      if (1 & r2[0])
        throw r2[1];
      return r2[1];
    }, trys: [], ops: [] };
    return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function a2(o3) {
      return function(a3) {
        return function(o4) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s2; )
            try {
              if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done)
                return r2;
              switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                case 0:
                case 1:
                  r2 = o4;
                  break;
                case 4:
                  return s2.label++, { value: o4[1], done: false };
                case 5:
                  s2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = s2.ops.pop(), s2.trys.pop();
                  continue;
                default:
                  if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                    s2 = 0;
                    continue;
                  }
                  if (o4[0] === 3 && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                    s2.label = o4[1];
                    break;
                  }
                  if (o4[0] === 6 && s2.label < r2[1]) {
                    s2.label = r2[1], r2 = o4;
                    break;
                  }
                  if (r2 && s2.label < r2[2]) {
                    s2.label = r2[2], s2.ops.push(o4);
                    break;
                  }
                  r2[2] && s2.ops.pop(), s2.trys.pop();
                  continue;
              }
              o4 = e2.call(t2, s2);
            } catch (t3) {
              o4 = [6, t3], n2 = 0;
            } finally {
              i2 = r2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, a3]);
      };
    }
  }
  var Cc, Ic, Pc = function(t2) {
    function e2(i2, n2) {
      var r2 = t2.call(this, i2, n2) || this;
      return r2.format = n2.format, r2.levels = n2.levels || 1, r2._width = n2.width, r2._height = n2.height, r2._extension = e2._formatToExtension(r2.format), (n2.levelBuffers || r2.buffer) && (r2._levelBuffers = n2.levelBuffers || e2._createLevelBuffers(i2 instanceof Uint8Array ? i2 : r2.buffer.uint8View, r2.format, r2.levels, 4, 4, r2.width, r2.height)), r2;
    }
    return Mc(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
      var n2 = t3.gl;
      if (!t3.context.extensions[this._extension])
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return false;
      for (var r2 = 0, o2 = this.levels; r2 < o2; r2++) {
        var s2 = this._levelBuffers[r2], a2 = s2.levelID, l2 = s2.levelWidth, h2 = s2.levelHeight, u2 = s2.levelBuffer;
        n2.compressedTexImage2D(n2.TEXTURE_2D, a2, this.format, l2, h2, 0, u2);
      }
      return true;
    }, e2.prototype.onBlobLoaded = function() {
      this._levelBuffers = e2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }, e2._formatToExtension = function(t3) {
      if (t3 >= 33776 && t3 <= 33779)
        return "s3tc";
      if (t3 >= 37488 && t3 <= 37497)
        return "etc";
      if (t3 >= 35840 && t3 <= 35843)
        return "pvrtc";
      if (t3 >= 36196)
        return "etc1";
      if (t3 >= 35986 && t3 <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, e2._createLevelBuffers = function(t3, e3, i2, n2, r2, o2, s2) {
      for (var a2 = new Array(i2), l2 = t3.byteOffset, h2 = o2, u2 = s2, c2 = h2 + n2 - 1 & ~(n2 - 1), d2 = u2 + r2 - 1 & ~(r2 - 1), p2 = c2 * d2 * wc[e3], f2 = 0; f2 < i2; f2++)
        a2[f2] = { levelID: f2, levelWidth: i2 > 1 ? h2 : c2, levelHeight: i2 > 1 ? u2 : d2, levelBuffer: new Uint8Array(t3.buffer, l2, p2) }, l2 += p2, p2 = (c2 = (h2 = h2 >> 1 || 1) + n2 - 1 & ~(n2 - 1)) * (d2 = (u2 = u2 >> 1 || 1) + r2 - 1 & ~(r2 - 1)) * wc[e3];
      return a2;
    }, e2;
  }(function(t2) {
    function e2(e3, i2) {
      i2 === void 0 && (i2 = { width: 1, height: 1, autoLoad: true });
      var n2, r2, o2 = this;
      return typeof e3 == "string" ? (n2 = e3, r2 = new Uint8Array()) : (n2 = null, r2 = e3), (o2 = t2.call(this, r2, i2) || this).origin = n2, o2.buffer = r2 ? new Vh.x(r2) : null, o2.origin && i2.autoLoad !== false && o2.load(), r2 && r2.length && (o2.loaded = true, o2.onBlobLoaded(o2.buffer.rawBinaryData)), o2;
    }
    return Mc(e2, t2), e2.prototype.onBlobLoaded = function(t3) {
    }, e2.prototype.load = function() {
      return t3 = this, e3 = void 0, n2 = function() {
        var t4;
        return Rc(this, function(e4) {
          switch (e4.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return [4, e4.sent().blob()];
            case 2:
              return [4, e4.sent().arrayBuffer()];
            case 3:
              return t4 = e4.sent(), this.data = new Uint32Array(t4), this.buffer = new Vh.x(t4), this.loaded = true, this.onBlobLoaded(t4), this.update(), [2, this];
          }
        });
      }, new ((i2 = Promise) || (i2 = Promise))(function(r2, o2) {
        function s2(t4) {
          try {
            l2(n2.next(t4));
          } catch (t5) {
            o2(t5);
          }
        }
        function a2(t4) {
          try {
            l2(n2.throw(t4));
          } catch (t5) {
            o2(t5);
          }
        }
        function l2(t4) {
          t4.done ? r2(t4.value) : new i2(function(e4) {
            e4(t4.value);
          }).then(s2, a2);
        }
        l2((n2 = n2.apply(t3, e3 || [])).next());
      });
      var t3, e3, i2, n2;
    }, e2;
  }(Vh.i)), Oc = function() {
    function t2() {
    }
    return t2.use = function(e2, i2) {
      var n2 = e2.data;
      if (e2.type === pc.TYPE.JSON && n2 && n2.cacheID && n2.textures) {
        for (var r2 = n2.textures, o2 = void 0, s2 = void 0, a2 = 0, l2 = r2.length; a2 < l2; a2++) {
          var h2 = r2[a2], u2 = h2.src, c2 = h2.format;
          if (c2 || (s2 = u2), t2.textureFormats[c2]) {
            o2 = u2;
            break;
          }
        }
        if (!(o2 = o2 || s2))
          return void i2(new Error("Cannot load compressed-textures in " + e2.url + ", make sure you provide a fallback"));
        if (o2 === e2.url)
          return void i2(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        var d2 = { crossOrigin: e2.crossOrigin, metadata: e2.metadata.imageMetadata, parentResource: e2 }, p2 = Ph.url.resolve(e2.url.replace(this.baseUrl, ""), o2), f2 = n2.cacheID;
        this.add(f2, p2, d2, function(t3) {
          if (t3.error)
            i2(t3.error);
          else {
            var n3 = t3.texture, r3 = n3 === void 0 ? null : n3, o3 = t3.textures, s3 = o3 === void 0 ? {} : o3;
            Object.assign(e2, { texture: r3, textures: s3 }), i2();
          }
        });
      } else
        i2();
    }, Object.defineProperty(t2, "textureExtensions", { get: function() {
      if (!t2._textureExtensions) {
        var e2 = document.createElement("canvas").getContext("webgl");
        if (!e2)
          return console.warn("WebGL not available for compressed textures. Silently failing."), {};
        var i2 = { s3tc: e2.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: e2.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: e2.getExtension("WEBGL_compressed_texture_etc"), etc1: e2.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: e2.getExtension("WEBGL_compressed_texture_atc"), astc: e2.getExtension("WEBGL_compressed_texture_astc") };
        t2._textureExtensions = i2;
      }
      return t2._textureExtensions;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "textureFormats", { get: function() {
      if (!t2._textureFormats) {
        var e2 = t2.textureExtensions;
        for (var i2 in t2._textureFormats = {}, e2) {
          var n2 = e2[i2];
          n2 && Object.assign(t2._textureFormats, Object.getPrototypeOf(n2));
        }
      }
      return t2._textureFormats;
    }, enumerable: false, configurable: true }), t2;
  }();
  function Nc(t2, e2, i2) {
    var n2 = { textures: {}, texture: null };
    return e2 ? (e2.map(function(t3) {
      return new Vh.t(new Vh.c(t3, Object.assign({ mipmap: Sc.k.OFF, alphaMode: Sc.a.NO_PREMULTIPLIED_ALPHA }, i2)));
    }).forEach(function(e3, i3) {
      var r2 = e3.baseTexture, o2 = t2 + "-" + (i3 + 1);
      Vh.c.addToCache(r2, o2), Vh.t.addToCache(e3, o2), i3 === 0 && (Vh.c.addToCache(r2, t2), Vh.t.addToCache(e3, t2), n2.texture = e3), n2.textures[o2] = e3;
    }), n2) : n2;
  }
  pc.setExtensionXhrType("dds", pc.XHR_RESPONSE_TYPE.BUFFER);
  var Lc, Dc, Fc = 3, Bc = 4, Uc = 7, kc = 19, Gc = 2, Hc = 0, jc = 1, zc = 2, Vc = 3;
  !function(t2) {
    t2[t2.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", t2[t2.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", t2[t2.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", t2[t2.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", t2[t2.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", t2[t2.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", t2[t2.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", t2[t2.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", t2[t2.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", t2[t2.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", t2[t2.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", t2[t2.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", t2[t2.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", t2[t2.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", t2[t2.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", t2[t2.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", t2[t2.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", t2[t2.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", t2[t2.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", t2[t2.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", t2[t2.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", t2[t2.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", t2[t2.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", t2[t2.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", t2[t2.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", t2[t2.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", t2[t2.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", t2[t2.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", t2[t2.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", t2[t2.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", t2[t2.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", t2[t2.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", t2[t2.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", t2[t2.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", t2[t2.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", t2[t2.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", t2[t2.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", t2[t2.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", t2[t2.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", t2[t2.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", t2[t2.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", t2[t2.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", t2[t2.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", t2[t2.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", t2[t2.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", t2[t2.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", t2[t2.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", t2[t2.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", t2[t2.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", t2[t2.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", t2[t2.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", t2[t2.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", t2[t2.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", t2[t2.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", t2[t2.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", t2[t2.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", t2[t2.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", t2[t2.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", t2[t2.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", t2[t2.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", t2[t2.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", t2[t2.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", t2[t2.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", t2[t2.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", t2[t2.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", t2[t2.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", t2[t2.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", t2[t2.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", t2[t2.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", t2[t2.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", t2[t2.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", t2[t2.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", t2[t2.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", t2[t2.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", t2[t2.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", t2[t2.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", t2[t2.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", t2[t2.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", t2[t2.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", t2[t2.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", t2[t2.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", t2[t2.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", t2[t2.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", t2[t2.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", t2[t2.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", t2[t2.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", t2[t2.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", t2[t2.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", t2[t2.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", t2[t2.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", t2[t2.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", t2[t2.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", t2[t2.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", t2[t2.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", t2[t2.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", t2[t2.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", t2[t2.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", t2[t2.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", t2[t2.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", t2[t2.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", t2[t2.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", t2[t2.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", t2[t2.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", t2[t2.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", t2[t2.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", t2[t2.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", t2[t2.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", t2[t2.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", t2[t2.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", t2[t2.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", t2[t2.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", t2[t2.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", t2[t2.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", t2[t2.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", t2[t2.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
  }(Lc || (Lc = {})), function(t2) {
    t2[t2.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", t2[t2.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", t2[t2.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
  }(Dc || (Dc = {}));
  var Xc, Wc, Yc, qc = ((Cc = {})[827611204] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Cc[861165636] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Cc[894720068] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Cc), Zc = ((Ic = {})[Lc.DXGI_FORMAT_BC1_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC1_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC2_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC2_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC3_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ic[Lc.DXGI_FORMAT_BC3_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ic[Lc.DXGI_FORMAT_BC1_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC2_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC3_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, Ic), Jc = function() {
    function t2() {
    }
    return t2.use = function(e2, i2) {
      if (e2.extension === "dds" && e2.data)
        try {
          Object.assign(e2, Nc(e2.name || e2.url, t2.parse(e2.data), e2.metadata));
        } catch (t3) {
          return void i2(t3);
        }
      i2();
    }, t2.parse = function(t3) {
      var e2 = new Uint32Array(t3);
      if (e2[0] !== 542327876)
        throw new Error("Invalid DDS file magic word");
      var i2 = new Uint32Array(t3, 0, 124 / Uint32Array.BYTES_PER_ELEMENT), n2 = i2[Fc], r2 = i2[Bc], o2 = i2[Uc], s2 = new Uint32Array(t3, kc * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT), a2 = s2[1];
      if (4 & a2) {
        var l2 = s2[Gc];
        if (l2 !== 808540228) {
          var h2 = qc[l2], u2 = new Uint8Array(t3, 128);
          return [new Pc(u2, { format: h2, width: r2, height: n2, levels: o2 })];
        }
        var c2 = new Uint32Array(e2.buffer, 128, 20 / Uint32Array.BYTES_PER_ELEMENT), d2 = c2[Hc], p2 = c2[jc], f2 = c2[zc], m2 = c2[Vc], g2 = Zc[d2];
        if (g2 === void 0)
          throw new Error("DDSLoader cannot parse texture data with DXGI format " + d2);
        if (f2 === 4)
          throw new Error("DDSLoader does not support cubemap textures");
        if (p2 === Dc.DDS_DIMENSION_TEXTURE3D)
          throw new Error("DDSLoader does not supported 3D texture data");
        var v2 = new Array();
        if (m2 === 1)
          v2.push(new Uint8Array(t3, 148));
        else {
          for (var _2 = wc[g2], y2 = 0, x2 = r2, b2 = n2, T2 = 0; T2 < o2; T2++) {
            y2 += Math.max(1, x2 + 3 & -4) * Math.max(1, b2 + 3 & -4) * _2, x2 >>>= 1, b2 >>>= 1;
          }
          var E2 = 148;
          for (T2 = 0; T2 < m2; T2++)
            v2.push(new Uint8Array(t3, E2, y2)), E2 += y2;
        }
        return v2.map(function(t4) {
          return new Pc(t4, { format: g2, width: r2, height: n2, levels: o2 });
        });
      }
      if (64 & a2)
        throw new Error("DDSLoader does not support uncompressed texture data.");
      if (512 & a2)
        throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
      if (131072 & a2)
        throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
      if (2 & a2)
        throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
      throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
    }, t2;
  }();
  pc.setExtensionXhrType("ktx", pc.XHR_RESPONSE_TYPE.BUFFER);
  var Kc = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], Qc = 12, $c = 16, td = 24, ed = 28, id = 36, nd = 40, rd = 44, od = 48, sd = 52, ad = 56, ld = 60, hd = ((Xc = {})[Sc.r.UNSIGNED_BYTE] = 1, Xc[Sc.r.UNSIGNED_SHORT] = 2, Xc[Sc.r.INT] = 4, Xc[Sc.r.UNSIGNED_INT] = 4, Xc[Sc.r.FLOAT] = 4, Xc[Sc.r.HALF_FLOAT] = 8, Xc), ud = ((Wc = {})[Sc.h.RGBA] = 4, Wc[Sc.h.RGB] = 3, Wc[Sc.h.RG] = 2, Wc[Sc.h.RED] = 1, Wc[Sc.h.LUMINANCE] = 1, Wc[Sc.h.LUMINANCE_ALPHA] = 2, Wc[Sc.h.ALPHA] = 1, Wc), cd = ((Yc = {})[Sc.r.UNSIGNED_SHORT_4_4_4_4] = 2, Yc[Sc.r.UNSIGNED_SHORT_5_5_5_1] = 2, Yc[Sc.r.UNSIGNED_SHORT_5_6_5] = 2, Yc), dd = function() {
    function t2() {
    }
    return t2.use = function(e2, i2) {
      if (e2.extension === "ktx" && e2.data)
        try {
          var n2 = e2.name || e2.url, r2 = t2.parse(n2, e2.data), o2 = r2.compressed, s2 = r2.uncompressed, a2 = r2.kvData;
          if (o2) {
            var l2 = Nc(n2, o2, e2.metadata);
            if (a2 && l2.textures)
              for (var h2 in l2.textures)
                l2.textures[h2].baseTexture.ktxKeyValueData = a2;
            Object.assign(e2, l2);
          } else if (s2) {
            var u2 = {};
            s2.forEach(function(t3, e3) {
              var i3 = new Vh.t(new Vh.c(t3.resource, { mipmap: Sc.k.OFF, alphaMode: Sc.a.NO_PREMULTIPLIED_ALPHA, type: t3.type, format: t3.format })), r3 = n2 + "-" + (e3 + 1);
              a2 && (i3.baseTexture.ktxKeyValueData = a2), Vh.c.addToCache(i3.baseTexture, r3), Vh.t.addToCache(i3, r3), e3 === 0 && (u2[n2] = i3, Vh.c.addToCache(i3.baseTexture, n2), Vh.t.addToCache(i3, n2)), u2[r3] = i3;
            }), Object.assign(e2, { textures: u2 });
          }
        } catch (t3) {
          return void i2(t3);
        }
      i2();
    }, t2.parse = function(e2, i2) {
      var n2 = new DataView(i2);
      if (!t2.validate(e2, n2))
        return null;
      var r2 = n2.getUint32(Qc, true) === 67305985, o2 = n2.getUint32($c, r2), s2 = n2.getUint32(td, r2), a2 = n2.getUint32(ed, r2), l2 = n2.getUint32(id, r2), h2 = n2.getUint32(nd, r2) || 1, u2 = n2.getUint32(rd, r2) || 1, c2 = n2.getUint32(od, r2) || 1, d2 = n2.getUint32(sd, r2), p2 = n2.getUint32(ad, r2), f2 = n2.getUint32(ld, r2);
      if (h2 === 0 || u2 !== 1)
        throw new Error("Only 2D textures are supported");
      if (d2 !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
      if (c2 !== 1)
        throw new Error("WebGL does not support array textures");
      var m2, g2 = l2 + 3 & -4, v2 = h2 + 3 & -4, _2 = new Array(c2), y2 = l2 * h2;
      if (o2 === 0 && (y2 = g2 * v2), (m2 = o2 !== 0 ? hd[o2] ? hd[o2] * ud[s2] : cd[o2] : wc[a2]) === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
      for (var x2 = t2.loadKeyValueData ? t2.parseKvData(n2, f2, r2) : null, b2 = y2 * m2, T2 = l2, E2 = h2, S2 = g2, w2 = v2, A2 = 64 + f2, M2 = 0; M2 < p2; M2++) {
        for (var R2 = n2.getUint32(A2, r2), C2 = A2 + 4, I2 = 0; I2 < c2; I2++) {
          var P2 = _2[I2];
          P2 || (P2 = _2[I2] = new Array(p2)), P2[M2] = { levelID: M2, levelWidth: p2 > 1 || o2 !== 0 ? T2 : S2, levelHeight: p2 > 1 || o2 !== 0 ? E2 : w2, levelBuffer: new Uint8Array(i2, C2, b2) }, C2 += b2;
        }
        A2 = (A2 += R2 + 4) % 4 != 0 ? A2 + 4 - A2 % 4 : A2, b2 = (S2 = (T2 = T2 >> 1 || 1) + 4 - 1 & -4) * (w2 = (E2 = E2 >> 1 || 1) + 4 - 1 & -4) * m2;
      }
      return o2 !== 0 ? { uncompressed: _2.map(function(e3) {
        var i3 = e3[0].levelBuffer, n3 = false;
        return o2 === Sc.r.FLOAT ? i3 = new Float32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4) : o2 === Sc.r.UNSIGNED_INT ? (n3 = true, i3 = new Uint32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4)) : o2 === Sc.r.INT && (n3 = true, i3 = new Int32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4)), { resource: new Vh.i(i3, { width: e3[0].levelWidth, height: e3[0].levelHeight }), type: o2, format: n3 ? t2.convertFormatToInteger(s2) : s2 };
      }), kvData: x2 } : { compressed: _2.map(function(t3) {
        return new Pc(null, { format: a2, width: l2, height: h2, levels: p2, levelBuffers: t3 });
      }), kvData: x2 };
    }, t2.validate = function(t3, e2) {
      for (var i2 = 0; i2 < Kc.length; i2++)
        if (e2.getUint8(i2) !== Kc[i2])
          return console.error(t3 + " is not a valid *.ktx file!"), false;
      return true;
    }, t2.convertFormatToInteger = function(t3) {
      switch (t3) {
        case Sc.h.RGBA:
          return Sc.h.RGBA_INTEGER;
        case Sc.h.RGB:
          return Sc.h.RGB_INTEGER;
        case Sc.h.RG:
          return Sc.h.RG_INTEGER;
        case Sc.h.RED:
          return Sc.h.RED_INTEGER;
        default:
          return t3;
      }
    }, t2.parseKvData = function(t3, e2, i2) {
      for (var n2 = /* @__PURE__ */ new Map(), r2 = 0; r2 < e2; ) {
        var o2 = t3.getUint32(64 + r2, i2), s2 = 64 + r2 + 4, a2 = 3 - (o2 + 3) % 4;
        if (o2 === 0 || o2 > e2 - r2) {
          console.error("KTXLoader: keyAndValueByteSize out of bounds");
          break;
        }
        for (var l2 = 0; l2 < o2 && t3.getUint8(s2 + l2) !== 0; l2++)
          ;
        if (l2 === -1) {
          console.error("KTXLoader: Failed to find null byte terminating kvData key");
          break;
        }
        var h2 = new TextDecoder().decode(new Uint8Array(t3.buffer, s2, l2)), u2 = new DataView(t3.buffer, s2 + l2 + 1, o2 - l2 - 1);
        n2.set(h2, u2), r2 += 4 + o2 + a2;
      }
      return n2;
    }, t2.loadKeyValueData = false, t2;
  }(), pd = function(t2, e2) {
    return (pd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function fd(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    pd(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var md, gd, vd = function(t2) {
    function e2(e3, i2, n2, r2) {
      e3 === void 0 && (e3 = 1500), n2 === void 0 && (n2 = 16384), r2 === void 0 && (r2 = false);
      var o2 = t2.call(this) || this;
      return n2 > 16384 && (n2 = 16384), o2._properties = [false, true, false, false, false], o2._maxSize = e3, o2._batchSize = n2, o2._buffers = null, o2._bufferUpdateIDs = [], o2._updateID = 0, o2.interactiveChildren = false, o2.blendMode = Sc.b.NORMAL, o2.autoResize = r2, o2.roundPixels = true, o2.baseTexture = null, o2.setProperties(i2), o2._tint = 0, o2.tintRgb = new Float32Array(4), o2.tint = 16777215, o2;
    }
    return fd(e2, t2), e2.prototype.setProperties = function(t3) {
      t3 && (this._properties[0] = "vertices" in t3 || "scale" in t3 ? !!t3.vertices || !!t3.scale : this._properties[0], this._properties[1] = "position" in t3 ? !!t3.position : this._properties[1], this._properties[2] = "rotation" in t3 ? !!t3.rotation : this._properties[2], this._properties[3] = "uvs" in t3 ? !!t3.uvs : this._properties[3], this._properties[4] = "tint" in t3 || "alpha" in t3 ? !!t3.tint || !!t3.alpha : this._properties[4]);
    }, e2.prototype.updateTransform = function() {
      this.displayObjectUpdateTransform();
    }, Object.defineProperty(e2.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t3) {
      this._tint = t3, Object(Ph.hex2rgb)(t3, this.tintRgb);
    }, enumerable: false, configurable: true }), e2.prototype.render = function(t3) {
      var e3 = this;
      this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
        return e3.onChildrenChange(0);
      })), t3.batch.setObjectRenderer(t3.plugins.particle), t3.plugins.particle.render(this));
    }, e2.prototype.onChildrenChange = function(t3) {
      for (var e3 = Math.floor(t3 / this._batchSize); this._bufferUpdateIDs.length < e3; )
        this._bufferUpdateIDs.push(0);
      this._bufferUpdateIDs[e3] = ++this._updateID;
    }, e2.prototype.dispose = function() {
      if (this._buffers) {
        for (var t3 = 0; t3 < this._buffers.length; ++t3)
          this._buffers[t3].destroy();
        this._buffers = null;
      }
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this, e3), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
    }, e2;
  }(Oh.b), _d = function() {
    function t2(t3, e2, i2) {
      this.geometry = new Vh.l(), this.indexBuffer = null, this.size = i2, this.dynamicProperties = [], this.staticProperties = [];
      for (var n2 = 0; n2 < t3.length; ++n2) {
        var r2 = t3[n2];
        r2 = { attributeName: r2.attributeName, size: r2.size, uploadFunction: r2.uploadFunction, type: r2.type || Sc.r.FLOAT, offset: r2.offset }, e2[n2] ? this.dynamicProperties.push(r2) : this.staticProperties.push(r2);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return t2.prototype.initBuffers = function() {
      var t3 = this.geometry, e2 = 0;
      this.indexBuffer = new Vh.h(Object(Ph.createIndicesForQuads)(this.size), true, true), t3.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
        (s2 = this.dynamicProperties[i2]).offset = e2, e2 += s2.size, this.dynamicStride += s2.size;
      }
      var n2 = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(n2), this.dynamicDataUint32 = new Uint32Array(n2), this.dynamicBuffer = new Vh.h(this.dynamicData, false, false);
      var r2 = 0;
      this.staticStride = 0;
      for (i2 = 0; i2 < this.staticProperties.length; ++i2) {
        (s2 = this.staticProperties[i2]).offset = r2, r2 += s2.size, this.staticStride += s2.size;
      }
      var o2 = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(o2), this.staticDataUint32 = new Uint32Array(o2), this.staticBuffer = new Vh.h(this.staticData, true, false);
      for (i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
        var s2 = this.dynamicProperties[i2];
        t3.addAttribute(s2.attributeName, this.dynamicBuffer, 0, s2.type === Sc.r.UNSIGNED_BYTE, s2.type, 4 * this.dynamicStride, 4 * s2.offset);
      }
      for (i2 = 0; i2 < this.staticProperties.length; ++i2) {
        s2 = this.staticProperties[i2];
        t3.addAttribute(s2.attributeName, this.staticBuffer, 0, s2.type === Sc.r.UNSIGNED_BYTE, s2.type, 4 * this.staticStride, 4 * s2.offset);
      }
    }, t2.prototype.uploadDynamic = function(t3, e2, i2) {
      for (var n2 = 0; n2 < this.dynamicProperties.length; n2++) {
        var r2 = this.dynamicProperties[n2];
        r2.uploadFunction(t3, e2, i2, r2.type === Sc.r.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r2.offset);
      }
      this.dynamicBuffer._updateID++;
    }, t2.prototype.uploadStatic = function(t3, e2, i2) {
      for (var n2 = 0; n2 < this.staticProperties.length; n2++) {
        var r2 = this.staticProperties[n2];
        r2.uploadFunction(t3, e2, i2, r2.type === Sc.r.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r2.offset);
      }
      this.staticBuffer._updateID++;
    }, t2.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, t2;
  }(), yd = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.shader = null, i2.properties = null, i2.tempMatrix = new Lh.d(), i2.properties = [{ attributeName: "aVertexPosition", size: 2, uploadFunction: i2.uploadVertices, offset: 0 }, { attributeName: "aPositionCoord", size: 2, uploadFunction: i2.uploadPosition, offset: 0 }, { attributeName: "aRotation", size: 1, uploadFunction: i2.uploadRotation, offset: 0 }, { attributeName: "aTextureCoord", size: 2, uploadFunction: i2.uploadUvs, offset: 0 }, { attributeName: "aColor", size: 1, type: Sc.r.UNSIGNED_BYTE, uploadFunction: i2.uploadTint, offset: 0 }], i2.shader = Vh.r.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), i2.state = Vh.s.for2d(), i2;
    }
    return fd(e2, t2), e2.prototype.render = function(t3) {
      var e3 = t3.children, i2 = t3._maxSize, n2 = t3._batchSize, r2 = this.renderer, o2 = e3.length;
      if (o2 !== 0) {
        o2 > i2 && !t3.autoResize && (o2 = i2);
        var s2 = t3._buffers;
        s2 || (s2 = t3._buffers = this.generateBuffers(t3));
        var a2 = e3[0]._texture.baseTexture;
        this.state.blendMode = Object(Ph.correctBlendMode)(t3.blendMode, a2.alphaMode), r2.state.set(this.state);
        var l2 = r2.gl, h2 = t3.worldTransform.copyTo(this.tempMatrix);
        h2.prepend(r2.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = h2.toArray(true), this.shader.uniforms.uColor = Object(Ph.premultiplyRgba)(t3.tintRgb, t3.worldAlpha, this.shader.uniforms.uColor, a2.alphaMode), this.shader.uniforms.uSampler = a2, this.renderer.shader.bind(this.shader);
        for (var u2 = false, c2 = 0, d2 = 0; c2 < o2; c2 += n2, d2 += 1) {
          var p2 = o2 - c2;
          p2 > n2 && (p2 = n2), d2 >= s2.length && s2.push(this._generateOneMoreBuffer(t3));
          var f2 = s2[d2];
          f2.uploadDynamic(e3, c2, p2);
          var m2 = t3._bufferUpdateIDs[d2] || 0;
          (u2 = u2 || f2._updateID < m2) && (f2._updateID = t3._updateID, f2.uploadStatic(e3, c2, p2)), r2.geometry.bind(f2.geometry), l2.drawElements(l2.TRIANGLES, 6 * p2, l2.UNSIGNED_SHORT, 0);
        }
      }
    }, e2.prototype.generateBuffers = function(t3) {
      for (var e3 = [], i2 = t3._maxSize, n2 = t3._batchSize, r2 = t3._properties, o2 = 0; o2 < i2; o2 += n2)
        e3.push(new _d(this.properties, r2, n2));
      return e3;
    }, e2.prototype._generateOneMoreBuffer = function(t3) {
      var e3 = t3._batchSize, i2 = t3._properties;
      return new _d(this.properties, i2, e3);
    }, e2.prototype.uploadVertices = function(t3, e3, i2, n2, r2, o2) {
      for (var s2 = 0, a2 = 0, l2 = 0, h2 = 0, u2 = 0; u2 < i2; ++u2) {
        var c2 = t3[e3 + u2], d2 = c2._texture, p2 = c2.scale.x, f2 = c2.scale.y, m2 = d2.trim, g2 = d2.orig;
        m2 ? (s2 = (a2 = m2.x - c2.anchor.x * g2.width) + m2.width, l2 = (h2 = m2.y - c2.anchor.y * g2.height) + m2.height) : (s2 = g2.width * (1 - c2.anchor.x), a2 = g2.width * -c2.anchor.x, l2 = g2.height * (1 - c2.anchor.y), h2 = g2.height * -c2.anchor.y), n2[o2] = a2 * p2, n2[o2 + 1] = h2 * f2, n2[o2 + r2] = s2 * p2, n2[o2 + r2 + 1] = h2 * f2, n2[o2 + 2 * r2] = s2 * p2, n2[o2 + 2 * r2 + 1] = l2 * f2, n2[o2 + 3 * r2] = a2 * p2, n2[o2 + 3 * r2 + 1] = l2 * f2, o2 += 4 * r2;
      }
    }, e2.prototype.uploadPosition = function(t3, e3, i2, n2, r2, o2) {
      for (var s2 = 0; s2 < i2; s2++) {
        var a2 = t3[e3 + s2].position;
        n2[o2] = a2.x, n2[o2 + 1] = a2.y, n2[o2 + r2] = a2.x, n2[o2 + r2 + 1] = a2.y, n2[o2 + 2 * r2] = a2.x, n2[o2 + 2 * r2 + 1] = a2.y, n2[o2 + 3 * r2] = a2.x, n2[o2 + 3 * r2 + 1] = a2.y, o2 += 4 * r2;
      }
    }, e2.prototype.uploadRotation = function(t3, e3, i2, n2, r2, o2) {
      for (var s2 = 0; s2 < i2; s2++) {
        var a2 = t3[e3 + s2].rotation;
        n2[o2] = a2, n2[o2 + r2] = a2, n2[o2 + 2 * r2] = a2, n2[o2 + 3 * r2] = a2, o2 += 4 * r2;
      }
    }, e2.prototype.uploadUvs = function(t3, e3, i2, n2, r2, o2) {
      for (var s2 = 0; s2 < i2; ++s2) {
        var a2 = t3[e3 + s2]._texture._uvs;
        a2 ? (n2[o2] = a2.x0, n2[o2 + 1] = a2.y0, n2[o2 + r2] = a2.x1, n2[o2 + r2 + 1] = a2.y1, n2[o2 + 2 * r2] = a2.x2, n2[o2 + 2 * r2 + 1] = a2.y2, n2[o2 + 3 * r2] = a2.x3, n2[o2 + 3 * r2 + 1] = a2.y3, o2 += 4 * r2) : (n2[o2] = 0, n2[o2 + 1] = 0, n2[o2 + r2] = 0, n2[o2 + r2 + 1] = 0, n2[o2 + 2 * r2] = 0, n2[o2 + 2 * r2 + 1] = 0, n2[o2 + 3 * r2] = 0, n2[o2 + 3 * r2 + 1] = 0, o2 += 4 * r2);
      }
    }, e2.prototype.uploadTint = function(t3, e3, i2, n2, r2, o2) {
      for (var s2 = 0; s2 < i2; ++s2) {
        var a2 = t3[e3 + s2], l2 = a2._texture.baseTexture.alphaMode > 0, h2 = a2.alpha, u2 = h2 < 1 && l2 ? Object(Ph.premultiplyTint)(a2._tintRGB, h2) : a2._tintRGB + (255 * h2 << 24);
        n2[o2] = u2, n2[o2 + r2] = u2, n2[o2 + 2 * r2] = u2, n2[o2 + 3 * r2] = u2, o2 += 4 * r2;
      }
    }, e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, e2;
  }(Vh.m), xd = i(4);
  !function(t2) {
    t2.MITER = "miter", t2.BEVEL = "bevel", t2.ROUND = "round";
  }(md || (md = {})), function(t2) {
    t2.BUTT = "butt", t2.ROUND = "round", t2.SQUARE = "square";
  }(gd || (gd = {}));
  var bd = { adaptive: true, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount: function(t2, e2) {
    if (e2 === void 0 && (e2 = 20), !this.adaptive || !t2 || isNaN(t2))
      return e2;
    var i2 = Math.ceil(t2 / this.maxLength);
    return i2 < this.minSegments ? i2 = this.minSegments : i2 > this.maxSegments && (i2 = this.maxSegments), i2;
  } }, Td = function() {
    function t2() {
      this.color = 16777215, this.alpha = 1, this.texture = Vh.t.WHITE, this.matrix = null, this.visible = false, this.reset();
    }
    return t2.prototype.clone = function() {
      var e2 = new t2();
      return e2.color = this.color, e2.alpha = this.alpha, e2.texture = this.texture, e2.matrix = this.matrix, e2.visible = this.visible, e2;
    }, t2.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = Vh.t.WHITE, this.matrix = null, this.visible = false;
    }, t2.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, t2;
  }(), Ed = function(t2, e2) {
    return (Ed = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function Sd(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    Ed(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  function wd(t2, e2) {
    var i2, n2;
    e2 === void 0 && (e2 = false);
    var r2 = t2.length;
    if (!(r2 < 6)) {
      for (var o2 = 0, s2 = 0, a2 = t2[r2 - 2], l2 = t2[r2 - 1]; s2 < r2; s2 += 2) {
        var h2 = t2[s2], u2 = t2[s2 + 1];
        o2 += (h2 - a2) * (u2 + l2), a2 = h2, l2 = u2;
      }
      if (!e2 && o2 > 0 || e2 && o2 <= 0) {
        var c2 = r2 / 2;
        for (s2 = c2 + c2 % 2; s2 < r2; s2 += 2) {
          var d2 = r2 - s2 - 2, p2 = r2 - s2 - 1, f2 = s2, m2 = s2 + 1;
          i2 = [t2[f2], t2[d2]], t2[d2] = i2[0], t2[f2] = i2[1], n2 = [t2[m2], t2[p2]], t2[p2] = n2[0], t2[m2] = n2[1];
        }
      }
    }
  }
  var Ad = { build: function(t2) {
    t2.points = t2.shape.points.slice();
  }, triangulate: function(t2, e2) {
    var i2 = t2.points, n2 = t2.holes, r2 = e2.points, o2 = e2.indices;
    if (i2.length >= 6) {
      wd(i2, false);
      for (var s2 = [], a2 = 0; a2 < n2.length; a2++) {
        var l2 = n2[a2];
        wd(l2.points, true), s2.push(i2.length / 2), i2 = i2.concat(l2.points);
      }
      var h2 = Object(Ph.earcut)(i2, s2, 2);
      if (!h2)
        return;
      var u2 = r2.length / 2;
      for (a2 = 0; a2 < h2.length; a2 += 3)
        o2.push(h2[a2] + u2), o2.push(h2[a2 + 1] + u2), o2.push(h2[a2 + 2] + u2);
      for (a2 = 0; a2 < i2.length; a2++)
        r2.push(i2[a2]);
    }
  } }, Md = { build: function(t2) {
    var e2, i2, n2, r2, o2, s2, a2 = t2.points;
    if (t2.type === Lh.l.CIRC) {
      var l2 = t2.shape;
      e2 = l2.x, i2 = l2.y, o2 = s2 = l2.radius, n2 = r2 = 0;
    } else if (t2.type === Lh.l.ELIP) {
      var h2 = t2.shape;
      e2 = h2.x, i2 = h2.y, o2 = h2.width, s2 = h2.height, n2 = r2 = 0;
    } else {
      var u2 = t2.shape, c2 = u2.width / 2, d2 = u2.height / 2;
      e2 = u2.x + c2, i2 = u2.y + d2, n2 = c2 - (o2 = s2 = Math.max(0, Math.min(u2.radius, Math.min(c2, d2)))), r2 = d2 - s2;
    }
    if (o2 >= 0 && s2 >= 0 && n2 >= 0 && r2 >= 0) {
      var p2 = Math.ceil(2.3 * Math.sqrt(o2 + s2)), f2 = 8 * p2 + (n2 ? 4 : 0) + (r2 ? 4 : 0);
      if (a2.length = f2, f2 !== 0) {
        if (p2 === 0)
          return a2.length = 8, a2[0] = a2[6] = e2 + n2, a2[1] = a2[3] = i2 + r2, a2[2] = a2[4] = e2 - n2, void (a2[5] = a2[7] = i2 - r2);
        var m2 = 0, g2 = 4 * p2 + (n2 ? 2 : 0) + 2, v2 = g2, _2 = f2, y2 = e2 + (w2 = n2 + o2), x2 = e2 - w2, b2 = i2 + (A2 = r2);
        if (a2[m2++] = y2, a2[m2++] = b2, a2[--g2] = b2, a2[--g2] = x2, r2) {
          var T2 = i2 - A2;
          a2[v2++] = x2, a2[v2++] = T2, a2[--_2] = T2, a2[--_2] = y2;
        }
        for (var E2 = 1; E2 < p2; E2++) {
          var S2 = Math.PI / 2 * (E2 / p2);
          y2 = e2 + (w2 = n2 + Math.cos(S2) * o2), x2 = e2 - w2, b2 = i2 + (A2 = r2 + Math.sin(S2) * s2), T2 = i2 - A2;
          a2[m2++] = y2, a2[m2++] = b2, a2[--g2] = b2, a2[--g2] = x2, a2[v2++] = x2, a2[v2++] = T2, a2[--_2] = T2, a2[--_2] = y2;
        }
        var w2, A2;
        y2 = e2 + (w2 = n2), x2 = e2 - w2, b2 = i2 + (A2 = r2 + s2), T2 = i2 - A2;
        a2[m2++] = y2, a2[m2++] = b2, a2[--_2] = T2, a2[--_2] = y2, n2 && (a2[m2++] = x2, a2[m2++] = b2, a2[--_2] = T2, a2[--_2] = x2);
      }
    } else
      a2.length = 0;
  }, triangulate: function(t2, e2) {
    var i2, n2, r2 = t2.points, o2 = e2.points, s2 = e2.indices, a2 = o2.length / 2, l2 = a2;
    if (t2.type !== Lh.l.RREC) {
      var h2 = t2.shape;
      i2 = h2.x, n2 = h2.y;
    } else {
      var u2 = t2.shape;
      i2 = u2.x + u2.width / 2, n2 = u2.y + u2.height / 2;
    }
    var c2 = t2.matrix;
    o2.push(t2.matrix ? c2.a * i2 + c2.c * n2 + c2.tx : i2, t2.matrix ? c2.b * i2 + c2.d * n2 + c2.ty : n2), a2++, o2.push(r2[0], r2[1]);
    for (var d2 = 2; d2 < r2.length; d2 += 2)
      o2.push(r2[d2], r2[d2 + 1]), s2.push(a2++, l2, a2);
    s2.push(l2 + 1, l2, a2);
  } }, Rd = { build: function(t2) {
    var e2 = t2.shape, i2 = e2.x, n2 = e2.y, r2 = e2.width, o2 = e2.height, s2 = t2.points;
    s2.length = 0, s2.push(i2, n2, i2 + r2, n2, i2 + r2, n2 + o2, i2, n2 + o2);
  }, triangulate: function(t2, e2) {
    var i2 = t2.points, n2 = e2.points, r2 = n2.length / 2;
    n2.push(i2[0], i2[1], i2[2], i2[3], i2[6], i2[7], i2[4], i2[5]), e2.indices.push(r2, r2 + 1, r2 + 2, r2 + 1, r2 + 2, r2 + 3);
  } };
  function Cd(t2, e2, i2) {
    return t2 + (e2 - t2) * i2;
  }
  function Id(t2, e2, i2, n2, r2, o2, s2) {
    s2 === void 0 && (s2 = []);
    for (var a2 = s2, l2 = 0, h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0; f2 <= 20; ++f2)
      l2 = Cd(t2, i2, m2 = f2 / 20), h2 = Cd(e2, n2, m2), u2 = Cd(i2, r2, m2), c2 = Cd(n2, o2, m2), d2 = Cd(l2, u2, m2), p2 = Cd(h2, c2, m2), f2 === 0 && a2[a2.length - 2] === d2 && a2[a2.length - 1] === p2 || a2.push(d2, p2);
    return a2;
  }
  var Pd = { build: function(t2) {
    if (Jd.nextRoundedRectBehavior)
      Md.build(t2);
    else {
      var e2 = t2.shape, i2 = t2.points, n2 = e2.x, r2 = e2.y, o2 = e2.width, s2 = e2.height, a2 = Math.max(0, Math.min(e2.radius, Math.min(o2, s2) / 2));
      i2.length = 0, a2 ? (Id(n2, r2 + a2, n2, r2, n2 + a2, r2, i2), Id(n2 + o2 - a2, r2, n2 + o2, r2, n2 + o2, r2 + a2, i2), Id(n2 + o2, r2 + s2 - a2, n2 + o2, r2 + s2, n2 + o2 - a2, r2 + s2, i2), Id(n2 + a2, r2 + s2, n2, r2 + s2, n2, r2 + s2 - a2, i2)) : i2.push(n2, r2, n2 + o2, r2, n2 + o2, r2 + s2, n2, r2 + s2);
    }
  }, triangulate: function(t2, e2) {
    if (Jd.nextRoundedRectBehavior)
      Md.triangulate(t2, e2);
    else {
      for (var i2 = t2.points, n2 = e2.points, r2 = e2.indices, o2 = n2.length / 2, s2 = Object(Ph.earcut)(i2, null, 2), a2 = 0, l2 = s2.length; a2 < l2; a2 += 3)
        r2.push(s2[a2] + o2), r2.push(s2[a2 + 1] + o2), r2.push(s2[a2 + 2] + o2);
      for (a2 = 0, l2 = i2.length; a2 < l2; a2++)
        n2.push(i2[a2], i2[++a2]);
    }
  } };
  function Od(t2, e2, i2, n2, r2, o2, s2, a2) {
    var l2, h2;
    s2 ? (l2 = n2, h2 = -i2) : (l2 = -n2, h2 = i2);
    var u2 = t2 - i2 * r2 + l2, c2 = e2 - n2 * r2 + h2, d2 = t2 + i2 * o2 + l2, p2 = e2 + n2 * o2 + h2;
    return a2.push(u2, c2), a2.push(d2, p2), 2;
  }
  function Nd(t2, e2, i2, n2, r2, o2, s2, a2) {
    var l2 = i2 - t2, h2 = n2 - e2, u2 = Math.atan2(l2, h2), c2 = Math.atan2(r2 - t2, o2 - e2);
    a2 && u2 < c2 ? u2 += 2 * Math.PI : !a2 && u2 > c2 && (c2 += 2 * Math.PI);
    var d2 = u2, p2 = c2 - u2, f2 = Math.abs(p2), m2 = Math.sqrt(l2 * l2 + h2 * h2), g2 = 1 + (15 * f2 * Math.sqrt(m2) / Math.PI >> 0), v2 = p2 / g2;
    if (d2 += v2, a2) {
      s2.push(t2, e2), s2.push(i2, n2);
      for (var _2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2)
        s2.push(t2, e2), s2.push(t2 + Math.sin(y2) * m2, e2 + Math.cos(y2) * m2);
      s2.push(t2, e2), s2.push(r2, o2);
    } else {
      s2.push(i2, n2), s2.push(t2, e2);
      for (_2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2)
        s2.push(t2 + Math.sin(y2) * m2, e2 + Math.cos(y2) * m2), s2.push(t2, e2);
      s2.push(r2, o2), s2.push(t2, e2);
    }
    return 2 * g2;
  }
  function Ld(t2, e2) {
    t2.lineStyle.native ? function(t3, e3) {
      var i2 = 0, n2 = t3.shape, r2 = t3.points || n2.points, o2 = n2.type !== Lh.l.POLY || n2.closeStroke;
      if (r2.length !== 0) {
        var s2 = e3.points, a2 = e3.indices, l2 = r2.length / 2, h2 = s2.length / 2, u2 = h2;
        for (s2.push(r2[0], r2[1]), i2 = 1; i2 < l2; i2++)
          s2.push(r2[2 * i2], r2[2 * i2 + 1]), a2.push(u2, u2 + 1), u2++;
        o2 && a2.push(u2, h2);
      }
    }(t2, e2) : function(t3, e3) {
      var i2 = t3.shape, n2 = t3.points || i2.points.slice(), r2 = e3.closePointEps;
      if (n2.length !== 0) {
        var o2 = t3.lineStyle, s2 = new Lh.g(n2[0], n2[1]), a2 = new Lh.g(n2[n2.length - 2], n2[n2.length - 1]), l2 = i2.type !== Lh.l.POLY || i2.closeStroke, h2 = Math.abs(s2.x - a2.x) < r2 && Math.abs(s2.y - a2.y) < r2;
        if (l2) {
          n2 = n2.slice(), h2 && (n2.pop(), n2.pop(), a2.set(n2[n2.length - 2], n2[n2.length - 1]));
          var u2 = 0.5 * (s2.x + a2.x), c2 = 0.5 * (a2.y + s2.y);
          n2.unshift(u2, c2), n2.push(u2, c2);
        }
        var d2 = e3.points, p2 = n2.length / 2, f2 = n2.length, m2 = d2.length / 2, g2 = o2.width / 2, v2 = g2 * g2, _2 = o2.miterLimit * o2.miterLimit, y2 = n2[0], x2 = n2[1], b2 = n2[2], T2 = n2[3], E2 = 0, S2 = 0, w2 = -(x2 - T2), A2 = y2 - b2, M2 = 0, R2 = 0, C2 = Math.sqrt(w2 * w2 + A2 * A2);
        w2 /= C2, A2 /= C2, w2 *= g2, A2 *= g2;
        var I2 = o2.alignment, P2 = 2 * (1 - I2), O2 = 2 * I2;
        l2 || (o2.cap === gd.ROUND ? f2 += Nd(y2 - w2 * (P2 - O2) * 0.5, x2 - A2 * (P2 - O2) * 0.5, y2 - w2 * P2, x2 - A2 * P2, y2 + w2 * O2, x2 + A2 * O2, d2, true) + 2 : o2.cap === gd.SQUARE && (f2 += Od(y2, x2, w2, A2, P2, O2, true, d2))), d2.push(y2 - w2 * P2, x2 - A2 * P2), d2.push(y2 + w2 * O2, x2 + A2 * O2);
        for (var N2 = 1; N2 < p2 - 1; ++N2) {
          y2 = n2[2 * (N2 - 1)], x2 = n2[2 * (N2 - 1) + 1], b2 = n2[2 * N2], T2 = n2[2 * N2 + 1], E2 = n2[2 * (N2 + 1)], S2 = n2[2 * (N2 + 1) + 1], w2 = -(x2 - T2), A2 = y2 - b2, w2 /= C2 = Math.sqrt(w2 * w2 + A2 * A2), A2 /= C2, w2 *= g2, A2 *= g2, M2 = -(T2 - S2), R2 = b2 - E2, M2 /= C2 = Math.sqrt(M2 * M2 + R2 * R2), R2 /= C2, M2 *= g2, R2 *= g2;
          var L2 = b2 - y2, D2 = x2 - T2, F2 = b2 - E2, B2 = S2 - T2, U2 = D2 * F2 - B2 * L2, k2 = U2 < 0;
          if (Math.abs(U2) < 0.1)
            d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2);
          else {
            var G2 = (-w2 + y2) * (-A2 + T2) - (-w2 + b2) * (-A2 + x2), H2 = (-M2 + E2) * (-R2 + T2) - (-M2 + b2) * (-R2 + S2), j2 = (L2 * H2 - F2 * G2) / U2, z2 = (B2 * G2 - D2 * H2) / U2, V2 = (j2 - b2) * (j2 - b2) + (z2 - T2) * (z2 - T2), X2 = b2 + (j2 - b2) * P2, W2 = T2 + (z2 - T2) * P2, Y2 = b2 - (j2 - b2) * O2, q2 = T2 - (z2 - T2) * O2, Z2 = k2 ? P2 : O2;
            V2 <= Math.min(L2 * L2 + D2 * D2, F2 * F2 + B2 * B2) + Z2 * Z2 * v2 ? o2.join === md.BEVEL || V2 / v2 > _2 ? (k2 ? (d2.push(X2, W2), d2.push(b2 + w2 * O2, T2 + A2 * O2), d2.push(X2, W2), d2.push(b2 + M2 * O2, T2 + R2 * O2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(Y2, q2), d2.push(b2 - M2 * P2, T2 - R2 * P2), d2.push(Y2, q2)), f2 += 2) : o2.join === md.ROUND ? k2 ? (d2.push(X2, W2), d2.push(b2 + w2 * O2, T2 + A2 * O2), f2 += Nd(b2, T2, b2 + w2 * O2, T2 + A2 * O2, b2 + M2 * O2, T2 + R2 * O2, d2, true) + 4, d2.push(X2, W2), d2.push(b2 + M2 * O2, T2 + R2 * O2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(Y2, q2), f2 += Nd(b2, T2, b2 - w2 * P2, T2 - A2 * P2, b2 - M2 * P2, T2 - R2 * P2, d2, false) + 4, d2.push(b2 - M2 * P2, T2 - R2 * P2), d2.push(Y2, q2)) : (d2.push(X2, W2), d2.push(Y2, q2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2), o2.join === md.ROUND ? f2 += k2 ? Nd(b2, T2, b2 + w2 * O2, T2 + A2 * O2, b2 + M2 * O2, T2 + R2 * O2, d2, true) + 2 : Nd(b2, T2, b2 - w2 * P2, T2 - A2 * P2, b2 - M2 * P2, T2 - R2 * P2, d2, false) + 2 : o2.join === md.MITER && V2 / v2 <= _2 && (k2 ? (d2.push(Y2, q2), d2.push(Y2, q2)) : (d2.push(X2, W2), d2.push(X2, W2)), f2 += 2), d2.push(b2 - M2 * P2, T2 - R2 * P2), d2.push(b2 + M2 * O2, T2 + R2 * O2), f2 += 2);
          }
        }
        y2 = n2[2 * (p2 - 2)], x2 = n2[2 * (p2 - 2) + 1], b2 = n2[2 * (p2 - 1)], w2 = -(x2 - (T2 = n2[2 * (p2 - 1) + 1])), A2 = y2 - b2, w2 /= C2 = Math.sqrt(w2 * w2 + A2 * A2), A2 /= C2, w2 *= g2, A2 *= g2, d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2), l2 || (o2.cap === gd.ROUND ? f2 += Nd(b2 - w2 * (P2 - O2) * 0.5, T2 - A2 * (P2 - O2) * 0.5, b2 - w2 * P2, T2 - A2 * P2, b2 + w2 * O2, T2 + A2 * O2, d2, false) + 2 : o2.cap === gd.SQUARE && (f2 += Od(b2, T2, w2, A2, P2, O2, false, d2)));
        var J2 = e3.indices, K2 = bd.epsilon * bd.epsilon;
        for (N2 = m2; N2 < f2 + m2 - 2; ++N2)
          y2 = d2[2 * N2], x2 = d2[2 * N2 + 1], b2 = d2[2 * (N2 + 1)], T2 = d2[2 * (N2 + 1) + 1], E2 = d2[2 * (N2 + 2)], S2 = d2[2 * (N2 + 2) + 1], Math.abs(y2 * (T2 - S2) + b2 * (S2 - x2) + E2 * (x2 - T2)) < K2 || J2.push(N2, N2 + 1, N2 + 2);
      }
    }(t2, e2);
  }
  var Dd, Fd = function() {
    function t2() {
    }
    return t2.curveTo = function(t3, e2, i2, n2, r2, o2) {
      var s2 = o2[o2.length - 2], a2 = o2[o2.length - 1] - e2, l2 = s2 - t3, h2 = n2 - e2, u2 = i2 - t3, c2 = Math.abs(a2 * u2 - l2 * h2);
      if (c2 < 1e-8 || r2 === 0)
        return o2[o2.length - 2] === t3 && o2[o2.length - 1] === e2 || o2.push(t3, e2), null;
      var d2 = a2 * a2 + l2 * l2, p2 = h2 * h2 + u2 * u2, f2 = a2 * h2 + l2 * u2, m2 = r2 * Math.sqrt(d2) / c2, g2 = r2 * Math.sqrt(p2) / c2, v2 = m2 * f2 / d2, _2 = g2 * f2 / p2, y2 = m2 * u2 + g2 * l2, x2 = m2 * h2 + g2 * a2, b2 = l2 * (g2 + v2), T2 = a2 * (g2 + v2), E2 = u2 * (m2 + _2), S2 = h2 * (m2 + _2);
      return { cx: y2 + t3, cy: x2 + e2, radius: r2, startAngle: Math.atan2(T2 - x2, b2 - y2), endAngle: Math.atan2(S2 - x2, E2 - y2), anticlockwise: l2 * h2 > u2 * a2 };
    }, t2.arc = function(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
      for (var h2 = s2 - o2, u2 = bd._segmentsCount(Math.abs(h2) * r2, 40 * Math.ceil(Math.abs(h2) / Lh.f)), c2 = h2 / (2 * u2), d2 = 2 * c2, p2 = Math.cos(c2), f2 = Math.sin(c2), m2 = u2 - 1, g2 = m2 % 1 / m2, v2 = 0; v2 <= m2; ++v2) {
        var _2 = c2 + o2 + d2 * (v2 + g2 * v2), y2 = Math.cos(_2), x2 = -Math.sin(_2);
        l2.push((p2 * y2 + f2 * x2) * r2 + i2, (p2 * -x2 + f2 * y2) * r2 + n2);
      }
    }, t2;
  }(), Bd = function() {
    function t2() {
    }
    return t2.curveLength = function(t3, e2, i2, n2, r2, o2, s2, a2) {
      for (var l2 = 0, h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = t3, x2 = e2, b2 = 1; b2 <= 10; ++b2)
        v2 = y2 - (m2 = (f2 = (p2 = (d2 = 1 - (h2 = b2 / 10)) * d2) * d2) * t3 + 3 * p2 * h2 * i2 + 3 * d2 * (u2 = h2 * h2) * r2 + (c2 = u2 * h2) * s2), _2 = x2 - (g2 = f2 * e2 + 3 * p2 * h2 * n2 + 3 * d2 * u2 * o2 + c2 * a2), y2 = m2, x2 = g2, l2 += Math.sqrt(v2 * v2 + _2 * _2);
      return l2;
    }, t2.curveTo = function(e2, i2, n2, r2, o2, s2, a2) {
      var l2 = a2[a2.length - 2], h2 = a2[a2.length - 1];
      a2.length -= 2;
      var u2 = bd._segmentsCount(t2.curveLength(l2, h2, e2, i2, n2, r2, o2, s2)), c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
      a2.push(l2, h2);
      for (var g2 = 1, v2 = 0; g2 <= u2; ++g2)
        p2 = (d2 = (c2 = 1 - (v2 = g2 / u2)) * c2) * c2, m2 = (f2 = v2 * v2) * v2, a2.push(p2 * l2 + 3 * d2 * v2 * e2 + 3 * c2 * f2 * n2 + m2 * o2, p2 * h2 + 3 * d2 * v2 * i2 + 3 * c2 * f2 * r2 + m2 * s2);
    }, t2;
  }(), Ud = function() {
    function t2() {
    }
    return t2.curveLength = function(t3, e2, i2, n2, r2, o2) {
      var s2 = t3 - 2 * i2 + r2, a2 = e2 - 2 * n2 + o2, l2 = 2 * i2 - 2 * t3, h2 = 2 * n2 - 2 * e2, u2 = 4 * (s2 * s2 + a2 * a2), c2 = 4 * (s2 * l2 + a2 * h2), d2 = l2 * l2 + h2 * h2, p2 = 2 * Math.sqrt(u2 + c2 + d2), f2 = Math.sqrt(u2), m2 = 2 * u2 * f2, g2 = 2 * Math.sqrt(d2), v2 = c2 / f2;
      return (m2 * p2 + f2 * c2 * (p2 - g2) + (4 * d2 * u2 - c2 * c2) * Math.log((2 * f2 + v2 + p2) / (v2 + g2))) / (4 * m2);
    }, t2.curveTo = function(e2, i2, n2, r2, o2) {
      for (var s2 = o2[o2.length - 2], a2 = o2[o2.length - 1], l2 = bd._segmentsCount(t2.curveLength(s2, a2, e2, i2, n2, r2)), h2 = 0, u2 = 0, c2 = 1; c2 <= l2; ++c2) {
        var d2 = c2 / l2;
        h2 = s2 + (e2 - s2) * d2, u2 = a2 + (i2 - a2) * d2, o2.push(h2 + (e2 + (n2 - e2) * d2 - h2) * d2, u2 + (i2 + (r2 - i2) * d2 - u2) * d2);
      }
    }, t2;
  }(), kd = function() {
    function t2() {
      this.reset();
    }
    return t2.prototype.begin = function(t3, e2, i2) {
      this.reset(), this.style = t3, this.start = e2, this.attribStart = i2;
    }, t2.prototype.end = function(t3, e2) {
      this.attribSize = e2 - this.attribStart, this.size = t3 - this.start;
    }, t2.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, t2;
  }(), Gd = ((Dd = {})[Lh.l.POLY] = Ad, Dd[Lh.l.CIRC] = Md, Dd[Lh.l.ELIP] = Md, Dd[Lh.l.RECT] = Rd, Dd[Lh.l.RREC] = Pd, Dd), Hd = [], jd = [], zd = function() {
    function t2(t3, e2, i2, n2) {
      e2 === void 0 && (e2 = null), i2 === void 0 && (i2 = null), n2 === void 0 && (n2 = null), this.points = [], this.holes = [], this.shape = t3, this.lineStyle = i2, this.fillStyle = e2, this.matrix = n2, this.type = t3.type;
    }
    return t2.prototype.clone = function() {
      return new t2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, t2.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, t2;
  }(), Vd = new Lh.g(), Xd = new Oh.a(), Wd = function(t2) {
    function e2() {
      var e3 = t2.call(this) || this;
      return e3.closePointEps = 1e-4, e3.boundsPadding = 0, e3.uvsFloat32 = null, e3.indicesUint16 = null, e3.batchable = false, e3.points = [], e3.colors = [], e3.uvs = [], e3.indices = [], e3.textureIds = [], e3.graphicsData = [], e3.drawCalls = [], e3.batchDirty = -1, e3.batches = [], e3.dirty = 0, e3.cacheDirty = -1, e3.clearDirty = 0, e3.shapeIndex = 0, e3._bounds = new Oh.a(), e3.boundsDirty = -1, e3;
    }
    return Sd(e2, t2), Object.defineProperty(e2.prototype, "bounds", { get: function() {
      return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
    }, enumerable: false, configurable: true }), e2.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var t3 = 0; t3 < this.drawCalls.length; t3++)
        this.drawCalls[t3].texArray.clear(), jd.push(this.drawCalls[t3]);
      this.drawCalls.length = 0;
      for (t3 = 0; t3 < this.batches.length; t3++) {
        var e3 = this.batches[t3];
        e3.reset(), Hd.push(e3);
      }
      this.batches.length = 0;
    }, e2.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, e2.prototype.drawShape = function(t3, e3, i2, n2) {
      e3 === void 0 && (e3 = null), i2 === void 0 && (i2 = null), n2 === void 0 && (n2 = null);
      var r2 = new zd(t3, e3, i2, n2);
      return this.graphicsData.push(r2), this.dirty++, this;
    }, e2.prototype.drawHole = function(t3, e3) {
      if (e3 === void 0 && (e3 = null), !this.graphicsData.length)
        return null;
      var i2 = new zd(t3, null, null, e3), n2 = this.graphicsData[this.graphicsData.length - 1];
      return i2.lineStyle = n2.lineStyle, n2.holes.push(i2), this.dirty++, this;
    }, e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this);
      for (var e3 = 0; e3 < this.graphicsData.length; ++e3)
        this.graphicsData[e3].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, e2.prototype.containsPoint = function(t3) {
      for (var e3 = this.graphicsData, i2 = 0; i2 < e3.length; ++i2) {
        var n2 = e3[i2];
        if (n2.fillStyle.visible && (n2.shape && (n2.matrix ? n2.matrix.applyInverse(t3, Vd) : Vd.copyFrom(t3), n2.shape.contains(Vd.x, Vd.y)))) {
          var r2 = false;
          if (n2.holes)
            for (var o2 = 0; o2 < n2.holes.length; o2++) {
              if (n2.holes[o2].shape.contains(Vd.x, Vd.y)) {
                r2 = true;
                break;
              }
            }
          if (!r2)
            return true;
        }
      }
      return false;
    }, e2.prototype.updateBatches = function(t3) {
      if (this.graphicsData.length) {
        if (this.validateBatching()) {
          this.cacheDirty = this.dirty;
          var e3 = this.uvs, i2 = this.graphicsData, n2 = null, r2 = null;
          this.batches.length > 0 && (r2 = (n2 = this.batches[this.batches.length - 1]).style);
          for (var o2 = this.shapeIndex; o2 < i2.length; o2++) {
            this.shapeIndex++;
            var s2 = i2[o2], a2 = s2.fillStyle, l2 = s2.lineStyle;
            Gd[s2.type].build(s2), s2.matrix && this.transformPoints(s2.points, s2.matrix), (a2.visible || l2.visible) && this.processHoles(s2.holes);
            for (var h2 = 0; h2 < 2; h2++) {
              var u2 = h2 === 0 ? a2 : l2;
              if (u2.visible) {
                var c2 = u2.texture.baseTexture, d2 = this.indices.length, p2 = this.points.length / 2;
                c2.wrapMode = Sc.s.REPEAT, h2 === 0 ? this.processFill(s2) : this.processLine(s2);
                var f2 = this.points.length / 2 - p2;
                f2 !== 0 && (n2 && !this._compareStyles(r2, u2) && (n2.end(d2, p2), n2 = null), n2 || ((n2 = Hd.pop() || new kd()).begin(u2, d2, p2), this.batches.push(n2), r2 = u2), this.addUvs(this.points, e3, u2.texture, p2, f2, u2.matrix));
              }
            }
          }
          var m2 = this.indices.length, g2 = this.points.length / 2;
          if (n2 && n2.end(m2, g2), this.batches.length !== 0) {
            if (this.indicesUint16 && this.indices.length === this.indicesUint16.length)
              this.indicesUint16.set(this.indices);
            else {
              var v2 = g2 > 65535 && t3;
              this.indicesUint16 = v2 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
            }
            this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
          } else
            this.batchable = true;
        }
      } else
        this.batchable = true;
    }, e2.prototype._compareStyles = function(t3, e3) {
      return !(!t3 || !e3) && (t3.texture.baseTexture === e3.texture.baseTexture && (t3.color + t3.alpha === e3.color + e3.alpha && !!t3.native == !!e3.native));
    }, e2.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return false;
      for (var t3 = 0, e3 = this.graphicsData.length; t3 < e3; t3++) {
        var i2 = this.graphicsData[t3], n2 = i2.fillStyle, r2 = i2.lineStyle;
        if (n2 && !n2.texture.baseTexture.valid)
          return false;
        if (r2 && !r2.texture.baseTexture.valid)
          return false;
      }
      return true;
    }, e2.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var t3 = this.batches, e3 = 0, i2 = t3.length; e3 < i2; e3++)
        for (var n2 = t3[e3], r2 = 0; r2 < n2.size; r2++) {
          var o2 = n2.start + r2;
          this.indicesUint16[o2] = this.indicesUint16[o2] - n2.attribStart;
        }
    }, e2.prototype.isBatchable = function() {
      if (this.points.length > 131070)
        return false;
      for (var t3 = this.batches, i2 = 0; i2 < t3.length; i2++)
        if (t3[i2].style.native)
          return false;
      return this.points.length < 2 * e2.BATCHABLE_SIZE;
    }, e2.prototype.buildDrawCalls = function() {
      for (var t3 = ++Vh.c._globalBatch, e3 = 0; e3 < this.drawCalls.length; e3++)
        this.drawCalls[e3].texArray.clear(), jd.push(this.drawCalls[e3]);
      this.drawCalls.length = 0;
      var i2 = this.colors, n2 = this.textureIds, r2 = jd.pop();
      r2 || ((r2 = new Vh.d()).texArray = new Vh.g()), r2.texArray.count = 0, r2.start = 0, r2.size = 0, r2.type = Sc.f.TRIANGLES;
      var o2 = 0, s2 = null, a2 = 0, l2 = false, h2 = Sc.f.TRIANGLES, u2 = 0;
      this.drawCalls.push(r2);
      for (e3 = 0; e3 < this.batches.length; e3++) {
        var c2 = this.batches[e3], d2 = c2.style, p2 = d2.texture.baseTexture;
        l2 !== !!d2.native && (h2 = (l2 = !!d2.native) ? Sc.f.LINES : Sc.f.TRIANGLES, s2 = null, o2 = 8, t3++), s2 !== p2 && (s2 = p2, p2._batchEnabled !== t3 && (o2 === 8 && (t3++, o2 = 0, r2.size > 0 && ((r2 = jd.pop()) || ((r2 = new Vh.d()).texArray = new Vh.g()), this.drawCalls.push(r2)), r2.start = u2, r2.size = 0, r2.texArray.count = 0, r2.type = h2), p2.touched = 1, p2._batchEnabled = t3, p2._batchLocation = o2, p2.wrapMode = Sc.s.REPEAT, r2.texArray.elements[r2.texArray.count++] = p2, o2++)), r2.size += c2.size, u2 += c2.size, a2 = p2._batchLocation, this.addColors(i2, d2.color, d2.alpha, c2.attribSize, c2.attribStart), this.addTextureIds(n2, a2, c2.attribSize, c2.attribStart);
      }
      Vh.c._globalBatch = t3, this.packAttributes();
    }, e2.prototype.packAttributes = function() {
      for (var t3 = this.points, e3 = this.uvs, i2 = this.colors, n2 = this.textureIds, r2 = new ArrayBuffer(3 * t3.length * 4), o2 = new Float32Array(r2), s2 = new Uint32Array(r2), a2 = 0, l2 = 0; l2 < t3.length / 2; l2++)
        o2[a2++] = t3[2 * l2], o2[a2++] = t3[2 * l2 + 1], o2[a2++] = e3[2 * l2], o2[a2++] = e3[2 * l2 + 1], s2[a2++] = i2[l2], o2[a2++] = n2[l2];
      this._buffer.update(r2), this._indexBuffer.update(this.indicesUint16);
    }, e2.prototype.processFill = function(t3) {
      t3.holes.length ? Ad.triangulate(t3, this) : Gd[t3.type].triangulate(t3, this);
    }, e2.prototype.processLine = function(t3) {
      Ld(t3, this);
      for (var e3 = 0; e3 < t3.holes.length; e3++)
        Ld(t3.holes[e3], this);
    }, e2.prototype.processHoles = function(t3) {
      for (var e3 = 0; e3 < t3.length; e3++) {
        var i2 = t3[e3];
        Gd[i2.type].build(i2), i2.matrix && this.transformPoints(i2.points, i2.matrix);
      }
    }, e2.prototype.calculateBounds = function() {
      var t3 = this._bounds, e3 = Xd, i2 = Lh.d.IDENTITY;
      this._bounds.clear(), e3.clear();
      for (var n2 = 0; n2 < this.graphicsData.length; n2++) {
        var r2 = this.graphicsData[n2], o2 = r2.shape, s2 = r2.type, a2 = r2.lineStyle, l2 = r2.matrix || Lh.d.IDENTITY, h2 = 0;
        if (a2 && a2.visible && (h2 = a2.width, s2 !== Lh.l.POLY || r2.fillStyle.visible ? h2 *= Math.max(0, a2.alignment) : h2 *= Math.max(a2.alignment, 1 - a2.alignment)), i2 !== l2 && (e3.isEmpty() || (t3.addBoundsMatrix(e3, i2), e3.clear()), i2 = l2), s2 === Lh.l.RECT || s2 === Lh.l.RREC) {
          var u2 = o2;
          e3.addFramePad(u2.x, u2.y, u2.x + u2.width, u2.y + u2.height, h2, h2);
        } else if (s2 === Lh.l.CIRC) {
          var c2 = o2;
          e3.addFramePad(c2.x, c2.y, c2.x, c2.y, c2.radius + h2, c2.radius + h2);
        } else if (s2 === Lh.l.ELIP) {
          var d2 = o2;
          e3.addFramePad(d2.x, d2.y, d2.x, d2.y, d2.width + h2, d2.height + h2);
        } else {
          var p2 = o2;
          t3.addVerticesMatrix(i2, p2.points, 0, p2.points.length, h2, h2);
        }
      }
      e3.isEmpty() || t3.addBoundsMatrix(e3, i2), t3.pad(this.boundsPadding, this.boundsPadding);
    }, e2.prototype.transformPoints = function(t3, e3) {
      for (var i2 = 0; i2 < t3.length / 2; i2++) {
        var n2 = t3[2 * i2], r2 = t3[2 * i2 + 1];
        t3[2 * i2] = e3.a * n2 + e3.c * r2 + e3.tx, t3[2 * i2 + 1] = e3.b * n2 + e3.d * r2 + e3.ty;
      }
    }, e2.prototype.addColors = function(t3, e3, i2, n2, r2) {
      r2 === void 0 && (r2 = 0);
      var o2 = (e3 >> 16) + (65280 & e3) + ((255 & e3) << 16), s2 = Object(Ph.premultiplyTint)(o2, i2);
      t3.length = Math.max(t3.length, r2 + n2);
      for (var a2 = 0; a2 < n2; a2++)
        t3[r2 + a2] = s2;
    }, e2.prototype.addTextureIds = function(t3, e3, i2, n2) {
      n2 === void 0 && (n2 = 0), t3.length = Math.max(t3.length, n2 + i2);
      for (var r2 = 0; r2 < i2; r2++)
        t3[n2 + r2] = e3;
    }, e2.prototype.addUvs = function(t3, e3, i2, n2, r2, o2) {
      o2 === void 0 && (o2 = null);
      for (var s2 = 0, a2 = e3.length, l2 = i2.frame; s2 < r2; ) {
        var h2 = t3[2 * (n2 + s2)], u2 = t3[2 * (n2 + s2) + 1];
        if (o2) {
          var c2 = o2.a * h2 + o2.c * u2 + o2.tx;
          u2 = o2.b * h2 + o2.d * u2 + o2.ty, h2 = c2;
        }
        s2++, e3.push(h2 / l2.width, u2 / l2.height);
      }
      var d2 = i2.baseTexture;
      (l2.width < d2.width || l2.height < d2.height) && this.adjustUvs(e3, i2, a2, r2);
    }, e2.prototype.adjustUvs = function(t3, e3, i2, n2) {
      for (var r2 = e3.baseTexture, o2 = 1e-6, s2 = i2 + 2 * n2, a2 = e3.frame, l2 = a2.width / r2.width, h2 = a2.height / r2.height, u2 = a2.x / a2.width, c2 = a2.y / a2.height, d2 = Math.floor(t3[i2] + o2), p2 = Math.floor(t3[i2 + 1] + o2), f2 = i2 + 2; f2 < s2; f2 += 2)
        d2 = Math.min(d2, Math.floor(t3[f2] + o2)), p2 = Math.min(p2, Math.floor(t3[f2 + 1] + o2));
      u2 -= d2, c2 -= p2;
      for (f2 = i2; f2 < s2; f2 += 2)
        t3[f2] = (t3[f2] + u2) * l2, t3[f2 + 1] = (t3[f2 + 1] + c2) * h2;
    }, e2.BATCHABLE_SIZE = 100, e2;
  }(Vh.e), Yd = function(t2) {
    function e2() {
      var e3 = t2 !== null && t2.apply(this, arguments) || this;
      return e3.width = 0, e3.alignment = 0.5, e3.native = false, e3.cap = gd.BUTT, e3.join = md.MITER, e3.miterLimit = 10, e3;
    }
    return Sd(e2, t2), e2.prototype.clone = function() {
      var t3 = new e2();
      return t3.color = this.color, t3.alpha = this.alpha, t3.texture = this.texture, t3.matrix = this.matrix, t3.visible = this.visible, t3.width = this.width, t3.alignment = this.alignment, t3.native = this.native, t3.cap = this.cap, t3.join = this.join, t3.miterLimit = this.miterLimit, t3;
    }, e2.prototype.reset = function() {
      t2.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = false;
    }, e2;
  }(Td), qd = new Float32Array(3), Zd = {}, Jd = function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = null);
      var i2 = t2.call(this) || this;
      return i2.shader = null, i2.pluginName = "batch", i2.currentPath = null, i2.batches = [], i2.batchTint = -1, i2.batchDirty = -1, i2.vertexData = null, i2._fillStyle = new Td(), i2._lineStyle = new Yd(), i2._matrix = null, i2._holeMode = false, i2.state = Vh.s.for2d(), i2._geometry = e3 || new Wd(), i2._geometry.refCount++, i2._transformID = -1, i2.tint = 16777215, i2.blendMode = Sc.b.NORMAL, i2;
    }
    return Sd(e2, t2), Object.defineProperty(e2.prototype, "geometry", { get: function() {
      return this._geometry;
    }, enumerable: false, configurable: true }), e2.prototype.clone = function() {
      return this.finishPoly(), new e2(this._geometry);
    }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t3) {
      this.state.blendMode = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t3) {
      this._tint = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fill", { get: function() {
      return this._fillStyle;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "line", { get: function() {
      return this._lineStyle;
    }, enumerable: false, configurable: true }), e2.prototype.lineStyle = function(t3, e3, i2, n2, r2) {
      return t3 === void 0 && (t3 = null), e3 === void 0 && (e3 = 0), i2 === void 0 && (i2 = 1), n2 === void 0 && (n2 = 0.5), r2 === void 0 && (r2 = false), typeof t3 == "number" && (t3 = { width: t3, color: e3, alpha: i2, alignment: n2, native: r2 }), this.lineTextureStyle(t3);
    }, e2.prototype.lineTextureStyle = function(t3) {
      t3 = Object.assign({ width: 0, texture: Vh.t.WHITE, color: t3 && t3.texture ? 16777215 : 0, alpha: 1, matrix: null, alignment: 0.5, native: false, cap: gd.BUTT, join: md.MITER, miterLimit: 10 }, t3), this.currentPath && this.startPoly();
      var e3 = t3.width > 0 && t3.alpha > 0;
      return e3 ? (t3.matrix && (t3.matrix = t3.matrix.clone(), t3.matrix.invert()), Object.assign(this._lineStyle, { visible: e3 }, t3)) : this._lineStyle.reset(), this;
    }, e2.prototype.startPoly = function() {
      if (this.currentPath) {
        var t3 = this.currentPath.points, e3 = this.currentPath.points.length;
        e3 > 2 && (this.drawShape(this.currentPath), this.currentPath = new Lh.h(), this.currentPath.closeStroke = false, this.currentPath.points.push(t3[e3 - 2], t3[e3 - 1]));
      } else
        this.currentPath = new Lh.h(), this.currentPath.closeStroke = false;
    }, e2.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, e2.prototype.moveTo = function(t3, e3) {
      return this.startPoly(), this.currentPath.points[0] = t3, this.currentPath.points[1] = e3, this;
    }, e2.prototype.lineTo = function(t3, e3) {
      this.currentPath || this.moveTo(0, 0);
      var i2 = this.currentPath.points, n2 = i2[i2.length - 2], r2 = i2[i2.length - 1];
      return n2 === t3 && r2 === e3 || i2.push(t3, e3), this;
    }, e2.prototype._initCurve = function(t3, e3) {
      t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t3, e3]) : this.moveTo(t3, e3);
    }, e2.prototype.quadraticCurveTo = function(t3, e3, i2, n2) {
      this._initCurve();
      var r2 = this.currentPath.points;
      return r2.length === 0 && this.moveTo(0, 0), Ud.curveTo(t3, e3, i2, n2, r2), this;
    }, e2.prototype.bezierCurveTo = function(t3, e3, i2, n2, r2, o2) {
      return this._initCurve(), Bd.curveTo(t3, e3, i2, n2, r2, o2, this.currentPath.points), this;
    }, e2.prototype.arcTo = function(t3, e3, i2, n2, r2) {
      this._initCurve(t3, e3);
      var o2 = this.currentPath.points, s2 = Fd.curveTo(t3, e3, i2, n2, r2, o2);
      if (s2) {
        var a2 = s2.cx, l2 = s2.cy, h2 = s2.radius, u2 = s2.startAngle, c2 = s2.endAngle, d2 = s2.anticlockwise;
        this.arc(a2, l2, h2, u2, c2, d2);
      }
      return this;
    }, e2.prototype.arc = function(t3, e3, i2, n2, r2, o2) {
      if (o2 === void 0 && (o2 = false), n2 === r2)
        return this;
      if (!o2 && r2 <= n2 ? r2 += Lh.f : o2 && n2 <= r2 && (n2 += Lh.f), r2 - n2 === 0)
        return this;
      var s2 = t3 + Math.cos(n2) * i2, a2 = e3 + Math.sin(n2) * i2, l2 = this._geometry.closePointEps, h2 = this.currentPath ? this.currentPath.points : null;
      if (h2) {
        var u2 = Math.abs(h2[h2.length - 2] - s2), c2 = Math.abs(h2[h2.length - 1] - a2);
        u2 < l2 && c2 < l2 || h2.push(s2, a2);
      } else
        this.moveTo(s2, a2), h2 = this.currentPath.points;
      return Fd.arc(s2, a2, t3, e3, i2, n2, r2, o2, h2), this;
    }, e2.prototype.beginFill = function(t3, e3) {
      return t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = 1), this.beginTextureFill({ texture: Vh.t.WHITE, color: t3, alpha: e3 });
    }, e2.prototype.beginTextureFill = function(t3) {
      t3 = Object.assign({ texture: Vh.t.WHITE, color: 16777215, alpha: 1, matrix: null }, t3), this.currentPath && this.startPoly();
      var e3 = t3.alpha > 0;
      return e3 ? (t3.matrix && (t3.matrix = t3.matrix.clone(), t3.matrix.invert()), Object.assign(this._fillStyle, { visible: e3 }, t3)) : this._fillStyle.reset(), this;
    }, e2.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, e2.prototype.drawRect = function(t3, e3, i2, n2) {
      return this.drawShape(new Lh.j(t3, e3, i2, n2));
    }, e2.prototype.drawRoundedRect = function(t3, e3, i2, n2, r2) {
      return this.drawShape(new Lh.k(t3, e3, i2, n2, r2));
    }, e2.prototype.drawCircle = function(t3, e3, i2) {
      return this.drawShape(new Lh.a(t3, e3, i2));
    }, e2.prototype.drawEllipse = function(t3, e3, i2, n2) {
      return this.drawShape(new Lh.c(t3, e3, i2, n2));
    }, e2.prototype.drawPolygon = function() {
      for (var t3, e3 = arguments, i2 = [], n2 = 0; n2 < arguments.length; n2++)
        i2[n2] = e3[n2];
      var r2 = true, o2 = i2[0];
      o2.points ? (r2 = o2.closeStroke, t3 = o2.points) : t3 = Array.isArray(i2[0]) ? i2[0] : i2;
      var s2 = new Lh.h(t3);
      return s2.closeStroke = r2, this.drawShape(s2), this;
    }, e2.prototype.drawShape = function(t3) {
      return this._holeMode ? this._geometry.drawHole(t3, this._matrix) : this._geometry.drawShape(t3, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, e2.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = false, this.currentPath = null, this;
    }, e2.prototype.isFastRect = function() {
      var t3 = this._geometry.graphicsData;
      return !(t3.length !== 1 || t3[0].shape.type !== Lh.l.RECT || t3[0].matrix || t3[0].holes.length || t3[0].lineStyle.visible && t3[0].lineStyle.width);
    }, e2.prototype._render = function(t3) {
      this.finishPoly();
      var e3 = this._geometry, i2 = t3.context.supports.uint32Indices;
      e3.updateBatches(i2), e3.batchable ? (this.batchDirty !== e3.batchDirty && this._populateBatches(), this._renderBatched(t3)) : (t3.batch.flush(), this._renderDirect(t3));
    }, e2.prototype._populateBatches = function() {
      var t3 = this._geometry, e3 = this.blendMode, i2 = t3.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = t3.batchDirty, this.batches.length = i2, this.vertexData = new Float32Array(t3.points);
      for (var n2 = 0; n2 < i2; n2++) {
        var r2 = t3.batches[n2], o2 = r2.style.color, s2 = new Float32Array(this.vertexData.buffer, 4 * r2.attribStart * 2, 2 * r2.attribSize), a2 = new Float32Array(t3.uvsFloat32.buffer, 4 * r2.attribStart * 2, 2 * r2.attribSize), l2 = { vertexData: s2, blendMode: e3, indices: new Uint16Array(t3.indicesUint16.buffer, 2 * r2.start, r2.size), uvs: a2, _batchRGB: Object(Ph.hex2rgb)(o2), _tintRGB: o2, _texture: r2.style.texture, alpha: r2.style.alpha, worldAlpha: 1 };
        this.batches[n2] = l2;
      }
    }, e2.prototype._renderBatched = function(t3) {
      if (this.batches.length) {
        t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var e3 = 0, i2 = this.batches.length; e3 < i2; e3++) {
          var n2 = this.batches[e3];
          n2.worldAlpha = this.worldAlpha * n2.alpha, t3.plugins[this.pluginName].render(n2);
        }
      }
    }, e2.prototype._renderDirect = function(t3) {
      var e3 = this._resolveDirectShader(t3), i2 = this._geometry, n2 = this.tint, r2 = this.worldAlpha, o2 = e3.uniforms, s2 = i2.drawCalls;
      o2.translationMatrix = this.transform.worldTransform, o2.tint[0] = (n2 >> 16 & 255) / 255 * r2, o2.tint[1] = (n2 >> 8 & 255) / 255 * r2, o2.tint[2] = (255 & n2) / 255 * r2, o2.tint[3] = r2, t3.shader.bind(e3), t3.geometry.bind(i2, e3), t3.state.set(this.state);
      for (var a2 = 0, l2 = s2.length; a2 < l2; a2++)
        this._renderDrawCallDirect(t3, i2.drawCalls[a2]);
    }, e2.prototype._renderDrawCallDirect = function(t3, e3) {
      for (var i2 = e3.texArray, n2 = e3.type, r2 = e3.size, o2 = e3.start, s2 = i2.count, a2 = 0; a2 < s2; a2++)
        t3.texture.bind(i2.elements[a2], a2);
      t3.geometry.draw(n2, r2, o2);
    }, e2.prototype._resolveDirectShader = function(t3) {
      var e3 = this.shader, i2 = this.pluginName;
      if (!e3) {
        if (!Zd[i2]) {
          for (var n2 = t3.plugins[i2].MAX_TEXTURES, r2 = new Int32Array(n2), o2 = 0; o2 < n2; o2++)
            r2[o2] = o2;
          var s2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Lh.d(), default: Vh.v.from({ uSamplers: r2 }, true) }, a2 = t3.plugins[i2]._shader.program;
          Zd[i2] = new Vh.r(a2, s2);
        }
        e3 = Zd[i2];
      }
      return e3;
    }, e2.prototype._calculateBounds = function() {
      this.finishPoly();
      var t3 = this._geometry;
      if (t3.graphicsData.length) {
        var e3 = t3.bounds, i2 = e3.minX, n2 = e3.minY, r2 = e3.maxX, o2 = e3.maxY;
        this._bounds.addFrame(this.transform, i2, n2, r2, o2);
      }
    }, e2.prototype.containsPoint = function(t3) {
      return this.worldTransform.applyInverse(t3, e2._TEMP_POINT), this._geometry.containsPoint(e2._TEMP_POINT);
    }, e2.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var t3 = Object(Ph.hex2rgb)(this.tint, qd), e3 = 0; e3 < this.batches.length; e3++) {
          var i2 = this.batches[e3], n2 = i2._batchRGB, r2 = (t3[0] * n2[0] * 255 << 16) + (t3[1] * n2[1] * 255 << 8) + (0 | t3[2] * n2[2] * 255);
          i2._tintRGB = (r2 >> 16) + (65280 & r2) + ((255 & r2) << 16);
        }
      }
    }, e2.prototype.calculateVertices = function() {
      var t3 = this.transform._worldID;
      if (this._transformID !== t3) {
        this._transformID = t3;
        for (var e3 = this.transform.worldTransform, i2 = e3.a, n2 = e3.b, r2 = e3.c, o2 = e3.d, s2 = e3.tx, a2 = e3.ty, l2 = this._geometry.points, h2 = this.vertexData, u2 = 0, c2 = 0; c2 < l2.length; c2 += 2) {
          var d2 = l2[c2], p2 = l2[c2 + 1];
          h2[u2++] = i2 * d2 + r2 * p2 + s2, h2[u2++] = o2 * p2 + n2 * d2 + a2;
        }
      }
    }, e2.prototype.closePath = function() {
      var t3 = this.currentPath;
      return t3 && (t3.closeStroke = true, this.finishPoly()), this;
    }, e2.prototype.setMatrix = function(t3) {
      return this._matrix = t3, this;
    }, e2.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = true, this;
    }, e2.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = false, this;
    }, e2.prototype.destroy = function(e3) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t2.prototype.destroy.call(this, e3);
    }, e2.nextRoundedRectBehavior = false, e2._TEMP_POINT = new Lh.g(), e2;
  }(Oh.b), Kd = function(t2, e2) {
    return (Kd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Qd, $d = new Lh.g(), tp = new Uint16Array([0, 1, 2, 0, 2, 3]), ep = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this) || this;
      return i2._anchor = new Lh.e(i2._onAnchorUpdate, i2, e3 ? e3.defaultAnchor.x : 0, e3 ? e3.defaultAnchor.y : 0), i2._texture = null, i2._width = 0, i2._height = 0, i2._tint = null, i2._tintRGB = null, i2.tint = 16777215, i2.blendMode = Sc.b.NORMAL, i2._cachedTint = 16777215, i2.uvs = null, i2.texture = e3 || Vh.t.EMPTY, i2.vertexData = new Float32Array(8), i2.vertexTrimmedData = null, i2._transformID = -1, i2._textureID = -1, i2._transformTrimmedID = -1, i2._textureTrimmedID = -1, i2.indices = tp, i2.pluginName = "batch", i2.isSprite = true, i2._roundPixels = xd.b.ROUND_PIXELS, i2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Kd(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Object(Ph.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Object(Ph.sign)(this.scale.y) * this._height / this._texture.orig.height);
    }, e2.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, e2.prototype.calculateVertices = function() {
      var t3 = this._texture;
      if (this._transformID !== this.transform._worldID || this._textureID !== t3._updateID) {
        this._textureID !== t3._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t3._updateID;
        var e3 = this.transform.worldTransform, i2 = e3.a, n2 = e3.b, r2 = e3.c, o2 = e3.d, s2 = e3.tx, a2 = e3.ty, l2 = this.vertexData, h2 = t3.trim, u2 = t3.orig, c2 = this._anchor, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
        if (h2 ? (d2 = (p2 = h2.x - c2._x * u2.width) + h2.width, f2 = (m2 = h2.y - c2._y * u2.height) + h2.height) : (d2 = (p2 = -c2._x * u2.width) + u2.width, f2 = (m2 = -c2._y * u2.height) + u2.height), l2[0] = i2 * p2 + r2 * m2 + s2, l2[1] = o2 * m2 + n2 * p2 + a2, l2[2] = i2 * d2 + r2 * m2 + s2, l2[3] = o2 * m2 + n2 * d2 + a2, l2[4] = i2 * d2 + r2 * f2 + s2, l2[5] = o2 * f2 + n2 * d2 + a2, l2[6] = i2 * p2 + r2 * f2 + s2, l2[7] = o2 * f2 + n2 * p2 + a2, this._roundPixels)
          for (var g2 = xd.b.RESOLUTION, v2 = 0; v2 < l2.length; ++v2)
            l2[v2] = Math.round((l2[v2] * g2 | 0) / g2);
      }
    }, e2.prototype.calculateTrimmedVertices = function() {
      if (this.vertexTrimmedData) {
        if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
          return;
      } else
        this.vertexTrimmedData = new Float32Array(8);
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var t3 = this._texture, e3 = this.vertexTrimmedData, i2 = t3.orig, n2 = this._anchor, r2 = this.transform.worldTransform, o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d, h2 = r2.tx, u2 = r2.ty, c2 = -n2._x * i2.width, d2 = c2 + i2.width, p2 = -n2._y * i2.height, f2 = p2 + i2.height;
      e3[0] = o2 * c2 + a2 * p2 + h2, e3[1] = l2 * p2 + s2 * c2 + u2, e3[2] = o2 * d2 + a2 * p2 + h2, e3[3] = l2 * p2 + s2 * d2 + u2, e3[4] = o2 * d2 + a2 * f2 + h2, e3[5] = l2 * f2 + s2 * d2 + u2, e3[6] = o2 * c2 + a2 * f2 + h2, e3[7] = l2 * f2 + s2 * c2 + u2;
    }, e2.prototype._render = function(t3) {
      this.calculateVertices(), t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), t3.plugins[this.pluginName].render(this);
    }, e2.prototype._calculateBounds = function() {
      var t3 = this._texture.trim, e3 = this._texture.orig;
      !t3 || t3.width === e3.width && t3.height === e3.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, e2.prototype.getLocalBounds = function(e3) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Oh.a()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), e3 = this._localBoundsRect), this._localBounds.getRectangle(e3)) : t2.prototype.getLocalBounds.call(this, e3);
    }, e2.prototype.containsPoint = function(t3) {
      this.worldTransform.applyInverse(t3, $d);
      var e3 = this._texture.orig.width, i2 = this._texture.orig.height, n2 = -e3 * this.anchor.x, r2 = 0;
      return $d.x >= n2 && $d.x < n2 + e3 && (r2 = -i2 * this.anchor.y, $d.y >= r2 && $d.y < r2 + i2);
    }, e2.prototype.destroy = function(e3) {
      if (t2.prototype.destroy.call(this, e3), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof e3 == "boolean" ? e3 : e3 && e3.texture) {
        var i2 = typeof e3 == "boolean" ? e3 : e3 && e3.baseTexture;
        this._texture.destroy(!!i2);
      }
      this._texture = null;
    }, e2.from = function(t3, i2) {
      return new e2(t3 instanceof Vh.t ? t3 : Vh.t.from(t3, i2));
    }, Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t3) {
      this._roundPixels !== t3 && (this._transformID = -1), this._roundPixels = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }, set: function(t3) {
      var e3 = Object(Ph.sign)(this.scale.x) || 1;
      this.scale.x = e3 * t3 / this._texture.orig.width, this._width = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }, set: function(t3) {
      var e3 = Object(Ph.sign)(this.scale.y) || 1;
      this.scale.y = e3 * t3 / this._texture.orig.height, this._height = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "anchor", { get: function() {
      return this._anchor;
    }, set: function(t3) {
      this._anchor.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t3) {
      this._tint = t3, this._tintRGB = (t3 >> 16) + (65280 & t3) + ((255 & t3) << 16);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "texture", { get: function() {
      return this._texture;
    }, set: function(t3) {
      this._texture !== t3 && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t3 || Vh.t.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t3 && (t3.baseTexture.valid ? this._onTextureUpdate() : t3.once("update", this._onTextureUpdate, this)));
    }, enumerable: false, configurable: true }), e2;
  }(Oh.b), ip = function(t2, e2) {
    return (ip = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  !function(t2) {
    t2[t2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t2[t2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
  }(Qd || (Qd = {}));
  var np = { align: "left", breakWords: false, dropShadow: false, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: "black", dropShadowDistance: 5, fill: "black", fillGradientType: Qd.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", letterSpacing: 0, lineHeight: 0, lineJoin: "miter", miterLimit: 10, padding: 0, stroke: "black", strokeThickness: 0, textBaseline: "alphabetic", trim: false, whiteSpace: "pre", wordWrap: false, wordWrapWidth: 100, leading: 0 }, rp = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], op = function() {
    function t2(t3) {
      this.styleID = 0, this.reset(), lp(this, t3, t3);
    }
    return t2.prototype.clone = function() {
      var e2 = {};
      return lp(e2, this, np), new t2(e2);
    }, t2.prototype.reset = function() {
      lp(this, np, np);
    }, Object.defineProperty(t2.prototype, "align", { get: function() {
      return this._align;
    }, set: function(t3) {
      this._align !== t3 && (this._align = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "breakWords", { get: function() {
      return this._breakWords;
    }, set: function(t3) {
      this._breakWords !== t3 && (this._breakWords = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadow", { get: function() {
      return this._dropShadow;
    }, set: function(t3) {
      this._dropShadow !== t3 && (this._dropShadow = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowAlpha", { get: function() {
      return this._dropShadowAlpha;
    }, set: function(t3) {
      this._dropShadowAlpha !== t3 && (this._dropShadowAlpha = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowAngle", { get: function() {
      return this._dropShadowAngle;
    }, set: function(t3) {
      this._dropShadowAngle !== t3 && (this._dropShadowAngle = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowBlur", { get: function() {
      return this._dropShadowBlur;
    }, set: function(t3) {
      this._dropShadowBlur !== t3 && (this._dropShadowBlur = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowColor", { get: function() {
      return this._dropShadowColor;
    }, set: function(t3) {
      var e2 = ap(t3);
      this._dropShadowColor !== e2 && (this._dropShadowColor = e2, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowDistance", { get: function() {
      return this._dropShadowDistance;
    }, set: function(t3) {
      this._dropShadowDistance !== t3 && (this._dropShadowDistance = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fill", { get: function() {
      return this._fill;
    }, set: function(t3) {
      var e2 = ap(t3);
      this._fill !== e2 && (this._fill = e2, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fillGradientType", { get: function() {
      return this._fillGradientType;
    }, set: function(t3) {
      this._fillGradientType !== t3 && (this._fillGradientType = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fillGradientStops", { get: function() {
      return this._fillGradientStops;
    }, set: function(t3) {
      (function(t4, e2) {
        if (!Array.isArray(t4) || !Array.isArray(e2))
          return false;
        if (t4.length !== e2.length)
          return false;
        for (var i2 = 0; i2 < t4.length; ++i2)
          if (t4[i2] !== e2[i2])
            return false;
        return true;
      })(this._fillGradientStops, t3) || (this._fillGradientStops = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontFamily", { get: function() {
      return this._fontFamily;
    }, set: function(t3) {
      this.fontFamily !== t3 && (this._fontFamily = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontSize", { get: function() {
      return this._fontSize;
    }, set: function(t3) {
      this._fontSize !== t3 && (this._fontSize = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontStyle", { get: function() {
      return this._fontStyle;
    }, set: function(t3) {
      this._fontStyle !== t3 && (this._fontStyle = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontVariant", { get: function() {
      return this._fontVariant;
    }, set: function(t3) {
      this._fontVariant !== t3 && (this._fontVariant = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontWeight", { get: function() {
      return this._fontWeight;
    }, set: function(t3) {
      this._fontWeight !== t3 && (this._fontWeight = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "letterSpacing", { get: function() {
      return this._letterSpacing;
    }, set: function(t3) {
      this._letterSpacing !== t3 && (this._letterSpacing = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "lineHeight", { get: function() {
      return this._lineHeight;
    }, set: function(t3) {
      this._lineHeight !== t3 && (this._lineHeight = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "leading", { get: function() {
      return this._leading;
    }, set: function(t3) {
      this._leading !== t3 && (this._leading = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "lineJoin", { get: function() {
      return this._lineJoin;
    }, set: function(t3) {
      this._lineJoin !== t3 && (this._lineJoin = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "miterLimit", { get: function() {
      return this._miterLimit;
    }, set: function(t3) {
      this._miterLimit !== t3 && (this._miterLimit = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "padding", { get: function() {
      return this._padding;
    }, set: function(t3) {
      this._padding !== t3 && (this._padding = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "stroke", { get: function() {
      return this._stroke;
    }, set: function(t3) {
      var e2 = ap(t3);
      this._stroke !== e2 && (this._stroke = e2, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "strokeThickness", { get: function() {
      return this._strokeThickness;
    }, set: function(t3) {
      this._strokeThickness !== t3 && (this._strokeThickness = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "textBaseline", { get: function() {
      return this._textBaseline;
    }, set: function(t3) {
      this._textBaseline !== t3 && (this._textBaseline = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "trim", { get: function() {
      return this._trim;
    }, set: function(t3) {
      this._trim !== t3 && (this._trim = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "whiteSpace", { get: function() {
      return this._whiteSpace;
    }, set: function(t3) {
      this._whiteSpace !== t3 && (this._whiteSpace = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "wordWrap", { get: function() {
      return this._wordWrap;
    }, set: function(t3) {
      this._wordWrap !== t3 && (this._wordWrap = t3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "wordWrapWidth", { get: function() {
      return this._wordWrapWidth;
    }, set: function(t3) {
      this._wordWrapWidth !== t3 && (this._wordWrapWidth = t3, this.styleID++);
    }, enumerable: false, configurable: true }), t2.prototype.toFontString = function() {
      var t3 = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e2 = this.fontFamily;
      Array.isArray(this.fontFamily) || (e2 = this.fontFamily.split(","));
      for (var i2 = e2.length - 1; i2 >= 0; i2--) {
        var n2 = e2[i2].trim();
        !/([\"\'])[^\'\"]+\1/.test(n2) && rp.indexOf(n2) < 0 && (n2 = '"' + n2 + '"'), e2[i2] = n2;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t3 + " " + e2.join(",");
    }, t2;
  }();
  function sp(t2) {
    return typeof t2 == "number" ? Object(Ph.hex2string)(t2) : (typeof t2 == "string" && t2.indexOf("0x") === 0 && (t2 = t2.replace("0x", "#")), t2);
  }
  function ap(t2) {
    if (Array.isArray(t2)) {
      for (var e2 = 0; e2 < t2.length; ++e2)
        t2[e2] = sp(t2[e2]);
      return t2;
    }
    return sp(t2);
  }
  function lp(t2, e2, i2) {
    for (var n2 in i2)
      Array.isArray(e2[n2]) ? t2[n2] = e2[n2].slice() : t2[n2] = e2[n2];
  }
  var hp = function() {
    function t2(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
      this.text = t3, this.style = e2, this.width = i2, this.height = n2, this.lines = r2, this.lineWidths = o2, this.lineHeight = s2, this.maxLineWidth = a2, this.fontProperties = l2;
    }
    return t2.measureText = function(e2, i2, n2, r2) {
      r2 === void 0 && (r2 = t2._canvas), n2 = n2 == null ? i2.wordWrap : n2;
      var o2 = i2.toFontString(), s2 = t2.measureFont(o2);
      s2.fontSize === 0 && (s2.fontSize = i2.fontSize, s2.ascent = i2.fontSize);
      var a2 = r2.getContext("2d");
      a2.font = o2;
      for (var l2 = (n2 ? t2.wordWrap(e2, i2, r2) : e2).split(/(?:\r\n|\r|\n)/), h2 = new Array(l2.length), u2 = 0, c2 = 0; c2 < l2.length; c2++) {
        var d2 = a2.measureText(l2[c2]).width + (l2[c2].length - 1) * i2.letterSpacing;
        h2[c2] = d2, u2 = Math.max(u2, d2);
      }
      var p2 = u2 + i2.strokeThickness;
      i2.dropShadow && (p2 += i2.dropShadowDistance);
      var f2 = i2.lineHeight || s2.fontSize + i2.strokeThickness, m2 = Math.max(f2, s2.fontSize + i2.strokeThickness) + (l2.length - 1) * (f2 + i2.leading);
      return i2.dropShadow && (m2 += i2.dropShadowDistance), new t2(e2, i2, p2, m2, l2, h2, f2 + i2.leading, u2, s2);
    }, t2.wordWrap = function(e2, i2, n2) {
      n2 === void 0 && (n2 = t2._canvas);
      for (var r2 = n2.getContext("2d"), o2 = 0, s2 = "", a2 = "", l2 = /* @__PURE__ */ Object.create(null), h2 = i2.letterSpacing, u2 = i2.whiteSpace, c2 = t2.collapseSpaces(u2), d2 = t2.collapseNewlines(u2), p2 = !c2, f2 = i2.wordWrapWidth + h2, m2 = t2.tokenize(e2), g2 = 0; g2 < m2.length; g2++) {
        var v2 = m2[g2];
        if (t2.isNewline(v2)) {
          if (!d2) {
            a2 += t2.addLine(s2), p2 = !c2, s2 = "", o2 = 0;
            continue;
          }
          v2 = " ";
        }
        if (c2) {
          var _2 = t2.isBreakingSpace(v2), y2 = t2.isBreakingSpace(s2[s2.length - 1]);
          if (_2 && y2)
            continue;
        }
        var x2 = t2.getFromCache(v2, h2, l2, r2);
        if (x2 > f2)
          if (s2 !== "" && (a2 += t2.addLine(s2), s2 = "", o2 = 0), t2.canBreakWords(v2, i2.breakWords))
            for (var b2 = t2.wordWrapSplit(v2), T2 = 0; T2 < b2.length; T2++) {
              for (var E2 = b2[T2], S2 = 1; b2[T2 + S2]; ) {
                var w2 = b2[T2 + S2], A2 = E2[E2.length - 1];
                if (t2.canBreakChars(A2, w2, v2, T2, i2.breakWords))
                  break;
                E2 += w2, S2++;
              }
              T2 += E2.length - 1;
              var M2 = t2.getFromCache(E2, h2, l2, r2);
              M2 + o2 > f2 && (a2 += t2.addLine(s2), p2 = false, s2 = "", o2 = 0), s2 += E2, o2 += M2;
            }
          else {
            s2.length > 0 && (a2 += t2.addLine(s2), s2 = "", o2 = 0);
            var R2 = g2 === m2.length - 1;
            a2 += t2.addLine(v2, !R2), p2 = false, s2 = "", o2 = 0;
          }
        else
          x2 + o2 > f2 && (p2 = false, a2 += t2.addLine(s2), s2 = "", o2 = 0), (s2.length > 0 || !t2.isBreakingSpace(v2) || p2) && (s2 += v2, o2 += x2);
      }
      return a2 += t2.addLine(s2, false);
    }, t2.addLine = function(e2, i2) {
      return i2 === void 0 && (i2 = true), e2 = t2.trimRight(e2), e2 = i2 ? e2 + "\n" : e2;
    }, t2.getFromCache = function(t3, e2, i2, n2) {
      var r2 = i2[t3];
      if (typeof r2 != "number") {
        var o2 = t3.length * e2;
        r2 = n2.measureText(t3).width + o2, i2[t3] = r2;
      }
      return r2;
    }, t2.collapseSpaces = function(t3) {
      return t3 === "normal" || t3 === "pre-line";
    }, t2.collapseNewlines = function(t3) {
      return t3 === "normal";
    }, t2.trimRight = function(e2) {
      if (typeof e2 != "string")
        return "";
      for (var i2 = e2.length - 1; i2 >= 0; i2--) {
        var n2 = e2[i2];
        if (!t2.isBreakingSpace(n2))
          break;
        e2 = e2.slice(0, -1);
      }
      return e2;
    }, t2.isNewline = function(e2) {
      return typeof e2 == "string" && t2._newlines.indexOf(e2.charCodeAt(0)) >= 0;
    }, t2.isBreakingSpace = function(e2, i2) {
      return typeof e2 == "string" && t2._breakingSpaces.indexOf(e2.charCodeAt(0)) >= 0;
    }, t2.tokenize = function(e2) {
      var i2 = [], n2 = "";
      if (typeof e2 != "string")
        return i2;
      for (var r2 = 0; r2 < e2.length; r2++) {
        var o2 = e2[r2], s2 = e2[r2 + 1];
        t2.isBreakingSpace(o2, s2) || t2.isNewline(o2) ? (n2 !== "" && (i2.push(n2), n2 = ""), i2.push(o2)) : n2 += o2;
      }
      return n2 !== "" && i2.push(n2), i2;
    }, t2.canBreakWords = function(t3, e2) {
      return e2;
    }, t2.canBreakChars = function(t3, e2, i2, n2, r2) {
      return true;
    }, t2.wordWrapSplit = function(t3) {
      return t3.split("");
    }, t2.measureFont = function(e2) {
      if (t2._fonts[e2])
        return t2._fonts[e2];
      var i2 = { ascent: 0, descent: 0, fontSize: 0 }, n2 = t2._canvas, r2 = t2._context;
      r2.font = e2;
      var o2 = t2.METRICS_STRING + t2.BASELINE_SYMBOL, s2 = Math.ceil(r2.measureText(o2).width), a2 = Math.ceil(r2.measureText(t2.BASELINE_SYMBOL).width), l2 = Math.ceil(t2.HEIGHT_MULTIPLIER * a2);
      a2 = a2 * t2.BASELINE_MULTIPLIER | 0, n2.width = s2, n2.height = l2, r2.fillStyle = "#f00", r2.fillRect(0, 0, s2, l2), r2.font = e2, r2.textBaseline = "alphabetic", r2.fillStyle = "#000", r2.fillText(o2, 0, a2);
      var h2 = r2.getImageData(0, 0, s2, l2).data, u2 = h2.length, c2 = 4 * s2, d2 = 0, p2 = 0, f2 = false;
      for (d2 = 0; d2 < a2; ++d2) {
        for (var m2 = 0; m2 < c2; m2 += 4)
          if (h2[p2 + m2] !== 255) {
            f2 = true;
            break;
          }
        if (f2)
          break;
        p2 += c2;
      }
      for (i2.ascent = a2 - d2, p2 = u2 - c2, f2 = false, d2 = l2; d2 > a2; --d2) {
        for (m2 = 0; m2 < c2; m2 += 4)
          if (h2[p2 + m2] !== 255) {
            f2 = true;
            break;
          }
        if (f2)
          break;
        p2 -= c2;
      }
      return i2.descent = d2 - a2, i2.fontSize = i2.ascent + i2.descent, t2._fonts[e2] = i2, i2;
    }, t2.clearMetrics = function(e2) {
      e2 === void 0 && (e2 = ""), e2 ? delete t2._fonts[e2] : t2._fonts = {};
    }, Object.defineProperty(t2, "_canvas", { get: function() {
      if (!t2.__canvas) {
        var e2 = void 0;
        try {
          var i2 = new OffscreenCanvas(0, 0), n2 = i2.getContext("2d");
          if (n2 && n2.measureText)
            return t2.__canvas = i2, i2;
          e2 = document.createElement("canvas");
        } catch (t3) {
          e2 = document.createElement("canvas");
        }
        e2.width = e2.height = 10, t2.__canvas = e2;
      }
      return t2.__canvas;
    }, enumerable: false, configurable: true }), Object.defineProperty(t2, "_context", { get: function() {
      return t2.__context || (t2.__context = t2._canvas.getContext("2d")), t2.__context;
    }, enumerable: false, configurable: true }), t2;
  }();
  hp._fonts = {}, hp.METRICS_STRING = "|\xC9q\xC5", hp.BASELINE_SYMBOL = "M", hp.BASELINE_MULTIPLIER = 1.4, hp.HEIGHT_MULTIPLIER = 2, hp._newlines = [10, 13], hp._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
  var up = { texture: true, children: false, baseTexture: true }, cp = function(t2) {
    function e2(e3, i2, n2) {
      var r2 = this, o2 = false;
      n2 || (n2 = document.createElement("canvas"), o2 = true), n2.width = 3, n2.height = 3;
      var s2 = Vh.t.from(n2);
      return s2.orig = new Lh.j(), s2.trim = new Lh.j(), (r2 = t2.call(this, s2) || this)._ownCanvas = o2, r2.canvas = n2, r2.context = r2.canvas.getContext("2d"), r2._resolution = xd.b.RESOLUTION, r2._autoResolution = true, r2._text = null, r2._style = null, r2._styleListener = null, r2._font = "", r2.text = e3, r2.style = i2, r2.localStyleID = -1, r2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      ip(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype.updateText = function(t3) {
      var i2 = this._style;
      if (this.localStyleID !== i2.styleID && (this.dirty = true, this.localStyleID = i2.styleID), this.dirty || !t3) {
        this._font = this._style.toFontString();
        var n2, r2, o2 = this.context, s2 = hp.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), a2 = s2.width, l2 = s2.height, h2 = s2.lines, u2 = s2.lineHeight, c2 = s2.lineWidths, d2 = s2.maxLineWidth, p2 = s2.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a2) + 2 * i2.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, l2) + 2 * i2.padding) * this._resolution), o2.scale(this._resolution, this._resolution), o2.clearRect(0, 0, this.canvas.width, this.canvas.height), o2.font = this._font, o2.lineWidth = i2.strokeThickness, o2.textBaseline = i2.textBaseline, o2.lineJoin = i2.lineJoin, o2.miterLimit = i2.miterLimit;
        for (var f2 = i2.dropShadow ? 2 : 1, m2 = 0; m2 < f2; ++m2) {
          var g2 = i2.dropShadow && m2 === 0, v2 = g2 ? Math.ceil(Math.max(1, l2) + 2 * i2.padding) : 0, _2 = v2 * this._resolution;
          if (g2) {
            o2.fillStyle = "black", o2.strokeStyle = "black";
            var y2 = i2.dropShadowColor, x2 = Object(Ph.hex2rgb)(typeof y2 == "number" ? y2 : Object(Ph.string2hex)(y2)), b2 = i2.dropShadowBlur * this._resolution, T2 = i2.dropShadowDistance * this._resolution;
            o2.shadowColor = "rgba(" + 255 * x2[0] + "," + 255 * x2[1] + "," + 255 * x2[2] + "," + i2.dropShadowAlpha + ")", o2.shadowBlur = b2, o2.shadowOffsetX = Math.cos(i2.dropShadowAngle) * T2, o2.shadowOffsetY = Math.sin(i2.dropShadowAngle) * T2 + _2;
          } else
            o2.fillStyle = this._generateFillStyle(i2, h2, s2), o2.strokeStyle = i2.stroke, o2.shadowColor = "black", o2.shadowBlur = 0, o2.shadowOffsetX = 0, o2.shadowOffsetY = 0;
          var E2 = (u2 - p2.fontSize) / 2;
          (!e2.nextLineHeightBehavior || u2 - p2.fontSize < 0) && (E2 = 0);
          for (var S2 = 0; S2 < h2.length; S2++)
            n2 = i2.strokeThickness / 2, r2 = i2.strokeThickness / 2 + S2 * u2 + p2.ascent + E2, i2.align === "right" ? n2 += d2 - c2[S2] : i2.align === "center" && (n2 += (d2 - c2[S2]) / 2), i2.stroke && i2.strokeThickness && this.drawLetterSpacing(h2[S2], n2 + i2.padding, r2 + i2.padding - v2, true), i2.fill && this.drawLetterSpacing(h2[S2], n2 + i2.padding, r2 + i2.padding - v2);
        }
        this.updateTexture();
      }
    }, e2.prototype.drawLetterSpacing = function(t3, i2, n2, r2) {
      r2 === void 0 && (r2 = false);
      var o2 = this._style.letterSpacing, s2 = e2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (o2 === 0 || s2)
        return s2 && (this.context.letterSpacing = o2, this.context.textLetterSpacing = o2), void (r2 ? this.context.strokeText(t3, i2, n2) : this.context.fillText(t3, i2, n2));
      for (var a2 = i2, l2 = Array.from ? Array.from(t3) : t3.split(""), h2 = this.context.measureText(t3).width, u2 = 0, c2 = 0; c2 < l2.length; ++c2) {
        var d2 = l2[c2];
        r2 ? this.context.strokeText(d2, a2, n2) : this.context.fillText(d2, a2, n2);
        for (var p2 = "", f2 = c2 + 1; f2 < l2.length; ++f2)
          p2 += l2[f2];
        a2 += h2 - (u2 = this.context.measureText(p2).width) + o2, h2 = u2;
      }
    }, e2.prototype.updateTexture = function() {
      var t3 = this.canvas;
      if (this._style.trim) {
        var e3 = Object(Ph.trimCanvas)(t3);
        e3.data && (t3.width = e3.width, t3.height = e3.height, this.context.putImageData(e3.data, 0, 0));
      }
      var i2 = this._texture, n2 = this._style, r2 = n2.trim ? 0 : n2.padding, o2 = i2.baseTexture;
      i2.trim.width = i2._frame.width = t3.width / this._resolution, i2.trim.height = i2._frame.height = t3.height / this._resolution, i2.trim.x = -r2, i2.trim.y = -r2, i2.orig.width = i2._frame.width - 2 * r2, i2.orig.height = i2._frame.height - 2 * r2, this._onTextureUpdate(), o2.setRealSize(t3.width, t3.height, this._resolution), i2.updateUvs(), this.dirty = false;
    }, e2.prototype._render = function(e3) {
      this._autoResolution && this._resolution !== e3.resolution && (this._resolution = e3.resolution, this.dirty = true), this.updateText(true), t2.prototype._render.call(this, e3);
    }, e2.prototype.updateTransform = function() {
      this.updateText(true), t2.prototype.updateTransform.call(this);
    }, e2.prototype.getBounds = function(e3, i2) {
      return this.updateText(true), this._textureID === -1 && (e3 = false), t2.prototype.getBounds.call(this, e3, i2);
    }, e2.prototype.getLocalBounds = function(e3) {
      return this.updateText(true), t2.prototype.getLocalBounds.call(this, e3);
    }, e2.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, e2.prototype._generateFillStyle = function(t3, e3, i2) {
      var n2, r2 = t3.fill;
      if (!Array.isArray(r2))
        return r2;
      if (r2.length === 1)
        return r2[0];
      var o2 = t3.dropShadow ? t3.dropShadowDistance : 0, s2 = t3.padding || 0, a2 = this.canvas.width / this._resolution - o2 - 2 * s2, l2 = this.canvas.height / this._resolution - o2 - 2 * s2, h2 = r2.slice(), u2 = t3.fillGradientStops.slice();
      if (!u2.length)
        for (var c2 = h2.length + 1, d2 = 1; d2 < c2; ++d2)
          u2.push(d2 / c2);
      if (h2.unshift(r2[0]), u2.unshift(0), h2.push(r2[r2.length - 1]), u2.push(1), t3.fillGradientType === Qd.LINEAR_VERTICAL) {
        n2 = this.context.createLinearGradient(a2 / 2, s2, a2 / 2, l2 + s2);
        var p2 = i2.fontProperties.fontSize + t3.strokeThickness;
        for (d2 = 0; d2 < e3.length; d2++) {
          var f2 = i2.lineHeight * (d2 - 1) + p2, m2 = i2.lineHeight * d2, g2 = m2;
          d2 > 0 && f2 > m2 && (g2 = (m2 + f2) / 2);
          var v2 = m2 + p2, _2 = i2.lineHeight * (d2 + 1), y2 = v2;
          d2 + 1 < e3.length && _2 < v2 && (y2 = (v2 + _2) / 2);
          for (var x2 = (y2 - g2) / l2, b2 = 0; b2 < h2.length; b2++) {
            var T2 = 0;
            T2 = typeof u2[b2] == "number" ? u2[b2] : b2 / h2.length;
            var E2 = Math.min(1, Math.max(0, g2 / l2 + T2 * x2));
            E2 = Number(E2.toFixed(5)), n2.addColorStop(E2, h2[b2]);
          }
        }
      } else {
        n2 = this.context.createLinearGradient(s2, l2 / 2, a2 + s2, l2 / 2);
        var S2 = h2.length + 1, w2 = 1;
        for (d2 = 0; d2 < h2.length; d2++) {
          var A2 = void 0;
          A2 = typeof u2[d2] == "number" ? u2[d2] : w2 / S2, n2.addColorStop(A2, h2[d2]), w2++;
        }
      }
      return n2;
    }, e2.prototype.destroy = function(e3) {
      typeof e3 == "boolean" && (e3 = { children: e3 }), e3 = Object.assign({}, up, e3), t2.prototype.destroy.call(this, e3), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
    }, set: function(t3) {
      this.updateText(true);
      var e3 = Object(Ph.sign)(this.scale.x) || 1;
      this.scale.x = e3 * t3 / this._texture.orig.width, this._width = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
    }, set: function(t3) {
      this.updateText(true);
      var e3 = Object(Ph.sign)(this.scale.y) || 1;
      this.scale.y = e3 * t3 / this._texture.orig.height, this._height = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "style", { get: function() {
      return this._style;
    }, set: function(t3) {
      t3 = t3 || {}, this._style = t3 instanceof op ? t3 : new op(t3), this.localStyleID = -1, this.dirty = true;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "text", { get: function() {
      return this._text;
    }, set: function(t3) {
      t3 = String(t3 == null ? "" : t3), this._text !== t3 && (this._text = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
      return this._resolution;
    }, set: function(t3) {
      this._autoResolution = false, this._resolution !== t3 && (this._resolution = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), e2.nextLineHeightBehavior = false, e2.experimentalLetterSpacing = false, e2;
  }(ep);
  /*!
   * @pixi/prepare - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/prepare is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  xd.b.UPLOADS_PER_FRAME = 4;
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var dp = function(t2, e2) {
    return (dp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var pp = function() {
    function t2(t3) {
      this.maxItemsPerFrame = t3, this.itemsLeft = 0;
    }
    return t2.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, t2.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, t2;
  }();
  function fp(t2, e2) {
    var i2 = false;
    if (t2 && t2._textures && t2._textures.length) {
      for (var n2 = 0; n2 < t2._textures.length; n2++)
        if (t2._textures[n2] instanceof Vh.t) {
          var r2 = t2._textures[n2].baseTexture;
          e2.indexOf(r2) === -1 && (e2.push(r2), i2 = true);
        }
    }
    return i2;
  }
  function mp(t2, e2) {
    if (t2.baseTexture instanceof Vh.c) {
      var i2 = t2.baseTexture;
      return e2.indexOf(i2) === -1 && e2.push(i2), true;
    }
    return false;
  }
  function gp(t2, e2) {
    if (t2._texture && t2._texture instanceof Vh.t) {
      var i2 = t2._texture.baseTexture;
      return e2.indexOf(i2) === -1 && e2.push(i2), true;
    }
    return false;
  }
  function vp(t2, e2) {
    return e2 instanceof cp && (e2.updateText(true), true);
  }
  function _p(t2, e2) {
    if (e2 instanceof op) {
      var i2 = e2.toFontString();
      return hp.measureFont(i2), true;
    }
    return false;
  }
  function yp(t2, e2) {
    if (t2 instanceof cp) {
      e2.indexOf(t2.style) === -1 && e2.push(t2.style), e2.indexOf(t2) === -1 && e2.push(t2);
      var i2 = t2._texture.baseTexture;
      return e2.indexOf(i2) === -1 && e2.push(i2), true;
    }
    return false;
  }
  function xp(t2, e2) {
    return t2 instanceof op && (e2.indexOf(t2) === -1 && e2.push(t2), true);
  }
  var bp = function() {
    function t2(t3) {
      var e2 = this;
      this.limiter = new pp(xd.b.UPLOADS_PER_FRAME), this.renderer = t3, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = false, this.delayedTick = function() {
        e2.queue && e2.prepareItems();
      }, this.registerFindHook(yp), this.registerFindHook(xp), this.registerFindHook(fp), this.registerFindHook(mp), this.registerFindHook(gp), this.registerUploadHook(vp), this.registerUploadHook(_p);
    }
    return t2.prototype.upload = function(t3, e2) {
      typeof t3 == "function" && (e2 = t3, t3 = null), t3 && this.add(t3), this.queue.length ? (e2 && this.completes.push(e2), this.ticking || (this.ticking = true, Dh.a.system.addOnce(this.tick, this, Dh.c.UTILITY))) : e2 && e2();
    }, t2.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, t2.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t3 = this.queue[0], e2 = false;
        if (t3 && !t3._destroyed) {
          for (var i2 = 0, n2 = this.uploadHooks.length; i2 < n2; i2++)
            if (this.uploadHooks[i2](this.uploadHookHelper, t3)) {
              this.queue.shift(), e2 = true;
              break;
            }
        }
        e2 || this.queue.shift();
      }
      if (this.queue.length)
        Dh.a.system.addOnce(this.tick, this, Dh.c.UTILITY);
      else {
        this.ticking = false;
        var r2 = this.completes.slice(0);
        this.completes.length = 0;
        for (i2 = 0, n2 = r2.length; i2 < n2; i2++)
          r2[i2]();
      }
    }, t2.prototype.registerFindHook = function(t3) {
      return t3 && this.addHooks.push(t3), this;
    }, t2.prototype.registerUploadHook = function(t3) {
      return t3 && this.uploadHooks.push(t3), this;
    }, t2.prototype.add = function(t3) {
      for (var e2 = 0, i2 = this.addHooks.length; e2 < i2 && !this.addHooks[e2](t3, this.queue); e2++)
        ;
      if (t3 instanceof Oh.b)
        for (e2 = t3.children.length - 1; e2 >= 0; e2--)
          this.add(t3.children[e2]);
      return this;
    }, t2.prototype.destroy = function() {
      this.ticking && Dh.a.system.remove(this.tick, this), this.ticking = false, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, t2;
  }();
  function Tp(t2, e2) {
    return e2 instanceof Vh.c && (e2._glTextures[t2.CONTEXT_UID] || t2.texture.bind(e2), true);
  }
  function Ep(t2, e2) {
    if (!(e2 instanceof Jd))
      return false;
    var i2 = e2.geometry;
    e2.finishPoly(), i2.updateBatches();
    for (var n2 = i2.batches, r2 = 0; r2 < n2.length; r2++) {
      var o2 = n2[r2].style.texture;
      o2 && Tp(t2, o2.baseTexture);
    }
    return i2.batchable || t2.geometry.bind(i2, e2._resolveDirectShader(t2)), true;
  }
  function Sp(t2, e2) {
    return t2 instanceof Jd && (e2.push(t2), true);
  }
  var wp = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.uploadHookHelper = i2.renderer, i2.registerFindHook(Sp), i2.registerUploadHook(Tp), i2.registerUploadHook(Ep), i2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      dp(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2;
  }(bp), Ap = function() {
    function t2(t3, e2, i2) {
      i2 === void 0 && (i2 = null), this._texture = t3 instanceof Vh.t ? t3 : null, this.baseTexture = t3 instanceof Vh.c ? t3 : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e2;
      var n2 = this.baseTexture.resource;
      this.resolution = this._updateResolution(i2 || (n2 ? n2.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return t2.prototype._updateResolution = function(t3) {
      t3 === void 0 && (t3 = null);
      var e2 = this.data.meta.scale, i2 = Object(Ph.getResolutionOfUrl)(t3, null);
      return i2 === null && (i2 = e2 !== void 0 ? parseFloat(e2) : 1), i2 !== 1 && this.baseTexture.setResolution(i2), i2;
    }, t2.prototype.parse = function(e2) {
      this._batchIndex = 0, this._callback = e2, this._frameKeys.length <= t2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    }, t2.prototype._processFrames = function(e2) {
      for (var i2 = e2, n2 = t2.BATCH_SIZE; i2 - e2 < n2 && i2 < this._frameKeys.length; ) {
        var r2 = this._frameKeys[i2], o2 = this._frames[r2], s2 = o2.frame;
        if (s2) {
          var a2 = null, l2 = null, h2 = o2.trimmed !== false && o2.sourceSize ? o2.sourceSize : o2.frame, u2 = new Lh.j(0, 0, Math.floor(h2.w) / this.resolution, Math.floor(h2.h) / this.resolution);
          a2 = o2.rotated ? new Lh.j(Math.floor(s2.x) / this.resolution, Math.floor(s2.y) / this.resolution, Math.floor(s2.h) / this.resolution, Math.floor(s2.w) / this.resolution) : new Lh.j(Math.floor(s2.x) / this.resolution, Math.floor(s2.y) / this.resolution, Math.floor(s2.w) / this.resolution, Math.floor(s2.h) / this.resolution), o2.trimmed !== false && o2.spriteSourceSize && (l2 = new Lh.j(Math.floor(o2.spriteSourceSize.x) / this.resolution, Math.floor(o2.spriteSourceSize.y) / this.resolution, Math.floor(s2.w) / this.resolution, Math.floor(s2.h) / this.resolution)), this.textures[r2] = new Vh.t(this.baseTexture, a2, u2, l2, o2.rotated ? 2 : 0, o2.anchor), Vh.t.addToCache(this.textures[r2], r2);
        }
        i2++;
      }
    }, t2.prototype._processAnimations = function() {
      var t3 = this.data.animations || {};
      for (var e2 in t3) {
        this.animations[e2] = [];
        for (var i2 = 0; i2 < t3[e2].length; i2++) {
          var n2 = t3[e2][i2];
          this.animations[e2].push(this.textures[n2]);
        }
      }
    }, t2.prototype._parseComplete = function() {
      var t3 = this._callback;
      this._callback = null, this._batchIndex = 0, t3.call(this, this.textures);
    }, t2.prototype._nextBatch = function() {
      var e2 = this;
      this._processFrames(this._batchIndex * t2.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        e2._batchIndex * t2.BATCH_SIZE < e2._frameKeys.length ? e2._nextBatch() : (e2._processAnimations(), e2._parseComplete());
      }, 0);
    }, t2.prototype.destroy = function(t3) {
      var e2;
      for (var i2 in t3 === void 0 && (t3 = false), this.textures)
        this.textures[i2].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t3 && ((e2 = this._texture) === null || e2 === void 0 || e2.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null;
    }, t2.BATCH_SIZE = 1e3, t2;
  }(), Mp = function() {
    function t2() {
    }
    return t2.use = function(e2, i2) {
      var n2, r2, o2 = this, s2 = e2.name + "_image";
      if (e2.data && e2.type === pc.TYPE.JSON && e2.data.frames && !o2.resources[s2]) {
        var a2 = (r2 = (n2 = e2.data) === null || n2 === void 0 ? void 0 : n2.meta) === null || r2 === void 0 ? void 0 : r2.related_multi_packs;
        if (Array.isArray(a2))
          for (var l2 = function(t3) {
            if (typeof t3 != "string")
              return "continue";
            var i3 = t3.replace(".json", ""), n3 = Ph.url.resolve(e2.url.replace(o2.baseUrl, ""), t3);
            if (o2.resources[i3] || Object.values(o2.resources).some(function(t4) {
              return Ph.url.format(Ph.url.parse(t4.url)) === n3;
            }))
              return "continue";
            var r3 = { crossOrigin: e2.crossOrigin, loadType: pc.LOAD_TYPE.XHR, xhrType: pc.XHR_RESPONSE_TYPE.JSON, parentResource: e2, metadata: e2.metadata };
            o2.add(i3, n3, r3);
          }, h2 = 0, u2 = a2; h2 < u2.length; h2++) {
            l2(u2[h2]);
          }
        var c2 = { crossOrigin: e2.crossOrigin, metadata: e2.metadata.imageMetadata, parentResource: e2 }, d2 = t2.getResourcePath(e2, o2.baseUrl);
        o2.add(s2, d2, c2, function(t3) {
          if (t3.error)
            i2(t3.error);
          else {
            var n3 = new Ap(t3.texture, e2.data, e2.url);
            n3.parse(function() {
              e2.spritesheet = n3, e2.textures = n3.textures, i2();
            });
          }
        });
      } else
        i2();
    }, t2.getResourcePath = function(t3, e2) {
      return t3.isDataUrl ? t3.data.meta.image : Ph.url.resolve(t3.url.replace(e2, ""), t3.data.meta.image);
    }, t2;
  }(), Rp = function(t2, e2) {
    return (Rp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function Cp(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    Rp(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var Ip = new Lh.g(), Pp = function(t2) {
    function e2(e3, i2, n2) {
      i2 === void 0 && (i2 = 100), n2 === void 0 && (n2 = 100);
      var r2 = t2.call(this, e3) || this;
      return r2.tileTransform = new Lh.m(), r2._width = i2, r2._height = n2, r2.uvMatrix = r2.texture.uvMatrix || new Vh.u(e3), r2.pluginName = "tilingSprite", r2.uvRespectAnchor = false, r2;
    }
    return Cp(e2, t2), Object.defineProperty(e2.prototype, "clampMargin", { get: function() {
      return this.uvMatrix.clampMargin;
    }, set: function(t3) {
      this.uvMatrix.clampMargin = t3, this.uvMatrix.update(true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tileScale", { get: function() {
      return this.tileTransform.scale;
    }, set: function(t3) {
      this.tileTransform.scale.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tilePosition", { get: function() {
      return this.tileTransform.position;
    }, set: function(t3) {
      this.tileTransform.position.copyFrom(t3);
    }, enumerable: false, configurable: true }), e2.prototype._onTextureUpdate = function() {
      this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
    }, e2.prototype._render = function(t3) {
      var e3 = this._texture;
      e3 && e3.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), t3.plugins[this.pluginName].render(this));
    }, e2.prototype._calculateBounds = function() {
      var t3 = this._width * -this._anchor._x, e3 = this._height * -this._anchor._y, i2 = this._width * (1 - this._anchor._x), n2 = this._height * (1 - this._anchor._y);
      this._bounds.addFrame(this.transform, t3, e3, i2, n2);
    }, e2.prototype.getLocalBounds = function(e3) {
      return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), e3 = this._localBoundsRect), this._bounds.getRectangle(e3)) : t2.prototype.getLocalBounds.call(this, e3);
    }, e2.prototype.containsPoint = function(t3) {
      this.worldTransform.applyInverse(t3, Ip);
      var e3 = this._width, i2 = this._height, n2 = -e3 * this.anchor._x;
      if (Ip.x >= n2 && Ip.x < n2 + e3) {
        var r2 = -i2 * this.anchor._y;
        if (Ip.y >= r2 && Ip.y < r2 + i2)
          return true;
      }
      return false;
    }, e2.prototype.destroy = function(e3) {
      t2.prototype.destroy.call(this, e3), this.tileTransform = null, this.uvMatrix = null;
    }, e2.from = function(t3, i2) {
      return new e2(t3 instanceof Vh.t ? t3 : Vh.t.from(t3, i2), i2.width, i2.height);
    }, Object.defineProperty(e2.prototype, "width", { get: function() {
      return this._width;
    }, set: function(t3) {
      this._width = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this._height;
    }, set: function(t3) {
      this._height = t3;
    }, enumerable: false, configurable: true }), e2;
  }(ep), Op = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", Np = new Lh.d(), Lp = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return e3.runners.contextChange.add(i2), i2.quad = new Vh.o(), i2.state = Vh.s.for2d(), i2;
    }
    return Cp(e2, t2), e2.prototype.contextChange = function() {
      var t3 = this.renderer, e3 = { globals: t3.globalUniforms };
      this.simpleShader = Vh.r.from(Op, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e3), this.shader = t3.context.webGLVersion > 1 ? Vh.r.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e3) : Vh.r.from(Op, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e3);
    }, e2.prototype.render = function(t3) {
      var e3 = this.renderer, i2 = this.quad, n2 = i2.vertices;
      n2[0] = n2[6] = t3._width * -t3.anchor.x, n2[1] = n2[3] = t3._height * -t3.anchor.y, n2[2] = n2[4] = t3._width * (1 - t3.anchor.x), n2[5] = n2[7] = t3._height * (1 - t3.anchor.y);
      var r2 = t3.uvRespectAnchor ? t3.anchor.x : 0, o2 = t3.uvRespectAnchor ? t3.anchor.y : 0;
      (n2 = i2.uvs)[0] = n2[6] = -r2, n2[1] = n2[3] = -o2, n2[2] = n2[4] = 1 - r2, n2[5] = n2[7] = 1 - o2, i2.invalidate();
      var s2 = t3._texture, a2 = s2.baseTexture, l2 = t3.tileTransform.localTransform, h2 = t3.uvMatrix, u2 = a2.isPowerOfTwo && s2.frame.width === a2.width && s2.frame.height === a2.height;
      u2 && (a2._glTextures[e3.CONTEXT_UID] ? u2 = a2.wrapMode !== Sc.s.CLAMP : a2.wrapMode === Sc.s.CLAMP && (a2.wrapMode = Sc.s.REPEAT));
      var c2 = u2 ? this.simpleShader : this.shader, d2 = s2.width, p2 = s2.height, f2 = t3._width, m2 = t3._height;
      Np.set(l2.a * d2 / f2, l2.b * d2 / m2, l2.c * p2 / f2, l2.d * p2 / m2, l2.tx / f2, l2.ty / m2), Np.invert(), u2 ? Np.prepend(h2.mapCoord) : (c2.uniforms.uMapCoord = h2.mapCoord.toArray(true), c2.uniforms.uClampFrame = h2.uClampFrame, c2.uniforms.uClampOffset = h2.uClampOffset), c2.uniforms.uTransform = Np.toArray(true), c2.uniforms.uColor = Object(Ph.premultiplyTintToRgba)(t3.tint, t3.worldAlpha, c2.uniforms.uColor, a2.alphaMode), c2.uniforms.translationMatrix = t3.transform.worldTransform.toArray(true), c2.uniforms.uSampler = s2, e3.shader.bind(c2), e3.geometry.bind(i2), this.state.blendMode = Object(Ph.correctBlendMode)(t3.blendMode, a2.alphaMode), e3.state.set(this.state), e3.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, e2;
  }(Vh.m), Dp = i(8), Fp = function(t2, e2) {
    return (Fp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Bp = function() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }, Up = function() {
    function t2() {
    }
    return t2.test = function(t3) {
      return typeof t3 == "string" && t3.indexOf("info face=") === 0;
    }, t2.parse = function(t3) {
      var e2 = t3.match(/^[a-z]+\s+.+$/gm), i2 = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
      for (var n2 in e2) {
        var r2 = e2[n2].match(/^[a-z]+/gm)[0], o2 = e2[n2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), s2 = {};
        for (var a2 in o2) {
          var l2 = o2[a2].split("="), h2 = l2[0], u2 = l2[1].replace(/"/gm, ""), c2 = parseFloat(u2), d2 = isNaN(c2) ? u2 : c2;
          s2[h2] = d2;
        }
        i2[r2].push(s2);
      }
      var p2 = new Bp();
      return i2.info.forEach(function(t4) {
        return p2.info.push({ face: t4.face, size: parseInt(t4.size, 10) });
      }), i2.common.forEach(function(t4) {
        return p2.common.push({ lineHeight: parseInt(t4.lineHeight, 10) });
      }), i2.page.forEach(function(t4) {
        return p2.page.push({ id: parseInt(t4.id, 10), file: t4.file });
      }), i2.char.forEach(function(t4) {
        return p2.char.push({ id: parseInt(t4.id, 10), page: parseInt(t4.page, 10), x: parseInt(t4.x, 10), y: parseInt(t4.y, 10), width: parseInt(t4.width, 10), height: parseInt(t4.height, 10), xoffset: parseInt(t4.xoffset, 10), yoffset: parseInt(t4.yoffset, 10), xadvance: parseInt(t4.xadvance, 10) });
      }), i2.kerning.forEach(function(t4) {
        return p2.kerning.push({ first: parseInt(t4.first, 10), second: parseInt(t4.second, 10), amount: parseInt(t4.amount, 10) });
      }), i2.distanceField.forEach(function(t4) {
        return p2.distanceField.push({ distanceRange: parseInt(t4.distanceRange, 10), fieldType: t4.fieldType });
      }), p2;
    }, t2;
  }(), kp = function() {
    function t2() {
    }
    return t2.test = function(t3) {
      return t3 instanceof XMLDocument && t3.getElementsByTagName("page").length && t3.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, t2.parse = function(t3) {
      for (var e2 = new Bp(), i2 = t3.getElementsByTagName("info"), n2 = t3.getElementsByTagName("common"), r2 = t3.getElementsByTagName("page"), o2 = t3.getElementsByTagName("char"), s2 = t3.getElementsByTagName("kerning"), a2 = t3.getElementsByTagName("distanceField"), l2 = 0; l2 < i2.length; l2++)
        e2.info.push({ face: i2[l2].getAttribute("face"), size: parseInt(i2[l2].getAttribute("size"), 10) });
      for (l2 = 0; l2 < n2.length; l2++)
        e2.common.push({ lineHeight: parseInt(n2[l2].getAttribute("lineHeight"), 10) });
      for (l2 = 0; l2 < r2.length; l2++)
        e2.page.push({ id: parseInt(r2[l2].getAttribute("id"), 10) || 0, file: r2[l2].getAttribute("file") });
      for (l2 = 0; l2 < o2.length; l2++) {
        var h2 = o2[l2];
        e2.char.push({ id: parseInt(h2.getAttribute("id"), 10), page: parseInt(h2.getAttribute("page"), 10) || 0, x: parseInt(h2.getAttribute("x"), 10), y: parseInt(h2.getAttribute("y"), 10), width: parseInt(h2.getAttribute("width"), 10), height: parseInt(h2.getAttribute("height"), 10), xoffset: parseInt(h2.getAttribute("xoffset"), 10), yoffset: parseInt(h2.getAttribute("yoffset"), 10), xadvance: parseInt(h2.getAttribute("xadvance"), 10) });
      }
      for (l2 = 0; l2 < s2.length; l2++)
        e2.kerning.push({ first: parseInt(s2[l2].getAttribute("first"), 10), second: parseInt(s2[l2].getAttribute("second"), 10), amount: parseInt(s2[l2].getAttribute("amount"), 10) });
      for (l2 = 0; l2 < a2.length; l2++)
        e2.distanceField.push({ fieldType: a2[l2].getAttribute("fieldType"), distanceRange: parseInt(a2[l2].getAttribute("distanceRange"), 10) });
      return e2;
    }, t2;
  }(), Gp = function() {
    function t2() {
    }
    return t2.test = function(t3) {
      if (typeof t3 == "string" && t3.indexOf("<font>") > -1) {
        var e2 = new globalThis.DOMParser().parseFromString(t3, "text/xml");
        return kp.test(e2);
      }
      return false;
    }, t2.parse = function(t3) {
      var e2 = new globalThis.DOMParser().parseFromString(t3, "text/xml");
      return kp.parse(e2);
    }, t2;
  }(), Hp = [Up, kp, Gp];
  function jp(t2) {
    for (var e2 = 0; e2 < Hp.length; e2++)
      if (Hp[e2].test(t2))
        return Hp[e2];
    return null;
  }
  function zp(t2, e2, i2, n2, r2, o2, s2) {
    var a2 = i2.text, l2 = i2.fontProperties;
    e2.translate(n2, r2), e2.scale(o2, o2);
    var h2 = s2.strokeThickness / 2, u2 = -s2.strokeThickness / 2;
    if (e2.font = s2.toFontString(), e2.lineWidth = s2.strokeThickness, e2.textBaseline = s2.textBaseline, e2.lineJoin = s2.lineJoin, e2.miterLimit = s2.miterLimit, e2.fillStyle = function(t3, e3, i3, n3, r3, o3) {
      var s3, a3 = i3.fill;
      if (!Array.isArray(a3))
        return a3;
      if (a3.length === 1)
        return a3[0];
      var l3 = i3.dropShadow ? i3.dropShadowDistance : 0, h3 = i3.padding || 0, u3 = t3.width / n3 - l3 - 2 * h3, c3 = t3.height / n3 - l3 - 2 * h3, d3 = a3.slice(), p3 = i3.fillGradientStops.slice();
      if (!p3.length)
        for (var f3 = d3.length + 1, m2 = 1; m2 < f3; ++m2)
          p3.push(m2 / f3);
      if (d3.unshift(a3[0]), p3.unshift(0), d3.push(a3[a3.length - 1]), p3.push(1), i3.fillGradientType === Qd.LINEAR_VERTICAL) {
        s3 = e3.createLinearGradient(u3 / 2, h3, u3 / 2, c3 + h3);
        var g2 = 0, v2 = (o3.fontProperties.fontSize + i3.strokeThickness) / c3;
        for (m2 = 0; m2 < r3.length; m2++)
          for (var _2 = o3.lineHeight * m2, y2 = 0; y2 < d3.length; y2++) {
            var x2 = _2 / c3 + (typeof p3[y2] == "number" ? p3[y2] : y2 / d3.length) * v2, b2 = Math.max(g2, x2);
            b2 = Math.min(b2, 1), s3.addColorStop(b2, d3[y2]), g2 = b2;
          }
      } else {
        s3 = e3.createLinearGradient(h3, c3 / 2, u3 + h3, c3 / 2);
        var T2 = d3.length + 1, E2 = 1;
        for (m2 = 0; m2 < d3.length; m2++) {
          var S2 = void 0;
          S2 = typeof p3[m2] == "number" ? p3[m2] : E2 / T2, s3.addColorStop(S2, d3[m2]), E2++;
        }
      }
      return s3;
    }(t2, e2, s2, o2, [a2], i2), e2.strokeStyle = s2.stroke, s2.dropShadow) {
      var c2 = s2.dropShadowColor, d2 = Object(Ph.hex2rgb)(typeof c2 == "number" ? c2 : Object(Ph.string2hex)(c2)), p2 = s2.dropShadowBlur * o2, f2 = s2.dropShadowDistance * o2;
      e2.shadowColor = "rgba(" + 255 * d2[0] + "," + 255 * d2[1] + "," + 255 * d2[2] + "," + s2.dropShadowAlpha + ")", e2.shadowBlur = p2, e2.shadowOffsetX = Math.cos(s2.dropShadowAngle) * f2, e2.shadowOffsetY = Math.sin(s2.dropShadowAngle) * f2;
    } else
      e2.shadowColor = "black", e2.shadowBlur = 0, e2.shadowOffsetX = 0, e2.shadowOffsetY = 0;
    s2.stroke && s2.strokeThickness && e2.strokeText(a2, h2, u2 + i2.lineHeight - l2.descent), s2.fill && e2.fillText(a2, h2, u2 + i2.lineHeight - l2.descent), e2.setTransform(1, 0, 0, 1, 0, 0), e2.fillStyle = "rgba(0, 0, 0, 0)";
  }
  function Vp(t2) {
    return Array.from ? Array.from(t2) : t2.split("");
  }
  function Xp(t2) {
    return t2.codePointAt ? t2.codePointAt(0) : t2.charCodeAt(0);
  }
  var Wp = function() {
    function t2(t3, e2, i2) {
      var n2, r2, o2 = t3.info[0], s2 = t3.common[0], a2 = t3.page[0], l2 = t3.distanceField[0], h2 = Object(Ph.getResolutionOfUrl)(a2.file), u2 = {};
      this._ownsTextures = i2, this.font = o2.face, this.size = o2.size, this.lineHeight = s2.lineHeight / h2, this.chars = {}, this.pageTextures = u2;
      for (var c2 = 0; c2 < t3.page.length; c2++) {
        var d2 = t3.page[c2], p2 = d2.id, f2 = d2.file;
        u2[p2] = e2 instanceof Array ? e2[c2] : e2[f2], (l2 == null ? void 0 : l2.fieldType) && l2.fieldType !== "none" && (u2[p2].baseTexture.alphaMode = Sc.a.NO_PREMULTIPLIED_ALPHA);
      }
      for (c2 = 0; c2 < t3.char.length; c2++) {
        var m2 = t3.char[c2], g2 = (p2 = m2.id, m2.page), v2 = t3.char[c2], _2 = v2.x, y2 = v2.y, x2 = v2.width, b2 = v2.height, T2 = v2.xoffset, E2 = v2.yoffset, S2 = v2.xadvance;
        _2 /= h2, y2 /= h2, x2 /= h2, b2 /= h2, T2 /= h2, E2 /= h2, S2 /= h2;
        var w2 = new Lh.j(_2 + u2[g2].frame.x / h2, y2 + u2[g2].frame.y / h2, x2, b2);
        this.chars[p2] = { xOffset: T2, yOffset: E2, xAdvance: S2, kerning: {}, texture: new Vh.t(u2[g2].baseTexture, w2), page: g2 };
      }
      for (c2 = 0; c2 < t3.kerning.length; c2++) {
        var A2 = t3.kerning[c2], M2 = A2.first, R2 = A2.second, C2 = A2.amount;
        M2 /= h2, R2 /= h2, C2 /= h2, this.chars[R2] && (this.chars[R2].kerning[M2] = C2);
      }
      this.distanceFieldRange = l2 == null ? void 0 : l2.distanceRange, this.distanceFieldType = (r2 = (n2 = l2 == null ? void 0 : l2.fieldType) === null || n2 === void 0 ? void 0 : n2.toLowerCase()) !== null && r2 !== void 0 ? r2 : "none";
    }
    return t2.prototype.destroy = function() {
      for (var t3 in this.chars)
        this.chars[t3].texture.destroy(), this.chars[t3].texture = null;
      for (var t3 in this.pageTextures)
        this._ownsTextures && this.pageTextures[t3].destroy(true), this.pageTextures[t3] = null;
      this.chars = null, this.pageTextures = null;
    }, t2.install = function(e2, i2, n2) {
      var r2;
      if (e2 instanceof Bp)
        r2 = e2;
      else {
        var o2 = jp(e2);
        if (!o2)
          throw new Error("Unrecognized data format for font.");
        r2 = o2.parse(e2);
      }
      i2 instanceof Vh.t && (i2 = [i2]);
      var s2 = new t2(r2, i2, n2);
      return t2.available[s2.font] = s2, s2;
    }, t2.uninstall = function(e2) {
      var i2 = t2.available[e2];
      if (!i2)
        throw new Error("No font found named '" + e2 + "'");
      i2.destroy(), delete t2.available[e2];
    }, t2.from = function(e2, i2, n2) {
      if (!e2)
        throw new Error("[BitmapFont] Property `name` is required.");
      var r2 = Object.assign({}, t2.defaultOptions, n2), o2 = r2.chars, s2 = r2.padding, a2 = r2.resolution, l2 = r2.textureWidth, h2 = r2.textureHeight, u2 = function(t3) {
        typeof t3 == "string" && (t3 = [t3]);
        for (var e3 = [], i3 = 0, n3 = t3.length; i3 < n3; i3++) {
          var r3 = t3[i3];
          if (Array.isArray(r3)) {
            if (r3.length !== 2)
              throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + r3.length + ".");
            var o3 = r3[0].charCodeAt(0), s3 = r3[1].charCodeAt(0);
            if (s3 < o3)
              throw new Error("[BitmapFont]: Invalid character range.");
            for (var a3 = o3, l3 = s3; a3 <= l3; a3++)
              e3.push(String.fromCharCode(a3));
          } else
            e3.push.apply(e3, Vp(r3));
        }
        if (e3.length === 0)
          throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e3;
      }(o2), c2 = i2 instanceof op ? i2 : new op(i2), d2 = l2, p2 = new Bp();
      p2.info[0] = { face: c2.fontFamily, size: c2.fontSize }, p2.common[0] = { lineHeight: c2.fontSize };
      for (var f2, m2, g2, v2 = 0, _2 = 0, y2 = 0, x2 = [], b2 = 0; b2 < u2.length; b2++) {
        f2 || ((f2 = document.createElement("canvas")).width = l2, f2.height = h2, m2 = f2.getContext("2d"), g2 = new Vh.c(f2, { resolution: a2 }), x2.push(new Vh.t(g2)), p2.page.push({ id: x2.length - 1, file: "" }));
        var T2 = hp.measureText(u2[b2], c2, false, f2), E2 = T2.width, S2 = Math.ceil(T2.height), w2 = Math.ceil((c2.fontStyle === "italic" ? 2 : 1) * E2);
        if (_2 >= h2 - S2 * a2) {
          if (_2 === 0)
            throw new Error("[BitmapFont] textureHeight " + h2 + "px is too small for " + c2.fontSize + "px fonts");
          --b2, f2 = null, m2 = null, g2 = null, _2 = 0, v2 = 0, y2 = 0;
        } else if (y2 = Math.max(S2 + T2.fontProperties.descent, y2), w2 * a2 + v2 >= d2)
          --b2, _2 += y2 * a2, _2 = Math.ceil(_2), v2 = 0, y2 = 0;
        else {
          zp(f2, m2, T2, v2, _2, a2, c2);
          var A2 = Xp(T2.text);
          p2.char.push({ id: A2, page: x2.length - 1, x: v2 / a2, y: _2 / a2, width: w2, height: S2, xoffset: 0, yoffset: 0, xadvance: Math.ceil(E2 - (c2.dropShadow ? c2.dropShadowDistance : 0) - (c2.stroke ? c2.strokeThickness : 0)) }), v2 += (w2 + 2 * s2) * a2, v2 = Math.ceil(v2);
        }
      }
      b2 = 0;
      for (var M2 = u2.length; b2 < M2; b2++)
        for (var R2 = u2[b2], C2 = 0; C2 < M2; C2++) {
          var I2 = u2[C2], P2 = m2.measureText(R2).width, O2 = m2.measureText(I2).width, N2 = m2.measureText(R2 + I2).width - (P2 + O2);
          N2 && p2.kerning.push({ first: Xp(R2), second: Xp(I2), amount: N2 });
        }
      var L2 = new t2(p2, x2, true);
      return t2.available[e2] !== void 0 && t2.uninstall(e2), t2.available[e2] = L2, L2;
    }, t2.ALPHA = [["a", "z"], ["A", "Z"], " "], t2.NUMERIC = [["0", "9"]], t2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], t2.ASCII = [[" ", "~"]], t2.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: t2.ALPHANUMERIC }, t2.available = {}, t2;
  }(), Yp = [], qp = [], Zp = [], Jp = (function(t2) {
    function e2(i2, n2) {
      n2 === void 0 && (n2 = {});
      var r2 = t2.call(this) || this;
      r2._tint = 16777215;
      var o2 = Object.assign({}, e2.styleDefaults, n2), s2 = o2.align, a2 = o2.tint, l2 = o2.maxWidth, h2 = o2.letterSpacing, u2 = o2.fontName, c2 = o2.fontSize;
      if (!Wp.available[u2])
        throw new Error('Missing BitmapFont "' + u2 + '"');
      return r2._activePagesMeshData = [], r2._textWidth = 0, r2._textHeight = 0, r2._align = s2, r2._tint = a2, r2._fontName = u2, r2._fontSize = c2 || Wp.available[u2].size, r2.text = i2, r2._maxWidth = l2, r2._maxLineHeight = 0, r2._letterSpacing = h2, r2._anchor = new Lh.e(function() {
        r2.dirty = true;
      }, r2, 0, 0), r2._roundPixels = xd.b.ROUND_PIXELS, r2.dirty = true, r2._resolution = xd.b.RESOLUTION, r2._autoResolution = true, r2._textureCache = {}, r2;
    }
    (function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Fp(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    })(e2, t2), e2.prototype.updateText = function() {
      for (var t3, e3 = Wp.available[this._fontName], i2 = this._fontSize / e3.size, n2 = new Lh.g(), r2 = [], o2 = [], s2 = [], a2 = Vp(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "), l2 = this._maxWidth * e3.size / this._fontSize, h2 = e3.distanceFieldType === "none" ? Yp : qp, u2 = null, c2 = 0, d2 = 0, p2 = 0, f2 = -1, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = 0; y2 < a2.length; y2++) {
        var x2 = Xp(G2 = a2[y2]);
        if (/(?:\s)/.test(G2) && (f2 = y2, m2 = c2, _2++), G2 !== "\r" && G2 !== "\n") {
          var b2 = e3.chars[x2];
          if (b2) {
            u2 && b2.kerning[u2] && (n2.x += b2.kerning[u2]);
            var T2 = Zp.pop() || { texture: Vh.t.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new Lh.g() };
            T2.texture = b2.texture, T2.line = p2, T2.charCode = x2, T2.position.x = n2.x + b2.xOffset + this._letterSpacing / 2, T2.position.y = n2.y + b2.yOffset, T2.prevSpaces = _2, r2.push(T2), c2 = T2.position.x + Math.max(b2.xAdvance, b2.texture.orig.width), n2.x += b2.xAdvance + this._letterSpacing, v2 = Math.max(v2, b2.yOffset + b2.texture.height), u2 = x2, f2 !== -1 && l2 > 0 && n2.x > l2 && (++g2, Object(Ph.removeItems)(r2, 1 + f2 - g2, 1 + y2 - f2), y2 = f2, f2 = -1, o2.push(m2), s2.push(r2.length > 0 ? r2[r2.length - 1].prevSpaces : 0), d2 = Math.max(d2, m2), p2++, n2.x = 0, n2.y += e3.lineHeight, u2 = null, _2 = 0);
          }
        } else
          o2.push(c2), s2.push(-1), d2 = Math.max(d2, c2), ++p2, ++g2, n2.x = 0, n2.y += e3.lineHeight, u2 = null, _2 = 0;
      }
      var E2 = a2[a2.length - 1];
      E2 !== "\r" && E2 !== "\n" && (/(?:\s)/.test(E2) && (c2 = m2), o2.push(c2), d2 = Math.max(d2, c2), s2.push(-1));
      var S2 = [];
      for (y2 = 0; y2 <= p2; y2++) {
        var w2 = 0;
        this._align === "right" ? w2 = d2 - o2[y2] : this._align === "center" ? w2 = (d2 - o2[y2]) / 2 : this._align === "justify" && (w2 = s2[y2] < 0 ? 0 : (d2 - o2[y2]) / s2[y2]), S2.push(w2);
      }
      var A2 = r2.length, M2 = {}, R2 = [], C2 = this._activePagesMeshData;
      for (y2 = 0; y2 < C2.length; y2++)
        h2.push(C2[y2]);
      for (y2 = 0; y2 < A2; y2++) {
        var I2 = (j2 = r2[y2].texture).baseTexture.uid;
        if (!M2[I2]) {
          if (!(Z2 = h2.pop())) {
            var P2 = new Dp.b(), O2 = void 0, N2 = void 0;
            e3.distanceFieldType === "none" ? (O2 = new Dp.c(Vh.t.EMPTY), N2 = Sc.b.NORMAL) : (O2 = new Dp.c(Vh.t.EMPTY, { program: Vh.n.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n"), uniforms: { uFWidth: 0 } }), N2 = Sc.b.NORMAL_NPM);
            var L2 = new Dp.a(P2, O2);
            L2.blendMode = N2, Z2 = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: L2, vertices: null, uvs: null, indices: null };
          }
          Z2.index = 0, Z2.indexCount = 0, Z2.vertexCount = 0, Z2.uvsCount = 0, Z2.total = 0;
          var D2 = this._textureCache;
          D2[I2] = D2[I2] || new Vh.t(j2.baseTexture), Z2.mesh.texture = D2[I2], Z2.mesh.tint = this._tint, R2.push(Z2), M2[I2] = Z2;
        }
        M2[I2].total++;
      }
      for (y2 = 0; y2 < C2.length; y2++)
        R2.indexOf(C2[y2]) === -1 && this.removeChild(C2[y2].mesh);
      for (y2 = 0; y2 < R2.length; y2++)
        R2[y2].mesh.parent !== this && this.addChild(R2[y2].mesh);
      for (var y2 in this._activePagesMeshData = R2, M2) {
        var F2 = (Z2 = M2[y2]).total;
        if (!(((t3 = Z2.indices) === null || t3 === void 0 ? void 0 : t3.length) > 6 * F2) || Z2.vertices.length < 2 * Dp.a.BATCHABLE_SIZE)
          Z2.vertices = new Float32Array(8 * F2), Z2.uvs = new Float32Array(8 * F2), Z2.indices = new Uint16Array(6 * F2);
        else
          for (var B2 = Z2.total, U2 = Z2.vertices, k2 = 4 * B2 * 2; k2 < U2.length; k2++)
            U2[k2] = 0;
        Z2.mesh.size = 6 * F2;
      }
      for (y2 = 0; y2 < A2; y2++) {
        var G2, H2 = (G2 = r2[y2]).position.x + S2[G2.line] * (this._align === "justify" ? G2.prevSpaces : 1);
        this._roundPixels && (H2 = Math.round(H2));
        var j2, z2 = H2 * i2, V2 = G2.position.y * i2, X2 = M2[(j2 = G2.texture).baseTexture.uid], W2 = j2.frame, Y2 = j2._uvs, q2 = X2.index++;
        X2.indices[6 * q2 + 0] = 0 + 4 * q2, X2.indices[6 * q2 + 1] = 1 + 4 * q2, X2.indices[6 * q2 + 2] = 2 + 4 * q2, X2.indices[6 * q2 + 3] = 0 + 4 * q2, X2.indices[6 * q2 + 4] = 2 + 4 * q2, X2.indices[6 * q2 + 5] = 3 + 4 * q2, X2.vertices[8 * q2 + 0] = z2, X2.vertices[8 * q2 + 1] = V2, X2.vertices[8 * q2 + 2] = z2 + W2.width * i2, X2.vertices[8 * q2 + 3] = V2, X2.vertices[8 * q2 + 4] = z2 + W2.width * i2, X2.vertices[8 * q2 + 5] = V2 + W2.height * i2, X2.vertices[8 * q2 + 6] = z2, X2.vertices[8 * q2 + 7] = V2 + W2.height * i2, X2.uvs[8 * q2 + 0] = Y2.x0, X2.uvs[8 * q2 + 1] = Y2.y0, X2.uvs[8 * q2 + 2] = Y2.x1, X2.uvs[8 * q2 + 3] = Y2.y1, X2.uvs[8 * q2 + 4] = Y2.x2, X2.uvs[8 * q2 + 5] = Y2.y2, X2.uvs[8 * q2 + 6] = Y2.x3, X2.uvs[8 * q2 + 7] = Y2.y3;
      }
      for (var y2 in this._textWidth = d2 * i2, this._textHeight = (n2.y + e3.lineHeight) * i2, M2) {
        var Z2 = M2[y2];
        if (this.anchor.x !== 0 || this.anchor.y !== 0)
          for (var J2 = 0, K2 = this._textWidth * this.anchor.x, Q2 = this._textHeight * this.anchor.y, $2 = 0; $2 < Z2.total; $2++)
            Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2;
        this._maxLineHeight = v2 * i2;
        var tt2 = Z2.mesh.geometry.getBuffer("aVertexPosition"), et2 = Z2.mesh.geometry.getBuffer("aTextureCoord"), it2 = Z2.mesh.geometry.getIndex();
        tt2.data = Z2.vertices, et2.data = Z2.uvs, it2.data = Z2.indices, tt2.update(), et2.update(), it2.update();
      }
      for (y2 = 0; y2 < r2.length; y2++)
        Zp.push(r2[y2]);
    }, e2.prototype.updateTransform = function() {
      this.validate(), this.containerUpdateTransform();
    }, e2.prototype._render = function(e3) {
      this._autoResolution && this._resolution !== e3.resolution && (this._resolution = e3.resolution, this.dirty = true);
      var i2 = Wp.available[this._fontName], n2 = i2.distanceFieldRange, r2 = i2.distanceFieldType, o2 = i2.size;
      if (r2 !== "none")
        for (var s2 = this.worldTransform, a2 = s2.a, l2 = s2.b, h2 = s2.c, u2 = s2.d, c2 = Math.sqrt(a2 * a2 + l2 * l2), d2 = Math.sqrt(h2 * h2 + u2 * u2), p2 = (Math.abs(c2) + Math.abs(d2)) / 2, f2 = this._fontSize / o2, m2 = 0, g2 = this._activePagesMeshData; m2 < g2.length; m2++) {
          g2[m2].mesh.shader.uniforms.uFWidth = p2 * n2 * f2 * this._resolution;
        }
      t2.prototype._render.call(this, e3);
    }, e2.prototype.getLocalBounds = function() {
      return this.validate(), t2.prototype.getLocalBounds.call(this);
    }, e2.prototype.validate = function() {
      this.dirty && (this.updateText(), this.dirty = false);
    }, Object.defineProperty(e2.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t3) {
      if (this._tint !== t3) {
        this._tint = t3;
        for (var e3 = 0; e3 < this._activePagesMeshData.length; e3++)
          this._activePagesMeshData[e3].mesh.tint = t3;
      }
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "align", { get: function() {
      return this._align;
    }, set: function(t3) {
      this._align !== t3 && (this._align = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fontName", { get: function() {
      return this._fontName;
    }, set: function(t3) {
      if (!Wp.available[t3])
        throw new Error('Missing BitmapFont "' + t3 + '"');
      this._fontName !== t3 && (this._fontName = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fontSize", { get: function() {
      return this._fontSize;
    }, set: function(t3) {
      this._fontSize !== t3 && (this._fontSize = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "anchor", { get: function() {
      return this._anchor;
    }, set: function(t3) {
      typeof t3 == "number" ? this._anchor.set(t3) : this._anchor.copyFrom(t3);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "text", { get: function() {
      return this._text;
    }, set: function(t3) {
      t3 = String(t3 == null ? "" : t3), this._text !== t3 && (this._text = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "maxWidth", { get: function() {
      return this._maxWidth;
    }, set: function(t3) {
      this._maxWidth !== t3 && (this._maxWidth = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "maxLineHeight", { get: function() {
      return this.validate(), this._maxLineHeight;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textWidth", { get: function() {
      return this.validate(), this._textWidth;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "letterSpacing", { get: function() {
      return this._letterSpacing;
    }, set: function(t3) {
      this._letterSpacing !== t3 && (this._letterSpacing = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t3) {
      t3 !== this._roundPixels && (this._roundPixels = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textHeight", { get: function() {
      return this.validate(), this._textHeight;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
      return this._resolution;
    }, set: function(t3) {
      this._autoResolution = false, this._resolution !== t3 && (this._resolution = t3, this.dirty = true);
    }, enumerable: false, configurable: true }), e2.prototype.destroy = function(e3) {
      var i2 = this._textureCache;
      for (var n2 in i2) {
        i2[n2].destroy(), delete i2[n2];
      }
      this._textureCache = null, t2.prototype.destroy.call(this, e3);
    }, e2.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 };
  }(Oh.b), function() {
    function t2() {
    }
    return t2.add = function() {
      pc.setExtensionXhrType("fnt", pc.XHR_RESPONSE_TYPE.TEXT);
    }, t2.use = function(e2, i2) {
      var n2 = jp(e2.data);
      if (n2)
        for (var r2 = t2.getBaseUrl(this, e2), o2 = n2.parse(e2.data), s2 = {}, a2 = function(t3) {
          s2[t3.metadata.pageFile] = t3.texture, Object.keys(s2).length === o2.page.length && (e2.bitmapFont = Wp.install(o2, s2, true), i2());
        }, l2 = 0; l2 < o2.page.length; ++l2) {
          var h2 = o2.page[l2].file, u2 = r2 + h2, c2 = false;
          for (var d2 in this.resources) {
            var p2 = this.resources[d2];
            if (p2.url === u2) {
              p2.metadata.pageFile = h2, p2.texture ? a2(p2) : p2.onAfterMiddleware.add(a2), c2 = true;
              break;
            }
          }
          if (!c2) {
            var f2 = { crossOrigin: e2.crossOrigin, loadType: pc.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: h2 }, e2.metadata.imageMetadata), parentResource: e2 };
            this.add(u2, f2, a2);
          }
        }
      else
        i2();
    }, t2.getBaseUrl = function(e2, i2) {
      var n2 = i2.isDataUrl ? "" : t2.dirname(i2.url);
      return i2.isDataUrl && (n2 === "." && (n2 = ""), e2.baseUrl && n2 && e2.baseUrl.charAt(e2.baseUrl.length - 1) === "/" && (n2 += "/")), (n2 = n2.replace(e2.baseUrl, "")) && n2.charAt(n2.length - 1) !== "/" && (n2 += "/"), n2;
    }, t2.dirname = function(t3) {
      var e2 = t3.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e2 === t3 ? "." : e2 === "" ? "/" : e2;
    }, t2;
  }()), Kp = function(t2, e2) {
    return (Kp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Qp = function(t2) {
    function e2(e3) {
      e3 === void 0 && (e3 = 1);
      var i2 = t2.call(this, Vh.A, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", { uAlpha: 1 }) || this;
      return i2.alpha = e3, i2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Kp(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), Object.defineProperty(e2.prototype, "alpha", { get: function() {
      return this.uniforms.uAlpha;
    }, set: function(t3) {
      this.uniforms.uAlpha = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k), $p = function(t2, e2) {
    return ($p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function tf(t2, e2) {
    function i2() {
      this.constructor = t2;
    }
    $p(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  var ef, nf, rf, of, sf, af, lf, hf, uf, cf, df, pf, ff, mf, gf, vf, _f, yf, xf, bf = { 5: [0.153388, 0.221461, 0.250301], 7: [0.071303, 0.131514, 0.189879, 0.214607], 9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236], 11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596], 13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641], 15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448] }, Tf = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
  !function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(ef || (ef = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(nf || (nf = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(rf || (rf = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(of || (of = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(sf || (sf = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(af || (af = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(lf || (lf = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(hf || (hf = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(uf || (uf = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(cf || (cf = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(df || (df = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(pf || (pf = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(ff || (ff = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(mf || (mf = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(gf || (gf = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(vf || (vf = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(_f || (_f = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(yf || (yf = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(xf || (xf = {}));
  var Ef = function(t2) {
    function e2(e3, i2, n2, r2, o2) {
      i2 === void 0 && (i2 = 8), n2 === void 0 && (n2 = 4), r2 === void 0 && (r2 = xd.b.FILTER_RESOLUTION), o2 === void 0 && (o2 = 5);
      var s2 = this, a2 = function(t3, e4) {
        var i3, n3 = Math.ceil(t3 / 2), r3 = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }", o3 = "";
        i3 = e4 ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
        for (var s3 = 0; s3 < t3; s3++) {
          var a3 = i3.replace("%index%", s3.toString());
          o3 += a3 = a3.replace("%sampleIndex%", s3 - (n3 - 1) + ".0"), o3 += "\n";
        }
        return r3 = (r3 = r3.replace("%blur%", o3)).replace("%size%", t3.toString());
      }(o2, e3), l2 = function(t3) {
        for (var e4, i3 = bf[t3], n3 = i3.length, r3 = Tf, o3 = "", s3 = 0; s3 < t3; s3++) {
          var a3 = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s3.toString());
          e4 = s3, s3 >= n3 && (e4 = t3 - s3 - 1), o3 += a3 = a3.replace("%value%", i3[e4].toString()), o3 += "\n";
        }
        return r3 = (r3 = r3.replace("%blur%", o3)).replace("%size%", t3.toString());
      }(o2);
      return (s2 = t2.call(this, a2, l2) || this).horizontal = e3, s2.resolution = r2, s2._quality = 0, s2.quality = n2, s2.blur = i2, s2;
    }
    return tf(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
      if (i2 ? this.horizontal ? this.uniforms.strength = 1 / i2.width * (i2.width / e3.width) : this.uniforms.strength = 1 / i2.height * (i2.height / e3.height) : this.horizontal ? this.uniforms.strength = 1 / t3.renderer.width * (t3.renderer.width / e3.width) : this.uniforms.strength = 1 / t3.renderer.height * (t3.renderer.height / e3.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        t3.applyFilter(this, e3, i2, n2);
      else {
        var r2 = t3.getFilterTexture(), o2 = t3.renderer, s2 = e3, a2 = r2;
        this.state.blend = false, t3.applyFilter(this, s2, a2, mf.CLEAR);
        for (var l2 = 1; l2 < this.passes - 1; l2++) {
          t3.bindAndClear(s2, mf.BLIT), this.uniforms.uSampler = a2;
          var h2 = a2;
          a2 = s2, s2 = h2, o2.shader.bind(this), o2.geometry.draw(5);
        }
        this.state.blend = true, t3.applyFilter(this, a2, i2, n2), t3.returnFilterTexture(r2);
      }
    }, Object.defineProperty(e2.prototype, "blur", { get: function() {
      return this.strength;
    }, set: function(t3) {
      this.padding = 1 + 2 * Math.abs(t3), this.strength = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "quality", { get: function() {
      return this._quality;
    }, set: function(t3) {
      this._quality = t3, this.passes = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k), Sf = function(t2) {
    function e2(e3, i2, n2, r2) {
      e3 === void 0 && (e3 = 8), i2 === void 0 && (i2 = 4), n2 === void 0 && (n2 = xd.b.FILTER_RESOLUTION), r2 === void 0 && (r2 = 5);
      var o2 = t2.call(this) || this;
      return o2.blurXFilter = new Ef(true, e3, i2, n2, r2), o2.blurYFilter = new Ef(false, e3, i2, n2, r2), o2.resolution = n2, o2.quality = i2, o2.blur = e3, o2.repeatEdgePixels = false, o2;
    }
    return tf(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
      var r2 = Math.abs(this.blurXFilter.strength), o2 = Math.abs(this.blurYFilter.strength);
      if (r2 && o2) {
        var s2 = t3.getFilterTexture();
        this.blurXFilter.apply(t3, e3, s2, mf.CLEAR), this.blurYFilter.apply(t3, s2, i2, n2), t3.returnFilterTexture(s2);
      } else
        o2 ? this.blurYFilter.apply(t3, e3, i2, n2) : this.blurXFilter.apply(t3, e3, i2, n2);
    }, e2.prototype.updatePadding = function() {
      this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength));
    }, Object.defineProperty(e2.prototype, "blur", { get: function() {
      return this.blurXFilter.blur;
    }, set: function(t3) {
      this.blurXFilter.blur = this.blurYFilter.blur = t3, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "quality", { get: function() {
      return this.blurXFilter.quality;
    }, set: function(t3) {
      this.blurXFilter.quality = this.blurYFilter.quality = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blurX", { get: function() {
      return this.blurXFilter.blur;
    }, set: function(t3) {
      this.blurXFilter.blur = t3, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blurY", { get: function() {
      return this.blurYFilter.blur;
    }, set: function(t3) {
      this.blurYFilter.blur = t3, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blendMode", { get: function() {
      return this.blurYFilter.blendMode;
    }, set: function(t3) {
      this.blurYFilter.blendMode = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "repeatEdgePixels", { get: function() {
      return this._repeatEdgePixels;
    }, set: function(t3) {
      this._repeatEdgePixels = t3, this.updatePadding();
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k), wf = function(t2, e2) {
    return (wf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Af = function(t2) {
    function e2() {
      var e3 = this, i2 = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 };
      return (e3 = t2.call(this, Vh.z, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", i2) || this).alpha = 1, e3;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      wf(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype._loadMatrix = function(t3, e3) {
      e3 === void 0 && (e3 = false);
      var i2 = t3;
      e3 && (this._multiply(i2, this.uniforms.m, t3), i2 = this._colorMatrix(i2)), this.uniforms.m = i2;
    }, e2.prototype._multiply = function(t3, e3, i2) {
      return t3[0] = e3[0] * i2[0] + e3[1] * i2[5] + e3[2] * i2[10] + e3[3] * i2[15], t3[1] = e3[0] * i2[1] + e3[1] * i2[6] + e3[2] * i2[11] + e3[3] * i2[16], t3[2] = e3[0] * i2[2] + e3[1] * i2[7] + e3[2] * i2[12] + e3[3] * i2[17], t3[3] = e3[0] * i2[3] + e3[1] * i2[8] + e3[2] * i2[13] + e3[3] * i2[18], t3[4] = e3[0] * i2[4] + e3[1] * i2[9] + e3[2] * i2[14] + e3[3] * i2[19] + e3[4], t3[5] = e3[5] * i2[0] + e3[6] * i2[5] + e3[7] * i2[10] + e3[8] * i2[15], t3[6] = e3[5] * i2[1] + e3[6] * i2[6] + e3[7] * i2[11] + e3[8] * i2[16], t3[7] = e3[5] * i2[2] + e3[6] * i2[7] + e3[7] * i2[12] + e3[8] * i2[17], t3[8] = e3[5] * i2[3] + e3[6] * i2[8] + e3[7] * i2[13] + e3[8] * i2[18], t3[9] = e3[5] * i2[4] + e3[6] * i2[9] + e3[7] * i2[14] + e3[8] * i2[19] + e3[9], t3[10] = e3[10] * i2[0] + e3[11] * i2[5] + e3[12] * i2[10] + e3[13] * i2[15], t3[11] = e3[10] * i2[1] + e3[11] * i2[6] + e3[12] * i2[11] + e3[13] * i2[16], t3[12] = e3[10] * i2[2] + e3[11] * i2[7] + e3[12] * i2[12] + e3[13] * i2[17], t3[13] = e3[10] * i2[3] + e3[11] * i2[8] + e3[12] * i2[13] + e3[13] * i2[18], t3[14] = e3[10] * i2[4] + e3[11] * i2[9] + e3[12] * i2[14] + e3[13] * i2[19] + e3[14], t3[15] = e3[15] * i2[0] + e3[16] * i2[5] + e3[17] * i2[10] + e3[18] * i2[15], t3[16] = e3[15] * i2[1] + e3[16] * i2[6] + e3[17] * i2[11] + e3[18] * i2[16], t3[17] = e3[15] * i2[2] + e3[16] * i2[7] + e3[17] * i2[12] + e3[18] * i2[17], t3[18] = e3[15] * i2[3] + e3[16] * i2[8] + e3[17] * i2[13] + e3[18] * i2[18], t3[19] = e3[15] * i2[4] + e3[16] * i2[9] + e3[17] * i2[14] + e3[18] * i2[19] + e3[19], t3;
    }, e2.prototype._colorMatrix = function(t3) {
      var e3 = new Float32Array(t3);
      return e3[4] /= 255, e3[9] /= 255, e3[14] /= 255, e3[19] /= 255, e3;
    }, e2.prototype.brightness = function(t3, e3) {
      var i2 = [t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i2, e3);
    }, e2.prototype.tint = function(t3, e3) {
      var i2 = [(t3 >> 16 & 255) / 255, 0, 0, 0, 0, 0, (t3 >> 8 & 255) / 255, 0, 0, 0, 0, 0, (255 & t3) / 255, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i2, e3);
    }, e2.prototype.greyscale = function(t3, e3) {
      var i2 = [t3, t3, t3, 0, 0, t3, t3, t3, 0, 0, t3, t3, t3, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i2, e3);
    }, e2.prototype.blackAndWhite = function(t3) {
      this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.hue = function(t3, e3) {
      t3 = (t3 || 0) / 180 * Math.PI;
      var i2 = Math.cos(t3), n2 = Math.sin(t3), r2 = 1 / 3, o2 = (0, Math.sqrt)(r2), s2 = [i2 + (1 - i2) * r2, r2 * (1 - i2) - o2 * n2, r2 * (1 - i2) + o2 * n2, 0, 0, r2 * (1 - i2) + o2 * n2, i2 + r2 * (1 - i2), r2 * (1 - i2) - o2 * n2, 0, 0, r2 * (1 - i2) - o2 * n2, r2 * (1 - i2) + o2 * n2, i2 + r2 * (1 - i2), 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(s2, e3);
    }, e2.prototype.contrast = function(t3, e3) {
      var i2 = (t3 || 0) + 1, n2 = -0.5 * (i2 - 1), r2 = [i2, 0, 0, 0, n2, 0, i2, 0, 0, n2, 0, 0, i2, 0, n2, 0, 0, 0, 1, 0];
      this._loadMatrix(r2, e3);
    }, e2.prototype.saturate = function(t3, e3) {
      t3 === void 0 && (t3 = 0);
      var i2 = 2 * t3 / 3 + 1, n2 = -0.5 * (i2 - 1), r2 = [i2, n2, n2, 0, 0, n2, i2, n2, 0, 0, n2, n2, i2, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(r2, e3);
    }, e2.prototype.desaturate = function() {
      this.saturate(-1);
    }, e2.prototype.negative = function(t3) {
      this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.sepia = function(t3) {
      this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.technicolor = function(t3) {
      this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.polaroid = function(t3) {
      this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.toBGR = function(t3) {
      this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.kodachrome = function(t3) {
      this._loadMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.browni = function(t3) {
      this._loadMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.vintage = function(t3) {
      this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.colorTone = function(t3, e3, i2, n2, r2) {
      var o2 = ((i2 = i2 || 16770432) >> 16 & 255) / 255, s2 = (i2 >> 8 & 255) / 255, a2 = (255 & i2) / 255, l2 = ((n2 = n2 || 3375104) >> 16 & 255) / 255, h2 = (n2 >> 8 & 255) / 255, u2 = (255 & n2) / 255, c2 = [0.3, 0.59, 0.11, 0, 0, o2, s2, a2, t3 = t3 || 0.2, 0, l2, h2, u2, e3 = e3 || 0.15, 0, o2 - l2, s2 - h2, a2 - u2, 0, 0];
      this._loadMatrix(c2, r2);
    }, e2.prototype.night = function(t3, e3) {
      var i2 = [-2 * (t3 = t3 || 0.1), -t3, 0, 0, 0, -t3, 0, t3, 0, 0, 0, t3, 2 * t3, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i2, e3);
    }, e2.prototype.predator = function(t3, e3) {
      var i2 = [11.224130630493164 * t3, -4.794486999511719 * t3, -2.8746118545532227 * t3, 0 * t3, 0.40342438220977783 * t3, -3.6330697536468506 * t3, 9.193157196044922 * t3, -2.951810836791992 * t3, 0 * t3, -1.316135048866272 * t3, -3.2184197902679443 * t3, -4.2375030517578125 * t3, 7.476448059082031 * t3, 0 * t3, 0.8044459223747253 * t3, 0, 0, 0, 1, 0];
      this._loadMatrix(i2, e3);
    }, e2.prototype.lsd = function(t3) {
      this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], t3);
    }, e2.prototype.reset = function() {
      this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], false);
    }, Object.defineProperty(e2.prototype, "matrix", { get: function() {
      return this.uniforms.m;
    }, set: function(t3) {
      this.uniforms.m = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "alpha", { get: function() {
      return this.uniforms.uAlpha;
    }, set: function(t3) {
      this.uniforms.uAlpha = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k);
  Af.prototype.grayscale = Af.prototype.greyscale;
  /*!
   * @pixi/filter-displacement - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/filter-displacement is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Mf = function(t2, e2) {
    return (Mf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Rf = function(t2) {
    function e2(e3, i2) {
      var n2 = this, r2 = new Lh.d();
      return e3.renderable = false, (n2 = t2.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", { mapSampler: e3._texture, filterMatrix: r2, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }) || this).maskSprite = e3, n2.maskMatrix = r2, i2 == null && (i2 = 20), n2.scale = new Lh.g(i2, i2), n2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Mf(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
      this.uniforms.filterMatrix = t3.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
      var r2 = this.maskSprite.worldTransform, o2 = Math.sqrt(r2.a * r2.a + r2.b * r2.b), s2 = Math.sqrt(r2.c * r2.c + r2.d * r2.d);
      o2 !== 0 && s2 !== 0 && (this.uniforms.rotation[0] = r2.a / o2, this.uniforms.rotation[1] = r2.b / o2, this.uniforms.rotation[2] = r2.c / s2, this.uniforms.rotation[3] = r2.d / s2), t3.applyFilter(this, e3, i2, n2);
    }, Object.defineProperty(e2.prototype, "map", { get: function() {
      return this.uniforms.mapSampler;
    }, set: function(t3) {
      this.uniforms.mapSampler = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k), Cf = function(t2, e2) {
    return (Cf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var If = function(t2) {
    function e2() {
      return t2.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`) || this;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Cf(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2;
  }(Vh.k), Pf = function(t2, e2) {
    return (Pf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  var Of, Nf, Lf, Df, Ff, Bf, Uf, kf, Gf, Hf, jf, zf, Vf, Xf, Wf, Yf, qf, Zf, Jf, Kf = function(t2) {
    function e2(e3, i2) {
      e3 === void 0 && (e3 = 0.5), i2 === void 0 && (i2 = Math.random());
      var n2 = t2.call(this, Vh.z, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", { uNoise: 0, uSeed: 0 }) || this;
      return n2.noise = e3, n2.seed = i2, n2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      Pf(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), Object.defineProperty(e2.prototype, "noise", { get: function() {
      return this.uniforms.uNoise;
    }, set: function(t3) {
      this.uniforms.uNoise = t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "seed", { get: function() {
      return this.uniforms.uSeed;
    }, set: function(t3) {
      this.uniforms.uSeed = t3;
    }, enumerable: false, configurable: true }), e2;
  }(Vh.k);
  !function(t2) {
    t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
  }(Of || (Of = {})), function(t2) {
    t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
  }(Nf || (Nf = {})), function(t2) {
    t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
  }(Lf || (Lf = {})), function(t2) {
    t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
  }(Df || (Df = {})), function(t2) {
    t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(Ff || (Ff = {})), function(t2) {
    t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(Bf || (Bf = {})), function(t2) {
    t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(Uf || (Uf = {})), function(t2) {
    t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(kf || (kf = {})), function(t2) {
    t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
  }(Gf || (Gf = {})), function(t2) {
    t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
  }(Hf || (Hf = {})), function(t2) {
    t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(jf || (jf = {})), function(t2) {
    t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
  }(zf || (zf = {})), function(t2) {
    t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(Vf || (Vf = {})), function(t2) {
    t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
  }(Xf || (Xf = {})), function(t2) {
    t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
  }(Wf || (Wf = {})), function(t2) {
    t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
  }(Yf || (Yf = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
  }(qf || (qf = {})), function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
  }(Zf || (Zf = {})), function(t2) {
    t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(Jf || (Jf = {}));
  var Qf = new Lh.d();
  Oh.c.prototype._cacheAsBitmap = false, Oh.c.prototype._cacheData = null, Oh.c.prototype._cacheAsBitmapResolution = null, Oh.c.prototype._cacheAsBitmapMultisample = Zf.NONE;
  var $f = function() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  };
  Object.defineProperties(Oh.c.prototype, { cacheAsBitmapResolution: { get: function() {
    return this._cacheAsBitmapResolution;
  }, set: function(t2) {
    t2 !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t2, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
  } }, cacheAsBitmapMultisample: { get: function() {
    return this._cacheAsBitmapMultisample;
  }, set: function(t2) {
    t2 !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t2, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
  } }, cacheAsBitmap: { get: function() {
    return this._cacheAsBitmap;
  }, set: function(t2) {
    var e2;
    this._cacheAsBitmap !== t2 && (this._cacheAsBitmap = t2, t2 ? (this._cacheData || (this._cacheData = new $f()), (e2 = this._cacheData).originalRender = this.render, e2.originalRenderCanvas = this.renderCanvas, e2.originalUpdateTransform = this.updateTransform, e2.originalCalculateBounds = this.calculateBounds, e2.originalGetLocalBounds = this.getLocalBounds, e2.originalDestroy = this.destroy, e2.originalContainsPoint = this.containsPoint, e2.originalMask = this._mask, e2.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e2 = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e2.originalRender, this.renderCanvas = e2.originalRenderCanvas, this.calculateBounds = e2.originalCalculateBounds, this.getLocalBounds = e2.originalGetLocalBounds, this.destroy = e2.originalDestroy, this.updateTransform = e2.originalUpdateTransform, this.containsPoint = e2.originalContainsPoint, this._mask = e2.originalMask, this.filterArea = e2.originalFilterArea));
  } } }), Oh.c.prototype._renderCached = function(t2) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t2), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t2));
  }, Oh.c.prototype._initCachedDisplayObject = function(t2) {
    var e2;
    if (!this._cacheData || !this._cacheData.sprite) {
      var i2 = this.alpha;
      this.alpha = 1, t2.batch.flush();
      var n2 = this.getLocalBounds(null, true).clone();
      if (this.filters && this.filters.length) {
        var r2 = this.filters[0].padding;
        n2.pad(r2);
      }
      n2.ceil(xd.b.RESOLUTION);
      var o2 = t2.renderTexture.current, s2 = t2.renderTexture.sourceFrame.clone(), a2 = t2.renderTexture.destinationFrame.clone(), l2 = t2.projection.transform, h2 = Vh.p.create({ width: n2.width, height: n2.height, resolution: this.cacheAsBitmapResolution || t2.resolution, multisample: (e2 = this.cacheAsBitmapMultisample) !== null && e2 !== void 0 ? e2 : t2.multisample }), u2 = "cacheAsBitmap_" + Object(Ph.uid)();
      this._cacheData.textureCacheId = u2, Vh.c.addToCache(h2.baseTexture, u2), Vh.t.addToCache(h2, u2);
      var c2 = this.transform.localTransform.copyTo(Qf).invert().translate(-n2.x, -n2.y);
      this.render = this._cacheData.originalRender, t2.render(this, { renderTexture: h2, clear: true, transform: c2, skipUpdateTransform: false }), t2.framebuffer.blit(), t2.projection.transform = l2, t2.renderTexture.bind(o2, s2, a2), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i2;
      var d2 = new ep(h2);
      d2.transform.worldTransform = this.transform.worldTransform, d2.anchor.x = -n2.x / n2.width, d2.anchor.y = -n2.y / n2.height, d2.alpha = i2, d2._bounds = this._bounds, this._cacheData.sprite = d2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d2.containsPoint.bind(d2);
    }
  }, Oh.c.prototype._renderCachedCanvas = function(t2) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t2), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t2));
  }, Oh.c.prototype._initCachedDisplayObjectCanvas = function(t2) {
    if (!this._cacheData || !this._cacheData.sprite) {
      var e2 = this.getLocalBounds(null, true), i2 = this.alpha;
      this.alpha = 1;
      var n2 = t2.context, r2 = t2._projTransform;
      e2.ceil(xd.b.RESOLUTION);
      var o2 = Vh.p.create({ width: e2.width, height: e2.height }), s2 = "cacheAsBitmap_" + Object(Ph.uid)();
      this._cacheData.textureCacheId = s2, Vh.c.addToCache(o2.baseTexture, s2), Vh.t.addToCache(o2, s2);
      var a2 = Qf;
      this.transform.localTransform.copyTo(a2), a2.invert(), a2.tx -= e2.x, a2.ty -= e2.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t2.render(this, { renderTexture: o2, clear: true, transform: a2, skipUpdateTransform: false }), t2.context = n2, t2._projTransform = r2, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i2;
      var l2 = new ep(o2);
      l2.transform.worldTransform = this.transform.worldTransform, l2.anchor.x = -e2.x / e2.width, l2.anchor.y = -e2.y / e2.height, l2.alpha = i2, l2._bounds = this._bounds, this._cacheData.sprite = l2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t2._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l2.containsPoint.bind(l2);
    }
  }, Oh.c.prototype._calculateCachedBounds = function() {
    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
  }, Oh.c.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null);
  }, Oh.c.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(true), this._cacheData.sprite = null, Vh.c.removeFromCache(this._cacheData.textureCacheId), Vh.t.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
  }, Oh.c.prototype._cacheAsBitmapDestroy = function(t2) {
    this.cacheAsBitmap = false, this.destroy(t2);
  }, Oh.c.prototype.name = null, Oh.b.prototype.getChildByName = function(t2, e2) {
    for (var i2 = 0, n2 = this.children.length; i2 < n2; i2++)
      if (this.children[i2].name === t2)
        return this.children[i2];
    if (e2)
      for (i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
        if (this.children[i2].getChildByName) {
          var r2 = this.children[i2].getChildByName(t2, true);
          if (r2)
            return r2;
        }
      }
    return null;
  }, Oh.c.prototype.getGlobalPosition = function(t2, e2) {
    return t2 === void 0 && (t2 = new Lh.g()), e2 === void 0 && (e2 = false), this.parent ? this.parent.toGlobal(this.position, t2, e2) : (t2.x = this.position.x, t2.y = this.position.y), t2;
  };
  var tm = i(16), em = (i(12), function(t2, e2) {
    return (em = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  });
  var im = function(t2) {
    function e2(e3, i2) {
      i2 === void 0 && (i2 = true);
      var n2 = t2.call(this, e3[0] instanceof Vh.t ? e3[0] : e3[0].texture) || this;
      return n2._textures = null, n2._durations = null, n2._autoUpdate = i2, n2._isConnectedToTicker = false, n2.animationSpeed = 1, n2.loop = true, n2.updateAnchor = false, n2.onComplete = null, n2.onFrameChange = null, n2.onLoop = null, n2._currentTime = 0, n2._playing = false, n2._previousFrame = null, n2.textures = e3, n2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      em(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype.stop = function() {
      this._playing && (this._playing = false, this._autoUpdate && this._isConnectedToTicker && (Dh.a.shared.remove(this.update, this), this._isConnectedToTicker = false));
    }, e2.prototype.play = function() {
      this._playing || (this._playing = true, this._autoUpdate && !this._isConnectedToTicker && (Dh.a.shared.add(this.update, this, Dh.c.HIGH), this._isConnectedToTicker = true));
    }, e2.prototype.gotoAndStop = function(t3) {
      this.stop();
      var e3 = this.currentFrame;
      this._currentTime = t3, e3 !== this.currentFrame && this.updateTexture();
    }, e2.prototype.gotoAndPlay = function(t3) {
      var e3 = this.currentFrame;
      this._currentTime = t3, e3 !== this.currentFrame && this.updateTexture(), this.play();
    }, e2.prototype.update = function(t3) {
      if (this._playing) {
        var e3 = this.animationSpeed * t3, i2 = this.currentFrame;
        if (this._durations !== null) {
          var n2 = this._currentTime % 1 * this._durations[this.currentFrame];
          for (n2 += e3 / 60 * 1e3; n2 < 0; )
            this._currentTime--, n2 += this._durations[this.currentFrame];
          var r2 = Math.sign(this.animationSpeed * t3);
          for (this._currentTime = Math.floor(this._currentTime); n2 >= this._durations[this.currentFrame]; )
            n2 -= this._durations[this.currentFrame] * r2, this._currentTime += r2;
          this._currentTime += n2 / this._durations[this.currentFrame];
        } else
          this._currentTime += e3;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : i2 !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i2 || this.animationSpeed < 0 && this.currentFrame > i2) && this.onLoop(), this.updateTexture());
      }
    }, e2.prototype.updateTexture = function() {
      var t3 = this.currentFrame;
      this._previousFrame !== t3 && (this._previousFrame = t3, this._texture = this._textures[t3], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, e2.prototype.destroy = function(e3) {
      this.stop(), t2.prototype.destroy.call(this, e3), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, e2.fromFrames = function(t3) {
      for (var i2 = [], n2 = 0; n2 < t3.length; ++n2)
        i2.push(Vh.t.from(t3[n2]));
      return new e2(i2);
    }, e2.fromImages = function(t3) {
      for (var i2 = [], n2 = 0; n2 < t3.length; ++n2)
        i2.push(Vh.t.from(t3[n2]));
      return new e2(i2);
    }, Object.defineProperty(e2.prototype, "totalFrames", { get: function() {
      return this._textures.length;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textures", { get: function() {
      return this._textures;
    }, set: function(t3) {
      if (t3[0] instanceof Vh.t)
        this._textures = t3, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var e3 = 0; e3 < t3.length; e3++)
          this._textures.push(t3[e3].texture), this._durations.push(t3[e3].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "currentFrame", { get: function() {
      var t3 = Math.floor(this._currentTime) % this._textures.length;
      return t3 < 0 && (t3 += this._textures.length), t3;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "playing", { get: function() {
      return this._playing;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
      return this._autoUpdate;
    }, set: function(t3) {
      t3 !== this._autoUpdate && (this._autoUpdate = t3, !this._autoUpdate && this._isConnectedToTicker ? (Dh.a.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Dh.a.shared.add(this.update, this), this._isConnectedToTicker = true));
    }, enumerable: false, configurable: true }), e2;
  }(ep);
  /*!
   * pixi.js - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * pixi.js is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  Vh.q.registerPlugin("accessibility", Nh), Vh.q.registerPlugin("extract", nc), Vh.q.registerPlugin("interaction", zh), Vh.q.registerPlugin("particle", yd), Vh.q.registerPlugin("prepare", wp), Vh.q.registerPlugin("batch", Vh.f), Vh.q.registerPlugin("tilingSprite", Lp), yc.registerPlugin(Jp), yc.registerPlugin(Oc), yc.registerPlugin(Jc), yc.registerPlugin(dd), yc.registerPlugin(Mp), Xh.registerPlugin(Dh.b), Xh.registerPlugin(xc);
  var nm, rm = { AlphaFilter: Qp, BlurFilter: Sf, BlurFilterPass: Ef, ColorMatrixFilter: Af, DisplacementFilter: Rf, FXAAFilter: If, NoiseFilter: Kf }, om = i(10), sm = i(34), am = function() {
    function t2() {
    }
    return t2.offsetPolygon = function(e2, i2) {
      var n2 = [], r2 = e2.length;
      i2 = t2.isPolygonClockwise(e2) ? i2 : -1 * i2;
      for (var o2 = 0; o2 < r2; o2 += 2) {
        var s2 = o2 - 2;
        s2 < 0 && (s2 += r2);
        var a2 = (o2 + 2) % r2, l2 = e2[o2] - e2[s2], h2 = e2[o2 + 1] - e2[s2 + 1], u2 = Math.sqrt(l2 * l2 + h2 * h2);
        l2 /= u2, h2 /= u2;
        var c2 = -(h2 *= i2), d2 = l2 *= i2, p2 = [e2[s2] + c2, e2[s2 + 1] + d2], f2 = [e2[o2] + c2, e2[o2 + 1] + d2], m2 = e2[a2] - e2[o2], g2 = e2[a2 + 1] - e2[o2 + 1];
        m2 /= u2 = Math.sqrt(m2 * m2 + g2 * g2), g2 /= u2;
        var v2 = -(g2 *= i2), _2 = m2 *= i2, y2 = [e2[o2] + v2, e2[o2 + 1] + _2], x2 = [e2[a2] + v2, e2[a2 + 1] + _2], b2 = t2.findIntersection(p2[0], p2[1], f2[0], f2[1], y2[0], y2[1], x2[0], x2[1]);
        b2 && n2.push.apply(n2, b2);
      }
      return n2;
    }, t2.findIntersection = function(t3, e2, i2, n2, r2, o2, s2, a2) {
      var l2 = (a2 - o2) * (i2 - t3) - (s2 - r2) * (n2 - e2), h2 = (s2 - r2) * (e2 - o2) - (a2 - o2) * (t3 - r2);
      if (l2 === 0)
        return h2 === 0 && (i2 - t3) * (e2 - o2) - (n2 - e2) * (t3 - r2) === 0 ? [(t3 + i2) / 2, (e2 + n2) / 2] : null;
      var u2 = h2 / l2;
      return [t3 + u2 * (i2 - t3), e2 + u2 * (n2 - e2)];
    }, t2.isPolygonClockwise = function(t3) {
      for (var e2 = 0, i2 = 0, n2 = t3.length - 2; i2 < t3.length; n2 = i2, i2 += 2)
        e2 += (t3[i2] - t3[n2]) * (t3[i2 + 1] + t3[n2 + 1]);
      return e2 > 0;
    }, t2;
  }(), lm = function() {
    function t2(t3) {
      this._svgMatrix = null, this._tempMatrix = new Lh.d(), this.renderer = t3;
    }
    return t2.prototype._calcCanvasStyle = function(t3, e2) {
      var i2;
      return t3.texture && t3.texture.baseTexture !== Vh.t.WHITE.baseTexture ? t3.texture.valid ? (i2 = om.b.getTintedPattern(t3.texture, e2), this.setPatternTransform(i2, t3.matrix || Lh.d.IDENTITY)) : i2 = "#808080" : i2 = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), i2;
    }, t2.prototype.render = function(t3) {
      var e2 = this.renderer, i2 = e2.context, n2 = t3.worldAlpha, r2 = t3.transform.worldTransform;
      e2.setContextTransform(r2), e2.setBlendMode(t3.blendMode);
      for (var o2, s2, a2 = t3.geometry.graphicsData, l2 = (t3.tint >> 16 & 255) / 255, h2 = (t3.tint >> 8 & 255) / 255, u2 = (255 & t3.tint) / 255, c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2[c2], p2 = d2.shape, f2 = d2.fillStyle, m2 = d2.lineStyle, g2 = 0 | d2.fillStyle.color, v2 = 0 | d2.lineStyle.color;
        if (d2.matrix && e2.setContextTransform(r2.copyTo(this._tempMatrix).append(d2.matrix)), f2.visible) {
          var _2 = ((g2 >> 16 & 255) / 255 * l2 * 255 << 16) + ((g2 >> 8 & 255) / 255 * h2 * 255 << 8) + (255 & g2) / 255 * u2 * 255;
          o2 = this._calcCanvasStyle(f2, _2);
        }
        if (m2.visible) {
          var y2 = ((v2 >> 16 & 255) / 255 * l2 * 255 << 16) + ((v2 >> 8 & 255) / 255 * h2 * 255 << 8) + (255 & v2) / 255 * u2 * 255;
          s2 = this._calcCanvasStyle(m2, y2);
        }
        if (i2.lineWidth = m2.width, i2.lineCap = m2.cap, i2.lineJoin = m2.join, i2.miterLimit = m2.miterLimit, d2.type === Lh.l.POLY) {
          i2.beginPath();
          var x2 = (C2 = p2).points, b2 = d2.holes, T2 = void 0, E2 = void 0, S2 = void 0, w2 = void 0, A2 = void 0;
          i2.moveTo(x2[0], x2[1]);
          for (var M2 = 2; M2 < x2.length; M2 += 2)
            i2.lineTo(x2[M2], x2[M2 + 1]);
          if (C2.closeStroke && i2.closePath(), b2.length > 0) {
            A2 = [], T2 = 0, S2 = x2[0], w2 = x2[1];
            for (M2 = 2; M2 + 2 < x2.length; M2 += 2)
              T2 += (x2[M2] - S2) * (x2[M2 + 3] - w2) - (x2[M2 + 2] - S2) * (x2[M2 + 1] - w2);
            for (var R2 = 0; R2 < b2.length; R2++)
              if (x2 = b2[R2].shape.points) {
                E2 = 0, S2 = x2[0], w2 = x2[1];
                for (M2 = 2; M2 + 2 < x2.length; M2 += 2)
                  E2 += (x2[M2] - S2) * (x2[M2 + 3] - w2) - (x2[M2 + 2] - S2) * (x2[M2 + 1] - w2);
                if (E2 * T2 < 0) {
                  i2.moveTo(x2[0], x2[1]);
                  for (M2 = 2; M2 < x2.length; M2 += 2)
                    i2.lineTo(x2[M2], x2[M2 + 1]);
                } else {
                  i2.moveTo(x2[x2.length - 2], x2[x2.length - 1]);
                  for (M2 = x2.length - 4; M2 >= 0; M2 -= 2)
                    i2.lineTo(x2[M2], x2[M2 + 1]);
                }
                b2[R2].shape.closeStroke && i2.closePath(), A2[R2] = E2 * T2 < 0;
              }
          }
          f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fill()), m2.visible && this.paintPolygonStroke(C2, m2, s2, b2, A2, n2, i2);
        } else if (d2.type === Lh.l.RECT) {
          var C2 = p2;
          if (f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fillRect(C2.x, C2.y, C2.width, C2.height)), m2.visible) {
            var I2 = m2.width * (0.5 - (1 - m2.alignment)), P2 = C2.width + 2 * I2, O2 = C2.height + 2 * I2;
            i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.strokeRect(C2.x - I2, C2.y - I2, P2, O2);
          }
        } else if (d2.type === Lh.l.CIRC) {
          C2 = p2;
          if (i2.beginPath(), i2.arc(C2.x, C2.y, C2.radius, 0, 2 * Math.PI), i2.closePath(), f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fill()), m2.visible) {
            if (m2.alignment !== 0.5) {
              I2 = m2.width * (0.5 - (1 - m2.alignment));
              i2.beginPath(), i2.arc(C2.x, C2.y, C2.radius + I2, 0, 2 * Math.PI), i2.closePath();
            }
            i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
          }
        } else if (d2.type === Lh.l.ELIP) {
          C2 = p2;
          if ((z2 = m2.alignment === 1) || this.paintEllipse(C2, f2, m2, o2, n2, i2), m2.visible) {
            if (m2.alignment !== 0.5) {
              I2 = m2.width * (0.5 - (1 - m2.alignment));
              var N2 = 2 * (C2.width + I2), L2 = 2 * (C2.height + I2), D2 = C2.x - N2 / 2, F2 = C2.y - L2 / 2, B2 = N2 / 2 * 0.5522848, U2 = L2 / 2 * 0.5522848, k2 = D2 + N2, G2 = F2 + L2, H2 = D2 + N2 / 2, j2 = F2 + L2 / 2;
              i2.beginPath(), i2.moveTo(D2, j2), i2.bezierCurveTo(D2, j2 - U2, H2 - B2, F2, H2, F2), i2.bezierCurveTo(H2 + B2, F2, k2, j2 - U2, k2, j2), i2.bezierCurveTo(k2, j2 + U2, H2 + B2, G2, H2, G2), i2.bezierCurveTo(H2 - B2, G2, D2, j2 + U2, D2, j2), i2.closePath();
            }
            i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
          }
          z2 && this.paintEllipse(C2, f2, m2, o2, n2, i2);
        } else if (d2.type === Lh.l.RREC) {
          var z2;
          C2 = p2;
          if ((z2 = m2.alignment === 1) || this.paintRoundedRectangle(C2, f2, m2, o2, n2, i2), m2.visible) {
            if (m2.alignment !== 0.5) {
              P2 = C2.width, O2 = C2.height, I2 = m2.width * (0.5 - (1 - m2.alignment));
              var V2 = C2.x - I2, X2 = C2.y - I2, W2 = C2.width + 2 * I2, Y2 = C2.height + 2 * I2, q2 = I2 * (m2.alignment >= 1 ? Math.min(W2 / P2, Y2 / O2) : Math.min(P2 / W2, O2 / Y2)), Z2 = C2.radius + q2, J2 = Math.min(W2, Y2) / 2;
              Z2 = Z2 > J2 ? J2 : Z2, i2.beginPath(), i2.moveTo(V2, X2 + Z2), i2.lineTo(V2, X2 + Y2 - Z2), i2.quadraticCurveTo(V2, X2 + Y2, V2 + Z2, X2 + Y2), i2.lineTo(V2 + W2 - Z2, X2 + Y2), i2.quadraticCurveTo(V2 + W2, X2 + Y2, V2 + W2, X2 + Y2 - Z2), i2.lineTo(V2 + W2, X2 + Z2), i2.quadraticCurveTo(V2 + W2, X2, V2 + W2 - Z2, X2), i2.lineTo(V2 + Z2, X2), i2.quadraticCurveTo(V2, X2, V2, X2 + Z2), i2.closePath();
            }
            i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
          }
          z2 && this.paintRoundedRectangle(C2, f2, m2, o2, n2, i2);
        }
      }
    }, t2.prototype.paintPolygonStroke = function(t3, e2, i2, n2, r2, o2, s2) {
      if (e2.alignment !== 0.5) {
        var a2 = e2.width * (0.5 - (1 - e2.alignment)), l2 = am.offsetPolygon(t3.points, a2), h2 = void 0;
        s2.beginPath(), s2.moveTo(l2[0], l2[1]);
        for (var u2 = 2; u2 < l2.length; u2 += 2)
          s2.lineTo(l2[u2], l2[u2 + 1]);
        t3.closeStroke && s2.closePath();
        for (var c2 = 0; c2 < n2.length; c2++) {
          if (h2 = n2[c2].shape.points, l2 = am.offsetPolygon(h2, a2), r2[c2]) {
            s2.moveTo(l2[0], l2[1]);
            for (u2 = 2; u2 < l2.length; u2 += 2)
              s2.lineTo(l2[u2], l2[u2 + 1]);
          } else {
            s2.moveTo(l2[l2.length - 2], l2[l2.length - 1]);
            for (u2 = l2.length - 4; u2 >= 0; u2 -= 2)
              s2.lineTo(l2[u2], l2[u2 + 1]);
          }
          n2[c2].shape.closeStroke && s2.closePath();
        }
      }
      s2.globalAlpha = e2.alpha * o2, s2.strokeStyle = i2, s2.stroke();
    }, t2.prototype.paintEllipse = function(t3, e2, i2, n2, r2, o2) {
      var s2 = 2 * t3.width, a2 = 2 * t3.height, l2 = t3.x - s2 / 2, h2 = t3.y - a2 / 2, u2 = s2 / 2 * 0.5522848, c2 = a2 / 2 * 0.5522848, d2 = l2 + s2, p2 = h2 + a2, f2 = l2 + s2 / 2, m2 = h2 + a2 / 2;
      i2.alignment === 0 && o2.save(), o2.beginPath(), o2.moveTo(l2, m2), o2.bezierCurveTo(l2, m2 - c2, f2 - u2, h2, f2, h2), o2.bezierCurveTo(f2 + u2, h2, d2, m2 - c2, d2, m2), o2.bezierCurveTo(d2, m2 + c2, f2 + u2, p2, f2, p2), o2.bezierCurveTo(f2 - u2, p2, l2, m2 + c2, l2, m2), o2.closePath(), i2.alignment === 0 && o2.clip(), e2.visible && (o2.globalAlpha = e2.alpha * r2, o2.fillStyle = n2, o2.fill()), i2.alignment === 0 && o2.restore();
    }, t2.prototype.paintRoundedRectangle = function(t3, e2, i2, n2, r2, o2) {
      var s2 = t3.x, a2 = t3.y, l2 = t3.width, h2 = t3.height, u2 = t3.radius, c2 = Math.min(l2, h2) / 2;
      u2 = u2 > c2 ? c2 : u2, i2.alignment === 0 && o2.save(), o2.beginPath(), o2.moveTo(s2, a2 + u2), o2.lineTo(s2, a2 + h2 - u2), o2.quadraticCurveTo(s2, a2 + h2, s2 + u2, a2 + h2), o2.lineTo(s2 + l2 - u2, a2 + h2), o2.quadraticCurveTo(s2 + l2, a2 + h2, s2 + l2, a2 + h2 - u2), o2.lineTo(s2 + l2, a2 + u2), o2.quadraticCurveTo(s2 + l2, a2, s2 + l2 - u2, a2), o2.lineTo(s2 + u2, a2), o2.quadraticCurveTo(s2, a2, s2, a2 + u2), o2.closePath(), i2.alignment === 0 && o2.clip(), e2.visible && (o2.globalAlpha = e2.alpha * r2, o2.fillStyle = n2, o2.fill()), i2.alignment === 0 && o2.restore();
    }, t2.prototype.setPatternTransform = function(t3, e2) {
      if (this._svgMatrix !== false) {
        if (!this._svgMatrix) {
          var i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (i2 && i2.createSVGMatrix && (this._svgMatrix = i2.createSVGMatrix()), !this._svgMatrix || !t3.setTransform)
            return void (this._svgMatrix = false);
        }
        this._svgMatrix.a = e2.a, this._svgMatrix.b = e2.b, this._svgMatrix.c = e2.c, this._svgMatrix.d = e2.d, this._svgMatrix.e = e2.tx, this._svgMatrix.f = e2.ty, t3.setTransform(this._svgMatrix.inverse());
      }
    }, t2.prototype.destroy = function() {
      this.renderer = null, this._svgMatrix = null, this._tempMatrix = null;
    }, t2;
  }(), hm = new Lh.d();
  Jd.prototype.generateCanvasTexture = function(t2, e2) {
    e2 === void 0 && (e2 = 1);
    var i2 = this.getLocalBounds(), n2 = Vh.p.create({ width: i2.width, height: i2.height, scaleMode: t2, resolution: e2 });
    nm || (nm = new om.a()), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(hm), hm.invert(), hm.tx -= i2.x, hm.ty -= i2.y, nm.render(this, { renderTexture: n2, clear: true, transform: hm });
    var r2 = Vh.t.from(n2.baseTexture._canvasRenderTarget.canvas, { scaleMode: t2 });
    return r2.baseTexture.setResolution(e2), r2;
  }, Jd.prototype.cachedGraphicsData = [], Jd.prototype._renderCanvas = function(t2) {
    this.isMask !== true && (this.finishPoly(), t2.plugins.graphics.render(this));
  };
  /*!
   * @pixi/canvas-sprite - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var um = new Lh.d(), cm = function() {
    function t2(t3) {
      this.renderer = t3;
    }
    return t2.prototype.render = function(t3) {
      var e2 = t3._texture, i2 = this.renderer, n2 = i2.context;
      if (e2.valid) {
        var r2 = e2._frame.width, o2 = e2._frame.height, s2 = t3.transform.worldTransform, a2 = 0, l2 = 0, h2 = e2.baseTexture.getDrawableSource();
        if (!(e2.orig.width <= 0 || e2.orig.height <= 0) && e2.valid && h2) {
          i2.setBlendMode(t3.blendMode, true), i2.context.globalAlpha = t3.worldAlpha;
          var u2 = e2.baseTexture.scaleMode === Sc.p.LINEAR;
          i2.smoothProperty && i2.context[i2.smoothProperty] !== u2 && (n2[i2.smoothProperty] = u2), e2.trim ? (a2 = e2.trim.width / 2 + e2.trim.x - t3.anchor.x * e2.orig.width, l2 = e2.trim.height / 2 + e2.trim.y - t3.anchor.y * e2.orig.height) : (a2 = (0.5 - t3.anchor.x) * e2.orig.width, l2 = (0.5 - t3.anchor.y) * e2.orig.height), e2.rotate && (s2.copyTo(um), s2 = um, Lh.n.matrixAppendRotationInv(s2, e2.rotate, a2, l2), a2 = 0, l2 = 0), a2 -= r2 / 2, l2 -= o2 / 2, i2.setContextTransform(s2, t3.roundPixels, 1), t3.roundPixels && (a2 |= 0, l2 |= 0);
          var c2 = e2.baseTexture.resolution, d2 = i2._outerBlend;
          d2 && (n2.save(), n2.beginPath(), n2.rect(a2 * i2.resolution, l2 * i2.resolution, r2 * i2.resolution, o2 * i2.resolution), n2.clip()), t3.tint !== 16777215 ? (t3._cachedTint === t3.tint && t3._tintedCanvas.tintId === t3._texture._updateID || (t3._cachedTint = t3.tint, t3._tintedCanvas = om.b.getTintedCanvas(t3, t3.tint)), n2.drawImage(t3._tintedCanvas, 0, 0, Math.floor(r2 * c2), Math.floor(o2 * c2), Math.floor(a2 * i2.resolution), Math.floor(l2 * i2.resolution), Math.floor(r2 * i2.resolution), Math.floor(o2 * i2.resolution))) : n2.drawImage(h2, e2._frame.x * c2, e2._frame.y * c2, Math.floor(r2 * c2), Math.floor(o2 * c2), Math.floor(a2 * i2.resolution), Math.floor(l2 * i2.resolution), Math.floor(r2 * i2.resolution), Math.floor(o2 * i2.resolution)), d2 && n2.restore(), i2.setBlendMode(Sc.b.NORMAL);
        }
      }
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }();
  ep.prototype._tintedCanvas = null, ep.prototype._renderCanvas = function(t2) {
    t2.plugins.sprite.render(this);
  };
  /*!
   * @pixi/canvas-extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var dm = new Lh.j(), pm = function() {
    function t2(t3) {
      this.renderer = t3;
    }
    return t2.prototype.image = function(t3, e2, i2) {
      var n2 = new Image();
      return n2.src = this.base64(t3, e2, i2), n2;
    }, t2.prototype.base64 = function(t3, e2, i2) {
      return this.canvas(t3).toDataURL(e2, i2);
    }, t2.prototype.canvas = function(t3) {
      var e2, i2, n2, r2, o2 = this.renderer;
      t3 && (r2 = t3 instanceof Vh.p ? t3 : o2.generateTexture(t3)), r2 ? (e2 = r2.baseTexture._canvasRenderTarget.context, i2 = r2.baseTexture._canvasRenderTarget.resolution, n2 = r2.frame) : (e2 = o2.rootContext, i2 = o2.resolution, (n2 = dm).width = this.renderer.width, n2.height = this.renderer.height);
      var s2 = Math.floor(n2.width * i2 + 1e-4), a2 = Math.floor(n2.height * i2 + 1e-4), l2 = new Ph.CanvasRenderTarget(s2, a2, 1), h2 = e2.getImageData(n2.x * i2, n2.y * i2, s2, a2);
      return l2.context.putImageData(h2, 0, 0), l2.canvas;
    }, t2.prototype.pixels = function(t3) {
      var e2, i2, n2, r2, o2 = this.renderer;
      t3 && (r2 = t3 instanceof Vh.p ? t3 : o2.generateTexture(t3)), r2 ? (e2 = r2.baseTexture._canvasRenderTarget.context, i2 = r2.baseTexture._canvasRenderTarget.resolution, n2 = r2.frame) : (e2 = o2.rootContext, i2 = o2.resolution, (n2 = dm).width = o2.width, n2.height = o2.height);
      var s2 = n2.x * i2, a2 = n2.y * i2, l2 = n2.width * i2, h2 = n2.height * i2;
      return e2.getImageData(s2, a2, l2, h2).data;
    }, t2.prototype.destroy = function() {
      this.renderer = null;
    }, t2;
  }(), fm = function(t2, e2) {
    return (fm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var i2 in e3)
        e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
    })(t2, e2);
  };
  function mm(t2, e2) {
    var i2 = t2;
    if (e2 instanceof Vh.c) {
      var n2 = e2.source, r2 = n2.width === 0 ? i2.canvas.width : Math.min(i2.canvas.width, n2.width), o2 = n2.height === 0 ? i2.canvas.height : Math.min(i2.canvas.height, n2.height);
      return i2.ctx.drawImage(n2, 0, 0, r2, o2, 0, 0, i2.canvas.width, i2.canvas.height), true;
    }
    return false;
  }
  var gm, vm = function(t2) {
    function e2(e3) {
      var i2 = t2.call(this, e3) || this;
      return i2.uploadHookHelper = i2, i2.canvas = document.createElement("canvas"), i2.canvas.width = 16, i2.canvas.height = 16, i2.ctx = i2.canvas.getContext("2d"), i2.registerUploadHook(mm), i2;
    }
    return function(t3, e3) {
      function i2() {
        this.constructor = t3;
      }
      fm(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
    }(e2, t2), e2.prototype.destroy = function() {
      t2.prototype.destroy.call(this), this.ctx = null, this.canvas = null;
    }, e2;
  }(bp), _m = new Lh.d(), ym = new Lh.d(), xm = [new Lh.g(), new Lh.g(), new Lh.g(), new Lh.g()];
  /*!
   * @pixi/canvas-sprite-tiling - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite-tiling is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  Pp.prototype._renderCanvas = function(t2) {
    var e2 = this._texture;
    if (e2.baseTexture.valid) {
      var i2 = t2.context, n2 = this.worldTransform, r2 = e2.baseTexture, o2 = r2.getDrawableSource(), s2 = r2.resolution;
      if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
        this._textureID = this._texture._updateID;
        var a2 = new Ph.CanvasRenderTarget(e2._frame.width, e2._frame.height, s2);
        this.tint !== 16777215 ? (this._tintedCanvas = om.b.getTintedCanvas(this, this.tint), a2.context.drawImage(this._tintedCanvas, 0, 0)) : a2.context.drawImage(o2, -e2._frame.x * s2, -e2._frame.y * s2), this._cachedTint = this.tint, this._canvasPattern = a2.context.createPattern(a2.canvas, "repeat");
      }
      i2.globalAlpha = this.worldAlpha, t2.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform();
      var l2 = this.tileTransform.localTransform, h2 = this._width, u2 = this._height;
      _m.identity(), ym.copyFrom(l2), this.uvRespectAnchor || ym.translate(-this.anchor.x * h2, -this.anchor.y * u2), ym.scale(this.tileScale.x / s2, this.tileScale.y / s2), _m.prepend(ym), _m.prepend(n2), t2.setContextTransform(_m), i2.fillStyle = this._canvasPattern;
      var c2 = this.anchor.x * -h2, d2 = this.anchor.y * -u2;
      xm[0].set(c2, d2), xm[1].set(c2 + h2, d2), xm[2].set(c2 + h2, d2 + u2), xm[3].set(c2, d2 + u2);
      for (var p2 = 0; p2 < 4; p2++)
        ym.applyInverse(xm[p2], xm[p2]);
      i2.beginPath(), i2.moveTo(xm[0].x, xm[0].y);
      for (p2 = 1; p2 < 4; p2++)
        i2.lineTo(xm[p2].x, xm[p2].y);
      i2.closePath(), i2.fill();
    }
  }, vd.prototype.renderCanvas = function(t2) {
    if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) {
      var e2 = t2.context, i2 = this.worldTransform, n2 = true, r2 = 0, o2 = 0, s2 = 0, a2 = 0;
      t2.setBlendMode(this.blendMode), e2.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
      for (var l2 = 0; l2 < this.children.length; ++l2) {
        var h2 = this.children[l2];
        if (h2.visible && h2._texture.valid) {
          var u2 = h2._texture.frame;
          if (e2.globalAlpha = this.worldAlpha * h2.alpha, h2.rotation % (2 * Math.PI) == 0)
            n2 && (t2.setContextTransform(i2, false, 1), n2 = false), r2 = h2.anchor.x * (-u2.width * h2.scale.x) + h2.position.x + 0.5, o2 = h2.anchor.y * (-u2.height * h2.scale.y) + h2.position.y + 0.5, s2 = u2.width * h2.scale.x, a2 = u2.height * h2.scale.y;
          else {
            n2 || (n2 = true), h2.displayObjectUpdateTransform();
            var c2 = h2.worldTransform;
            t2.setContextTransform(c2, this.roundPixels, 1), r2 = h2.anchor.x * -u2.width + 0.5, o2 = h2.anchor.y * -u2.height + 0.5, s2 = u2.width, a2 = u2.height;
          }
          var d2 = h2._texture.baseTexture.resolution;
          e2.drawImage(h2._texture.baseTexture.getDrawableSource(), u2.x * d2, u2.y * d2, u2.width * d2, u2.height * d2, r2 * t2.resolution, o2 * t2.resolution, s2 * t2.resolution, a2 * t2.resolution);
        }
      }
    }
  }, Oh.b.prototype._renderCanvas = function(t2) {
  }, Oh.b.prototype.renderCanvas = function(t2) {
    if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
      this._mask && t2.maskManager.pushMask(this._mask), this._renderCanvas(t2);
      for (var e2 = 0, i2 = this.children.length; e2 < i2; ++e2)
        this.children[e2].renderCanvas(t2);
      this._mask && t2.maskManager.popMask(t2);
    }
  }, Oh.c.prototype.renderCanvas = function(t2) {
  }, cp.prototype._renderCanvas = function(t2) {
    this._autoResolution && this._resolution !== t2.resolution && (this._resolution = t2.resolution, this.dirty = true), this.updateText(true), ep.prototype._renderCanvas.call(this, t2);
  }, om.a.registerPlugin("accessibility", Nh), om.a.registerPlugin("extract", pm), om.a.registerPlugin("graphics", lm), om.a.registerPlugin("interaction", zh), om.a.registerPlugin("mesh", sm.a), om.a.registerPlugin("prepare", vm), om.a.registerPlugin("sprite", cm);
  class bm extends Za.a {
    constructor() {
      super(), this.prevTime = -1, this.times = 0, this.valueTotal = 0, this.destroyed = false, this.value = 0, this.calcFps();
    }
    calcFps() {
      requestAnimationFrame((t2) => {
        const e2 = t2 - this.prevTime;
        this.valueTotal += e2, this.times += 1, this.times > 20 && (this.value = Math.floor(1e3 * this.times / this.valueTotal), this.valueTotal = 0, this.times = 0, this.destroyed || this.emit("update", this.value)), this.prevTime = t2, this.destroyed || this.calcFps();
      });
    }
    destroy() {
      this.destroyed = true;
    }
  }
  !function(t2) {
    t2.ResourceError = "RESOURCE_ERROR", t2.RuntimeError = "RUNTIME_ERROR", t2.RuntimeWarn = "RUNTIME_WARN", t2.CanvasCrash = "CANVAS_CRASH";
  }(gm || (gm = {}));
  class Tm extends Error {
    constructor(t2, e2) {
      var i2, n2;
      super(e2), i2 = this, n2 = new.target.prototype, Object.setPrototypeOf ? Object.setPrototypeOf(i2, n2) : i2.__proto__ && (i2.__proto__ = n2), this.errorType = t2, this.errorMsg = e2;
    }
    static transform(t2) {
      return t2 instanceof Tm ? t2 : new Tm(gm.RuntimeError, t2.message);
    }
  }
  function Em() {
    return function(t2, e2, i2) {
      const n2 = i2.value;
      i2.value = function(...t3) {
        try {
          return n2.apply(this, t3);
        } catch (t4) {
          throw new Tm(gm.RuntimeWarn, t4.message);
        }
      };
    };
  }
  var Sm = i(48), wm = i.n(Sm), Am = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  function Mm() {
    return r();
  }
  const Rm = "__delay_resolve_result__";
  function Cm(t2) {
    return new Promise((e2) => {
      setTimeout(() => {
        e2(Rm);
      }, t2);
    });
  }
  function Im(t2, e2) {
    return Am(this, void 0, void 0, function* () {
      const i2 = yield Promise.race([t2(), Cm(e2)]);
      return i2 === Rm ? Rm : i2;
    });
  }
  function Pm(t2, e2) {
    return Am(this, void 0, void 0, function* () {
      const i2 = Date.now();
      for (; !t2() && Date.now() - i2 < e2; )
        yield Cm(16);
    });
  }
  var Om = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  function Nm(t2, e2) {
    return Om(this, void 0, void 0, function* () {
      const i2 = yield Im(() => fetch(t2), e2);
      if (i2 === Rm)
        throw new Tm(gm.ResourceError, `"${t2}" loaded timeout"`);
      if (!i2.ok)
        throw new Tm(gm.ResourceError, `"${t2}" loaded failed with status "${i2.status}"`);
      return i2;
    });
  }
  class Lm {
    constructor(t2, e2, i2, n2, r2, o2, s2) {
      this.timeout = 15e3, this.useCache = false, this.taskId = "", this.delegate = null, this.urlInterrupter = null, this.useCache = e2, this.localStorage = t2, this.logger = i2, this.tracker = n2, this.timeout = r2, this.delegate = o2 || null, this.urlInterrupter = s2 || null;
    }
    attachTaskId(t2) {
      this.taskId = t2;
    }
    fetchJson(t2) {
      return Om(this, void 0, void 0, function* () {
        const e2 = Date.now();
        let i2 = t2;
        const n2 = t2;
        if (this.urlInterrupter && typeof this.urlInterrupter == "function") {
          const t3 = Date.now();
          i2 = yield this.urlInterrupter(i2), this.logger.info("use url interrupter, time: " + (Date.now() - t3), this.taskId);
        }
        let r2;
        if (this.useCache && (this.logger.info("load resource from cache. " + n2, this.taskId || ""), r2 = yield this.localStorage.getItem(n2)), r2)
          return this.logger.info("cache hit. " + n2, this.taskId || ""), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "cache" } }), r2;
        {
          let t3;
          if (this.delegate) {
            this.logger.info("load resource by delegate. " + n2, this.taskId || "");
            const r3 = Date.now();
            try {
              const o2 = yield Im(() => this.delegate.loadJson(i2), this.timeout);
              if (this.logger.info(`load resource by delegate end. ${n2}, time: ${Date.now() - r3}`, this.taskId || ""), o2 === Rm)
                throw new Tm(gm.ResourceError, `"${n2}" loaded timeout"`);
              t3 = JSON.parse(o2), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "delegate" } });
            } catch (t4) {
              this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "delegate" } });
            }
          } else {
            this.logger.info("load resource from server. " + n2, this.taskId || "");
            const r3 = Date.now();
            try {
              t3 = yield (yield Nm("" + i2, this.timeout)).json();
            } catch (t4) {
              throw this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "fetch" } }), t4;
            }
            this.logger.info(`load resource from server end. ${n2}, time: ${Date.now() - r3}`, this.taskId || ""), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "fetch" } });
          }
          return this.logger.info("load end. " + n2, this.taskId || ""), this.useCache && this.localStorage.setItem(n2, t3).catch(() => {
          }), t3;
        }
      });
    }
    fetchPng(t2, e2) {
      return Om(this, void 0, void 0, function* () {
        const i2 = Date.now();
        let n2 = t2;
        const r2 = t2;
        if (this.urlInterrupter && typeof this.urlInterrupter == "function") {
          const t3 = Date.now();
          n2 = yield this.urlInterrupter(n2), this.logger.info("use url interrupter, time: " + (Date.now() - t3), this.taskId);
        }
        let o2;
        const s2 = r2 + "-v2";
        if (this.useCache && (this.logger.info("load resource from cache. " + r2, this.taskId || ""), o2 = yield this.localStorage.getItem(s2)), o2) {
          const { scale: t3, scaledBase64: e3 } = o2;
          this.logger.info("cache hit. " + r2, this.taskId || "");
          const s3 = new Vh.c(e3, { resolution: 1 });
          return this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "cache" } }), { baseTexture: s3, scale: t3 };
        }
        {
          let t3;
          if (this.delegate)
            try {
              this.logger.info("load resource by delegate. " + r2, this.taskId || "");
              const e3 = Date.now();
              if (t3 = yield Im(() => this.delegate.loadImage(n2), this.timeout), this.logger.info(`load resource by delegate end. ${r2}, time: ${Date.now() - e3}`, this.taskId || ""), t3 === Rm)
                throw new Tm(gm.ResourceError, `"${r2}" loaded timeout"`);
              this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "delegate" } });
            } catch (t4) {
              this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "delegate" } });
            }
          else
            try {
              this.logger.info("load resource from server. " + r2, this.taskId || "");
              const e3 = Date.now(), o3 = yield Nm(n2, this.timeout);
              this.logger.info(`load resource from server end. ${r2}, time: ${Date.now() - e3}`, this.taskId || ""), t3 = yield o3.blob(), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "fetch" } });
            } catch (t4) {
              this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "fetch" } });
            }
          o2 = yield function(t4) {
            return new Promise((e3, i3) => {
              const n3 = new FileReader();
              n3.onload = () => {
                e3(n3.result);
              }, n3.onerror = () => {
                i3(new Tm(gm.ResourceError, "Failed parse blob data."));
              }, n3.readAsDataURL(t4);
            });
          }(t3);
          const a2 = document.createElement("img");
          a2.src = o2, yield new Promise((t4, e3) => {
            a2.onload = () => t4(""), a2.onerror = () => e3(new Error("load sprite image failed"));
          });
          let l2 = e2;
          const h2 = a2.width || 1, u2 = a2.height || 1, c2 = 2048, d2 = 2048;
          if (h2 > c2 || u2 > d2) {
            l2 *= c2 / h2;
            const t4 = l2 * u2;
            t4 > d2 && (l2 *= u2 / t4);
          }
          const p2 = document.createElement("canvas"), f2 = Math.ceil(a2.width * l2), m2 = Math.ceil(a2.height * l2);
          p2.width = f2, p2.height = m2;
          p2.getContext("2d").drawImage(a2, 0, 0, f2, m2);
          const g2 = p2.toDataURL("image/png"), v2 = new Vh.c(g2, { resolution: 1 });
          return this.logger.info("load end. " + r2, this.taskId || ""), this.useCache && this.localStorage.setItem(s2, { scale: l2, scaledBase64: g2 }).catch(() => {
          }), { baseTexture: v2, scale: l2 };
        }
      });
    }
    destroy() {
    }
  }
  var Dm = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Fm {
    constructor(t2) {
      this.isPaused = false, this.timestamp = 0, this.callbackList = [], this.onTimeUpdate = (t3) => {
        const e2 = t3 / (xd.b.TARGET_FPMS || 0.06);
        if (!this.isPaused) {
          this.timestamp += e2, this.callbackList = this.callbackList.filter((t5) => t5 && !t5.applied);
          let { length: t4 } = this.callbackList;
          for (let e3 = 0; e3 < t4; e3++) {
            const i2 = this.callbackList[e3];
            if (i2 && !i2.applied) {
              if (!(i2.triggerTime <= this.timestamp))
                break;
              i2.running = true, i2.fn(), i2.applied = true, t4 = this.callbackList.length;
            }
          }
        }
      }, this.ticker = t2, this.ticker.add(this.onTimeUpdate);
    }
    setTimeout(t2, e2) {
      const i2 = Mm(), n2 = this.timestamp + Math.max(e2 || 16, 16);
      return this.callbackList.push({ fn: t2, triggerTime: n2, id: i2, applied: false, running: false }), this.callbackList.sort((t3, e3) => t3.triggerTime - e3.triggerTime), i2;
    }
    clearTimeout(t2) {
      const e2 = this.callbackList.findIndex((e3) => e3.id === t2);
      e2 >= 0 && !this.callbackList[e2].running && this.callbackList.splice(e2, 1);
    }
    delay(t2) {
      return new Promise((e2) => {
        this.setTimeout(e2, t2);
      });
    }
    waitUntil(t2, e2) {
      return Dm(this, void 0, void 0, function* () {
        const i2 = this.timestamp;
        for (; !t2() && this.timestamp - i2 < e2; )
          yield this.delay(50);
      });
    }
    pause() {
      this.isPaused = true;
    }
    resume() {
      this.isPaused = false;
    }
  }
  var Bm = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  function Um(t2, e2, i2) {
    return i2 ? Math.floor(parseFloat(t2) * e2) : Math.ceil(parseFloat(t2) * e2);
  }
  const km = { w: false, h: false, x: true, y: true };
  class Gm {
    constructor(t2) {
      this.gifs = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.frames = /* @__PURE__ */ Object.create(null), this.spriteSheets = [], this.loader = t2;
    }
    getTexture(t2) {
      return this.textures[t2] || null;
    }
    getFrameData(t2) {
      return this.frames[t2];
    }
    getGifFrames(t2) {
      return this.gifs[t2] ? this.gifs[t2].filter((t3) => !!t3) : [];
    }
    loadSpriteSheetItem(t2, e2, i2, n2) {
      return Bm(this, void 0, void 0, function* () {
        const r2 = yield this.loader.fetchJson(`${t2}/${e2}/jsonOutput/${i2}.json`), { baseTexture: o2, scale: s2 } = yield this.loader.fetchPng(`${t2}/${e2}/jsonOutput/${i2}.png`, n2);
        !function(t3, e3) {
          t3.meta && t3.meta.size && ["w", "h"].forEach((i3) => {
            t3.meta.size[i3] = Um(t3.meta.size[i3], e3, km[i3]);
          }), t3.frames && Object.keys(t3.frames).forEach((i3) => {
            t3.frames[i3].frame && ["x", "y", "w", "h"].forEach((n3) => {
              t3.frames[i3].frame[n3] = Um(t3.frames[i3].frame[n3], e3, km[n3]);
            }), t3.frames[i3].spriteSourceSize && ["x", "y", "w", "h"].forEach((n3) => {
              t3.frames[i3].spriteSourceSize[n3] = Um(t3.frames[i3].spriteSourceSize[n3], e3, km[n3]);
            }), t3.frames[i3].sourceSize && ["w", "h"].forEach((n3) => {
              t3.frames[i3].sourceSize[n3] = Um(t3.frames[i3].sourceSize[n3], e3, km[n3]);
            });
          });
        }(r2, s2);
        const a2 = new Ap(o2, r2);
        yield new Promise((t3) => {
          a2.parse(() => t3(""));
        }), this.spriteSheets.push(a2), Object.keys(a2.textures).forEach((t3) => {
          const e3 = t3.match(/^(.+)_gif_(\d+)$/);
          if (e3 && e3[1] && e3[2]) {
            const i3 = e3[1];
            this.gifs[i3] || (this.gifs[i3] = []);
            const n3 = parseInt(e3[2], 10);
            this.gifs[i3][n3] = a2.textures[t3];
          } else
            this.frames[t3] = r2.frames[t3], this.textures[t3] = a2.textures[t3];
        });
      });
    }
    destroy() {
      this.spriteSheets.forEach((t2) => t2.destroy(true)), this.spriteSheets = [], this.gifs = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.frames = /* @__PURE__ */ Object.create(null);
    }
  }
  var Hm = i(18), jm = i.n(Hm), zm = i(13), Vm = i.n(zm);
  function Xm(t2, e2, i2) {
    let n2, r2;
    const o2 = Math.round(t2) % 360;
    if (o2 % 180 == 0)
      n2 = Math.cos(o2 * (Math.PI / 180)) * e2, r2 = 0;
    else if (o2 % 90 == 0)
      n2 = 0, r2 = Math.sin(o2 * (Math.PI / 180)) * i2;
    else {
      const t3 = function(t4) {
        const e3 = t4 * Math.PI / 180;
        return Math.tan(e3);
      }(o2);
      n2 = e2 * i2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(e2 * t3, 2)), (o2 > 90 && o2 < 270 || o2 < -90 && o2 > -270) && (n2 = -n2), r2 = t3 * n2;
    }
    return { x: n2, y: r2 };
  }
  function Wm(t2, e2, i2, n2, r2, o2) {
    const s2 = t2, a2 = e2;
    let l2, h2, u2, c2, d2;
    if (Math.round(n2) === 0)
      l2 = r2, h2 = o2, d2 = 0;
    else if (Math.round(n2) >= 360)
      l2 = r2, h2 = o2, u2 = r2 + 2 * t2 * Math.abs(Math.cos(-i2 / 180 * Math.PI)), c2 = o2 + 2 * e2 * Math.sin(-i2 / 180 * Math.PI), d2 = 1;
    else {
      const t3 = -i2, e3 = -(i2 + n2), { x: u3, y: c3 } = Xm(t3, s2, a2), p2 = r2 - u3, f2 = o2 + c3, { x: m2, y: g2 } = Xm(e3, s2, a2);
      l2 = m2 + p2, h2 = f2 - g2, d2 = n2 >= -360 && n2 < -180 ? 1 : n2 >= -180 && n2 < 0 || n2 > 0 && n2 < 180 ? 0 : 1;
    }
    return { radiusX: s2, radiusY: a2, xAxisRotation: 0, largeArcFlag: d2, sweepFlag: n2 > 0 ? 1 : 0, endX: l2, endY: h2, middleX: u2, middleY: c2 };
  }
  class Ym {
    constructor() {
      this.pool = [];
    }
    getObject(t2) {
      const e2 = this.pool.find((t3) => !t3.isUsed);
      if (e2)
        return e2.isUsed = true, e2.obj;
      {
        const e3 = { obj: this.createObject(), isUsed: true, group: t2 };
        return this.pool.push(e3), e3.obj;
      }
    }
    collectObject(t2) {
      const e2 = this.pool.find((e3) => e3.obj === t2);
      e2 && (e2.isUsed = false, this.resetObject(e2.obj));
    }
    collectObjectByGroup(t2) {
      this.pool.filter((e2) => e2.group === t2).forEach((t3) => this.collectObject(t3.obj));
    }
  }
  const qm = new class extends Ym {
    createObject() {
      const t2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      return t2.setAttribute("xmlns", "http://www.w3.org/2000/svg"), t2.setAttribute("version", "1.1"), t2;
    }
    resetObject(t2) {
      t2.removeAttribute("viewBox"), t2.removeAttribute("width"), t2.removeAttribute("height"), t2.innerHTML = "";
    }
  }();
  const Zm = new class extends Ym {
    createObject() {
      return document.createElement("img");
    }
    resetObject(t2) {
      t2.removeAttribute("src");
    }
  }();
  var Jm = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Km {
    constructor(t2) {
      this.imgElements = [], this.svgElements = [], this.idToHashMap = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.graphics = [], this.hashToIdMap = /* @__PURE__ */ Object.create(null), this.maxResolution = t2;
    }
    render(t2, e2, i2, n2) {
      return Jm(this, void 0, void 0, function* () {
        const { items: e3, width: r2, height: o2 } = t2, s2 = Zm.getObject(i2), a2 = new Vh.c(s2, { width: r2 * n2, height: o2 * n2, resolution: 1 }), l2 = qm.getObject(i2);
        this.imgElements.push(s2), this.svgElements.push(l2), l2.setAttribute("viewBox", `0 0 ${r2} ${o2}`), l2.setAttribute("width", "" + r2), l2.setAttribute("height", "" + o2);
        const h2 = {};
        e3.forEach((t3) => {
          const { item: e4, x: i3, y: r3 } = t3, o3 = i3 + 2, s3 = r3 + 2;
          e4.pathsData.forEach((t4) => {
            let e5 = "";
            t4.cmds.forEach(([i4, n3]) => {
              e5 += i4 + " ", e5 += n3.map((e6) => (Vm()(e6) || (e6.x = e6.x + t4.offset.x + o3, e6.y = e6.y + t4.offset.y + s3), e6)).reduce((t5, e6) => (Vm()(e6) ? t5 += e6 + " " : t5 += `${e6.x} ${e6.y} `, t5), ""), e5 += " ";
            }), t4.pathElement.setAttribute("d", e5), l2.appendChild(t4.pathElement);
          });
          const u3 = e4.width - 4 - 2 * e4.padding, c3 = e4.height - 4 - 2 * e4.padding;
          this.textures[e4.hash] = { texture: new Vh.t(a2, new Lh.j((o3 + 2) * n2, (s3 + 2) * n2, u3 * n2, c3 * n2)), pivot: e4.pivot, scale: 1 / n2 }, h2[e4.hash] = this.hashToIdMap[e4.hash];
        });
        const u2 = (c2 = '<?xml version="1.0" encoding="utf-8"?>' + l2.outerHTML, "data:image/svg+xml," + encodeURIComponent(c2).replace(/'/g, "%27").replace(/"/g, "%22"));
        var c2;
        const d2 = document.createElement("img");
        d2.src = u2, yield new Promise((t3, e4) => {
          d2.onload = () => t3(""), d2.onerror = () => e4();
        });
        const p2 = document.createElement("canvas");
        p2.width = d2.width * n2, p2.height = d2.height * n2;
        p2.getContext("2d").drawImage(d2, 0, 0, p2.width, p2.height), s2.src = p2.toDataURL("image/png"), yield new Promise((t3, e4) => {
          s2.onload = () => t3(""), s2.onerror = () => e4();
        });
      });
    }
    getGraphicsData(t2) {
      const e2 = this.idToHashMap[t2] || "";
      return this.textures[e2] || null;
    }
    addGraphics(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
      var c2, d2;
      if (!s2 && !l2)
        return t2;
      const p2 = jm()(i2 + ((d2 = (c2 = s2 == null ? void 0 : s2.width) === null || c2 === void 0 ? void 0 : c2.toString()) !== null && d2 !== void 0 ? d2 : 0) + l2 + h2 + u2);
      if (this.hashToIdMap[p2] || (this.hashToIdMap[p2] = []), this.hashToIdMap[p2].push(t2), this.idToHashMap[t2] = p2, this.graphics.findIndex((t3) => t3.hash === p2) < 0) {
        const { graphicsWidth: t3, graphicsHeight: i3, pathsData: a3, pivot: c3, padding: d3 } = function(t4, e3, i4, n3, r3, o3, s3, a4, l3) {
          var h3;
          const u3 = [], c4 = { x: Math.abs(r3.x), y: Math.abs(r3.y) };
          let d4 = 0, p3 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = "none";
          const _2 = (h3 = n3 == null ? void 0 : n3.width) !== null && h3 !== void 0 ? h3 : 0;
          return s3 ? (d4 = e3, p3 = i4, g2 = 0) : (v2 = l3 || "#ff0000", g2 = _2, f2 = 0.5 * _2, m2 = 0.5 * _2, d4 = e3 + _2, p3 = i4 + _2, c4.x += 0.5 * _2, c4.y += 0.5 * _2), d4 += Math.abs(r3.x), p3 += Math.abs(r3.y), f2 += Math.abs(r3.x), m2 += Math.abs(r3.y), d4 += 4, p3 += 4, f2 += 2, m2 += 2, d4 = Math.ceil(d4), p3 = Math.ceil(p3), t4.forEach((t5) => {
            const e4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
            t5.fill !== "none" && s3 ? e4.setAttribute("fill", a4 || "#ff0000") : e4.setAttribute("fill", "none"), t5.hasStroke && !s3 && (e4.setAttribute("stroke-linecap", (n3 == null ? void 0 : n3.cap) || "butt"), e4.setAttribute("stroke-linejoin", (n3 == null ? void 0 : n3.join) || "miter"), e4.setAttribute("stroke-width", g2.toString()), e4.setAttribute("stroke", v2), (n3 == null ? void 0 : n3.dash) && e4.setAttribute("stroke-dasharray", n3.dash));
            const { scale: i5 } = t5, r4 = t5.path.trim().split(" ");
            let o4 = { x: 0, y: 0 };
            const l4 = { offset: { x: f2, y: m2 }, cmds: [], pathElement: e4 };
            for (let t6 = 0; t6 < r4.length; t6 += 2) {
              const e5 = r4[t6], n4 = r4[t6 + 1];
              if (e5 === "M") {
                let [t7, e6] = n4.split(",").map((t8) => Number(t8));
                o4 = { x: t7, y: e6 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, l4.cmds.push(["M", [{ x: t7, y: e6 }]]);
              } else if (e5 === "A") {
                const [t7, e6, r5, s4] = n4.split(",").map((t8) => Number(t8)), a5 = r5 / Math.PI * 180, h4 = s4 / Math.PI * 180, u4 = Wm(t7, e6, a5, h4, o4.x, o4.y);
                Math.round(h4) >= 360 ? (o4 = { x: u4.endX, y: u4.endY }, l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.middleX / 9525 * i5.x, y: u4.middleY / 9525 * i5.y }]]), l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.endX / 9525 * i5.x, y: u4.endY / 9525 * i5.y }]])) : (o4 = { x: u4.endX, y: u4.endY }, l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.endX / 9525 * i5.x, y: u4.endY / 9525 * i5.y }]]));
              } else if (e5 === "L") {
                let [t7, e6] = n4.split(",").map((t8) => Number(t8));
                o4 = { x: t7, y: e6 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, l4.cmds.push(["L", [{ x: t7, y: e6 }]]);
              } else if (e5 === "QB") {
                let [t7, e6, r5, s4] = n4.split(",").map((t8) => Number(t8));
                o4 = { x: r5, y: s4 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, r5 = r5 / 9525 * i5.x, s4 = s4 / 9525 * i5.y, l4.cmds.push(["Q", [{ x: t7, y: e6 }, { x: r5, y: s4 }]]);
              } else if (e5 === "CB") {
                let [t7, e6, r5, s4, a5, h4] = n4.split(",").map((t8) => Number(t8));
                o4 = { x: a5, y: h4 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, r5 = r5 / 9525 * i5.x, s4 = s4 / 9525 * i5.y, a5 = a5 / 9525 * i5.x, h4 = h4 / 9525 * i5.y, l4.cmds.push(["C", [{ x: t7, y: e6 }, { x: r5, y: s4 }, { x: a5, y: h4 }]]);
              } else
                e5 === "C" && l4.cmds.push(["Z", []]);
            }
            u3.push(l4);
          }), { graphicsWidth: d4, graphicsHeight: p3, pivot: c4, padding: 2, pathsData: u3 };
        }(e2, r2, o2, s2, n2, 0, l2, h2, u2);
        this.graphics.push({ hash: p2, pathsData: a3, pivot: c3, width: t3, height: i3, padding: d3 });
      }
      return t2;
    }
    pack() {
      this.graphics.forEach((t2) => {
        t2.width += 4, t2.height += 4;
      });
      return function t2(e2) {
        const i2 = [], n2 = e2.filter((t3) => {
          const e3 = t3.width < 2048 && t3.height < 2048;
          return e3 || i2.push(t3), e3;
        }).sort((t3, e3) => t3.width * t3.height - e3.width * e3.height);
        let r2 = n2.length + 1, o2 = 2050, s2 = 2050;
        const a2 = [];
        let l2 = null;
        for (; (o2 > 2048 || s2 > 2048) && n2.length > 0; )
          r2 -= 1, l2 = wm()(n2.slice(0, r2)), o2 = l2.width, s2 = l2.height;
        return l2 && a2.push(l2), i2.forEach((t3) => {
          const e3 = wm()([t3]);
          a2.push(e3);
        }), r2 < n2.length ? a2.concat(t2(n2.slice(r2))) : a2;
      }(this.graphics);
    }
    destroy() {
      Object.keys(this.textures).forEach((t2) => {
        var e2;
        (e2 = this.textures[t2]) === null || e2 === void 0 || e2.texture.destroy(true);
      }), this.textures = /* @__PURE__ */ Object.create(null), this.imgElements.forEach((t2) => Zm.collectObject(t2)), this.svgElements.forEach((t2) => qm.collectObject(t2)), this.graphics = [];
    }
  }
  class Qm {
    constructor() {
      this.runningTimeNodes = {};
    }
    addRunningTimeNode(t2, e2, i2) {
      const n2 = `${e2}_${t2}`;
      if (this.runningTimeNodes[n2])
        try {
          this.runningTimeNodes[n2].dispose(true);
        } catch (t3) {
        }
      this.runningTimeNodes[n2] = i2;
    }
    removeRunningTimeNode(t2, e2) {
      const i2 = `${e2}_${t2}`;
      delete this.runningTimeNodes[i2];
    }
  }
  class $m {
    constructor(t2) {
      this.eventHub = t2, this.targets = /* @__PURE__ */ Object.create(null);
    }
    getTargets() {
      return Object.keys(this.targets).map((t2) => this.targets[t2]);
    }
    addTarget(t2, e2) {
      this.targets[t2] = e2;
    }
    getTargetById(t2) {
      return this.targets[t2];
    }
    getTarget(t2, e2, i2 = { type: "el", index: 0, id: "" }) {
      var n2, r2;
      let o2 = this.targets[t2.id];
      return t2.type !== "shape" ? o2 : (t2.type === "shape" && t2.txEl && (o2 = (n2 = o2 == null ? void 0 : o2.getTextElement(t2.txEl.type, t2.txEl.range)) !== null && n2 !== void 0 ? n2 : null), t2.type === "shape" && t2.bg && i2.index === 0 && (e2 = false, o2 = (r2 = o2 == null ? void 0 : o2.getBgElement()) !== null && r2 !== void 0 ? r2 : null, this.eventHub.emit("IterateTimeNodeEnd", i2.id)), e2 && o2 ? o2.getIterateEntry(i2.type, i2.index, i2.id) : (o2 || this.eventHub.emit("IterateTimeNodeEnd", i2.id), o2));
    }
    clearTargets() {
      this.targets = /* @__PURE__ */ Object.create(null);
    }
  }
  class tg {
    constructor(t2) {
      this.target = t2;
    }
    get color() {
      return this.target.strokeColorFilter.currentColor;
    }
    set color(t2) {
      this.target.strokeColorFilter.color = t2;
    }
    get on() {
      return this.target.strokeActive ? "true" : "false";
    }
    set on(t2) {
      this.target.strokeActive = t2 === "true";
    }
  }
  class eg {
    constructor(t2) {
      this.applyCommand = (t3, e2) => {
        this.target.applyCommand(t3, e2);
      }, this.target = t2;
    }
  }
  class ig {
    constructor(t2) {
      this.target = t2;
    }
    get color() {
      return this.target.pptColorFilter.currentColor;
    }
    set color(t2) {
      this.target.pptColorActive && (this.target.pptColorFilter.color = t2);
    }
    get on() {
      return this.target.pptColorActive ? "true" : "false";
    }
    set on(t2) {
      this.target.pptColorActive = t2 === "true";
    }
    get designColor() {
      return this.target.pptColorFilter.designColor;
    }
    toString() {
      return this.color;
    }
  }
  class ng {
    constructor(t2) {
      this.target = t2;
    }
    get color() {
      return this.target.fillColorFilter.currentColor;
    }
    set color(t2) {
      this.target.fillActive && (this.target.fillColorFilter.color = t2);
    }
    get on() {
      return this.target.fillActive ? "true" : "false";
    }
    set on(t2) {
      this.target.fillActive = t2 === "true";
    }
    get designColor() {
      return this.target.fillColorFilter.designColor;
    }
  }
  class rg {
    constructor(t2, e2, i2) {
      this.hardHidden = false, this.designRotation = 0, this.target = t2, e2 === true && (this.hardHidden = true), this.designRotation = i2;
    }
    get opacity() {
      return this.target.alpha;
    }
    set opacity(t2) {
      this.target.alpha = t2;
    }
    get rotation() {
      return this.target.rotation / Math.PI * 180;
    }
    set rotation(t2) {
      this.target.rotation = t2 / 180 * Math.PI + this.designRotation;
    }
    get visibility() {
      return this.target.visible ? "visible" : "hidden";
    }
    set visibility(t2) {
      this.visibility === t2 || this.hardHidden || (this.target.visible = t2 === "visible");
    }
  }
  class og {
    constructor(t2, e2) {
      this.actions = [], this.ctx = e2, this.object = t2, this.object.interactive = true;
    }
    reset(t2) {
      this.object.interactive = false, this.object.removeAllListeners(), this.object = t2, this.object.interactive = true;
    }
    addAction(t2, e2) {
      this.actions.push([t2, e2]), e2 === "click" ? (this.object.addListener("pointertap", () => this.handleAction(t2)), this.object.cursor = "pointer") : e2 === "hover" && this.object.addListener("mouseover", () => this.handleAction(t2));
    }
    getOriginHitArea() {
      return this.object.hitArea ? this.object.hitArea : new Lh.k(0, 0, this.object.width, this.object.height);
    }
    handleAction(t2) {
      this.ctx.eventHub.emit(zy.hyperlinkTrigger, t2), this.execAction(t2);
    }
    execAction(t2) {
      var e2, i2;
      if (this.ctx.eventHub.emit(zy.userInput), t2.action === "ppaction://hlinksldjump") {
        const i3 = ((e2 = t2 == null ? void 0 : t2.target) !== null && e2 !== void 0 ? e2 : "").match(/slide(\d+)\.xml/);
        i3 && i3[1] && this.ctx.eventHub.emit(zy.requestGotoSlide, Number(i3[1]));
      } else if (t2.action === "ppaction://hlinkshowjump?jump=nextslide")
        this.ctx.eventHub.emit(zy.requestNextSlide);
      else if (t2.action === "ppaction://hlinkshowjump?jump=previousslide")
        this.ctx.eventHub.emit(zy.requestPrevSlide);
      else if (t2.action === "ppaction://hlinkshowjump?jump=firstslide")
        this.ctx.eventHub.emit(zy.requestGotoSlide, 1);
      else if (t2.action === "ppaction://hlinkshowjump?jump=lastslide")
        this.ctx.eventHub.emit(zy.requestGotoSlide, -1);
      else if (t2.action === "ppaction://hlinkshowjump?jump=lastslideviewed") {
        const t3 = this.ctx.lastViewedIndex;
        this.ctx.eventHub.emit(zy.requestGotoSlide, t3);
      } else
        t2.action === "ppaction://hlinkshowjump?jump=endshow" ? this.ctx.eventHub.emit(zy.requestGotoSlide, -1) : t2.action === "" && ((i2 = t2.target) === null || i2 === void 0 ? void 0 : i2.startsWith("http")) && this.ctx.eventHub.emit(zy.requestOpenUrl, t2.target);
    }
  }
  function sg(t2, e2, i2 = 5) {
    return Math.abs(t2 - e2) <= Math.pow(10, -i2);
  }
  function ag(t2) {
    return Math.floor(1e6 * t2) / 1e6;
  }
  class lg {
    constructor() {
      this.point = { x: 0, y: 0 }, this.slope = Math.PI / 4;
    }
    static fromPointSlope(t2, e2) {
      const i2 = new lg();
      return i2.point = t2, i2.slope = e2, i2;
    }
    resolveY(t2) {
      return Math.tan(this.slope) * (t2 - this.point.x) + this.point.y;
    }
    distanceToLinearEquation(t2) {
      return sg(this.slope, t2.slope) ? this.distanceToPoint(t2.point) : -1;
    }
    distanceToPoint(t2) {
      let e2 = 0;
      if (Math.tan(this.slope) * (t2.x - this.point.x) + this.point.y === t2.y)
        return 0;
      e2 = this.slope >= Math.PI / 2 ? this.slope - Math.PI / 2 : Math.PI / 2 + this.slope;
      const i2 = lg.fromPointSlope(t2, e2), n2 = this.crossPoint(i2);
      return n2 ? Math.ceil(Math.sqrt(Math.pow(n2.x - t2.x, 2) + Math.pow(n2.y - t2.y, 2))) : 0;
    }
    crossPoint(t2) {
      if (sg(t2.slope, this.slope))
        return null;
      let e2 = 0, i2 = 0;
      const n2 = Math.tan(t2.slope), r2 = Math.tan(this.slope), { x: o2, y: s2 } = this.point, { x: a2, y: l2 } = t2.point;
      return sg(this.slope, Math.PI / 2) ? (e2 = this.point.x, i2 = n2 * (e2 - a2) + l2) : sg(t2.slope, Math.PI / 2) ? (e2 = t2.point.x, i2 = r2 * (e2 - o2) + s2) : sg(this.slope, Math.PI) || sg(this.slope, 0) ? (i2 = this.point.y, e2 = (i2 - l2) / n2 + a2) : sg(t2.slope, Math.PI) || sg(t2.slope, 0) ? (i2 = t2.point.y, e2 = (i2 - s2) / r2 + o2) : (e2 = (n2 * a2 - l2 + s2 - r2 * o2) / (n2 - r2), i2 = r2 * (e2 - o2) + s2), { x: e2, y: i2 };
    }
  }
  class hg {
    constructor(t2, e2, i2) {
      var n2, r2, o2, s2, a2, l2;
      this.scaleExt = { x: 1, y: 1 }, this.scaleOrigin = { x: 1, y: 1 }, this.designScale = { x: 1, y: 1 }, this.bound = new Lh.j(0, 0, 1, 1), this.pptX = 0, this.pptY = 0, this.presetSubType = 0, this.designWidth = 0, this.designHeight = 0, this.designX = 0, this.designY = 0, this.hasPreset = false, this.container = new Oh.b(), this.ctx = e2, this.style = new rg(this.container, !!t2.hardHidden, t2.rotation || 0), this.designGlobalPosition = { x: i2.parentGlobalPos.x + ((r2 = (n2 = t2.position) === null || n2 === void 0 ? void 0 : n2.x) !== null && r2 !== void 0 ? r2 : 0), y: i2.parentGlobalPos.y + ((s2 = (o2 = t2.position) === null || o2 === void 0 ? void 0 : o2.y) !== null && s2 !== void 0 ? s2 : 0) }, (t2.hlinkClick || t2.hlinkHover) && (this.hyperlink = new og(this.container, this.ctx), t2.hlinkHover && ((a2 = this.hyperlink) === null || a2 === void 0 || a2.addAction(t2.hlinkHover, "hover")), t2.hlinkClick && ((l2 = this.hyperlink) === null || l2 === void 0 || l2.addAction(t2.hlinkClick, "click"))), this.ctx.clock.waitUntil(() => {
        try {
          return !!this.container.width;
        } catch (t3) {
          return false;
        }
      }, 3e3).then(() => {
        try {
          this.designWidth = this.designWidth || this.container.width;
        } catch (t3) {
        }
      }), this.ctx.clock.waitUntil(() => {
        try {
          return !!this.container.height;
        } catch (t3) {
          return false;
        }
      }, 3e3).then(() => {
        try {
          this.designHeight = this.designHeight || this.container.height;
        } catch (t3) {
        }
      });
    }
    updateScale() {
      this.container && (this.container.scale.x = this.designScale.x * this.scaleExt.x * this.scaleOrigin.x, this.container.scale.y = this.designScale.y * this.scaleExt.y * this.scaleOrigin.y);
    }
    updateTransform(t2) {
      var e2, i2, n2, r2, o2, s2, a2, l2;
      this.designWidth = t2.width, this.designHeight = t2.height, this.designX = (i2 = (e2 = t2.position) === null || e2 === void 0 ? void 0 : e2.x) !== null && i2 !== void 0 ? i2 : 0, this.designY = (r2 = (n2 = t2.position) === null || n2 === void 0 ? void 0 : n2.y) !== null && r2 !== void 0 ? r2 : 0;
      const h2 = this.designWidth / 2, u2 = this.designHeight / 2;
      this.container.width = this.designWidth, this.container.height = this.designHeight, this.container.pivot.x = h2, this.container.pivot.y = u2;
      const c2 = (s2 = (o2 = t2.position) === null || o2 === void 0 ? void 0 : o2.x) !== null && s2 !== void 0 ? s2 : 0, d2 = (l2 = (a2 = t2.position) === null || a2 === void 0 ? void 0 : a2.y) !== null && l2 !== void 0 ? l2 : 0;
      this.container.x = c2 + h2, this.container.y = d2 + u2, t2.scale && (this.designScale = { x: t2.scale.x, y: t2.scale.y }, this.container.scale.x = t2.scale.x, this.container.scale.y = t2.scale.y), t2.rotation && (this.container.rotation = t2.rotation);
      const p2 = new Jd();
      p2.drawRect(0, 0, this.designWidth, this.designHeight), this.container.addChild(p2), this.json.hardHidden && (this.container.visible = false), this.bound.x = c2, this.bound.y = d2, this.bound.width = this.designWidth, this.bound.height = this.designHeight;
    }
    get scale() {
      return this.scaleOrigin;
    }
    set scale(t2) {
      this.scaleOrigin.x = t2.x, this.scaleOrigin.y = t2.y, this.updateScale();
    }
    get design_ppt_w() {
      return ag(this.designWidth / this.ctx.stageWidth);
    }
    get design_ppt_h() {
      return ag((this.designHeight || this.container.height) / this.ctx.stageHeight);
    }
    get design_ppt_x() {
      return ag(this.designX / this.ctx.stageWidth);
    }
    get design_ppt_y() {
      return ag(this.designY / this.ctx.stageHeight);
    }
    get ppt_w() {
      return this.scaleExt.x * this.scaleOrigin.x * this.designWidth / this.ctx.stageWidth;
    }
    set ppt_w(t2) {
      this.designWidth && (this.scaleExt.x = t2 * this.ctx.stageWidth / this.designWidth, this.updateScale());
    }
    get ppt_h() {
      const t2 = this.designHeight || this.container.height;
      return this.scaleExt.y * this.scaleOrigin.y * t2 / this.ctx.stageHeight;
    }
    set ppt_h(t2) {
      this.designHeight && (this.scaleExt.y = t2 * this.ctx.stageHeight / this.designHeight, this.updateScale());
    }
    get ppt_x() {
      return (this.container.position.x - this.container.pivot.x) / this.ctx.stageWidth;
    }
    set ppt_x(t2) {
      this.pptX = t2;
      const e2 = this.presetSubType === 544 ? this.scaleExt.x : 1;
      this.container.position.x = t2 * this.ctx.stageWidth + this.container.pivot.x * e2;
    }
    get ppt_y() {
      return (this.container.position.y - this.container.pivot.y) / this.ctx.stageHeight;
    }
    set ppt_y(t2) {
      this.pptY = t2;
      const e2 = this.presetSubType === 544 ? this.scaleExt.y : 1;
      this.container.position.y = t2 * this.ctx.stageHeight + this.container.pivot.y * e2;
    }
    get r() {
      return this.container.rotation;
    }
    set r(t2) {
      this.container.rotation = t2;
    }
    set xshear(t2) {
      this.container.skew.x = t2;
    }
    get xshear() {
      return this.container.skew.x;
    }
    set yshear(t2) {
      this.container.skew.y = t2;
    }
    get yshear() {
      return this.container.skew.y;
    }
  }
  var ug = i(112), cg = i.n(ug);
  class dg {
    constructor(t2) {
      if (this._isInit = false, this.h = 0, this.s = 0, this.l = 0, this.a = 1, t2) {
        this._isInit = true;
        const e2 = t2.match(/-?[0-9]+/g);
        e2 && (this.h = parseInt(e2[0], 10), this.s = parseInt(e2[1], 10) / 100, this.l = parseInt(e2[2], 10) / 100);
      }
    }
    isInit() {
      return this._isInit;
    }
    by(t2, e2) {
      e2.h = Math.max(Math.min(this.h + t2.h, 359), 0), e2.s = Math.max(Math.min(this.s + t2.s, 1), 0), e2.l = Math.max(Math.min(this.l + t2.l, 1), 0), e2.a = Math.max(Math.min(this.a + t2.a, 1), 0);
    }
    fromHexString(t2) {
      const [e2, i2, n2, r2] = mg(t2);
      let o2 = 0, s2 = 0, a2 = 0;
      const l2 = Math.max(e2, i2, n2), h2 = Math.min(e2, i2, n2), u2 = l2 - h2;
      a2 = (l2 + h2) / 2, u2 === 0 ? o2 = 0 : l2 === e2 ? o2 = (i2 - n2) / u2 % 6 * 60 : l2 === i2 ? o2 = 60 * ((n2 - e2) / u2 + 2) : l2 === n2 && (o2 = 60 * ((e2 - i2) / u2 + 4)), s2 = u2 === 0 ? 0 : u2 / (1 - Math.abs(2 * a2 - 1)), this.h = o2, this.s = s2, this.l = a2, this.a = r2;
    }
    interpolationFrom(t2, e2, i2) {
      const n2 = t2.h + (this.h - t2.h) * e2, r2 = t2.s + (this.s - t2.s) * e2, o2 = t2.l + (this.l - t2.l) * e2, s2 = t2.a + (this.a - t2.a) * e2;
      i2.h = Math.max(Math.min(n2, 359), 0), i2.s = Math.max(Math.min(r2, 1), 0), i2.l = Math.max(Math.min(o2, 1), 0), i2.a = Math.max(Math.min(s2, 1), 0);
    }
    toHexString() {
      let t2 = [0, 0, 0, 0];
      const { h: e2, s: i2, l: n2 } = this;
      if (e2 < 360 && e2 >= 0 && i2 <= 1 && i2 >= 0 && n2 <= 1 && n2 >= 0) {
        let r2, o2, s2;
        const a2 = (1 - Math.abs(2 * n2 - 1)) * i2, l2 = a2 * (1 - Math.abs(e2 / 60 % 2 - 1)), h2 = n2 - a2 / 2;
        [r2, o2, s2] = e2 >= 0 && e2 < 60 ? [a2, l2, 0] : e2 >= 60 && e2 < 120 ? [l2, a2, 0] : e2 >= 120 && e2 < 180 ? [0, a2, l2] : e2 >= 180 && e2 < 240 ? [0, l2, a2] : e2 >= 240 && e2 < 300 ? [l2, 0, a2] : [a2, 0, l2], t2 = [r2 + h2, o2 + h2, s2 + h2, this.a];
      }
      return gg(t2);
    }
  }
  class pg {
    constructor(t2) {
      this._isInit = false, this.r = 0, this.g = 0, this.b = 0, this.a = 0, t2 && (this._isInit = true, this.fromHexString(t2));
    }
    fromHexString(t2) {
      const [e2, i2, n2, r2] = mg(t2);
      this.r = e2, this.g = i2, this.b = n2, this.a = r2;
    }
    isInit() {
      return this._isInit;
    }
    interpolationFrom(t2, e2, i2) {
      i2.r = t2.r + (this.r - t2.r) * e2, i2.g = t2.g + (this.g - t2.g) * e2, i2.b = t2.b + (this.b - t2.b) * e2, i2.a = t2.a + (this.a - t2.a) * e2;
    }
    by(t2, e2) {
      e2.r = Math.min(Math.max(this.r + t2.r, 0), 255), e2.g = Math.min(Math.max(this.g + t2.g, 0), 255), e2.b = Math.min(Math.max(this.b + t2.b, 0), 255), e2.a = Math.min(Math.max(this.a + t2.a, 0), 1);
    }
    toHexString() {
      return gg([this.r, this.g, this.b, this.a]);
    }
  }
  function fg(t2) {
    const e2 = t2.substring(1);
    return [parseInt(e2.substring(0, 6), 16), parseInt(e2.substring(6, 8), 16) / 255];
  }
  function mg(t2) {
    return (t2 = t2.replace(/^#/, "")).substring(6, 8).length === 0 && (t2 += "FF"), [parseInt(t2.substring(0, 2).padStart(8, "0"), 16) / 255, parseInt(t2.substring(2, 4).padStart(8, "0"), 16) / 255, parseInt(t2.substring(4, 6).padStart(8, "0"), 16) / 255, parseInt(t2.substring(6, 8).padStart(8, "0"), 16) / 255];
  }
  function gg(t2) {
    return "#" + Math.round(255 * t2[0]).toString(16).padStart(2, "0") + Math.round(255 * t2[1]).toString(16).padStart(2, "0") + Math.round(255 * t2[2]).toString(16).padStart(2, "0") + Math.round(255 * t2[3]).toString(16).padStart(2, "0");
  }
  function vg(t2, e2, i2) {
    const n2 = mg(t2), r2 = mg(e2), o2 = Math.round(255 * (n2[0] + (r2[0] - n2[0]) * i2)), s2 = Math.round(255 * (n2[1] + (r2[1] - n2[1]) * i2)), a2 = Math.round(255 * (n2[2] + (r2[2] - n2[2]) * i2)), l2 = Math.round(255 * (n2[3] + (r2[3] - n2[3]) * i2));
    return "#" + o2.toString(16).padStart(2, "0") + s2.toString(16).padStart(2, "0") + a2.toString(16).padStart(2, "0") + l2.toString(16).padStart(2, "0");
  }
  class _g extends Vh.k {
    constructor() {
      super(void 0, "\nvarying vec2 vTextureCoord;\n\nuniform vec4 color;\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 texColor = texture2D(uSampler, vTextureCoord);\n\n    if (texColor.a > 0.0) {\n        vec4 resultColor = color;\n        resultColor = resultColor * texColor.a;\n        gl_FragColor = resultColor;\n    } else {\n        gl_FragColor = texColor;\n    }\n}\n", { color: new Float32Array([0, 0, 0, 0]), active: 0 }), this.currentColor = "#FFFFFFFF", this.designColor = "#FFFFFFFF";
    }
    set color(t2) {
      this.currentColor = t2;
      const e2 = mg(t2);
      this.uniforms.color = Float32Array.from(e2);
    }
    get color() {
      return this.currentColor;
    }
  }
  const yg = new rm.ColorMatrixFilter();
  yg.matrix = [1, 0, 0, 0, -0.2, 0, 1, 0, 0, -0.2, 0, 0, 1, 0, -0.2, 0, 0, 0, 1, 0];
  const xg = new rm.ColorMatrixFilter();
  xg.matrix = [1, 0, 0, 0, -0.1, 0, 1, 0, 0, -0.1, 0, 0, 1, 0, -0.1, 0, 0, 0, 1, 0];
  const bg = new rm.ColorMatrixFilter();
  bg.matrix = [1, 0, 0, 0, 0.2, 0, 1, 0, 0, 0.2, 0, 0, 1, 0, 0.2, 0, 0, 0, 1, 0];
  const Tg = new rm.ColorMatrixFilter();
  Tg.matrix = [1, 0, 0, 0, 0.1, 0, 1, 0, 0, 0.1, 0, 0, 1, 0, 0.1, 0, 0, 0, 1, 0];
  const Eg = { darken: yg, darkenLess: xg, lightenLess: Tg, lighten: bg };
  class Sg extends hg {
    constructor(t2, e2, i2) {
      super({ position: { x: t2.x, y: t2.y }, width: t2.width, height: t2.height }, e2, i2), this.fillColorFilter = new _g(), this.fill = new ng(this), this.json = t2, this.ctx = e2, this.parentGlobalPos = i2.parentGlobalPos, this.global = { x: i2.parentGlobalPos.x + t2.x, y: i2.parentGlobalPos.y + t2.y }, this.updateTransform({ position: { x: t2.x, y: t2.y }, width: t2.width, height: t2.height });
    }
    get fillActive() {
      var t2, e2;
      return ((e2 = (t2 = this.container.filters) === null || t2 === void 0 ? void 0 : t2.length) !== null && e2 !== void 0 ? e2 : -1) > 0;
    }
    set fillActive(t2) {
      var e2, i2;
      t2 ? ((i2 = (e2 = this.container.filters) === null || e2 === void 0 ? void 0 : e2.indexOf(this.fillColorFilter)) !== null && i2 !== void 0 ? i2 : -1) < 0 && (this.container.filters = [this.fillColorFilter]) : this.container.filters = [];
    }
    get renderContainer() {
      return this.container;
    }
    get interactiveContainer() {
      return this.container;
    }
    clearOnSlideChange() {
    }
    initOnReuse() {
    }
    getTextElement() {
      return null;
    }
    getBgElement() {
      return null;
    }
    get ppt_x() {
      return this.global.x / this.ctx.stageWidth;
    }
    set ppt_x(t2) {
      const e2 = t2 * this.ctx.stageWidth - this.global.x, i2 = this.presetSubType === 544 ? this.scaleExt.x : 1;
      this.container.position.x = this.designX + e2 + this.container.pivot.x * i2;
    }
    get ppt_y() {
      return this.global.y / this.ctx.stageHeight;
    }
    set ppt_y(t2) {
      const e2 = t2 * this.ctx.stageHeight - this.global.y, i2 = this.presetSubType === 544 ? this.scaleExt.y : 1;
      this.container.position.y = this.designY + e2 + this.container.pivot.y * i2;
    }
    get design_ppt_x() {
      return ag(this.global.x / this.ctx.stageWidth);
    }
    get design_ppt_y() {
      return ag(this.global.y / this.ctx.stageHeight);
    }
  }
  class wg {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
      this.ctx = t2, this.type = e2, this.lineWidth = i2, this.width = n2, this.height = r2, this.fillColor = o2, this.isHorz = s2, this.renderContainer = new Oh.b(), this.ghcTextureId = `${a2}-text-p${l2}-l${h2}-u${u2}-underLine`;
    }
    createPaths() {
      if (this.type === "ww")
        return null;
      {
        let t2 = `M 0,0 L ${9525 * this.width},0`, [e2, i2] = [this.width, this.lineWidth];
        return this.isHorz || (t2 = "M 0,0 L 0," + 9525 * this.height, [e2, i2] = [this.lineWidth, this.height]), { paths: [{ id: Mm(), path: t2, fill: "norm", hasStroke: true, scale: { x: 1, y: 1 }, hash: jm()(t2) }], width: e2, height: i2 };
      }
    }
    getLineStyle() {
      const t2 = { width: this.lineWidth };
      return this.type === "dotted" && (t2.dash = "" + this.lineWidth), t2;
    }
    preRender() {
      const t2 = this.createPaths();
      if (t2) {
        const { paths: e2, width: i2, height: n2 } = t2, r2 = e2.reduce((t3, e3) => t3 + e3.hash, "");
        this.ctx.graphicsTexture.addGraphics(this.ghcTextureId, e2, r2, { x: 0, y: 0 }, i2, n2, this.getLineStyle(), this.ctx.objectPoolGroup, false, null, this.fillColor);
      }
    }
    render() {
      if (this.ghcTextureId) {
        const t2 = this.ctx.graphicsTexture.getGraphicsData(this.ghcTextureId);
        t2 && (this.sprite = new ep(), this.sprite.texture = t2.texture, this.sprite.pivot.x = t2.pivot.x, this.sprite.scale.x = t2.scale, this.sprite.scale.y = t2.scale);
      }
    }
    destroy() {
      var t2;
      (t2 = this.sprite) === null || t2 === void 0 || t2.destroy({ texture: true });
    }
  }
  const Ag = 134217729;
  function Mg(t2, e2, i2, n2, r2) {
    let o2, s2, a2, l2, h2 = e2[0], u2 = n2[0], c2 = 0, d2 = 0;
    u2 > h2 == u2 > -h2 ? (o2 = h2, h2 = e2[++c2]) : (o2 = u2, u2 = n2[++d2]);
    let p2 = 0;
    if (c2 < t2 && d2 < i2)
      for (u2 > h2 == u2 > -h2 ? (s2 = h2 + o2, a2 = o2 - (s2 - h2), h2 = e2[++c2]) : (s2 = u2 + o2, a2 = o2 - (s2 - u2), u2 = n2[++d2]), o2 = s2, a2 !== 0 && (r2[p2++] = a2); c2 < t2 && d2 < i2; )
        u2 > h2 == u2 > -h2 ? (s2 = o2 + h2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (h2 - l2), h2 = e2[++c2]) : (s2 = o2 + u2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (u2 - l2), u2 = n2[++d2]), o2 = s2, a2 !== 0 && (r2[p2++] = a2);
    for (; c2 < t2; )
      s2 = o2 + h2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (h2 - l2), h2 = e2[++c2], o2 = s2, a2 !== 0 && (r2[p2++] = a2);
    for (; d2 < i2; )
      s2 = o2 + u2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (u2 - l2), u2 = n2[++d2], o2 = s2, a2 !== 0 && (r2[p2++] = a2);
    return o2 === 0 && p2 !== 0 || (r2[p2++] = o2), p2;
  }
  function Rg(t2, e2) {
    let i2 = e2[0];
    for (let n2 = 1; n2 < t2; n2++)
      i2 += e2[n2];
    return i2;
  }
  function Cg(t2) {
    return new Float64Array(t2);
  }
  const Ig = Cg(4), Pg = Cg(8), Og = Cg(12), Ng = Cg(16), Lg = Cg(4);
  function Dg(t2, e2, i2, n2, r2, o2) {
    const s2 = (e2 - o2) * (i2 - r2), a2 = (t2 - r2) * (n2 - o2), l2 = s2 - a2;
    if (s2 === 0 || a2 === 0 || s2 > 0 != a2 > 0)
      return l2;
    const h2 = Math.abs(s2 + a2);
    return Math.abs(l2) >= 33306690738754716e-32 * h2 ? l2 : -function(t3, e3, i3, n3, r3, o3, s3) {
      let a3, l3, h3, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
      const w2 = t3 - r3, A2 = i3 - r3, M2 = e3 - o3, R2 = n3 - o3;
      x2 = w2 * R2, d2 = Ag * w2, p2 = d2 - (d2 - w2), f2 = w2 - p2, d2 = Ag * R2, m2 = d2 - (d2 - R2), g2 = R2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = M2 * A2, d2 = Ag * M2, p2 = d2 - (d2 - M2), f2 = M2 - p2, d2 = Ag * A2, m2 = d2 - (d2 - A2), g2 = A2 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Ig[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Ig[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Ig[2] = _2 - (S2 - c2) + (v2 - c2), Ig[3] = S2;
      let C2 = Rg(4, Ig), I2 = 22204460492503146e-32 * s3;
      if (C2 >= I2 || -C2 >= I2)
        return C2;
      if (c2 = t3 - w2, a3 = t3 - (w2 + c2) + (c2 - r3), c2 = i3 - A2, h3 = i3 - (A2 + c2) + (c2 - r3), c2 = e3 - M2, l3 = e3 - (M2 + c2) + (c2 - o3), c2 = n3 - R2, u2 = n3 - (R2 + c2) + (c2 - o3), a3 === 0 && l3 === 0 && h3 === 0 && u2 === 0)
        return C2;
      if (I2 = 11093356479670487e-47 * s3 + 33306690738754706e-32 * Math.abs(C2), C2 += w2 * u2 + R2 * a3 - (M2 * h3 + A2 * l3), C2 >= I2 || -C2 >= I2)
        return C2;
      x2 = a3 * R2, d2 = Ag * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = Ag * R2, m2 = d2 - (d2 - R2), g2 = R2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * A2, d2 = Ag * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = Ag * A2, m2 = d2 - (d2 - A2), g2 = A2 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
      const P2 = Mg(4, Ig, 4, Lg, Pg);
      x2 = w2 * u2, d2 = Ag * w2, p2 = d2 - (d2 - w2), f2 = w2 - p2, d2 = Ag * u2, m2 = d2 - (d2 - u2), g2 = u2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = M2 * h3, d2 = Ag * M2, p2 = d2 - (d2 - M2), f2 = M2 - p2, d2 = Ag * h3, m2 = d2 - (d2 - h3), g2 = h3 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
      const O2 = Mg(P2, Pg, 4, Lg, Og);
      x2 = a3 * u2, d2 = Ag * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = Ag * u2, m2 = d2 - (d2 - u2), g2 = u2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * h3, d2 = Ag * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = Ag * h3, m2 = d2 - (d2 - h3), g2 = h3 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
      const N2 = Mg(O2, Og, 4, Lg, Ng);
      return Ng[N2 - 1];
    }(t2, e2, i2, n2, r2, o2, h2);
  }
  const Fg = Math.pow(2, -52), Bg = new Uint32Array(512);
  class Ug {
    static from(t2, e2 = Vg, i2 = Xg) {
      const n2 = t2.length, r2 = new Float64Array(2 * n2);
      for (let o2 = 0; o2 < n2; o2++) {
        const n3 = t2[o2];
        r2[2 * o2] = e2(n3), r2[2 * o2 + 1] = i2(n3);
      }
      return new Ug(r2);
    }
    constructor(t2) {
      const e2 = t2.length >> 1;
      if (e2 > 0 && typeof t2[0] != "number")
        throw new Error("Expected coords to contain numbers.");
      this.coords = t2;
      const i2 = Math.max(2 * e2 - 5, 0);
      this._triangles = new Uint32Array(3 * i2), this._halfedges = new Int32Array(3 * i2), this._hashSize = Math.ceil(Math.sqrt(e2)), this._hullPrev = new Uint32Array(e2), this._hullNext = new Uint32Array(e2), this._hullTri = new Uint32Array(e2), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(e2), this._dists = new Float64Array(e2), this.update();
    }
    update() {
      const { coords: t2, _hullPrev: e2, _hullNext: i2, _hullTri: n2, _hullHash: r2 } = this, o2 = t2.length >> 1;
      let s2 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, h2 = -1 / 0;
      for (let e3 = 0; e3 < o2; e3++) {
        const i3 = t2[2 * e3], n3 = t2[2 * e3 + 1];
        i3 < s2 && (s2 = i3), n3 < a2 && (a2 = n3), i3 > l2 && (l2 = i3), n3 > h2 && (h2 = n3), this._ids[e3] = e3;
      }
      const u2 = (s2 + l2) / 2, c2 = (a2 + h2) / 2;
      let d2, p2, f2, m2 = 1 / 0;
      for (let e3 = 0; e3 < o2; e3++) {
        const i3 = kg(u2, c2, t2[2 * e3], t2[2 * e3 + 1]);
        i3 < m2 && (d2 = e3, m2 = i3);
      }
      const g2 = t2[2 * d2], v2 = t2[2 * d2 + 1];
      m2 = 1 / 0;
      for (let e3 = 0; e3 < o2; e3++) {
        if (e3 === d2)
          continue;
        const i3 = kg(g2, v2, t2[2 * e3], t2[2 * e3 + 1]);
        i3 < m2 && i3 > 0 && (p2 = e3, m2 = i3);
      }
      let _2 = t2[2 * p2], y2 = t2[2 * p2 + 1], x2 = 1 / 0;
      for (let e3 = 0; e3 < o2; e3++) {
        if (e3 === d2 || e3 === p2)
          continue;
        const i3 = Hg(g2, v2, _2, y2, t2[2 * e3], t2[2 * e3 + 1]);
        i3 < x2 && (f2 = e3, x2 = i3);
      }
      let b2 = t2[2 * f2], T2 = t2[2 * f2 + 1];
      if (x2 === 1 / 0) {
        for (let e4 = 0; e4 < o2; e4++)
          this._dists[e4] = t2[2 * e4] - t2[0] || t2[2 * e4 + 1] - t2[1];
        jg(this._ids, this._dists, 0, o2 - 1);
        const e3 = new Uint32Array(o2);
        let i3 = 0;
        for (let t3 = 0, n3 = -1 / 0; t3 < o2; t3++) {
          const r3 = this._ids[t3];
          this._dists[r3] > n3 && (e3[i3++] = r3, n3 = this._dists[r3]);
        }
        return this.hull = e3.subarray(0, i3), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0));
      }
      if (Dg(g2, v2, _2, y2, b2, T2) < 0) {
        const t3 = p2, e3 = _2, i3 = y2;
        p2 = f2, _2 = b2, y2 = T2, f2 = t3, b2 = e3, T2 = i3;
      }
      const E2 = function(t3, e3, i3, n3, r3, o3) {
        const s3 = i3 - t3, a3 = n3 - e3, l3 = r3 - t3, h3 = o3 - e3, u3 = s3 * s3 + a3 * a3, c3 = l3 * l3 + h3 * h3, d3 = 0.5 / (s3 * h3 - a3 * l3);
        return { x: t3 + (h3 * u3 - a3 * c3) * d3, y: e3 + (s3 * c3 - l3 * u3) * d3 };
      }(g2, v2, _2, y2, b2, T2);
      this._cx = E2.x, this._cy = E2.y;
      for (let e3 = 0; e3 < o2; e3++)
        this._dists[e3] = kg(t2[2 * e3], t2[2 * e3 + 1], E2.x, E2.y);
      jg(this._ids, this._dists, 0, o2 - 1), this._hullStart = d2;
      let S2 = 3;
      i2[d2] = e2[f2] = p2, i2[p2] = e2[d2] = f2, i2[f2] = e2[p2] = d2, n2[d2] = 0, n2[p2] = 1, n2[f2] = 2, r2.fill(-1), r2[this._hashKey(g2, v2)] = d2, r2[this._hashKey(_2, y2)] = p2, r2[this._hashKey(b2, T2)] = f2, this.trianglesLen = 0, this._addTriangle(d2, p2, f2, -1, -1, -1);
      for (let o3, s3, a3 = 0; a3 < this._ids.length; a3++) {
        const l3 = this._ids[a3], h3 = t2[2 * l3], u3 = t2[2 * l3 + 1];
        if (a3 > 0 && Math.abs(h3 - o3) <= Fg && Math.abs(u3 - s3) <= Fg)
          continue;
        if (o3 = h3, s3 = u3, l3 === d2 || l3 === p2 || l3 === f2)
          continue;
        let c3 = 0;
        for (let t3 = 0, e3 = this._hashKey(h3, u3); t3 < this._hashSize && (c3 = r2[(e3 + t3) % this._hashSize], c3 === -1 || c3 === i2[c3]); t3++)
          ;
        c3 = e2[c3];
        let m3, g3 = c3;
        for (; m3 = i2[g3], Dg(h3, u3, t2[2 * g3], t2[2 * g3 + 1], t2[2 * m3], t2[2 * m3 + 1]) >= 0; )
          if (g3 = m3, g3 === c3) {
            g3 = -1;
            break;
          }
        if (g3 === -1)
          continue;
        let v3 = this._addTriangle(g3, l3, i2[g3], -1, -1, n2[g3]);
        n2[l3] = this._legalize(v3 + 2), n2[g3] = v3, S2++;
        let _3 = i2[g3];
        for (; m3 = i2[_3], Dg(h3, u3, t2[2 * _3], t2[2 * _3 + 1], t2[2 * m3], t2[2 * m3 + 1]) < 0; )
          v3 = this._addTriangle(_3, l3, m3, n2[l3], -1, n2[_3]), n2[l3] = this._legalize(v3 + 2), i2[_3] = _3, S2--, _3 = m3;
        if (g3 === c3)
          for (; m3 = e2[g3], Dg(h3, u3, t2[2 * m3], t2[2 * m3 + 1], t2[2 * g3], t2[2 * g3 + 1]) < 0; )
            v3 = this._addTriangle(m3, l3, g3, -1, n2[g3], n2[m3]), this._legalize(v3 + 2), n2[m3] = v3, i2[g3] = g3, S2--, g3 = m3;
        this._hullStart = e2[l3] = g3, i2[g3] = e2[_3] = l3, i2[l3] = _3, r2[this._hashKey(h3, u3)] = l3, r2[this._hashKey(t2[2 * g3], t2[2 * g3 + 1])] = g3;
      }
      this.hull = new Uint32Array(S2);
      for (let t3 = 0, e3 = this._hullStart; t3 < S2; t3++)
        this.hull[t3] = e3, e3 = i2[e3];
      this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(t2, e2) {
      return Math.floor(function(t3, e3) {
        const i2 = t3 / (Math.abs(t3) + Math.abs(e3));
        return (e3 > 0 ? 3 - i2 : 1 + i2) / 4;
      }(t2 - this._cx, e2 - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(t2) {
      const { _triangles: e2, _halfedges: i2, coords: n2 } = this;
      let r2 = 0, o2 = 0;
      for (; ; ) {
        const s2 = i2[t2], a2 = t2 - t2 % 3;
        if (o2 = a2 + (t2 + 2) % 3, s2 === -1) {
          if (r2 === 0)
            break;
          t2 = Bg[--r2];
          continue;
        }
        const l2 = s2 - s2 % 3, h2 = a2 + (t2 + 1) % 3, u2 = l2 + (s2 + 2) % 3, c2 = e2[o2], d2 = e2[t2], p2 = e2[h2], f2 = e2[u2];
        if (Gg(n2[2 * c2], n2[2 * c2 + 1], n2[2 * d2], n2[2 * d2 + 1], n2[2 * p2], n2[2 * p2 + 1], n2[2 * f2], n2[2 * f2 + 1])) {
          e2[t2] = f2, e2[s2] = c2;
          const n3 = i2[u2];
          if (n3 === -1) {
            let e3 = this._hullStart;
            do {
              if (this._hullTri[e3] === u2) {
                this._hullTri[e3] = t2;
                break;
              }
              e3 = this._hullPrev[e3];
            } while (e3 !== this._hullStart);
          }
          this._link(t2, n3), this._link(s2, i2[o2]), this._link(o2, u2);
          const a3 = l2 + (s2 + 1) % 3;
          r2 < Bg.length && (Bg[r2++] = a3);
        } else {
          if (r2 === 0)
            break;
          t2 = Bg[--r2];
        }
      }
      return o2;
    }
    _link(t2, e2) {
      this._halfedges[t2] = e2, e2 !== -1 && (this._halfedges[e2] = t2);
    }
    _addTriangle(t2, e2, i2, n2, r2, o2) {
      const s2 = this.trianglesLen;
      return this._triangles[s2] = t2, this._triangles[s2 + 1] = e2, this._triangles[s2 + 2] = i2, this._link(s2, n2), this._link(s2 + 1, r2), this._link(s2 + 2, o2), this.trianglesLen += 3, s2;
    }
  }
  function kg(t2, e2, i2, n2) {
    const r2 = t2 - i2, o2 = e2 - n2;
    return r2 * r2 + o2 * o2;
  }
  function Gg(t2, e2, i2, n2, r2, o2, s2, a2) {
    const l2 = t2 - s2, h2 = e2 - a2, u2 = i2 - s2, c2 = n2 - a2, d2 = r2 - s2, p2 = o2 - a2, f2 = u2 * u2 + c2 * c2, m2 = d2 * d2 + p2 * p2;
    return l2 * (c2 * m2 - f2 * p2) - h2 * (u2 * m2 - f2 * d2) + (l2 * l2 + h2 * h2) * (u2 * p2 - c2 * d2) < 0;
  }
  function Hg(t2, e2, i2, n2, r2, o2) {
    const s2 = i2 - t2, a2 = n2 - e2, l2 = r2 - t2, h2 = o2 - e2, u2 = s2 * s2 + a2 * a2, c2 = l2 * l2 + h2 * h2, d2 = 0.5 / (s2 * h2 - a2 * l2), p2 = (h2 * u2 - a2 * c2) * d2, f2 = (s2 * c2 - l2 * u2) * d2;
    return p2 * p2 + f2 * f2;
  }
  function jg(t2, e2, i2, n2) {
    if (n2 - i2 <= 20)
      for (let r2 = i2 + 1; r2 <= n2; r2++) {
        const n3 = t2[r2], o2 = e2[n3];
        let s2 = r2 - 1;
        for (; s2 >= i2 && e2[t2[s2]] > o2; )
          t2[s2 + 1] = t2[s2--];
        t2[s2 + 1] = n3;
      }
    else {
      let r2 = i2 + 1, o2 = n2;
      zg(t2, i2 + n2 >> 1, r2), e2[t2[i2]] > e2[t2[n2]] && zg(t2, i2, n2), e2[t2[r2]] > e2[t2[n2]] && zg(t2, r2, n2), e2[t2[i2]] > e2[t2[r2]] && zg(t2, i2, r2);
      const s2 = t2[r2], a2 = e2[s2];
      for (; ; ) {
        do {
          r2++;
        } while (e2[t2[r2]] < a2);
        do {
          o2--;
        } while (e2[t2[o2]] > a2);
        if (o2 < r2)
          break;
        zg(t2, r2, o2);
      }
      t2[i2 + 1] = t2[o2], t2[o2] = s2, n2 - r2 + 1 >= o2 - i2 ? (jg(t2, e2, r2, n2), jg(t2, e2, i2, o2 - 1)) : (jg(t2, e2, i2, o2 - 1), jg(t2, e2, r2, n2));
    }
  }
  function zg(t2, e2, i2) {
    const n2 = t2[e2];
    t2[e2] = t2[i2], t2[i2] = n2;
  }
  function Vg(t2) {
    return t2[0];
  }
  function Xg(t2) {
    return t2[1];
  }
  function Wg(t2, e2, i2) {
    let n2 = null;
    const r2 = new Oh.b();
    if (t2.stopList.sort((t3, e3) => t3.pos - e3.pos), !t2.stopList.find((t3) => t3.pos === 0)) {
      const e3 = t2.stopList[0];
      t2.stopList.unshift({ pos: 0, color: e3.color });
    }
    if (!t2.stopList.find((t3) => t3.pos === 1)) {
      const e3 = t2.stopList[t2.stopList.length - 1];
      t2.stopList.push({ pos: 1, color: e3.color });
    }
    const o2 = (t3) => {
      const e3 = [];
      for (let i3 = 0, n3 = t3.length; i3 < n3 - 1; i3++) {
        const n4 = t3[i3], r3 = t3[i3 + 1], o3 = n4.pos + 0.5 * (r3.pos - n4.pos), s2 = vg(n4.color, r3.color, 0.5), a2 = 2 * i3;
        e3[a2] = n4, e3[a2 + 1] = { color: s2, pos: o3 }, e3[a2 + 2] = r3;
      }
      return e3;
    };
    if (t2.stopList = o2(t2.stopList), t2.stopList = o2(t2.stopList), n2 = t2.line ? Yg(t2, e2, i2) : t2.path ? function(t3, e3, i3) {
      var n3, r3, o3;
      const s2 = [], a2 = { x: 0, y: 0 };
      if (((n3 = t3.path) === null || n3 === void 0 ? void 0 : n3.path) === "circle" || ((r3 = t3.path) === null || r3 === void 0 ? void 0 : r3.path) === "rect" || ((o3 = t3.path) === null || o3 === void 0 ? void 0 : o3.path) === "shape") {
        const n4 = e3 / 2, r4 = i3 / 2, o4 = Math.sqrt(n4 * n4 + r4 * r4);
        t3.stopList.forEach((t4) => {
          if (t4.pos === 0)
            s2.push({ point: { x: 0, y: 0 }, color: t4.color });
          else {
            const e4 = o4 * t4.pos, i4 = new zs();
            i4.absellipse(0, 0, e4, e4, 0, 2 * Math.PI, false, 0), i4.getPoints(50).forEach((e5) => {
              s2.push({ point: { x: e5.x, y: e5.y }, color: t4.color });
            });
          }
          a2.x = n4, a2.y = r4;
        });
      }
      return { points: s2, position: a2 };
    }(t2, e2, i2) : Yg(t2, e2, i2), n2) {
      const t3 = [], o3 = [], { position: s2, points: a2 } = n2, l2 = Ug.from(a2, (t4) => t4.point.x, (t4) => t4.point.y);
      for (let e3 = 0; e3 < l2.triangles.length; e3 += 3)
        t3.push(a2[l2.triangles[e3]].point.x, a2[l2.triangles[e3]].point.y), t3.push(a2[l2.triangles[e3 + 1]].point.x, a2[l2.triangles[e3 + 1]].point.y), t3.push(a2[l2.triangles[e3 + 2]].point.x, a2[l2.triangles[e3 + 2]].point.y), o3.push(...mg(a2[l2.triangles[e3]].color)), o3.push(...mg(a2[l2.triangles[e3 + 1]].color)), o3.push(...mg(a2[l2.triangles[e3 + 2]].color));
      const h2 = new Vh.l();
      h2.addAttribute("aVertexPosition", t3, 2), h2.addAttribute("aColor", o3, 4);
      const u2 = Vh.r.from("\n        precision mediump float;\n        attribute vec2 aVertexPosition;\n        attribute vec4 aColor;\n        uniform mat3 translationMatrix;\n        uniform mat3 projectionMatrix;\n        varying vec4 vColor;\n        void main() {\n            vColor = aColor;\n            gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n        }", "precision mediump float;    \n        varying vec4 vColor;\n        void main() {\n            float alpha = vColor.a;\n            vec4 color = vColor;\n            color.a = 1.0;\n            gl_FragColor = color * alpha;\n        }\n    "), c2 = new Jd();
      c2.drawRect(0, 0, e2 + 1, i2 + 1), r2.mask = c2, r2.addChild(c2);
      const d2 = new Dp.a(h2, u2);
      d2.position.x = s2.x, d2.position.y = s2.y, r2.addChild(d2);
    }
    return r2;
  }
  function Yg(t2, e2, i2) {
    const n2 = e2 / 2, r2 = i2 / 2, o2 = [{ x: -n2, y: r2 }, { x: -n2, y: -r2 }, { x: n2, y: r2 }, { x: n2, y: -r2 }], s2 = [lg.fromPointSlope({ x: -n2, y: 0 }, Math.PI / 2), lg.fromPointSlope({ x: 0, y: r2 }, 0), lg.fromPointSlope({ x: n2, y: 0 }, Math.PI / 2), lg.fromPointSlope({ x: 0, y: -r2 }, 0)], a2 = [], l2 = t2.stopList.slice(1, t2.stopList.length - 1).map((o3) => {
      var l3, h3, u3;
      const c3 = 2 * Math.PI;
      let d3 = (h3 = (l3 = t2.line) === null || l3 === void 0 ? void 0 : l3.ang) !== null && h3 !== void 0 ? h3 : 0;
      for (; d3 > c3; )
        d3 -= c3;
      for (; d3 < 0; )
        d3 += c3;
      const p3 = { x: 0, y: 0 };
      sg(d3, Math.PI / 2) ? (p3.x = 0, p3.y = i2 / 2 - o3.pos * i2) : sg(d3, 0) ? (p3.x = o3.pos * e2 - e2 / 2, p3.y = 0) : (p3.x = o3.pos * e2 - e2 / 2, p3.y = i2 / 2 - o3.pos * i2), d3 > Math.PI / 2 && d3 <= Math.PI && (p3.x *= -1), d3 > Math.PI && d3 <= 2 * Math.PI && (p3.y *= -1);
      const f2 = lg.fromPointSlope(p3, Math.PI / 2 - (((u3 = t2.line) === null || u3 === void 0 ? void 0 : u3.ang) || 0)), m2 = s2.map((t3) => f2.crossPoint(t3)).filter((t3) => t3 && t3.x <= n2 && t3.x >= -n2 && t3.y <= r2 && t3.y >= -r2).map((t3) => ({ point: t3, color: o3.color })).sort((t3, e3) => e3.point.y - t3.point.y);
      a2.push(...m2);
      let g2 = Math.abs(m2[1].point.x - m2[0].point.x) / 10;
      for (let t3 = 20; t3--; ) {
        const e3 = t3 % 2 == 0 ? 1 : -1, i3 = p3.x + e3 * g2, s3 = f2.resolveY(i3);
        i3 <= n2 && i3 >= -n2 && s3 <= r2 && s3 >= -r2 && a2.push({ point: { x: i3, y: s3 }, color: o3.color }), g2 += g2;
      }
      return f2;
    });
    let h2 = [], u2 = [];
    t:
      for (let e3 = 0; e3 < o2.length; e3++) {
        const i3 = o2[e3];
        for (let e4 = 0; e4 < l2.length - 1; e4++) {
          const n4 = l2[e4], r4 = l2[e4 + 1], o3 = n4.distanceToLinearEquation(r4), s4 = n4.distanceToPoint(i3), h3 = r4.distanceToPoint(i3);
          if (s4 < o3 && h3 < o3) {
            const n5 = t2.stopList.slice(1, t2.stopList.length - 1)[e4], r5 = t2.stopList.slice(1, t2.stopList.length - 1)[e4 + 1], l3 = vg(n5.color, r5.color, s4 / o3);
            a2.splice(e4 + 1, 0, { point: i3, color: l3 });
            continue t;
          }
        }
        const n3 = l2[0], r3 = l2[l2.length - 1], s3 = n3.distanceToPoint(i3), c3 = r3.distanceToPoint(i3);
        s3 <= c3 ? h2.push({ point: i3, dis: s3 }) : u2.push({ point: i3, dis: c3 });
      }
    h2 = h2.sort((t3, e3) => e3.dis - t3.dis);
    const c2 = h2.map((e3, i3) => {
      if (i3 === 0)
        return { point: e3.point, color: t2.stopList[0].color };
      {
        const i4 = t2.stopList[0].color, n3 = t2.stopList[1].color;
        return { point: e3.point, color: vg(i4, n3, 1 - (h2[0].dis === 0 ? 1 : e3.dis / h2[0].dis)) };
      }
    }).sort((t3, e3) => e3.point.y - t3.point.y);
    u2 = u2.sort((t3, e3) => e3.dis - t3.dis);
    const d2 = u2.map((e3, i3) => {
      if (i3 === 0)
        return { point: e3.point, color: t2.stopList[t2.stopList.length - 1].color };
      {
        const i4 = t2.stopList[t2.stopList.length - 2].color, n3 = t2.stopList[t2.stopList.length - 1].color;
        return { point: e3.point, color: vg(i4, n3, u2[0].dis === 0 ? 0 : e3.dis / u2[0].dis) };
      }
    }).sort((t3, e3) => e3.point.y - t3.point.y), p2 = c2.concat(...a2).concat(d2);
    for (let t3 = 0; t3 < p2.length; t3++)
      p2[t3].point.x += n2, p2[t3].point.y = -p2[t3].point.y + r2;
    return { points: p2, position: { x: 0, y: 0 } };
  }
  const qg = "\nvec3 rgb2hsl(vec3 rgb) {\n    float cMax = max(max(rgb.r, rgb.g), rgb.b);\n    float cMin = min(min(rgb.r, rgb.g), rgb.b);\n    float delta = cMax - cMin;\n    \n    float h = 0.0;\n    if (delta == 0.0) {\n        h = 0.0;\n    } else if (cMax == rgb.r) {\n        h = 60.0 * mod(((rgb.g - rgb.b) / delta), 6.0);\n    } else if (cMax == rgb.g ) {\n        h = 60.0 * ((rgb.b - rgb.r) / delta + 2.0);\n    } else if (cMax == rgb.b) {\n        h = 60.0 * ((rgb.r - rgb.g) / delta + 4.0);\n    }\n    \n    float l = (cMax + cMin) / 2.0;\n    \n    float s = 0.0;\n    if (delta == 0.0) {\n        s = 0.0;\n    } else {\n        s = delta / (1.0 - abs(2.0 * l - 1.0));\n    }\n    \n    return vec3(h, s, l);\n}\n", Zg = [qg], Jg = { biLevel: "\nvec4 transform(vec4 texColor, float arg) {\n    mat3 rgb2yuv = mat3(\n        0.2126, 0.7152, 0.0722,\n        -0.09991, -0.33609, 0.43600,\n        0.615, -0.5586, -0.05639\n    );\n    vec3 yuv = texColor.rgb * rgb2yuv;\n    if (yuv.x >= 0.49 || texColor.a < 0.9) {\n        return vec4(1.0, 1.0, 1.0, 1.0) * texColor.a;\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0) * texColor.a;\n    }\n}\n", alphaModFix: "\nvec4 transform(vec4 texColor, float arg) {\n   return texColor * arg;\n}\n", alphaBiLevel: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a < arg) {\n        result.a = 0.0;\n    } else {\n        result.a = 1.0;\n    }\n    return result;\n}\n", alphaCeiling: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a > 0.0) {\n        result.a = 1.0;\n    }\n    return result;\n}\n", alphaFloor: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a < 1.0) {\n        result.a = 0.0;\n    }\n    return result;\n}\n", grayscl: "\nvec4 transform(vec4 texColor, float arg) {\n    float avg = (texColor.r + texColor.g + texColor.b) / 3.0;\n    return vec4(avg, avg, avg, texColor.a);\n}\n" };
  class Kg extends Vh.k {
    constructor(t2, e2) {
      var i2;
      super(void 0, (i2 = Jg[t2], `
varying vec2 vTextureCoord;

uniform float arg;
uniform sampler2D uSampler;

${Zg.map((t3) => t3 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg);
}
`), { arg: e2 });
    }
  }
  const Qg = [qg], $g = { clrChange: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    float epsilon = 0.001;\n    vec3 colorDiff = arg1.rgb - (texColor.rgb / max(texColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    if (colorDistance < epsilon) {\n        arg2.rgb *= arg2.a;\n        return arg2;\n    } else {\n        return texColor;\n    }\n}\n", changeBulletColor: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    if (texColor.a == 0.0) {\n        return texColor;\n    } else {\n        return arg2;\n    }\n}\n", duotone: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    float avg = (texColor.r + texColor.g + texColor.b) / 3.0;\n\n    vec3 hsl = rgb2hsl(vec3(avg, avg, avg));\n\n    vec3 result = arg2.rgb * hsl.z + arg1.rgb * (1.0 - hsl.z);\n\n    return vec4(result * texColor.a, texColor.a);\n}\n" };
  class tv extends Vh.k {
    constructor(t2, e2, i2) {
      var n2;
      super(void 0, (n2 = $g[t2], `
varying vec2 vTextureCoord;

uniform vec4 arg1;
uniform vec4 arg2;
uniform sampler2D uSampler;

${Qg.map((t3) => t3 + "\n").join("\n")}

${n2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: Float32Array.from(e2), arg2: Float32Array.from(i2) });
    }
  }
  const ev = [qg], iv = { lum: "\nvec4 transform(vec4 texColor, float arg1, float arg2) {\n    vec3 rgb = texColor.rgb / texColor.a;\n\n    // \u5BF9\u6BD4\u5EA6\n    highp float C = arg2 * 255.0;\n    highp float F = (259.0 * (255.0 + C)) / (255.0 * (259.0 - C));\n    rgb.rgb = F * (rgb.rgb - 0.5) + 0.5;\n\n    // \u4EAE\u5EA6\n    rgb.rgb += arg1;\n\n    rgb.rgb *= texColor.a;\n    return vec4(rgb, texColor.a);\n}\n" };
  class nv extends Vh.k {
    constructor(t2, e2, i2) {
      var n2;
      super(void 0, (n2 = iv[t2], `
varying vec2 vTextureCoord;

uniform float arg1;
uniform float arg2;
uniform sampler2D uSampler;

${ev.map((t3) => t3 + "\n").join("\n")}

${n2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: e2, arg2: i2 });
    }
  }
  const rv = [qg], ov = { alphaInv: "\nvec4 transform(vec4 texColor, vec4 arg1) {\n    float alpha = 1.0 - texColor.a;\n    arg1.rgb = arg1.rgb * alpha;\n    arg1.a = alpha;\n    return arg1;\n}\n" };
  class sv extends Vh.k {
    constructor(t2, e2) {
      var i2;
      super(void 0, (i2 = ov[t2], `
varying vec2 vTextureCoord;

uniform vec4 arg1;
uniform sampler2D uSampler;

${rv.map((t3) => t3 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1);
}
`), { arg1: Float32Array.from(e2) });
    }
  }
  function av(t2, e2) {
    const i2 = [];
    return t2.forEach((t3) => {
      const n2 = ((e2 == null ? void 0 : e2.filter) || []).indexOf(t3.type) >= 0;
      if (["biLevel", "alphaBiLevel", "alphaCeiling", "alphaModFix", "alphaFloor", "grayscl"].indexOf(t3.type) >= 0 && n2)
        i2.push(new Kg(t3.type, t3.args[0] || 0));
      else if (["clrChange", "changeBulletColor", "duotone"].indexOf(t3.type) >= 0 && n2) {
        const e3 = mg(t3.args[0]), n3 = mg(t3.args[1]);
        i2.push(new tv(t3.type, e3, n3));
      } else if (t3.type === "lum" && n2)
        i2.push(new nv(t3.type, t3.args[0], t3.args[1]));
      else if (t3.type === "alphaInv" && n2) {
        const e3 = mg(t3.args[0]);
        i2.push(new sv(t3.type, e3));
      }
    }), i2;
  }
  class lv {
    constructor(t2, e2, i2, n2, r2) {
      this.ctx = t2, this.fillStyle = e2, this.width = i2, this.height = n2, this.config = r2, this.clonedObjects = [], this._displayObject = null, this.gradientHash = jm()(`${JSON.stringify(e2)}${Math.ceil(i2)}${Math.ceil(n2)}`);
    }
    get displayObject() {
      return this._displayObject || (this._displayObject = this.createDisplayObject()), this._displayObject;
    }
    set displayObject(t2) {
      this._displayObject && this._displayObject.destroy({ children: true, texture: true }), this._displayObject = t2;
    }
    get hasFill() {
      return !!this.fillStyle && this.fillStyle.fillType !== "noFill";
    }
    createDisplayObject() {
      var t2;
      if (!this.fillStyle)
        return null;
      if (this.config.useSlideBackgroundFill && this.ctx.bgTexture) {
        const t3 = new ep();
        return t3.texture = this.ctx.bgTexture, t3;
      }
      if (this.fillStyle.fillType === "solidFill" || this.fillStyle.fillType === "noFill")
        return null;
      if (this.fillStyle.fillType === "gradientFill") {
        const t3 = new ep(), e2 = Wg(JSON.parse(JSON.stringify(this.fillStyle)), this.width, this.height), i2 = Vh.p.create({ width: this.width, height: this.height, resolution: this.ctx.renderer.resolution });
        return this.ctx.renderer.render(e2, { renderTexture: i2 }), e2.destroy({ children: true, texture: true }), t3.texture = i2, t3;
      }
      if (this.fillStyle.fillType === "blipFill") {
        const { src: e2, filters: i2 } = this.fillStyle, n2 = this.ctx.spriteTexture.getTexture(e2), r2 = this.ctx.spriteTexture.getFrameData(e2);
        if (n2) {
          const e3 = new ep();
          if (e3.texture = n2, i2.length > 0 && this.config.useFilter && (this.ctx.featureList || {}).filter && (e3.filters = av(i2, this.ctx.featureList)), this.config.fillFloat) {
            const { l: i3, t: n3, r: r3, b: o2 } = this.config.fillFloat.fillRect, s2 = this.width * (1 - i3 - r3), a2 = this.height * (1 - n3 - o2), l2 = (t2 = this.config.shapeRotation) !== null && t2 !== void 0 ? t2 : 0, h2 = new Jd();
            h2.drawRect(0, 0, s2, a2), h2.pivot.x = s2 / 2, h2.pivot.y = a2 / 2, h2.rotation = l2;
            const u2 = h2.getBounds(), c2 = u2.width, d2 = u2.height;
            e3.width = c2, e3.height = d2, e3.anchor.x = 0.5, e3.anchor.y = 0.5, e3.rotation = -1 * l2, e3.name = "math-texture", l2 === 0 ? (e3.position.x = c2 / 2 + i3 * this.width, e3.position.y = d2 / 2 + n3 * this.height) : (e3.position.x = this.width / 2, e3.position.y = this.height / 2);
          } else
            e3.width = this.width, e3.height = this.height, r2.rotate && (e3.position.x = this.width / 2, e3.position.y = this.height / 2, e3.anchor.x = 0.5, e3.anchor.y = 0.5, e3.rotation = r2.rotate / 180 * Math.PI);
          return e3;
        }
      } else if (this.fillStyle.fillType === "gifFill") {
        const { src: t3, delays: e2, filters: i2 } = this.fillStyle, n2 = this.ctx.spriteTexture.getGifFrames(t3).map((t4, i3) => ({ texture: t4, time: e2[i3] || 20 })), r2 = new im(n2, true);
        r2.name = Mm(), r2.width = this.width, r2.height = this.height, i2.length > 0 && this.config.useFilter && (this.ctx.featureList || {}).filter && (r2.filters = av(i2, this.ctx.featureList));
        const o2 = this.fillStyle.loop;
        let s2 = 1;
        return r2.onLoop = () => {
          s2 += 1, o2 > 0 && s2 > o2 && r2.gotoAndStop(r2.totalFrames);
        }, r2;
      }
      return null;
    }
    isSolidFill() {
      var t2;
      return ((t2 = this.fillStyle) === null || t2 === void 0 ? void 0 : t2.fillType) === "solidFill";
    }
    getSolidFillColor() {
      var t2;
      return ((t2 = this.fillStyle) === null || t2 === void 0 ? void 0 : t2.fillType) === "solidFill" ? this.fillStyle.color : "#000000";
    }
    getClonedDisplayObject() {
      const t2 = this.createDisplayObject();
      return this.clonedObjects.push(t2), t2;
    }
    destroy() {
      var t2;
      (t2 = this._displayObject) === null || t2 === void 0 || t2.destroy(), this._displayObject = null, this.clonedObjects.forEach((t3) => {
        t3 == null || t3.destroy();
      }), this.clonedObjects = [];
    }
  }
  class hv extends Vh.k {
  }
  var uv = i(113), cv = i.n(uv), dv = i(114), pv = i.n(dv);
  class fv extends hv {
    constructor(t2) {
      super(cv.a, pv.a, { uShapeFilterArea: new Float32Array([0, 0, 0, 0]), uGlowColor: mg(t2.color), uSdfSampler: Vh.t.WHITE, uSdfReady: 0, uSdfMaxDis: 0, uRad: t2.rad / 2, uSdfPosition: new Float32Array([0, 0]) }), this.priority = 3, this.json = t2;
    }
    filterAreaJustify(t2) {
      const e2 = Math.ceil(this.json.rad), i2 = Math.ceil(t2.width + 2 * e2), n2 = Math.ceil(t2.height + 2 * e2);
      return new Lh.j(t2.x - e2, t2.y - e2, i2, n2);
    }
    sdfBox(t2, e2) {
      const i2 = Math.ceil(this.json.rad), n2 = Math.ceil(t2 + 2 * i2), r2 = Math.ceil(e2 + 2 * i2);
      return new Lh.j(i2, i2, n2, r2);
    }
  }
  var mv = i(19), gv = i.n(mv), vv = i(115), _v = i.n(vv);
  class yv extends hv {
    constructor(t2) {
      super(gv.a, _v.a, { uShapeFilterArea: new Float32Array([0, 0, 0, 0]), uRad: t2.rad, uSdfSampler: Vh.t.WHITE, uSdfReady: 0, uSdfMaxDis: 1 }), this.priority = 2, this.json = t2;
    }
    filterAreaJustify(t2) {
      return t2;
    }
    sdfBox(t2, e2) {
      return new Lh.j(0, 0, t2, e2);
    }
  }
  class xv {
  }
  var bv = i(116), Tv = i.n(bv);
  class Ev extends Vh.k {
    constructor(t2) {
      super(gv.a, Tv.a, { uColor: mg(t2) });
    }
  }
  class Sv extends xv {
    constructor(t2, e2, i2) {
      super(), this.order = 1, this.outputTexture = Vh.t.WHITE, this.frameTextures = [], this.json = t2, this.effectContainer = e2, this.outputSprite = new ep(), this.targetScale = i2, this.outputSprite.scale.x = this.json.sx, this.outputSprite.scale.y = this.json.sy, this.outputSprite.skew.x = (this.targetScale.x > 0 ? 1 : -1) * this.json.kx, this.outputSprite.skew.y = (this.targetScale.y > 0 ? 1 : -1) * this.json.ky, this.outputSprite.filters = [new rm.BlurFilter(this.json.blurRad / 2, 4), new Ev(this.json.color)];
    }
    updateFrame(t2) {
      const e2 = this.frameTextures[t2];
      if (e2) {
        const t3 = this.effectContainer.getBounds(), i2 = (this.effectContainer.width - e2.width) / 2, n2 = (this.effectContainer.height - e2.height) / 2, r2 = new Lh.g(t3.x, t3.y), o2 = new Lh.g(t3.x, t3.y);
        switch (this.json.align) {
          case "tl":
            o2.x = t3.x, o2.y = t3.y;
            break;
          case "t":
            o2.x = t3.x + t3.width / 2, o2.y = t3.y, r2.x += t3.width / 2;
            break;
          case "tr":
            o2.x = t3.x + t3.width, o2.y = t3.y, r2.x += t3.width;
            break;
          case "l":
            o2.x = t3.x, o2.y = t3.y + t3.height / 2, r2.y += t3.height / 2;
            break;
          case "ctr":
            o2.x = t3.x + t3.width / 2, o2.y = t3.y + t3.height / 2, r2.x += t3.width / 2, r2.y += t3.height / 2;
            break;
          case "r":
            o2.x = t3.x + t3.width, o2.y = t3.y + t3.height / 2, r2.x += t3.width, r2.y += t3.height / 2;
            break;
          case "bl":
            o2.x = t3.x, o2.y = t3.y + t3.height, r2.y += t3.height;
            break;
          case "b":
            o2.x = t3.x + t3.width / 2, o2.y = t3.y + t3.height, r2.x += t3.width / 2, r2.y += t3.height;
            break;
          case "br":
            o2.x = t3.x + t3.width, o2.y = t3.y + t3.height, r2.x += t3.width, r2.y += t3.height;
        }
        const s2 = this.effectContainer.toLocal(o2);
        this.outputSprite.pivot.x = s2.x, this.outputSprite.pivot.y = s2.y;
        const a2 = new Lh.g(this.json.dist, 0), l2 = new Lh.d();
        l2.rotate(this.json.dir), l2.translate(r2.x + i2, r2.y + n2), l2.apply({ x: a2.x, y: a2.y }, a2);
        const h2 = this.effectContainer.toLocal(a2);
        this.outputSprite.position.x = h2.x, this.outputSprite.position.y = h2.y, this.outputSprite.texture = e2;
      }
    }
    createOutput(t2, e2) {
      this.frameTextures[e2] = t2;
    }
    setFrameOffset(t2, e2) {
    }
  }
  var wv = i(117), Av = i.n(wv);
  class Mv extends Vh.k {
    constructor(t2, e2) {
      super(gv.a, Av.a, { uStartAlpha: t2.startAlpha, uEndAlpha: t2.endAlpha, uStartPos: t2.startPos, uEndPos: t2.endPos, uHeight: e2 }), console.log(this);
    }
  }
  class Rv extends xv {
    constructor(t2, e2, i2, n2, r2) {
      super(), this.order = 2, this.outputSprite = new ep(), this.outputTexture = Vh.t.WHITE, this.frameTextures = [], this.json = t2, this.shapeScaleX = n2, this.effectContainer = e2, this.rotation = i2, this.ctx = r2, this.outputSprite.anchor.x = 0.5, this.outputSprite.anchor.y = 0.5;
      const o2 = this.effectContainer.getBounds();
      this.outputSprite.filters = [new rm.BlurFilter(this.json.blurRad / 2, 4), new Mv(this.json, o2.height)], this.outputSprite.alpha = 0.5, this.outputSprite.rotation = this.shapeScaleX === -1 ? Math.PI + 2 * this.rotation : Math.PI - 2 * this.rotation, this.outputSprite.scale.x = -1;
    }
    updateFrame(t2) {
      const e2 = this.frameTextures[t2];
      e2 && (this.outputSprite.texture = e2);
    }
    createOutput(t2, e2) {
      this.frameTextures[e2] = t2;
    }
    setFrameOffset(t2, e2) {
      const i2 = this.effectContainer.getBounds(), n2 = new Lh.g(i2.x + i2.width / 2, i2.y + i2.height / 2), r2 = new Lh.g(n2.x, n2.y + i2.height + this.json.dist), o2 = this.effectContainer.toLocal(r2);
      this.outputSprite.position.x = o2.x + t2, this.outputSprite.position.y = o2.y + e2;
    }
  }
  var Cv = i(118), Iv = i.n(Cv);
  class Pv extends hv {
    constructor(t2) {
      super(gv.a, Iv.a, {}), this.priority = 1, this.json = t2;
    }
    filterAreaJustify(t2) {
      return t2;
    }
    sdfBox() {
      return null;
    }
  }
  var Ov = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Nv extends Za.a {
    constructor(t2, e2, i2, n2, r2, o2) {
      super(), this.effects = [], this.attachs = [], this.frames = /* @__PURE__ */ new Map(), this._targetContainer = new Oh.b(), this.frameCount = 1, this.ctx = n2, this.originWidth = t2.width, this.originHeight = t2.height, this.cacheKey = i2, this.sourceSprite = new ep();
      for (const i3 of e2)
        switch (i3.type) {
          case "innerShadow":
            this.effects.push(new Pv(i3));
            break;
          case "softEdge":
            this.effects.push(new yv(i3));
            break;
          case "glow":
            this.effects.push(new fv(i3));
            break;
          case "reflection":
            this.attachs.push(new Rv(i3, t2, r2, o2.x, this.ctx));
            break;
          case "outerShadow":
            this.attachs.push(new Sv(i3, t2, o2));
        }
      this.effects = this.effects.sort((t3, e3) => t3.priority - e3.priority), this.attachs = this.attachs.sort((t3, e3) => t3.order - e3.order);
      for (const t3 of this.attachs)
        this._targetContainer.addChild(t3.outputSprite);
      this.sourceSprite.name = "effect-sprite";
      const s2 = new Lh.j(0, 0, this.originWidth, this.originHeight), a2 = this.effects.map((t3) => t3.filterAreaJustify(s2)), l2 = a2.map((t3) => t3.x), h2 = a2.map((t3) => t3.y), u2 = a2.map((t3) => t3.width), c2 = a2.map((t3) => t3.height);
      this.filterArea = new Lh.j(Math.min(...l2, 0), Math.min(...h2, 0), Math.max(...u2, this.originWidth), Math.max(...c2, this.originHeight)), this.sourceSprite.filters = this.effects, this.sourceSprite.filterArea = new Lh.j(0, 0, this.filterArea.width, this.filterArea.height), this._targetSprite = new ep(), this._targetSprite.name = "effect-sprite", this._targetContainer.sortableChildren = true, this._targetSprite.zIndex = 999, this._targetContainer.addChild(this._targetSprite);
    }
    get container() {
      return this._targetContainer;
    }
    getSdfTexture(t2, e2) {
      return Ov(this, void 0, void 0, function* () {
        const i2 = `${this.cacheKey}_${t2}`, n2 = this.effects.map((t3) => ({ sdfRect: t3.sdfBox(e2.width, e2.height) })).reduce((t3, e3) => e3.sdfRect ? (t3.width < e3.sdfRect.width && (t3.width = e3.sdfRect.width), t3.height < e3.sdfRect.height && (t3.height = e3.sdfRect.height), t3) : t3, new Lh.j(0, 0));
        return n2.width === 0 || n2.height === 0 ? null : this.ctx.sdfManager.getSdf(e2, n2, i2);
      });
    }
    setFrameCount(t2) {
      this.frameCount = t2;
    }
    updateFrame(t2) {
      const e2 = this.frames.get(t2);
      if (e2) {
        this._targetSprite.texture = e2.texture, this._targetSprite.pivot.x = e2.pivotX, this._targetSprite.pivot.y = e2.pivotY;
        for (const e3 of this.attachs)
          e3.updateFrame(t2);
      }
    }
    hasFrame(t2) {
      return this.frames.has(t2);
    }
    setFrameOffset(t2, e2) {
      this._targetContainer.position.x = -1 * t2, this._targetContainer.position.y = -1 * e2, this.attachs.forEach((i2) => i2.setFrameOffset(t2, e2));
    }
    createFrame(t2, e2) {
      var i2, n2;
      return Ov(this, void 0, void 0, function* () {
        const r2 = e2.width, o2 = e2.height;
        if (this.frames.has(t2))
          return;
        const s2 = yield this.getSdfTexture(t2, e2), a2 = (i2 = s2 == null ? void 0 : s2.texture.width) !== null && i2 !== void 0 ? i2 : 0, l2 = (n2 = s2 == null ? void 0 : s2.texture.height) !== null && n2 !== void 0 ? n2 : 0;
        for (const t3 of this.effects) {
          const i3 = t3.sdfBox(e2.width, e2.height);
          i3 && s2 && (t3.uniforms.uSdfSampler = s2.texture, t3.uniforms.uSdfIsReady = 1, t3.uniforms.uSdfMaxDis = s2.maxDis, t3.uniforms.uSdfPosition = new Float32Array([(s2.texture.width - i3.width) / 2 / s2.texture.width, (s2.texture.height - i3.height) / 2 / s2.texture.height])), t3.uniforms.uShapeFilterArea = new Float32Array([0, 0, this.filterArea.width, this.filterArea.height]);
        }
        this.sourceSprite.texture = e2;
        const h2 = (this.filterArea.width - this.sourceSprite.width) / 2, u2 = (this.filterArea.height - this.sourceSprite.height) / 2;
        this.sourceSprite.x = h2, this.sourceSprite.y = u2;
        const c2 = Math.max(r2, a2, this.filterArea.width), d2 = Math.max(o2, l2, this.filterArea.height), p2 = Vh.p.create({ width: c2, height: d2, resolution: this.ctx.renderer.resolution });
        this.ctx.renderer.render(this.sourceSprite, { renderTexture: p2 }), this.frames.set(t2, { texture: p2, pivotX: -1 * (this.originWidth - c2) / 2, pivotY: -1 * (this.originWidth - c2) / 2 });
        for (const e3 of this.attachs)
          e3.createOutput(p2, t2);
        Array.from(this.frames.keys()).length === this.frameCount && this.emit("ready");
      });
    }
  }
  var Lv = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Dv extends Sg {
    constructor(t2, e2, i2) {
      var n2;
      super(t2, e2, i2), this.textureContainer = new Oh.b(), this.underline = null, this.cacheSprite = new ep(), this.effectContainer = new Oh.b(), this.effectObject = null;
      const { shapeId: r2, paragraphIndex: o2, lineIndex: s2, unitIndex: a2, lineHeight: l2, width: h2, underLine: u2, fill: c2, height: d2, isHorz: p2, lineWidth: f2 } = t2, m2 = ((n2 = c2 == null ? void 0 : c2.fill) === null || n2 === void 0 ? void 0 : n2.fillType) === "solidFill" ? c2.fill.color : null;
      if (u2) {
        const t3 = p2 ? l2 / 16 : f2 / 16;
        this.underline = new wg(e2, u2.type, t3, h2, d2, m2, p2, r2, o2, s2, a2);
      }
      if (this.textGraphics = this.createTextGraphics(), this.textFill = this.createTextFill(), this.strokeGraphics = this.createStrokeGraphics(), this.strokeFill = this.createStrokeFill(), this.effectContainer.name = "effect-container", this.effectContainer.zIndex = 1, this.container.addChild(this.effectContainer), t2.effectIndexList && t2.effectIndexList.length && i2.effectList) {
        const { effectList: e3 } = i2;
        this.effectList = t2.effectIndexList.map((t3) => {
          const i3 = e3[t3];
          return i3.type === "outerShadow" && i3.dist > 5 && (i3.dist = 5), e3[t3];
        }), this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
          if (this.ctx.slideIndex === t3 && this.effectObject) {
            const t4 = this.getEffectTexture();
            if (t4) {
              const { texture: e4, offsetX: i3, offsetY: n3 } = t4;
              this.effectObject.setFrameOffset(i3, n3), this.effectObject.createFrame(1, e4);
            }
          }
        });
      }
    }
    getEffectTexture() {
      const { lineHeight: t2, fillLineHeight: e2, isHorz: i2, lineWidth: n2 } = this.json, r2 = this.effectContainer.getLocalBounds();
      let o2 = 0, s2 = 0;
      for (const t3 of this.effectContainer.children)
        t3.pivot.x > o2 && (o2 = t3.pivot.x), t3.pivot.y > s2 && (s2 = t3.pivot.y);
      const a2 = new Lh.d();
      a2.translate(o2, s2);
      const l2 = Vh.p.create({ width: i2 ? r2.width : n2, height: i2 ? Math.max(e2, t2) : r2.height, resolution: 2 });
      return this.ctx.renderer.render(this.effectContainer, { renderTexture: l2, transform: a2 }), { texture: l2, offsetX: o2, offsetY: s2 };
    }
    createStrokeFill() {
      const { stroke: t2, lineWidth: e2, lineHeight: i2 } = this.json;
      return new lv(this.ctx, t2 == null ? void 0 : t2.fill, e2, i2, { useFilter: false, useSlideBackgroundFill: false });
    }
    createStrokeGraphics() {
      const { stroke: t2 } = this.json, e2 = (t2 == null ? void 0 : t2.key) ? { fillType: "blipFill", src: t2.key, filters: [] } : void 0;
      return new lv(this.ctx, e2, (t2 == null ? void 0 : t2.width) || 0, (t2 == null ? void 0 : t2.height) || 0, { useFilter: false, useSlideBackgroundFill: false });
    }
    createTextFill() {
      const { isHorz: t2, fill: e2, lineWidth: i2, lineHeight: n2, fillLineHeight: r2 } = this.json;
      return t2 ? new lv(this.ctx, e2 == null ? void 0 : e2.fill, i2, Math.max(r2, n2), { useFilter: false, useSlideBackgroundFill: false }) : new lv(this.ctx, e2 == null ? void 0 : e2.fill, r2, n2, { useFilter: false, useSlideBackgroundFill: false });
    }
    createTextGraphics() {
      var t2;
      const { fill: e2, content: i2 } = this.json;
      let n2 = "#000000";
      ((t2 = e2 == null ? void 0 : e2.fill) === null || t2 === void 0 ? void 0 : t2.fillType) === "solidFill" && (n2 = e2.fill.color);
      const r2 = (e2 == null ? void 0 : e2.key) ? { fillType: "blipFill", src: e2.key, filters: [{ type: "changeBulletColor", args: ["#000000", n2] }] } : void 0;
      return new lv(this.ctx, r2, (e2 == null ? void 0 : e2.width) || 0, (e2 == null ? void 0 : e2.height) || 0, { useFilter: i2 === "\u25FE", useSlideBackgroundFill: false });
    }
    getIterateEntry() {
      return null;
    }
    getBgElement() {
      return null;
    }
    updateTransform(t2) {
      var e2, i2, n2, r2;
      const { isHorz: o2 } = this.json;
      t2.position = { x: o2 && (i2 = (e2 = t2.position) === null || e2 === void 0 ? void 0 : e2.x) !== null && i2 !== void 0 ? i2 : 0, y: o2 ? 0 : (r2 = (n2 = t2.position) === null || n2 === void 0 ? void 0 : n2.y) !== null && r2 !== void 0 ? r2 : 0 }, t2.width = o2 ? this.json.width : this.json.lineWidth, t2.height = o2 ? this.json.lineHeight : this.json.height, super.updateTransform(t2);
    }
    preRender() {
      var t2;
      (t2 = this.underline) === null || t2 === void 0 || t2.preRender();
    }
    render(t2) {
      t2.addSubMTask(() => Lv(this, void 0, void 0, function* () {
        this.doRender();
      }), "@TextUnitImpl[doRender]"), t2.addSubMTask(() => Lv(this, void 0, void 0, function* () {
        var t3;
        if (this.effectList && this.effectList.length > 0) {
          const e2 = `${this.ctx.taskId}_${this.ctx.slideIndex}_${(t3 = this.json.fill) === null || t3 === void 0 ? void 0 : t3.key}_${this.json.effectIndexList}`;
          this.effectObject = new Nv(this.effectContainer, this.effectList, e2, this.ctx, 0, new Lh.g(1, 1)), this.effectObject.on("ready", () => {
            var t4;
            this.effectContainer.visible = false, this.effectObject.container.zIndex = 10, this.container.addChild(this.effectObject.container), (t4 = this.effectObject) === null || t4 === void 0 || t4.updateFrame(1);
          });
        }
      }), "@ShapeImpl[post.render]");
    }
    doRender() {
      let t2 = false;
      const { lineWidth: e2, lineHeight: i2, baseLine: n2, isHorz: r2, underline: o2, height: s2, width: a2, highlightColor: l2, x: h2, y: u2, content: c2, fillLineHeight: d2, fill: p2 } = this.json;
      let f2 = this.json.needFill !== false;
      if (p2 && p2.fill && p2.fill.fillType !== "solidFill" && (f2 = true), l2) {
        const t3 = new Jd(), [n3, o3] = fg(l2);
        t3.beginFill(n3, o3), t3.drawRect(0, 0, r2 ? a2 : e2, r2 ? i2 : s2), t3.endFill(), this.textureContainer.addChild(t3);
      }
      if (this.textGraphics.displayObject) {
        const e3 = this.textGraphics.displayObject;
        if (r2 && (e3.position.y = u2 > 0 ? u2 : 0), f2) {
          const i3 = this.textFill.displayObject;
          if (i3)
            i3.mask = e3, i3.addChild(e3), i3.position.x = -h2, e3.position.x += h2, t2 = true, this.textureContainer.addChild(i3);
          else if (this.textFill.isSolidFill()) {
            const i4 = new _g();
            i4.color = this.textFill.getSolidFillColor(), e3.filters = [i4], t2 = true, this.textureContainer.addChild(e3);
          }
        } else
          this.textureContainer.addChild(e3);
      }
      if (this.strokeGraphics.displayObject) {
        const e3 = this.strokeGraphics.displayObject;
        if (f2) {
          const i3 = this.strokeFill.displayObject;
          if (i3)
            i3.mask = e3, i3.addChild(e3), r2 ? i3.position.y = u2 > 0 ? u2 : 0 : i3.position.x = h2, this.textureContainer.addChild(i3);
          else if (this.strokeFill.isSolidFill()) {
            r2 ? e3.position.y = u2 > 0 ? u2 : 0 : e3.position.x = h2;
            const i4 = new _g();
            i4.color = this.strokeFill.getSolidFillColor(), e3.filters = [i4], t2 = true, this.textureContainer.addChild(e3);
          }
        } else
          r2 ? e3.position.y = u2 > 0 ? u2 : 0 : e3.position.x = h2, this.textureContainer.addChild(e3);
      }
      if (this.underline && (this.underline.render(), this.underline.sprite)) {
        r2 ? (this.underline.sprite.position.y = o2 ? o2 - i2 / 16 : n2, this.underline.sprite.position.x = 0) : (this.underline.sprite.position.x = 0, this.underline.sprite.position.y = 0);
        const t3 = this.textFill.getClonedDisplayObject();
        t3 ? (t3.mask = this.underline.sprite, t3.addChild(this.underline.sprite), this.textureContainer.addChild(t3)) : this.textureContainer.addChild(this.underline.sprite);
      }
      if (t2) {
        const t3 = Vh.p.create({ width: r2 ? a2 : e2, height: r2 ? Math.max(d2, i2) : s2, resolution: this.ctx.renderer.resolution });
        this.ctx.renderer.render(this.textureContainer, { renderTexture: t3 }), this.cacheSprite.texture = t3, r2 && u2 < 0 && (this.cacheSprite.position.y = u2), this.effectContainer.addChild(this.cacheSprite);
      } else
        this.effectContainer.addChild(this.textureContainer);
      this.container.name = c2;
    }
    destroy() {
      this.textFill.destroy(), this.textGraphics.destroy(), this.strokeFill.destroy(), this.strokeGraphics.destroy(), this.cacheSprite.texture.destroy(true), this.cacheSprite.destroy(), this.textureContainer.destroy(), this.container.destroy();
    }
  }
  var Fv = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Bv extends Sg {
    constructor(t2, e2, i2) {
      super(t2, e2, i2), this.units = [], this.isHorz = true, this.hyperLinkMap = /* @__PURE__ */ new Map(), this.hyperLinkContainerMap = /* @__PURE__ */ new Map(), this.effectList = [], i2.effectList && (this.effectList = i2.effectList);
    }
    getIterateElements() {
      return this.units;
    }
    getIterateEntry(t2, e2, i2) {
      return this.units[e2] ? this.units[e2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
    }
    preRender() {
    }
    createUnits(t2, e2, i2, n2) {
      for (let r2 = 0, o2 = this.json.textUnits.length; r2 < o2; r2++)
        n2.addSubMTask(() => Fv(this, void 0, void 0, function* () {
          const n3 = this.json.textUnits[r2], { height: o3, width: s2, fillHeight: a2, baseline: l2, y: h2, underline: u2 } = this.json, c2 = new Dv(Object.assign(Object.assign({}, n3), { lineHeight: o3, lineWidth: s2, baseLine: l2 - h2, underline: u2, fillLineHeight: a2 || o3, isHorz: this.isHorz, shapeId: t2, paragraphIndex: e2, lineIndex: i2, unitIndex: r2 }), this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
          if (c2.preRender(), this.units.push(c2), n3.hyperlink || n3.hlinkHover) {
            const t3 = new og(c2.container, this.ctx);
            n3.hyperlink && t3.addAction(n3.hyperlink, "click"), n3.hlinkHover && t3.addAction(n3.hlinkHover, "hover"), this.container.sortableChildren = true;
          }
        }), "@TextLineImpl[createUnits]");
    }
    render(t2) {
      for (const e2 of this.units.reverse())
        e2.render(t2), t2.addSubMTask(() => Fv(this, void 0, void 0, function* () {
          this.container.addChild(e2.container);
        }), "@TextLineImpl[container.addChild]");
    }
    destroy() {
      this.units.forEach((t2) => {
        t2.destroy();
      }), this.container.destroy({ children: false }), this.hyperLinkMap.clear();
      for (const t2 of this.hyperLinkContainerMap.values())
        t2.destroy({ children: true, baseTexture: true, texture: true });
      this.hyperLinkContainerMap.clear();
    }
  }
  var Uv = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class kv extends Sg {
    constructor(t2, e2, i2) {
      super(t2, e2, i2), this.iterateElements = [], this.lines = [], this.effectList = [], this.isHorz = true, i2.effectList && (this.effectList = i2.effectList);
    }
    getIterateElements() {
      if (this.iterateElements.length > 0)
        return this.iterateElements;
      const t2 = this.lines.reduce((t3, e2) => t3 = t3.concat(e2.getIterateElements()), []);
      return this.iterateElements = t2, t2;
    }
    getIterateEntry(t2, e2, i2) {
      const n2 = this.getIterateElements();
      return n2[e2] ? n2[e2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
    }
    preRender() {
    }
    createLines(t2, e2, i2) {
      for (let n2 = 0, r2 = this.json.lines.length; n2 < r2; n2++)
        i2.addSubMTask(() => Uv(this, void 0, void 0, function* () {
          const r3 = this.json.lines[n2], o2 = new Bv(r3, this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
          o2.isHorz = this.isHorz, o2.container.name = "line-" + n2, o2.createUnits(t2, e2, n2, i2), this.lines.push(o2);
        }), "@TextParagraphImpl[createLines]");
    }
    render(t2) {
      for (const e2 of this.lines)
        e2.render(t2), t2.addSubMTask(() => Uv(this, void 0, void 0, function* () {
          this.container.addChild(e2.container);
        }), "@TextParagraphImpl[container.addChild]");
    }
    destroy() {
      this.lines.forEach((t2) => {
        t2.destroy();
      }), this.container.destroy({ children: false });
    }
  }
  function Gv(t2, e2, i2) {
    let n2, r2;
    const o2 = Math.round(t2) % 360;
    if (o2 % 180 == 0)
      n2 = Math.cos(o2 * (Math.PI / 180)) * e2, r2 = 0;
    else if (o2 % 90 == 0)
      n2 = 0, r2 = -Math.sin(o2 * (Math.PI / 180)) * i2;
    else {
      const t3 = Math.tan(o2 * Math.PI / 180);
      n2 = e2 * i2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(e2 * t3, 2)), (o2 > 90 && o2 < 270 || o2 < -90 && o2 > -270) && (n2 = -n2), r2 = -t3 * n2;
    }
    return { x: n2, y: r2 };
  }
  function Hv(t2, e2, i2, n2, r2, o2) {
    const s2 = Gv((r2 = -r2) / Math.PI * 180, i2, n2), a2 = t2.x - s2.x, l2 = t2.y - s2.y;
    return { centerX: a2 / 9525 * e2.x, centerY: l2 / 9525 * e2.y, rx: i2 / 9525 * e2.x, ry: n2 / 9525 * e2.y, st: -r2, end: -r2 + o2, aClockWise: o2 < 0 };
  }
  function jv(t2) {
    const e2 = new zs(), { scale: i2 } = t2;
    let n2 = { x: 0, y: 0 };
    const r2 = t2.path.trim().split(" ");
    for (let t3 = 0; t3 < r2.length; t3 += 2) {
      const o2 = r2[t3], s2 = r2[t3 + 1];
      if (o2 === "M") {
        let [t4, r3] = s2.split(",").map((t5) => Number(t5));
        n2 = { x: t4, y: r3 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, e2.moveTo(t4, r3);
      } else if (o2 === "A") {
        const [t4, r3, o3, a2] = s2.split(",").map((t5) => Number(t5)), { centerX: l2, centerY: h2, rx: u2, ry: c2, st: d2, end: p2, aClockWise: f2 } = Hv(n2, i2, t4, r3, o3, a2);
        e2.absellipse(l2, h2, u2, c2, d2, p2, f2, 0);
      } else if (o2 === "L") {
        let [t4, r3] = s2.split(",").map((t5) => Number(t5));
        n2 = { x: t4, y: r3 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, e2.lineTo(t4, r3);
      } else if (o2 === "QB") {
        let [t4, r3, o3, a2] = s2.split(",").map((t5) => Number(t5));
        n2 = { x: o3, y: a2 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, o3 = o3 / 9525 * i2.x, a2 = a2 / 9525 * i2.y, e2.quadraticCurveTo(t4, r3, o3, a2);
      } else if (o2 === "CB") {
        let [t4, r3, o3, a2, l2, h2] = s2.split(",").map((t5) => Number(t5));
        n2 = { x: l2, y: h2 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, o3 = o3 / 9525 * i2.x, a2 = a2 / 9525 * i2.y, l2 = l2 / 9525 * i2.x, h2 = h2 / 9525 * i2.y, e2.bezierCurveTo(t4, r3, o3, a2, l2, h2);
      } else if (o2 === "C")
        try {
          e2.closePath();
        } catch (t4) {
        }
    }
    return e2;
  }
  function zv(t2, e2) {
    return t2.curves.map((t3) => t3.getPoints(e2)).reduce((t3, e3) => t3.concat(e3), []);
  }
  const Vv = { textCirclePour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textStop: { top: (t2) => zv(t2, 100), bottom: (t2) => zv(t2, 100) }, textPlain: { top: (t2) => zv(t2, 100), bottom: (t2) => zv(t2, 100) }, textTriangle: { top: (t2) => zv(t2, 50), bottom: (t2) => zv(t2, 101) }, textTriangleInverted: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 101) }, textChevron: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 50) }, textChevronInverted: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 50) }, textRingInside: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textRingOutside: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textArchUpPour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textArchDownPour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCurveUp: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCurveDown: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCanUp: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCanDown: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textWave1: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textWave2: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textDoubleWave1: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textWave4: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textInflate: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textDeflate: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textInflateBottom: { top: (t2) => zv(t2, 180), bottom: (t2) => t2.getPoints(180) }, textDeflateBottom: { top: (t2) => zv(t2, 180), bottom: (t2) => t2.getPoints(180) }, textInflateTop: { bottom: (t2) => zv(t2, 180), top: (t2) => t2.getPoints(180) }, textDeflateTop: { bottom: (t2) => zv(t2, 180), top: (t2) => t2.getPoints(180) }, textFadeRight: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeLeft: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textSlantUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textSlantDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCascadeUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCascadeDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textArchUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textArchDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCircle: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) } };
  function Xv(t2, e2, i2, n2, r2) {
    const o2 = t2.trim().split(" "), [s2, a2] = o2[1].split(",").map((t3) => parseFloat(t3)), [l2, h2, u2, c2] = o2[3].split(",").map((t3) => parseFloat(t3)), d2 = function(t3, e3, i3, n3, r3, o3) {
      const s3 = Math.abs(o3 * Math.sqrt((i3 * i3 + n3 * n3) / 2)), a3 = Math.ceil(s3 / 9525 / 10);
      let l3 = 0, h3 = r3, u3 = { x: t3 + i3 * Math.cos(h3), y: e3 + n3 * Math.sin(h3) };
      for (let r4 = 0; r4 < a3; r4 += 1) {
        h3 += o3 / a3;
        const r5 = { x: t3 + i3 * Math.cos(h3), y: e3 + n3 * Math.sin(h3) };
        l3 += Math.sqrt(Math.pow(r5.x - u3.x, 2) + Math.pow(r5.y - u3.y, 2)), u3 = r5;
      }
      return l3;
    }(s2, a2, l2, h2, u2, c2);
    r2 *= Math.min(1, d2 / 9525 / n2);
    const p2 = new Lh.d();
    p2.translate(r2 + e2 / 2, 0), p2.rotate(2 * Math.PI - u2);
    const f2 = new Lh.g(0, 0), m2 = p2.apply(f2);
    m2.x += e2 / 2, m2.y = i2 / 2 - m2.y;
    const g2 = l2 + 9525 * r2, v2 = h2 + 9525 * r2;
    return `M ${9525 * m2.x},${9525 * m2.y} A ${g2},${v2},${u2},${c2}`;
  }
  var Wv = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Yv {
    constructor(t2, e2, i2, n2, r2) {
      var o2;
      this.iterateElements = [], this.paragraphs = [], this.effectList = [], this.container = new Oh.b(), this.textContainer = new Oh.b(), this.textColorFilter = new _g(), this.json = t2, this.ctx = e2, this.shapeRotation = r2, this.parentGlobalPos = n2, this.iterateType = i2, this.container.name = "textBody", this.global = { x: this.parentGlobalPos.x + t2.position.x, y: this.parentGlobalPos.y + t2.position.y }, this.container.position.x = t2.position.x, this.container.position.y = t2.position.y, this.container.scale.x = t2.scale.x, this.container.scale.y = t2.scale.y;
      const s2 = new Jd();
      s2.drawRect(0, 0, t2.width, t2.height), this.container.addChild(s2), this.container.addChild(this.textContainer), this.textColorFilter.currentColor = "#000000FF", this.textColorFilter.designColor = "#000000FF", this.effectList = (o2 = t2.effectList) !== null && o2 !== void 0 ? o2 : [];
    }
    get width() {
      return this.json.width;
    }
    get height() {
      return this.json.height;
    }
    get x() {
      return this.json.position.x;
    }
    get y() {
      return this.json.position.y;
    }
    set color(t2) {
      var e2;
      ((e2 = this.container.filters) !== null && e2 !== void 0 ? e2 : []).length > 0 && (this.textColorFilter.color = t2);
    }
    get color() {
      return this.textColorFilter.color;
    }
    get on() {
      var t2;
      return ((t2 = this.container.filters) !== null && t2 !== void 0 ? t2 : []).length > 0 ? "true" : "false";
    }
    set on(t2) {
      var e2;
      t2 === "true" ? ((e2 = this.container.filters) !== null && e2 !== void 0 ? e2 : []).indexOf(this.textColorFilter) < 0 && (this.container.filters = [this.textColorFilter]) : this.container.filters = [];
    }
    getTextElement(t2, e2) {
      return t2 === "paragraph" ? this.paragraphs[e2[0]] : null;
    }
    getIterateEntry(t2, e2) {
      return this.iterateElements[t2] ? this.iterateElements[t2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", e2), null);
    }
    destroy() {
      this.paragraphs.forEach((t2) => {
        t2.destroy();
      }), this.textColorFilter.destroy();
    }
    createParagraphs(t2, e2) {
      for (let i2 = 0, n2 = this.json.paragraphs.length; i2 < n2; i2++)
        e2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
          var n3;
          const r2 = this.json.paragraphs[i2], o2 = new kv(r2, this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
          o2.isHorz = (n3 = this.json.isHorz) === null || n3 === void 0 || n3, o2.createLines(t2, i2, e2), e2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
            this.iterateElements = this.iterateElements.concat(o2.getIterateElements()), o2.container.name = "\u6BB5\u843D-" + i2, this.paragraphs.push(o2);
          }), "@TextBodyImpl[paragraphs.push]");
        }), "@TextBodyImpl[createParagraphs]");
    }
    render(t2) {
      for (const e2 of this.paragraphs)
        e2.render(t2), t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
          this.textContainer.addChild(e2.container);
        }), "@TextBodyImpl[container.addChild]");
      t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
        const { width: t3 } = this.container;
        this.container.scale.x < 0 && (this.container.x += -1 * t3);
      }), "@TextBodyImpl[reset width]"), t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
        if (this.json.presetTextShape) {
          const t3 = this.json.paragraphs.map((t4) => t4.x).reduce((t4, e3) => Math.min(t4, e3)), e2 = this.json.paragraphs[0].y, i2 = this.textContainer.getBounds(), { width: n2, height: r2 } = i2, { geometry: o2, type: s2 } = this.json.presetTextShape;
          if (o2.paths) {
            const i3 = Vh.p.create({ width: n2, height: r2, resolution: this.ctx.renderer.resolution }), a2 = new Lh.d();
            a2.translate(-t3, -e2), this.ctx.renderer.render(this.textContainer, { renderTexture: i3, transform: a2 });
            const l2 = this.json.isHorz !== void 0 && !this.json.isHorz;
            if (["textCircle", "textArchUp", "textArchDown"].indexOf(this.json.presetTextShape.type) >= 0) {
              const t4 = Xv(o2.paths[0].path, this.json.width, this.json.height, n2, r2);
              o2.paths.unshift(Object.assign(Object.assign({}, o2.paths[0]), { path: t4 }));
            }
            const h2 = function(t4, e3, i4, n3) {
              if (!Vv[i4])
                return null;
              const r3 = Vv[i4].top(jv(e3)), o3 = Vv[i4].bottom(jv(t4));
              if (r3.length !== o3.length)
                return null;
              const s3 = Math.min(r3.length, o3.length), a3 = 1 / (s3 - 1), l3 = [], h3 = [], u2 = new Array(2 * s3).fill("").map((t5, e4) => e4);
              for (let t5 = 0; t5 < s3; t5++)
                l3.push(r3[t5].x, r3[t5].y), n3 ? h3.push(1, a3 * t5) : h3.push(a3 * t5, 0), l3.push(o3[t5].x, o3[t5].y), n3 ? h3.push(0, a3 * t5) : h3.push(a3 * t5, 1);
              return { vertices: new Float32Array(l3), uvs: new Float32Array(h3), drawMode: Sc.f.TRIANGLE_STRIP, indices: new Uint16Array(u2) };
            }(o2.paths[1], o2.paths[0], s2, l2);
            if (h2) {
              const t4 = new tm.b(i3, h2.vertices, h2.uvs, h2.indices, h2.drawMode);
              this.textContainer.visible = false, this.container.addChild(t4);
            }
          }
        }
      }), "presetTextShape");
    }
  }
  class qv {
    constructor(t2) {
      this.scaleX = 1, this.scaleY = 1, this.pivot = { x: 0, y: 0 }, this.paths = [], this.hash = "", this.width = 0, this.height = 0, this.graphicsId = "", this.textureId = "", this.id = t2.id, this.type = t2.type, this.heightSize = t2.heightSize, this.widthSize = t2.widthSize, this.fillStyle = t2.fillStyle || { fillType: "solidFill", color: "#ffffffff" }, this.lineWidth = t2.lineWidth || 1, this.position = t2.position || { x: 0, y: 0 }, this.rotate = t2.rotation || 1, this.path = this.getUnitPath(), this.setScaleFromLineWidth(), this.setScaleFromSize(), this.generatePaths(), this.setPivot();
    }
    setPivot() {
      switch (this.type) {
        case "oval":
        case "diamond":
          this.pivot = { x: this.width / 2, y: this.height / 2 };
          break;
        case "triangle":
          this.pivot = { x: 0.7 * this.width, y: this.height / 2 };
          break;
        case "arrow":
        case "stealth":
        default:
          this.pivot = { x: this.width, y: this.height / 2 };
      }
    }
    generatePaths() {
      this.hash = "arrow-" + jm()(this.path + this.scaleX + this.scaleY), this.paths = [{ id: this.id, path: this.path, fill: "norm", hasStroke: false, hash: this.hash, scale: { x: this.scaleX, y: this.scaleY } }];
    }
    getUnitPath() {
      switch (this.type) {
        case "stealth":
          return "M 0,0 L 95250,47625 L 0,95250 L 28575,47625 C C";
        case "oval":
          return "M 0,47625 A 47625,47625,-3.14159265,6.2831853 C C";
        case "diamond":
          return "M 47625,0 L 95250,47625 L 47625,95250 L 0,47625 C C";
        case "arrow":
          return "M 9525,0 L 95250,47625 L 9525,95250 L 0,85725 L 68389.5,47625 L 0,9525 C C";
        case "triangle":
          return "M 0,0 L 95250,47625 L 0,95250 C C";
        default:
          return "";
      }
    }
    setScaleFromLineWidth() {
      switch (this.type) {
        case "stealth":
        case "oval":
        case "diamond":
        case "arrow":
        case "triangle":
          this.scaleX *= 0.29 * this.lineWidth + 0.7, this.scaleY *= 0.29 * this.lineWidth + 0.7;
          break;
        default:
          throw new Error("can't match any arrow type!");
      }
    }
    setScaleFromSize() {
      switch (this.type) {
        case "stealth":
        case "oval":
        case "diamond":
        case "arrow":
        case "triangle":
          this.scaleX *= 1, this.scaleY *= 1;
          break;
        default:
          throw new Error("can't match any arrow type!");
      }
      switch (this.widthSize) {
        case "sm":
          this.scaleX *= 3 / 4;
          break;
        case "lg":
          this.scaleX *= 1.25;
          break;
        case "med":
          this.scaleX *= 1;
      }
      switch (this.heightSize) {
        case "sm":
          this.scaleY *= 3 / 4;
          break;
        case "lg":
          this.scaleY *= 1.25;
          break;
        case "med":
          this.scaleY *= 1;
      }
      this.width = 10 * this.scaleX, this.height = 10 * this.scaleY;
    }
  }
  class Zv {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
      this.id = t2, this.ctx = e2, this.paths = i2, this.hash = n2, this.nept = r2, this.width = o2, this.height = s2, this.lineStyle = a2, this.shouldFill = l2, this.bgColor = h2, this.lnColor = u2, this.clonedObjects = [], this._displayObject = null, this.isRectangle = false, this.isPureRect = false, this.isColoredPureRect = false, this.isRectangle = this.rectangleDetect(i2), this.isRectangle && l2 ? this.bgColor ? this.isColoredPureRect = true : this.isPureRect = true : this.ctx.graphicsTexture.addGraphics(this.id, this.paths, this.hash, this.nept, this.width, this.height, this.lineStyle, this.ctx.objectPoolGroup, this.shouldFill, this.bgColor, this.lnColor);
    }
    get displayObject() {
      return this._displayObject;
    }
    pointDis(t2, e2) {
      return Math.pow(t2.x - e2.x, 2) + Math.pow(t2.y - e2.y, 2);
    }
    isPoint(t2) {
      return Number.isNaN(Number(t2.x)) || Number.isNaN(Number(t2.y));
    }
    isSquare(t2, e2) {
      if (t2.join("") !== "MLLLC" && t2.join("") !== "MLLLCC")
        return false;
      const i2 = e2.filter((t3) => !this.isPoint(t3));
      if (i2.length !== 4)
        return false;
      const n2 = Math.min(...i2.map((t3) => t3.x)), r2 = Math.min(...i2.map((t3) => t3.y)), o2 = Math.max(...i2.map((t3) => t3.x)), s2 = Math.max(...i2.map((t3) => t3.y));
      for (const t3 of i2)
        if (t3.x !== n2 && t3.x !== o2 || t3.y !== r2 && t3.y !== s2)
          return false;
      return true;
    }
    rectangleDetect(t2) {
      if (t2.length !== 1)
        return false;
      const e2 = t2[0].path.trim().split(" ");
      if (e2.length !== 10)
        return false;
      const i2 = [], n2 = [];
      for (let t3 = 0; t3 < e2.length; t3 += 2) {
        const r3 = e2[t3], o3 = e2[t3 + 1], [s3, a2] = o3.split(",").map((t4) => Number(t4) / 100);
        i2.push(r3), n2.push({ x: s3, y: a2 });
      }
      if (this.isSquare(i2, n2))
        return false;
      for (let t3 = 0; t3 < 3; t3++) {
        const e3 = n2[t3], i3 = n2[t3 + 1];
        if (e3.x !== i3.x && e3.y !== i3.y)
          return false;
      }
      const r2 = n2.slice(0, 4).reduce((t3, e3) => t3 + e3.x, 0) / 4, o2 = n2.slice(0, 4).reduce((t3, e3) => t3 + e3.y, 0) / 4;
      if (Number.isNaN(r2) || Number.isNaN(o2))
        return false;
      const s2 = { x: r2, y: o2 };
      return sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[1])) && sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[2])) && sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[3])) && this.pointDis(s2, n2[0]) === this.pointDis(s2, n2[1]);
    }
    createDisplayObject() {
      if (this.isPureRect) {
        const t2 = new Jd();
        return t2.beginFill(0, 1), t2.drawRect(0, 0, this.width, this.height), t2;
      }
      if (this.isColoredPureRect && this.bgColor) {
        const t2 = new Jd(), [e2, i2] = fg(this.bgColor);
        return t2.beginFill(e2, i2), t2.drawRect(0, 0, this.width, this.height), t2;
      }
      {
        const t2 = new ep(), e2 = this.ctx.graphicsTexture.getGraphicsData(this.id);
        return e2 ? (t2.texture = e2.texture, t2.pivot.x = e2.pivot.x, t2.pivot.y = e2.pivot.y, t2.scale.x = e2.scale, t2.scale.y = e2.scale, t2) : null;
      }
    }
    getClonedDisplayObject() {
      const t2 = this.createDisplayObject();
      return this.clonedObjects.push(t2), t2;
    }
    render() {
      this._displayObject = this.createDisplayObject();
    }
    isNeedMask(t2, e2) {
      let i2 = false;
      return this._displayObject && (i2 = !(this.isRectangle && Math.abs(t2 - this._displayObject.width) < 2 && Math.abs(e2 - this._displayObject.height) < 2 && this.shouldFill)), i2;
    }
    addArrows(t2) {
      var e2;
      (e2 = this._displayObject) === null || e2 === void 0 || e2.addChild(t2);
    }
    destroy() {
      var t2;
      (t2 = this._displayObject) === null || t2 === void 0 || t2.destroy(), this._displayObject = null, this.clonedObjects.forEach((t3) => {
        t3 == null || t3.destroy();
      }), this.clonedObjects = [];
    }
  }
  var Jv = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  const Kv = { pivot: { x: 0, y: 0 }, width: 0, height: 0 };
  class Qv extends hg {
    constructor(t2, e2, i2) {
      var n2, r2, o2, s2, a2, l2, h2, u2, c2;
      super(t2, e2, i2), this.renderContainer = new Oh.b(), this.needCacheAsBitMap = false, this.backgroundGraphics = null, this.effectList = [], this.strokeGraphics = null, this.ghco = null, this.useGroupFill = false, this.arrowList = [], this.fillColorFilter = new _g(), this.strokeColorFilter = new _g(), this.pptColorFilter = new _g(), this.id = "", this.ppt_c = new ig(this), this.fill = new ng(this), this.stroke = new tg(this), this.effectObject = null, this.effectContainer = new Oh.b(), this.effectDisposer = () => {
      }, this.json = t2, this.option = i2, this.json.fillStyle && this.json.fillStyle.fillType === "groupFill" && i2.groupFillStyle && (this.json.fillStyle = i2.groupFillStyle, this.useGroupFill = true), this.id = t2.id;
      const { fillStyle: d2, lineStyle: p2 } = this.json;
      this.container.sortableChildren = true, this.container.name = t2.id + "_container_[Shape]", this.effectContainer.name = "effect-container", this.effectContainer.zIndex = 1, this.container.addChild(this.effectContainer), this.renderContainer.name = t2.id + "_render_container_[Shape]", this.generateArrowList(), this.backgroundFill = this.createBackgroundFill(), this.backgroundGraphics = this.createBackgroundGraphics(), this.strokeFill = this.createStrokeFill(), this.strokeGraphics = this.createStrokeGraphics();
      try {
        this.ghco = new Zv(this.json.id + "-path-graphics-text-wrap", this.ctx, (o2 = (r2 = (n2 = this.json.textBody) === null || n2 === void 0 ? void 0 : n2.presetTextShape) === null || r2 === void 0 ? void 0 : r2.geometry.paths) !== null && o2 !== void 0 ? o2 : [], (l2 = (a2 = (s2 = this.json.textBody) === null || s2 === void 0 ? void 0 : s2.presetTextShape) === null || a2 === void 0 ? void 0 : a2.geometry.hash) !== null && l2 !== void 0 ? l2 : "", { x: 0, y: 0 }, ((h2 = this.json.textBody) === null || h2 === void 0 ? void 0 : h2.width) || 100, ((u2 = this.json.textBody) === null || u2 === void 0 ? void 0 : u2.height) || 100, { width: 2, fill: { fillType: "solidFill", color: "#FF0000FF" } }, false, null, null);
      } catch (t3) {
        this.ctx.logger.error(t3.message, this.ctx.taskId);
      }
      this.ctx.timingTargets.addTarget(this.id, this), (d2 == null ? void 0 : d2.fillType) === "solidFill" && (this.fillColorFilter.currentColor = d2.color, this.fillColorFilter.designColor = d2.color), ((c2 = p2 == null ? void 0 : p2.fill) === null || c2 === void 0 ? void 0 : c2.fillType) === "solidFill" && (this.strokeColorFilter.currentColor = p2.fill.color, this.strokeColorFilter.designColor = p2.fill.color), this.updateTransform(this.json), t2.textBody && (this.text = new Yv(t2.textBody, this.ctx, t2.textBody.iterateType, { x: this.designGlobalPosition.x, y: this.designGlobalPosition.y }, this.json.rotation || 0)), this.container.hitArea = new Lh.k(1, 1, this.json.width, this.json.height), this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
        if (this.ctx.slideIndex === t3 && this.effectObject) {
          const t4 = this.getEffectTexture();
          if (t4) {
            const { texture: e3, offsetX: i3, offsetY: n3 } = t4;
            this.effectObject.setFrameOffset(i3, n3), this.effectObject.createFrame(1, e3);
          }
        }
      });
    }
    get interactiveContainer() {
      return this.renderContainer;
    }
    get strokeActive() {
      var t2, e2, i2, n2, r2, o2, s2;
      return this.strokeFill.displayObject ? ((i2 = (e2 = (t2 = this.strokeFill.displayObject) === null || t2 === void 0 ? void 0 : t2.filters) === null || e2 === void 0 ? void 0 : e2.length) !== null && i2 !== void 0 ? i2 : -1) > 0 : ((s2 = (o2 = (r2 = (n2 = this.strokeGraphics) === null || n2 === void 0 ? void 0 : n2.displayObject) === null || r2 === void 0 ? void 0 : r2.filters) === null || o2 === void 0 ? void 0 : o2.length) !== null && s2 !== void 0 ? s2 : -1) > 0;
    }
    set strokeActive(t2) {
      var e2, i2, n2, r2, o2, s2;
      const { displayObject: a2 } = this.strokeFill;
      t2 ? a2 && ((i2 = (e2 = a2.filters) === null || e2 === void 0 ? void 0 : e2.indexOf(this.strokeColorFilter)) !== null && i2 !== void 0 ? i2 : -1) < 0 ? a2.filters = [this.strokeColorFilter] : ((n2 = this.strokeGraphics) === null || n2 === void 0 ? void 0 : n2.displayObject) && ((o2 = (r2 = this.strokeGraphics.displayObject.filters) === null || r2 === void 0 ? void 0 : r2.indexOf(this.strokeColorFilter)) !== null && o2 !== void 0 ? o2 : -1) < 0 && (this.strokeGraphics.displayObject.filters = [this.strokeColorFilter]) : a2 ? a2.filters = [] : ((s2 = this.strokeGraphics) === null || s2 === void 0 ? void 0 : s2.displayObject) && (this.strokeGraphics.displayObject.filters = []);
    }
    get pptColorActive() {
      var t2, e2;
      return ((e2 = (t2 = this.renderContainer.filters) === null || t2 === void 0 ? void 0 : t2.length) !== null && e2 !== void 0 ? e2 : -1) > 0;
    }
    set pptColorActive(t2) {
      this.renderContainer.filters = t2 ? [this.pptColorFilter] : [];
    }
    get fillActive() {
      var t2, e2, i2, n2, r2, o2, s2;
      return this.backgroundFill.displayObject ? ((i2 = (e2 = (t2 = this.backgroundFill.displayObject) === null || t2 === void 0 ? void 0 : t2.filters) === null || e2 === void 0 ? void 0 : e2.length) !== null && i2 !== void 0 ? i2 : -1) > 0 : ((s2 = (o2 = (r2 = (n2 = this.backgroundGraphics) === null || n2 === void 0 ? void 0 : n2.displayObject) === null || r2 === void 0 ? void 0 : r2.filters) === null || o2 === void 0 ? void 0 : o2.length) !== null && s2 !== void 0 ? s2 : -1) > 0;
    }
    set fillActive(t2) {
      var e2, i2, n2, r2, o2, s2;
      t2 ? this.backgroundFill.displayObject && ((i2 = (e2 = this.backgroundFill.displayObject.filters) === null || e2 === void 0 ? void 0 : e2.indexOf(this.fillColorFilter)) !== null && i2 !== void 0 ? i2 : -1) < 0 ? this.backgroundFill.displayObject.filters = [this.fillColorFilter] : ((n2 = this.backgroundGraphics) === null || n2 === void 0 ? void 0 : n2.displayObject) && ((o2 = (r2 = this.backgroundGraphics.displayObject.filters) === null || r2 === void 0 ? void 0 : r2.indexOf(this.fillColorFilter)) !== null && o2 !== void 0 ? o2 : -1) < 0 && (this.backgroundGraphics.displayObject.filters = [this.fillColorFilter]) : this.backgroundFill.displayObject ? this.backgroundFill.displayObject.filters = [] : ((s2 = this.backgroundGraphics) === null || s2 === void 0 ? void 0 : s2.displayObject) && (this.backgroundGraphics.displayObject.filters = []);
    }
    getTextElement(t2, e2) {
      var i2, n2;
      if (this.json.isMathFallback) {
        if (!this.json.textBody)
          return this;
        const t3 = () => this.json.textBody.paragraphs[0].lines.length <= 1, e3 = () => this.json.textBody.paragraphs[0].lines[0].textUnits.length <= 1, i3 = () => this.json.textBody.paragraphs[0].lines[0].textUnits[0].content.trim() === "";
        if ((() => this.json.textBody.paragraphs.length <= 1)() && t3() && e3() && i3())
          return this;
      }
      return (n2 = (i2 = this.text) === null || i2 === void 0 ? void 0 : i2.getTextElement(t2, e2)) !== null && n2 !== void 0 ? n2 : null;
    }
    getBgElement() {
      return this;
    }
    getIterateEntry(t2, e2, i2) {
      return e2 === 0 ? this : t2 === "el" ? (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null) : this.text ? this.text.getIterateEntry(e2 - 1, i2) || null : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
    }
    getEffectTexture() {
      const t2 = this.effectContainer.getLocalBounds();
      let e2 = 0, i2 = 0;
      for (const t3 of this.effectContainer.children)
        t3.pivot.x > e2 && (e2 = t3.pivot.x), t3.pivot.y > i2 && (i2 = t3.pivot.y);
      const n2 = new Lh.d();
      if (n2.translate(e2, i2), this.effectContainer.children.length === 0)
        return null;
      const r2 = Vh.p.create({ width: t2.width, height: t2.height, resolution: this.ctx.renderer.resolution });
      return this.ctx.renderer.render(this.effectContainer, { renderTexture: r2, transform: n2 }), { texture: r2, offsetX: e2, offsetY: i2 };
    }
    createStrokeGraphics() {
      var t2, e2, i2, n2;
      const { id: r2, geometry: o2, lineStyle: s2 } = this.json, { width: a2, height: l2, pivot: h2 } = (o2 == null ? void 0 : o2.lineTransform) || Kv, u2 = a2 || this.json.width, c2 = l2 || this.json.height, d2 = ((t2 = s2 == null ? void 0 : s2.fill) === null || t2 === void 0 ? void 0 : t2.fillType) === "solidFill" ? s2.fill.color : null;
      return s2 && ((e2 = s2.fill) === null || e2 === void 0 ? void 0 : e2.fillType) !== "noFill" ? new Zv(r2 + "-path-graphics", this.ctx, (i2 = o2 == null ? void 0 : o2.paths) !== null && i2 !== void 0 ? i2 : [], (n2 = o2 == null ? void 0 : o2.hash) !== null && n2 !== void 0 ? n2 : "", h2 || { x: 0, y: 0 }, u2, c2, s2, false, null, d2) : null;
    }
    createStrokeFill() {
      const [t2, e2] = this.calculateFillObjectOffset(), { geometry: i2, lineStyle: n2, width: r2, height: o2 } = this.json, s2 = (i2 == null ? void 0 : i2.lineTransform) || Kv, a2 = Vm()(n2 == null ? void 0 : n2.width) ? n2.width : 1;
      return new lv(this.ctx, n2 == null ? void 0 : n2.fill, (s2.width || r2) + a2 + t2, Math.max((s2.height || o2) + a2, e2), { useFilter: true, useSlideBackgroundFill: false });
    }
    createBackgroundGraphics() {
      var t2;
      const { geometry: e2, lineStyle: i2, fillStyle: n2, id: r2 } = this.json, { width: o2, height: s2, pivot: a2 } = (e2 == null ? void 0 : e2.lineTransform) || Kv, l2 = o2 || this.json.width, h2 = s2 || this.json.height, u2 = (n2 == null ? void 0 : n2.fillType) === "solidFill" ? n2.color : null;
      return n2 && n2.fillType !== "noFill" || this.json.isPicture ? new Zv(r2 + "-bg-graphics", this.ctx, (t2 = e2 == null ? void 0 : e2.paths) !== null && t2 !== void 0 ? t2 : [], (e2 == null ? void 0 : e2.hash) || "", a2 || { x: 0, y: 0 }, l2, h2, i2, true, u2, null) : null;
    }
    createBackgroundFill() {
      var t2, e2, i2, n2;
      const { fillStyle: r2, width: o2, height: s2, lineStyle: a2, geometry: l2 } = this.json, h2 = (l2 == null ? void 0 : l2.fillTransform) || Kv, u2 = { useFilter: true, useSlideBackgroundFill: this.json.useBgFill, fillFloat: this.json.fillFloat, shapeRotation: this.json.rotation }, c2 = this.useGroupFill && ((t2 = this.option.groupSize) === null || t2 === void 0 ? void 0 : t2.w) ? this.option.groupSize.w : h2.width || o2, d2 = this.useGroupFill && ((e2 = this.option.groupSize) === null || e2 === void 0 ? void 0 : e2.h) ? this.option.groupSize.h : h2.height || s2;
      return new lv(this.ctx, r2, c2 + ((i2 = a2 == null ? void 0 : a2.width) !== null && i2 !== void 0 ? i2 : 0), d2 + ((n2 = a2 == null ? void 0 : a2.width) !== null && n2 !== void 0 ? n2 : 0), u2);
    }
    createBackground() {
      var t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2;
      const { pivot: d2, width: p2, height: f2 } = ((t2 = this.json.geometry) === null || t2 === void 0 ? void 0 : t2.fillTransform) || Kv, { displayObject: m2 } = this.backgroundFill;
      m2 ? (this.json.useBgFill && ((i2 = this.backgroundGraphics) === null || i2 === void 0 ? void 0 : i2.displayObject) ? (this.needCacheAsBitMap = true, m2.mask = this.backgroundGraphics.displayObject, m2.pivot.x = ((n2 = this.json.position) === null || n2 === void 0 ? void 0 : n2.x) || 0, m2.pivot.y = ((r2 = this.json.position) === null || r2 === void 0 ? void 0 : r2.y) || 0, this.effectContainer.addChild(this.backgroundGraphics.displayObject)) : ((o2 = this.json.fillStyle) === null || o2 === void 0 ? void 0 : o2.fillType) === "gifFill" ? (m2.height = f2 || this.designHeight, m2.width = p2 || this.designWidth, m2 instanceof im && m2.play(), ((s2 = this.backgroundGraphics) === null || s2 === void 0 ? void 0 : s2.isNeedMask(m2.width, m2.height)) && (m2.mask = this.backgroundGraphics.displayObject, this.backgroundGraphics.displayObject && this.effectContainer.addChild(this.backgroundGraphics.displayObject))) : ((a2 = this.backgroundGraphics) === null || a2 === void 0 ? void 0 : a2.isNeedMask(m2.width, m2.height)) && (this.json.fillFloat || (this.needCacheAsBitMap = true, m2.mask = this.backgroundGraphics.displayObject, this.backgroundGraphics.displayObject && this.effectContainer.addChild(this.backgroundGraphics.displayObject))), this.json.fillFloat || (m2.x = d2.x, m2.y = d2.y), this.useGroupFill && (m2.x -= (h2 = (l2 = this.json.position) === null || l2 === void 0 ? void 0 : l2.x) !== null && h2 !== void 0 ? h2 : 0, m2.y -= (c2 = (u2 = this.json.position) === null || u2 === void 0 ? void 0 : u2.y) !== null && c2 !== void 0 ? c2 : 0), this.effectContainer.addChild(m2)) : this.backgroundFill.hasFill && ((e2 = this.backgroundGraphics) === null || e2 === void 0 ? void 0 : e2.displayObject) && this.effectContainer.addChild(this.backgroundGraphics.displayObject);
    }
    createPathFill() {
      var t2, e2, i2;
      const { displayObject: n2 } = this.strokeFill, r2 = (t2 = this.strokeGraphics) === null || t2 === void 0 ? void 0 : t2.displayObject, [o2, s2] = this.calculateFillObjectOffset();
      n2 ? (((e2 = this.strokeGraphics) === null || e2 === void 0 ? void 0 : e2.isNeedMask(n2.width, n2.height)) && r2 && (this.needCacheAsBitMap = true, n2.pivot.x = r2.pivot.x, n2.pivot.y = r2.pivot.y, r2.pivot.x = 0, r2.pivot.y = 0, n2.mask = r2, n2.addChild(r2), n2.position.x = -o2 / 2, n2.position.y = -s2 / 2, r2.position.x = o2 / 2, r2.position.y = s2 / 2), this.effectContainer.addChild(n2)) : this.strokeFill.hasFill && ((i2 = this.strokeGraphics) === null || i2 === void 0 ? void 0 : i2.displayObject) && this.effectContainer.addChild(this.strokeGraphics.displayObject);
    }
    createFilledPathMask() {
      var t2, e2, i2;
      const n2 = ((e2 = (t2 = this.json.geometry) === null || t2 === void 0 ? void 0 : t2.paths) === null || e2 === void 0 ? void 0 : e2.filter((t3) => t3.fill !== "none" && t3.fill !== "norm")) || [];
      for (const t3 of n2) {
        const e3 = this.ctx.graphicsTexture.getGraphicsData(t3.id);
        if (e3) {
          const n3 = new ep(e3.texture);
          n3.pivot.x = e3.pivot.x, n3.pivot.y = e3.pivot.y, n3.scale.x = e3.scale, n3.scale.y = e3.scale;
          const r2 = this.backgroundFill.getClonedDisplayObject(), o2 = (i2 = this.backgroundGraphics) === null || i2 === void 0 ? void 0 : i2.getClonedDisplayObject(), s2 = r2 || o2;
          s2 && (this.backgroundFill.displayObject && (s2.pivot.x = this.backgroundFill.displayObject.pivot.x, s2.pivot.y = this.backgroundFill.displayObject.pivot.y), s2.mask = n3, s2.filters = [Eg[t3.fill]], this.needCacheAsBitMap = true, this.effectContainer.addChild(s2), this.effectContainer.addChild(n3));
        }
      }
    }
    createArrow() {
      this.arrowList.length && this.arrowList.forEach((t2) => {
        var e2;
        const i2 = this.ctx.graphicsTexture.getGraphicsData(t2.graphicsId);
        if (i2) {
          const { texture: n2 } = i2, r2 = new ep(n2);
          r2.pivot.x = t2.pivot.x, r2.pivot.y = t2.pivot.y, r2.position.x = t2.position.x, r2.position.y = t2.position.y, r2.rotation = t2.rotate / 180 * Math.PI, r2.scale.x = i2.scale, r2.scale.y = i2.scale, (e2 = this.backgroundGraphics) === null || e2 === void 0 || e2.addArrows(r2);
        }
      });
    }
    generateArrowList() {
      var t2, e2;
      const { lineArrowList: i2, lineStyle: n2, id: r2 } = this.json, o2 = ((t2 = n2 == null ? void 0 : n2.fill) === null || t2 === void 0 ? void 0 : t2.fillType) === "solidFill" ? n2.fill.color : null;
      (e2 = i2 || []) === null || e2 === void 0 || e2.forEach((t3, e3) => {
        var i3, s2;
        const a2 = new qv(Object.assign(Object.assign({}, t3), { fillStyle: n2 == null ? void 0 : n2.fill, lineWidth: (i3 = n2 == null ? void 0 : n2.width) !== null && i3 !== void 0 ? i3 : 0 }));
        a2.graphicsId = `${r2}-arrow-${e3}-graphics`, a2.textureId = `${r2}-arrow-${e3}-fill`, this.ctx.graphicsTexture.addGraphics(a2.graphicsId, (s2 = a2.paths) !== null && s2 !== void 0 ? s2 : [], a2.hash, { x: 0, y: 0 }, a2.width, a2.height, void 0, this.ctx.objectPoolGroup, true, o2, null), this.arrowList.push(a2);
      });
    }
    calculateFillObjectOffset() {
      let [t2, e2] = [0, 0];
      return this.arrowList.length && (t2 = this.arrowList.reduce((t3, e3) => Math.max(t3, e3.width), 0), e2 = this.arrowList.reduce((t3, e3) => Math.max(t3, e3.height), 0)), [t2, e2];
    }
    preRender(t2) {
      var e2, i2, n2;
      const { lineStyle: r2, geometry: o2 } = this.json, { width: s2, height: a2 } = (o2 == null ? void 0 : o2.lineTransform) || Kv, l2 = s2 || this.json.width, h2 = a2 || this.json.height, u2 = ((e2 = o2 == null ? void 0 : o2.paths) === null || e2 === void 0 ? void 0 : e2.filter((t3) => t3.fill !== "none" && t3.fill !== "norm")) || [], c2 = ((i2 = r2 == null ? void 0 : r2.fill) === null || i2 === void 0 ? void 0 : i2.fillType) === "solidFill" ? r2.fill.color : null;
      t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
        for (const t3 of u2)
          this.ctx.graphicsTexture.addGraphics(t3.id, [t3], t3.hash, ((o2 == null ? void 0 : o2.lineTransform) || Kv).pivot, l2, h2, r2, this.ctx.objectPoolGroup, true, null, c2);
      }), "@ShapeImpl[addGraphics]"), (n2 = this.text) === null || n2 === void 0 || n2.createParagraphs(this.json.id, t2);
    }
    subClassRender() {
      return Jv(this, void 0, void 0, function* () {
      });
    }
    render(t2) {
      t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
        var t3, e2;
        (t3 = this.strokeGraphics) === null || t3 === void 0 || t3.render(), (e2 = this.backgroundGraphics) === null || e2 === void 0 || e2.render(), this.createBackground(), yield this.subClassRender(), this.createFilledPathMask(), this.createPathFill(), this.createArrow();
      }), "@ShapeImpl[render]"), this.text && this.text.render(t2), t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
        var t3, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2;
        if (((t3 = this.json.textBody) === null || t3 === void 0 ? void 0 : t3.iterateType) === "wd" || ((e2 = this.json.textBody) === null || e2 === void 0 ? void 0 : e2.iterateType) === "lt") {
          if (this.renderContainer.addChild(this.container), this.text) {
            const { x: t4, y: e3 } = (i2 = this.json.scale) !== null && i2 !== void 0 ? i2 : { x: 1, y: 1 };
            this.text.container.scale.x = e3 < 0 ? -Math.abs(t4) : Math.abs(t4), this.text.container.scale.y = e3, this.text.container.position.x = ((r2 = (n2 = this.json.position) === null || n2 === void 0 ? void 0 : n2.x) !== null && r2 !== void 0 ? r2 : 0) + this.text.x, this.text.container.position.y = ((s2 = (o2 = this.json.position) === null || o2 === void 0 ? void 0 : o2.y) !== null && s2 !== void 0 ? s2 : 0) + this.text.y, this.text.container.scale.y < 0 && (this.text.container.position.y += this.text.height), this.text.container.scale.x < 0 && (this.text.container.position.x += this.json.width), this.json.textRotation && (this.text.container.rotation = this.json.textRotation), this.renderContainer.addChild(this.text.container);
          }
        } else {
          if (this.text) {
            if (this.json.textRotation) {
              this.text.container.rotation = this.json.textRotation;
              const { width: t5, height: e4 } = this.text, { x: i4, y: n3 } = this.text.container.position;
              this.text.container.pivot.x = t5 / 2, this.text.container.pivot.y = e4 / 2, this.text.container.x = i4 + t5 / 2, this.text.container.y = n3 + e4 / 2;
            }
            if (cg()(this.json.textRotateWithShape) && !this.json.textRotateWithShape) {
              const t5 = this.json.rotation || 0;
              this.text.container.rotation = -t5;
              const { width: e4 } = this.text;
              this.text.container.position.x = e4;
            }
            this.text.container.zIndex = 100;
            const t4 = (a2 = this.json.effectList) === null || a2 === void 0 ? void 0 : a2.find((t5) => t5.type === "outerShadow"), e3 = (l2 = this.json.effectList) === null || l2 === void 0 ? void 0 : l2.find((t5) => t5.type === "softEdge"), i3 = (h2 = this.json.effectList) === null || h2 === void 0 ? void 0 : h2.find((t5) => t5.type === "glow");
            t4 && t4.sx !== 1 || e3 || i3 ? this.container.addChild(this.text.container) : this.effectContainer.addChild(this.text.container);
          }
          this.renderContainer.addChild(this.container);
        }
        if (this.needCacheAsBitMap, this.json.id === "background" && this.ctx.hasBackgroundFillShape) {
          const t4 = Vh.p.create({ width: this.json.width, height: this.json.height, resolution: Math.ceil(this.ctx.renderer.resolution) });
          this.ctx.renderer.render(this.renderContainer, { renderTexture: t4 }), this.ctx.bgTexture = t4;
        }
        this.json.effectList && this.json.effectList.length > 0 && ((u2 = this.ctx.featureList) === null || u2 === void 0 ? void 0 : u2.effect) && !this.ctx.forceCanvas && !this.json.media && (this.effectObject = new Nv(this.effectContainer, this.json.effectList, `${this.ctx.taskId}_${this.ctx.slideIndex}_${this.json.id}`, this.ctx, this.json.rotation || 0, new Lh.g(((c2 = this.json.scale) === null || c2 === void 0 ? void 0 : c2.x) || 1, ((d2 = this.json.scale) === null || d2 === void 0 ? void 0 : d2.y) || 1)), function(t4) {
          var e3, i3, n3;
          return ((e3 = t4.fillStyle) === null || e3 === void 0 ? void 0 : e3.fillType) === "gifFill" || (((n3 = (i3 = t4.lineStyle) === null || i3 === void 0 ? void 0 : i3.fill) === null || n3 === void 0 ? void 0 : n3.fillType) === "gifFill" || !!t4.picFill && t4.picFill.fillType === "gifFill");
        }(this.json) && this.effectObject.setFrameCount(-1), this.effectObject.on("ready", () => {
          var t4;
          this.effectContainer.visible = false, this.effectObject.container.zIndex = 10, this.container.addChild(this.effectObject.container), (t4 = this.effectObject) === null || t4 === void 0 || t4.updateFrame(1);
        }));
      }), "@ShapeImpl[post.render]");
    }
    clearOnSlideChange() {
    }
    initOnReuse() {
    }
    destroy() {
      var t2, e2, i2, n2;
      (t2 = this.text) === null || t2 === void 0 || t2.destroy(), this.fillColorFilter.destroy(), this.strokeColorFilter.destroy(), this.backgroundFill.destroy(), (e2 = this.backgroundGraphics) === null || e2 === void 0 || e2.destroy(), this.strokeFill.destroy(), (i2 = this.strokeGraphics) === null || i2 === void 0 || i2.destroy(), this.renderContainer.destroy(), (n2 = this.arrowRenderTexture) === null || n2 === void 0 || n2.destroy(true), this.arrowList = [], this.effectDisposer();
    }
  }
  var $v = i(119);
  const t_ = new (i.n($v)).a(), e_ = t_.getDevice(), i_ = t_.getBrowser(), n_ = t_.getOS(), r_ = { isDesktop() {
    let t2 = true;
    return e_.type === "mobile" && (t2 = false), /Samsung/.test(i_.name || "") && (t2 = false), window.__nativeTags && window.__nativeTags.platform && (t2 = false), t2;
  }, isIOS() {
    let t2 = false;
    return window.__nativeTags && window.__nativeTags.platform && /^ios/i.test(window.__nativeTags.platform) && (t2 = true), n_.name && /iOS/.test(n_.name) && (t2 = true), t2;
  }, isAndroid() {
    let t2 = false;
    return window.__nativeTags && window.__nativeTags.platform && /^android/i.test(window.__nativeTags.platform) && (t2 = true), n_.name && /android/i.test(n_.name) && (t2 = true), t2;
  }, isLowGpuMemory() {
    var t2, e2;
    const i2 = (e2 = (t2 = window.__nativeTags) === null || t2 === void 0 ? void 0 : t2.platform) !== null && e2 !== void 0 ? e2 : "";
    if (i2) {
      const t3 = i2.split(" ");
      if (t3[1]) {
        if (/^iPad/.test(t3[1])) {
          const e3 = t3[1].match(/^iPad(\d+)/);
          return !(e3 && e3[1] && parseInt(e3[1], 10) >= 6);
        }
        if (/^iPhone/.test(t3[1])) {
          const e3 = t3[1].match(/^iPhone(\d+)/);
          return !(e3 && e3[1] && parseInt(e3[1], 10) >= 9);
        }
        return false;
      }
      return false;
    }
    return true;
  } };
  var o_ = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  function s_(t2, e2) {
    for (const i2 in e2)
      t2.style[i2] = e2[i2];
  }
  const a_ = { medianContainerClass: "median-container", hoverHiddeDelay: 1500, portalWidth: 300, portalHeight: 50, hiddenOpacity: "0", hoverOpacity: "1", opacityAnimationTime: 0.4 };
  class l_ {
    constructor(t2) {
      var e2, i2;
      this.progress = document.createElement("div"), this.totalTime = document.createElement("span"), this.playButton = document.createElement("div"), this.pauseButton = document.createElement("div"), this.currentTime = document.createElement("span"), this.mediaController = document.createElement("div"), this.currentProgress = document.createElement("div"), this.fullScreenButton = document.createElement("div"), this.exitFullScreenButton = document.createElement("div"), this.medianIsEnd = false, this.pickBookmarkIndex = 0, this.playCallBackList = [], this.duration = 0, this.isVideo = false, this.start = 0, this.end = 0, this.fullscreenStatus = false, this.fadeState = { in: false, out: false }, this.changeMediaProgress = (t3) => {
        if (this.ctx.isPlayerPaused())
          return void this.ctx.logger.info("Media controller prevent seek event with paused state", this.ctx.taskId);
        t3.stopPropagation();
        const e3 = t3.offsetX / this.progress.clientWidth * this.duration;
        this.medianIsEnd = false, this.ctx.mode !== "interactive" && this.jumpToTime(e3), this.ctx.mode !== "local" && this.ctx.eventHub.emit(zy.mediaSeek, { id: this.targetId, time: e3, isPlaying: this.media.isPlaying }), this.delayHide();
      }, this.jumpToTime = (t3 = 0) => o_(this, void 0, void 0, function* () {
        yield Pm(() => !!this.duration, 3e3);
        const e3 = Math.floor(t3) + this.start;
        this.media.currentTime !== e3 && (this.media.currentTime = e3, this.changeBookmarkIndex(e3, e3 > this.media.currentTime));
      }), this.showController = (t3) => {
        t3.stopPropagation(), this.show();
      }, this.getMediaDuration = () => {
        this.duration && !Number.isNaN(this.duration) || (this.duration = this.media.duration, this.start && (this.duration -= this.start, this.jumpToTime()), this.end && (this.duration -= this.end)), this.totalTime.innerText = l_.formatTime(this.duration);
      }, this.playMedia = () => o_(this, void 0, void 0, function* () {
        this.playButton.style.display = "none", this.pauseButton.style.display = "block", yield this.media.play(), this.medianIsEnd && (this.medianIsEnd = false, this.jumpToTime()), this.playCallBackList.forEach((t3) => {
          t3();
        }), this.delayHide();
      }), this.pauseMedia = () => o_(this, void 0, void 0, function* () {
        this.playButton.style.display = "block", this.pauseButton.style.display = "none", yield this.media.pause();
      }), this.onMouseOut = (t3) => {
        t3.stopPropagation(), this.hide();
      }, this.mediaTimeUpdate = () => o_(this, void 0, void 0, function* () {
        const t3 = this.media.currentTime - this.start;
        if (this.duration > 0 && (Math.abs(t3 - this.duration) < 0.3 || t3 > this.duration) && (yield this.pauseMedia(), this.medianIsEnd = true, this.jumpToTime(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.targetId }), this.onClickCancelFullScreenButtonHandle()), this.currentTime.innerText = l_.formatTime(t3), this.currentProgress.style.flex = (t3 / this.duration).toString(), this.bookmarkList && this.bookmarkList.length > 0) {
          const t4 = this.bookmarkList[this.pickBookmarkIndex];
          t4 && t4.time.toFixed(0) === this.media.currentTime.toFixed(0) && (this.ctx.timingEventHub.emit(`shape ${this.shapeId} onMediaBookmark ${t4.name}`), this.pickBookmarkIndex += 1);
        }
        this.fadeHit(t3);
      }), this.onPauseMedia = () => {
        this.playButton.style.display = "block", this.pauseButton.style.display = "none";
      }, this.onPlayMedia = () => {
        this.fadeState = { in: false, out: false }, this.fadeHit(0), this.playButton.style.display = "none", this.pauseButton.style.display = "block", this.playCallBackList.forEach((t3) => {
          t3();
        }), this.media.currentTime < this.start && this.jumpToTime();
      }, this._playMediaFromCtrl = () => {
        this.playMediaFromCtrl(false);
      }, this._pauseMediaFromCtrl = () => {
        this.pauseMediaFromCtrl(false), this.delayHide();
      }, this.onClickFullScreenButtonHandle = () => {
        this.fullscreenPlay();
      }, this.onClickCancelFullScreenButtonHandle = () => {
        this.fullscreenStatus = false, this.media.requestCancelFullscreen(), this.ctx.eventHub.emit(zy.fullscreenChange, { targetId: this.targetId, state: false }), this.delayHide();
      }, this.onFullScreenChange = (t3) => {
        const { status: e3, targetId: i3, slideIndex: n2 } = t3;
        this.changeFullScreenState(e3, i3, n2), this.delayHide();
      }, this.onContainerSizeChange = () => {
        this.setControllerPosition();
      }, this.onControllerShowStatusChange = ({ slideIndex: t3, targetId: e3, status: i3 }) => {
        if (t3 === this.ctx.slideIndex) {
          if (this.targetId === e3) {
            const { hiddenOpacity: t4, hoverOpacity: e4 } = a_;
            i3 ? (this.mediaController.style.opacity = e4, this.mediaController.style.display = "flex") : this.mediaController.style.opacity = t4;
          }
          this.delayHide();
        }
      }, this.targetId = t2.targetId, this.ctx = t2.ctx, this.height = t2.height, this.width = t2.width, this.target = t2.target, this.media = t2.media, this.info = t2.info, this.shapeId = t2.shapeId, this.canvasElement = t2.canvasElement, this.media.type === "video" && (this.isVideo = true), this.getMedianContainer(), this.createMediaController(), this.info.cut && (this.start = (e2 = this.info.cut.start) !== null && e2 !== void 0 ? e2 : 0, this.end = (i2 = this.info.cut.end) !== null && i2 !== void 0 ? i2 : 0), this.info.bookmarkList && (this.bookmarkList = this.info.bookmarkList.sort((t3, e3) => t3.time - e3.time));
    }
    get clippedDuration() {
      return this.duration;
    }
    getMedianContainer() {
      var t2;
      const { medianContainerClass: e2 } = a_;
      let i2 = (t2 = this.canvasElement.parentElement) === null || t2 === void 0 ? void 0 : t2.querySelector("." + e2);
      i2 || (i2 = document.createElement("div"), i2.className = e2, this.canvasElement.parentElement.appendChild(i2)), this.container = i2;
    }
    static formatTime(t2) {
      let e2 = "00:00";
      if (t2) {
        const i2 = Math.floor(t2 / 60), n2 = String(i2 < 0 ? 0 : i2).padStart(2, "0"), r2 = Math.floor(t2 % 60);
        e2 = `${n2}:${String(r2 < 0 ? 0 : r2).padStart(2, "0")}`;
      }
      return e2;
    }
    generatePlayButton(t2 = 20, e2 = 20) {
      const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      i2.setAttributeNS(null, "viewBox", "0 0 512 512"), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "width", e2.toString());
      const n2 = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      return n2.setAttributeNS(null, "points", "35 0, 477 256, 35 512"), n2.setAttributeNS(null, "fill", "#000000"), i2.appendChild(n2), i2;
    }
    generatePauseButton(t2 = 20, e2 = 20) {
      const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      s_(i2, { height: t2 + "px" }), i2.setAttributeNS(null, "viewBox", "0 0 512 512"), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "width", e2.toString());
      const n2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      n2.setAttributeNS(null, "x", "35"), n2.setAttributeNS(null, "y", "0"), n2.setAttributeNS(null, "width", "148"), n2.setAttributeNS(null, "height", "512");
      const r2 = n2.cloneNode(true);
      return r2.setAttributeNS(null, "x", "330"), i2.append(n2, r2), i2;
    }
    generateFullScreenButton(t2 = 20, e2 = 20) {
      const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      s_(i2, { height: t2 + "px", width: e2 + "px" }), i2.setAttributeNS(null, "width", e2.toString()), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "viewBox", "0 0 1024 1024");
      const n2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
      return n2.setAttributeNS(null, "d", "M918.116352 107.409408c10.186752 10.175488 10.186752 26.691584 0 36.87936L653.734912 407.038976c-10.187776 10.187776-26.703872 10.187776-36.891648 0-10.175488-10.187776-10.175488-26.703872 0.013312-36.891648l264.38144-262.73792c10.174464-10.187776 26.69056-10.200064 36.87936-0.013312L918.117376 107.409408zM878.281728 148.096l-161.155072-0.44544c-11.283456 0.279552-20.85888-8.226816-21.90336-19.458048l0-13.421568c0.318464-10.671104 8.889344-19.241984 19.560448-19.560448l187.030528 0.827392c0.1792-0.037888 0.357376-0.0768 0.523264-0.089088l9.549824-0.229376c5.005312-0.152576 9.843712 1.770496 13.372416 5.336064 3.32288 3.629056 4.9664 8.49408 4.545536 13.40928l-1.032192 9.537536c0 0.191488 0.70144 0.318464 0.70144 0.49664l-0.534528 188.279808c-0.54784 9.984-9.092096 17.637376-19.076096 17.089536-0.165888-0.012288-0.319488-0.0256-0.484352-0.037888L896.009216 329.8304c-10.379264-0.0512-18.733056-8.506368-18.681856-18.885632 0.013312-0.191488 0.013312-0.381952 0.013312-0.585728L878.281728 148.096zM105.884672 916.661248c-10.187776-10.175488-10.200064-26.691584-0.013312-36.87936 0 0 0-0.013312 0.013312-0.013312l265.19552-262.73792c10.35264-10.008576 26.86976-9.729024 36.866048 0.636928 9.766912 10.110976 9.766912 26.131456 0 36.242432L143.579136 916.661248C133.072896 926.848 116.3776 926.848 105.884672 916.661248L105.884672 916.661248zM146.533376 875.973632l161.154048 0.433152c11.283456-0.292864 20.85888 8.213504 21.891072 19.458048l0 13.38368c-0.292864 10.672128-8.876032 19.255296-19.560448 19.561472l-187.858944-0.828416c-0.165888 0.037888-0.344064 0.075776-0.509952 0.089088l-9.550848 0.229376c-5.004288 0.152576-9.831424-1.782784-13.35808-5.336064-3.323904-3.629056-4.979712-8.493056-4.54656-13.395968l1.031168-9.537536c0-0.191488-0.712704-0.330752-0.700416-0.509952l0.534528-188.278784c0.534528-9.984 9.066496-17.625088 19.050496-17.089536 0.165888 0.013312 0.330752 0.0256 0.508928 0.037888l14.212096 0c10.365952 0.0512 18.719744 8.507392 18.656256 18.873344 0 0.191488 0 0.395264-0.013312 0.598016L146.533376 875.973632zM918.116352 916.661248c10.186752-10.175488 10.200064-26.691584 0.012288-36.87936 0 0 0-0.013312-0.012288-0.013312l-264.38144-262.73792c-10.365952-10.008576-26.86976-9.729024-36.87936 0.636928-9.766912 10.110976-9.766912 26.131456 0 36.242432L881.22368 916.661248c10.186752 10.186752 26.703872 10.186752 36.891648 0.013312L918.115328 916.661248 918.116352 916.661248zM878.281728 875.973632l-161.168384 0.433152c-11.270144-0.292864-20.845568 8.213504-21.890048 19.458048l0 13.38368c0.306176 10.672128 8.889344 19.241984 19.560448 19.561472l187.030528-0.828416c0.1792 0.037888 0.357376 0.075776 0.523264 0.089088l9.549824 0.229376c5.005312 0.152576 9.843712-1.782784 13.372416-5.336064 3.32288-3.629056 4.978688-8.493056 4.545536-13.395968l-1.032192-9.537536c0-0.191488 0.70144-0.330752 0.70144-0.509952l-0.534528-188.278784c-0.54784-9.984-9.092096-17.637376-19.076096-17.089536-0.165888 0.013312-0.319488 0.0256-0.484352 0.037888L896.009216 694.19008c-10.379264 0.0512-18.733056 8.507392-18.681856 18.885632 0 0.191488 0.013312 0.381952 0.013312 0.584704L878.281728 875.973632zM105.884672 107.409408c-10.187776 10.175488-10.187776 26.691584 0 36.87936l265.19552 262.750208c10.187776 10.187776 26.691584 10.187776 36.87936 0s10.175488-26.703872-0.012288-36.891648l-264.368128-262.73792C133.072896 97.222656 116.3776 97.222656 105.884672 107.409408L105.884672 107.409408zM146.533376 148.096l161.154048-0.44544c11.283456 0.292864 20.85888-8.213504 21.891072-19.458048l0-13.421568c-0.306176-10.671104-8.889344-19.241984-19.560448-19.560448l-187.858944 0.827392c-0.165888-0.0512-0.344064-0.0768-0.509952-0.089088l-9.550848-0.229376c-5.004288-0.152576-9.831424 1.782784-13.35808 5.336064-3.323904 3.629056-4.979712 8.49408-4.54656 13.40928l1.031168 9.537536c0 0.191488-0.712704 0.318464-0.700416 0.49664l0.534528 188.279808c0.534528 9.970688 9.066496 17.624064 19.050496 17.089536 0.165888-0.012288 0.330752-0.0256 0.508928-0.037888l14.212096 0c10.365952-0.0512 18.719744-8.506368 18.656256-18.87232 0-0.191488 0-0.395264-0.013312-0.598016L146.533376 148.096z"), i2.appendChild(n2), document.body.appendChild(i2), i2;
    }
    generateExitFullScreenButton(t2 = 20, e2 = 20) {
      const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      s_(i2, { height: t2 + "px", width: e2 + "px" }), i2.setAttributeNS(null, "width", e2.toString()), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "viewBox", "0 0 1024 1024");
      const n2 = document.createElementNS("http://www.w3.org/2000/svg", "path"), r2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
      return n2.setAttributeNS(null, "d", "M716.8 998.4a25.6 25.6 0 0 1-25.6-25.6v-256a25.6 25.6 0 0 1 25.6-25.6h256a25.6 25.6 0 1 1 0 51.2h-230.4v230.4a25.6 25.6 0 0 1-25.6 25.6zM307.2 998.4a25.6 25.6 0 0 1-25.6-25.6v-230.4H51.2a25.6 25.6 0 1 1 0-51.2h256a25.6 25.6 0 0 1 25.6 25.6v256a25.6 25.6 0 0 1-25.6 25.6zM972.8 332.8h-256a25.6 25.6 0 0 1-25.6-25.6v-256a25.6 25.6 0 1 1 51.2 0v230.4h230.4a25.6 25.6 0 1 1 0 51.2zM307.2 332.8h-256a25.6 25.6 0 1 1 0-51.2h230.4V51.2a25.6 25.6 0 1 1 51.2 0v256a25.6 25.6 0 0 1-25.6 25.6z"), r2.setAttributeNS(null, "d", "M307.2 332.8a25.6 25.6 0 0 1-18.112-7.488L56.896 93.12a25.6 25.6 0 0 1 36.224-36.224l232.192 232.192A25.6 25.6 0 0 1 307.2 332.8zM716.8 332.8a25.6 25.6 0 0 1-18.112-43.712L930.88 56.896a25.6 25.6 0 0 1 36.224 36.224l-232.192 232.192a25.472 25.472 0 0 1-18.112 7.488zM948.992 974.592a25.6 25.6 0 0 1-18.112-7.488l-232.192-232.192a25.6 25.6 0 0 1 36.224-36.224l232.192 232.192a25.6 25.6 0 0 1-18.112 43.712zM75.008 974.592a25.6 25.6 0 0 1-18.112-43.712l232.192-232.192a25.6 25.6 0 0 1 36.224 36.224l-232.192 232.192a25.472 25.472 0 0 1-18.112 7.488z"), i2.appendChild(n2), i2.appendChild(r2), document.body.appendChild(i2), i2;
    }
    createButton() {
      const t2 = { marginLeft: "15px", marginRight: "10px", fontSize: "0", height: "20px", display: "flex", justifyContent: "center", alignItems: "center" };
      s_(this.playButton, Object.assign(Object.assign({}, t2), { display: "block" }));
      const e2 = this.generatePlayButton();
      s_(e2, { height: "20px" }), this.playButton.appendChild(e2), s_(this.pauseButton, Object.assign(Object.assign({}, t2), { display: "none" }));
      const i2 = this.generatePauseButton();
      if (s_(i2, { height: "20px" }), this.pauseButton.appendChild(i2), !this.isVideo)
        return;
      const n2 = this.generateFullScreenButton(20, 20);
      this.fullScreenButton.appendChild(n2), s_(this.fullScreenButton, Object.assign(Object.assign({}, t2), { display: "block" }));
      const r2 = this.generateExitFullScreenButton(20, 20);
      this.exitFullScreenButton.appendChild(r2), s_(this.exitFullScreenButton, Object.assign(Object.assign({}, t2), { display: "none" }));
    }
    createTimer() {
      const t2 = document.createElement("div");
      s_(t2, { width: "100px" }), this.currentTime.innerText = "00:00";
      const e2 = document.createElement("span");
      return e2.innerText = "/", t2.append(this.currentTime, e2, this.totalTime), t2;
    }
    createProgress() {
      const t2 = { flex: "1", position: "relative" };
      this.isVideo || (t2.marginRight = "10px"), s_(this.progress, t2);
      const e2 = document.createElement("div");
      s_(e2, { background: "#D9D9D9", position: "relative", height: "10px", display: "flex" }), this.progress.appendChild(e2), s_(this.currentProgress, { background: "#4F4F4F", top: "0px", left: "0", height: "10px", flex: "0" }), e2.appendChild(this.currentProgress);
    }
    fadeHit(t2) {
      if (!this.info.fade)
        return;
      const { start: e2, end: i2 } = this.info.fade;
      e2 && !this.fadeState.in && t2 >= 0 && (this.fadeState.in = true, this.media.fadeIn(0, e2)), i2 && !this.fadeState.out && t2 >= this.duration - i2 / 1e3 && (this.fadeState.out = true, this.media.fadeOut(0, i2));
    }
    changeBookmarkIndex(t2, e2) {
      if (this.bookmarkList && this.bookmarkList.length !== 0) {
        if (this.pickBookmarkIndex > 0) {
          for (let e3 = 0; e3 < this.pickBookmarkIndex; e3++)
            if (this.bookmarkList[e3].time > t2) {
              this.pickBookmarkIndex = e3;
              break;
            }
        }
        if (e2) {
          let e3 = this.pickBookmarkIndex - 1;
          for (let i2 = 0; i2 < this.bookmarkList.length; i2++)
            this.bookmarkList[i2].time < t2 && (e3 = i2);
          for (let t3 = this.pickBookmarkIndex; t3 <= e3; t3++) {
            const e4 = this.bookmarkList[t3];
            e4 && this.ctx.timingEventHub.emit(`shape ${this.shapeId} onMediaBookmark ${e4.name}`);
          }
          this.pickBookmarkIndex = e3 + 1;
        }
      }
    }
    playMediaFromCtrl(t2) {
      this.ctx.isPlayerPaused() ? this.ctx.logger.info("Media controller prevent play event with paused state", this.ctx.taskId) : (this.ctx.mode !== "interactive" && this.playMedia(), this.ctx.mode !== "local" && this.ctx.eventHub.emit(zy.mediaPlay, { id: this.targetId, time: this.media.currentTime - this.start, _stateOnly: t2 }));
    }
    pauseMediaFromCtrl(t2) {
      this.ctx.isPlayerPaused() ? this.ctx.logger.info("Media controller prevent pause event with paused state", this.ctx.taskId) : (this.ctx.mode !== "interactive" && this.pauseMedia(), this.ctx.mode === "local" || this.ctx.isRendering || this.ctx.eventHub.emit(zy.mediaPause, { id: this.targetId, time: this.media.currentTime - this.start, _stateOnly: t2 }));
    }
    setControllerPosition() {
      var t2;
      const { target: e2 } = this, { portalWidth: i2, portalHeight: n2 } = a_, { stageWidth: r2, stageHeight: o2 } = this.ctx, s2 = e2.getGlobalPosition(), a2 = Number((t2 = this.container) === null || t2 === void 0 ? void 0 : t2.getAttribute("data-scale")), l2 = r2 * a2, h2 = 1 / a2 * (i2 > l2 ? l2 / i2 : 1);
      s2.y = s2.y + this.height - n2, s2.x = Math.max(s2.x, 0), s2.x = Math.min(s2.x, r2 - i2 * h2), s2.y = Math.max(s2.y, 0), s2.y = Math.min(s2.y, o2 - n2), s_(this.mediaController, { height: n2 + "px", borderRadius: n2 / 2 + "px", width: i2 + "px", flexDirection: "row", alignItems: "center", position: "absolute", left: s2.x + "px", top: s2.y + "px", background: "#fff", zIndex: "2", border: "1px solid #ccc", transform: `scale(${h2})`, transformOrigin: "0 100%" }), this.fullscreenStatus && s_(this.mediaController, { left: "0", top: o2 - n2 + "px" });
    }
    createMediaController() {
      this.setControllerPosition(), s_(this.mediaController, { display: "none", transition: `opacity ${a_.opacityAnimationTime}s` }), this.createButton();
      const t2 = this.createTimer();
      this.createProgress(), this.mediaController.append(this.playButton, this.pauseButton, t2, this.progress), this.isVideo && this.mediaController.append(this.fullScreenButton, this.exitFullScreenButton), this.container.appendChild(this.mediaController), this.bindEvent();
    }
    addPlayCallBack(t2) {
      this.playCallBackList.push(t2);
    }
    fullscreenPlay() {
      this.fullscreenStatus = true, this.ctx.mode !== "interactive" && this.media.requestFullscreen(), this.ctx.mode !== "local" && this.ctx.eventHub.emit(zy.fullscreenChange, { targetId: this.targetId, state: true }), this.delayHide();
    }
    changeFullScreenState(t2, e2, i2) {
      i2 === this.ctx.slideIndex && (t2 && this.targetId === e2 ? this.fullscreenStatus = t2 : this.fullscreenStatus = false, this.fullscreenStatus ? (this.fullScreenButton.style.display = "none", this.exitFullScreenButton.style.display = "block") : (this.fullScreenButton.style.display = "block", this.exitFullScreenButton.style.display = "none"), this.setControllerPosition());
    }
    bindEvent() {
      r_.isDesktop() && (this.mediaController.addEventListener("mouseout", this.onMouseOut, false), this.mediaController.addEventListener("mouseover", this.showController, false)), this.progress.addEventListener("click", this.changeMediaProgress, false), this.playButton.addEventListener("click", this._playMediaFromCtrl, false), this.pauseButton.addEventListener("click", this._pauseMediaFromCtrl, false), this.media.on("durationchange", this.getMediaDuration, false), this.media.on("timeupdate", this.mediaTimeUpdate, false), this.media.on("pause", this.onPauseMedia, false), this.media.on("play", this.onPlayMedia, false), this.containerObserver = new MutationObserver(this.onContainerSizeChange), this.container && this.containerObserver.observe(this.container, { attributes: true, attributeFilter: ["data-scale", "style"] }), this.isVideo && (this.ctx.globalEventHub.on("onFullscreenChange", this.onFullScreenChange), this.ctx.globalEventHub.on("controllerShowStatusChange", this.onControllerShowStatusChange), this.fullScreenButton.addEventListener("click", this.onClickFullScreenButtonHandle, false), this.exitFullScreenButton.addEventListener("click", this.onClickCancelFullScreenButtonHandle, false));
    }
    unbindEvent() {
      var t2;
      r_.isDesktop() && (this.mediaController.removeEventListener("mouseout", this.onMouseOut, false), this.mediaController.removeEventListener("mouseover", this.showController, false)), this.progress.removeEventListener("click", this.changeMediaProgress, false), this.playButton.removeEventListener("click", this._playMediaFromCtrl, false), this.pauseButton.removeEventListener("click", this._pauseMediaFromCtrl, false), this.media.removeAllListeners(), (t2 = this.containerObserver) === null || t2 === void 0 || t2.disconnect(), this.isVideo && (this.ctx.globalEventHub.removeListener("onFullscreenChange", this.onFullScreenChange), this.ctx.globalEventHub.removeListener("controllerShowStatusChange", this.onControllerShowStatusChange), this.fullScreenButton.removeEventListener("click", this.onClickFullScreenButtonHandle, false), this.exitFullScreenButton.removeEventListener("click", this.onClickCancelFullScreenButtonHandle, false));
    }
    show() {
      this.setControllerPosition(), this.mediaController.style.opacity = a_.hoverOpacity, this.fullscreenStatus || (this.mediaController.style.display = "flex"), this.delayHide();
    }
    hide() {
      this.fullscreenStatus ? this.mediaController.style.opacity = a_.hiddenOpacity : this.mediaController.style.display = "none";
    }
    delayHide() {
      clearTimeout(this.autoHiddenTimer), this.autoHiddenTimer = setTimeout(() => {
        this.hide();
      }, a_.hoverHiddeDelay);
    }
    destroy() {
      var t2;
      this.unbindEvent(), this.playCallBackList = [], (t2 = this.container) === null || t2 === void 0 || t2.removeChild(this.mediaController);
    }
  }
  var h_ = i(120);
  class u_ extends Za.a {
    constructor(t2, e2, i2) {
      var n2, r2;
      super(), this.isGlobalPause = false, this.lastTime = -1, this.howl = null, this.rctClient = null, this.isHowlEnd = false, this.isHowlLoadEmit = false, this.staticEventId = 1001, this._catParams = void 0, this.url = t2, this.runningAudio = e2, i2 && (this._catParams = i2), Vy.RtcAudioClazz ? (this.rctClient = new Vy.RtcAudioClazz(t2, (n2 = this._catParams) === null || n2 === void 0 ? void 0 : n2.start, (r2 = this._catParams) === null || r2 === void 0 ? void 0 : r2.end), this.rctClient.on("load", () => this.emit("load")), this.rctClient.on("pause", () => this.emit("pause")), this.rctClient.on("play", () => {
        this.startTimeChangeEmit(), this.emit("play");
      }), this.rctClient.on("resumeAllAudioInterruptByAudioSessionChanged", () => {
        this.emit("resumeAllAudioInterruptByAudioSessionChanged");
      })) : (this.howl = new h_.Howl({ src: [t2] }), [this.staticEventId] = this.howl._getSoundIds(), this.howl.load(), this.howl.on("load", () => {
        this.isHowlLoadEmit = true, this.emit("load");
      }), this.howl.on("pause", () => this.emit("pause")), this.howl.on("play", () => {
        this.isHowlLoadEmit || this.emit("load"), this.isHowlEnd = false, this.startTimeChangeEmit(), this.emit("play");
      }), this.howl.on("end", () => {
        this.isHowlEnd = true;
      }));
    }
    startTimeChangeEmit() {
      this.currentTime !== this.lastTime && (this.lastTime = this.currentTime, this.emit("timeupdate", this.lastTime)), this.isPaused || setTimeout(() => {
        this.isPaused || this.startTimeChangeEmit();
      }, 300);
    }
    play() {
      var t2, e2, i2;
      this.runningAudio.has(this.url) && ((t2 = this.runningAudio.get(this.url)) === null || t2 === void 0 || t2.stop(), this.runningAudio.delete(this.url)), this.isHowlEnd = false, this.lastTime = -1, (e2 = this.howl) === null || e2 === void 0 || e2.play(this.staticEventId), (i2 = this.rctClient) === null || i2 === void 0 || i2.play(), this.runningAudio.set(this.url, this);
    }
    fade(t2, e2, i2) {
      this.howl && this.howl.fade(t2, e2, i2);
    }
    pause() {
      var t2, e2;
      (t2 = this.howl) === null || t2 === void 0 || t2.pause(this.staticEventId), (e2 = this.rctClient) === null || e2 === void 0 || e2.pause(), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
    }
    globalPause() {
      this.isPaused || (this.isGlobalPause = true, this.pause());
    }
    globalResume() {
      this.isGlobalPause && (this.isGlobalPause = false, this.play());
    }
    stop() {
      var t2;
      (t2 = this.howl) === null || t2 === void 0 || t2.pause(this.staticEventId), this.rctClient && (this.rctClient.pause(), this.rctClient.currentTime = 0), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
    }
    destroy() {
      var t2, e2, i2, n2, r2, o2, s2, a2;
      (t2 = this.howl) === null || t2 === void 0 || t2.stop(this.staticEventId), (e2 = this.howl) === null || e2 === void 0 || e2.unload(), (i2 = this.rctClient) === null || i2 === void 0 || i2.pause(), (n2 = this.rctClient) === null || n2 === void 0 || n2.destroy(), (r2 = this.rctClient) === null || r2 === void 0 || r2.removeAllListeners("load"), (o2 = this.rctClient) === null || o2 === void 0 || o2.removeAllListeners("play"), (s2 = this.rctClient) === null || s2 === void 0 || s2.removeAllListeners("pause"), (a2 = this.rctClient) === null || a2 === void 0 || a2.removeAllListeners("resumeAllAudioInterruptByAudioSessionChanged"), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
    }
    get currentTime() {
      return this.rctClient ? this.rctClient.currentTime : this.howl ? this.howl.seek(this.staticEventId) : -1;
    }
    set currentTime(t2) {
      this.rctClient ? this.rctClient.currentTime = t2 : this.howl && this.howl.seek(t2, this.staticEventId);
    }
    get duration() {
      return this.rctClient ? this.rctClient.duration : this.howl ? this.howl.duration(this.staticEventId) : 0;
    }
    get isPaused() {
      return this.rctClient ? this.rctClient.isPaused : !!this.howl && !this.howl.playing(this.staticEventId);
    }
    volume(t2) {
      this.rctClient ? this.rctClient.volume(t2) : this.howl && this.howl.volume(t2);
    }
  }
  var c_ = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class d_ extends Za.a {
    constructor(t2) {
      var e2, i2, n2, r2, o2, s2, a2;
      super(), this.type = "video", this.sprite = new ep(), this.isPlaying = false, this.isGlobalPause = false, this.fullscreen = false, this.url = "", this.isLoaded = false, this.onVideoResourceLoaded = () => {
        this.isLoaded = true;
      }, this.onVideoStalled = () => {
        this.ctx.logger.warn(this.url + ", Failed to fetch data, but trying.", this.ctx.taskId);
      }, this.updateVolume = (t3) => {
        this.rtcAudio.volume(t3);
      }, this.syncFullscreenVideoState = (t3) => {
        const { targetId: e3, state: i3, slideIndex: n3 } = t3;
        n3 === this.ctx.slideIndex && e3 === this.id && (i3 ? (this.requestFullscreen(), this.ctx.latestChangeFullscreenTargetId = e3) : this.requestCancelFullscreen());
      }, this.id = t2.id, this.start = (e2 = t2.video.cut) === null || e2 === void 0 ? void 0 : e2.start, this.end = (i2 = t2.video.cut) === null || i2 === void 0 ? void 0 : i2.end, this.fullscreen = (n2 = t2.video.fullscreen) !== null && n2 !== void 0 && n2, this.container = t2.container, this.ctx = t2.ctx, this.ctx.medias[this.id] = this;
      const l2 = t2.video.src;
      this.videoResource = new Vh.w(l2, { autoLoad: true, autoPlay: false, updateFPS: 30, crossorigin: true }), (r2 = this.videoElement) === null || r2 === void 0 || r2.addEventListener("stalled", this.onVideoStalled), (o2 = this.videoElement) === null || o2 === void 0 || o2.addEventListener("loadedmetadata", this.onVideoResourceLoaded), this.url = t2.video.src;
      let h2 = t2.video.src.replace(/4$/, "3");
      this.ctx.loaderDelegate && (h2 = this.ctx.loaderDelegate.redirectMedia(h2), this.ctx.logger.info(`redirect media url from ${t2.video.src.replace(/4$/, "3")} to ${h2} by delegate.`, t2.ctx.taskId)), this.rtcAudio = new u_(h2, t2.ctx.runningAudio, { start: (s2 = t2.video.cut) === null || s2 === void 0 ? void 0 : s2.start, end: (a2 = t2.video.cut) === null || a2 === void 0 ? void 0 : a2.end }), this.rtcAudio.on("timeupdate", (t3) => {
        if (this.videoElement) {
          const e3 = this.videoElement.currentTime;
          Math.abs(e3 - t3) > 0.5 && (this.videoElement.currentTime = t3);
        }
      }), this.rtcAudio.on("resumeAllAudioInterruptByAudioSessionChanged", () => {
        var t3;
        (t3 = this.videoElement) === null || t3 === void 0 || t3.pause(), setTimeout(() => {
          var t4;
          this.rtcAudio.isPaused || (t4 = this.videoElement) === null || t4 === void 0 || t4.play();
        }, 200);
      });
      const { video: u2, width: c2, height: d2, target: p2 } = t2;
      this.controller = new l_({ targetId: t2.id, shapeId: t2.shapeId, ctx: t2.ctx, width: c2, height: d2, target: p2, media: this, info: u2, canvasElement: t2.canvasElement }), this.controller.addPlayCallBack(() => {
        this.sprite.width = c2, this.sprite.height = d2, this.ctx.clock.setTimeout(() => {
          this.sprite.visible = true;
        }, 50);
      });
      const f2 = new Vh.c(null, { height: d2, width: c2 });
      f2.resource = this.videoResource, this.videoResource.bind(f2), this.sprite = new ep(), this.sprite.visible = false, this.sprite.texture = new Vh.t(f2), this.sprite.interactive = true, this.container.addChild(this.sprite), this.sprite.on("mouseover", (t3) => {
        t3.stopPropagation(), this.controller.show();
      }), this.sprite.on("mouseout", (t3) => {
        t3.stopPropagation(), this.controller.hide();
      }), ["durationchange", "timeupdate", "pause", "play"].forEach((t3) => {
        var e3;
        (e3 = this.videoElement) === null || e3 === void 0 || e3.addEventListener(t3, () => {
          t3 === "timeupdate" && this.isPlaying, this.emit(t3);
        });
      }), this.ctx.activeMedia.add(this), this.ctx.volumeAdjuster.on("update", this.updateVolume), this.ctx.globalEventHub.on("syncFullscreenVideoState", this.syncFullscreenVideoState);
    }
    get videoElement() {
      return this.videoResource.source;
    }
    get currentTime() {
      var t2, e2;
      return (e2 = (t2 = this.videoElement) === null || t2 === void 0 ? void 0 : t2.currentTime) !== null && e2 !== void 0 ? e2 : 0;
    }
    set currentTime(t2) {
      this.rtcAudio.currentTime = t2, this.videoElement && (this.videoElement.currentTime = t2);
    }
    get paused() {
      var t2, e2;
      return (e2 = (t2 = this.videoElement) === null || t2 === void 0 ? void 0 : t2.paused) === null || e2 === void 0 || e2;
    }
    get duration() {
      var t2, e2;
      return (e2 = (t2 = this.videoElement) === null || t2 === void 0 ? void 0 : t2.duration) !== null && e2 !== void 0 ? e2 : 0;
    }
    get clippedDuration() {
      return this.controller.clippedDuration;
    }
    showController() {
      this.controller.show();
    }
    hideController() {
      this.controller.hide();
    }
    play() {
      return c_(this, void 0, void 0, function* () {
        this.isPlaying = true, this.updateVolume(this.ctx.volumeAdjuster.volume), yield this.load(), yield this.ctx.clock.waitUntil(() => {
          const t3 = this.videoElement;
          return !!(t3 && t3.videoWidth > 0);
        }, 3e3);
        const t2 = this.videoElement;
        t2 && t2.videoWidth <= 0 || (this.videoElement && (this.videoElement.volume = 0, this.videoElement.muted = true), this.rtcAudio.on("play", () => {
          var t3;
          (t3 = this.videoElement) === null || t3 === void 0 || t3.play(), this.fullscreen && this.controller.fullscreenPlay();
        }), this.rtcAudio.play());
      });
    }
    load() {
      return this.videoResource.load();
    }
    pause() {
      this.isPlaying = false, this.ctx.logger.warn(this.url + ", pause video manual.", this.ctx.taskId), this.ctx.logger.warn(this.url + ", pause rtc audio manual.", this.ctx.taskId), this.rtcAudio.on("pause", () => {
        var t2;
        (t2 = this.videoElement) === null || t2 === void 0 || t2.pause();
      }), this.rtcAudio.pause();
    }
    globalPause() {
      this.isPlaying && (this.isGlobalPause = true, this.pause());
    }
    globalResume() {
      this.isGlobalPause && (this.isGlobalPause = false, this.play());
    }
    togglePause() {
      this.isPlaying ? this.pause() : this.play();
    }
    seek(t2) {
      this.controller.jumpToTime(t2);
    }
    stop() {
      this.rtcAudio.stop(), this.seek(0), this.pause(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.id });
    }
    requestFullscreen() {
      return c_(this, void 0, void 0, function* () {
        yield Pm(() => this.isLoaded, 5e3);
        const t2 = new Vh.t(this.sprite.texture.baseTexture);
        this.ctx.globalEventHub.emit("requestFullscreen", { texture: t2, index: this.ctx.slideIndex, targetId: this.id });
      });
    }
    requestCancelFullscreen() {
      this.ctx.globalEventHub.emit("requestCancelFullscreen", { targetId: this.id, index: this.ctx.slideIndex });
    }
    destroy() {
      var t2, e2, i2;
      this.ctx.volumeAdjuster.removeListener("update", this.updateVolume), this.ctx.globalEventHub.removeListener("syncFullscreenVideoState", this.syncFullscreenVideoState), (t2 = this.videoElement) === null || t2 === void 0 || t2.removeEventListener("stalled", this.onVideoStalled), (e2 = this.videoElement) === null || e2 === void 0 || e2.removeEventListener("loadedmetadata", this.onVideoResourceLoaded), this.sprite.interactive = false, this.sprite.destroy({ texture: true, baseTexture: true }), (i2 = this.videoResource) === null || i2 === void 0 || i2.destroy(), this.rtcAudio.destroy(), this.stop(), this.controller.destroy(), this.ctx.activeMedia.delete(this);
    }
    fadeIn(t2, e2) {
      this.rtcAudio.fade(t2, this.ctx.volumeAdjuster.volume, e2);
    }
    fadeOut(t2, e2) {
      this.rtcAudio.fade(this.ctx.volumeAdjuster.volume, t2, e2);
    }
  }
  var p_ = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class f_ extends Za.a {
    constructor(t2) {
      var e2, i2;
      super(), this.type = "audio", this.isPlaying = false, this.isGlobalPause = false, this.updateVolume = (t3) => {
        this.audioPlayer.volume(t3);
      }, this.id = t2.id;
      const n2 = t2.audio.src;
      this.audioPlayer = new u_(n2, t2.ctx.runningAudio, { start: (e2 = t2.audio.cut) === null || e2 === void 0 ? void 0 : e2.start, end: (i2 = t2.audio.cut) === null || i2 === void 0 ? void 0 : i2.end }), t2.audio.cut && (this.start = t2.audio.cut.start, this.end = t2.audio.cut.end), this.ctx = t2.ctx, this.ctx.medias[this.id] = this;
      const { width: r2, height: o2, target: s2 } = t2;
      this.controller = new l_({ targetId: t2.id, shapeId: t2.shapeId, ctx: t2.ctx, height: o2, width: r2, target: s2, media: this, info: t2.audio, canvasElement: t2.canvasElement }), this.audioPlayer.on("load", () => this.emit("durationchange")), this.audioPlayer.on("timeupdate", () => this.emit("timeupdate")), this.audioPlayer.on("pause", () => this.emit("pause")), this.audioPlayer.on("play", () => this.emit("play")), this.ctx.activeMedia.add(this), this.ctx.volumeAdjuster.on("update", this.updateVolume);
    }
    get currentTime() {
      return this.audioPlayer.currentTime;
    }
    set currentTime(t2) {
      this.audioPlayer.currentTime = t2;
    }
    get clippedDuration() {
      return this.controller.clippedDuration;
    }
    get paused() {
      return this.audioPlayer.isPaused;
    }
    get isPaused() {
      return this.audioPlayer.isPaused;
    }
    get duration() {
      return this.audioPlayer.duration;
    }
    load() {
      return Promise.resolve();
    }
    showController() {
      this.controller.show();
    }
    hideController() {
      this.controller.hide();
    }
    play() {
      return p_(this, void 0, void 0, function* () {
        this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent play event with paused state", this.ctx.taskId) : (this.updateVolume(this.ctx.volumeAdjuster.volume), this.isPlaying = true, this.audioPlayer.play());
      });
    }
    pause() {
      this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent pause event with paused state", this.ctx.taskId) : (this.isPlaying = false, this.audioPlayer.pause());
    }
    globalPause() {
      this.isPlaying && (this.isGlobalPause = true, this.pause());
    }
    globalResume() {
      this.isGlobalPause && (this.isGlobalPause = false, this.play());
    }
    togglePause() {
      this.isPlaying ? this.pause() : this.play();
    }
    seek(t2) {
      this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent seek event with paused state", this.ctx.taskId) : this.controller.jumpToTime(t2);
    }
    stop() {
      this.audioPlayer.stop(), this.seek(0), this.pause(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.id });
    }
    requestFullscreen() {
    }
    requestCancelFullscreen() {
    }
    destroy() {
      this.ctx.volumeAdjuster.removeListener("update", this.updateVolume), this.stop(), this.controller.destroy(), this.ctx.activeMedia.delete(this), this.audioPlayer.destroy();
    }
    fadeIn(t2, e2) {
      this.audioPlayer.fade(t2, this.ctx.volumeAdjuster.volume, e2);
    }
    fadeOut(t2, e2) {
      this.audioPlayer.fade(this.ctx.volumeAdjuster.volume, t2, e2);
    }
  }
  var m_ = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class g_ extends Qv {
    constructor(t2, e2, i2) {
      super(Object.assign(Object.assign({}, t2), { type: "Shape", useBgFill: false, textRotateWithShape: true, isPicture: true }), e2, i2), this.isInteractiveOutside = false, this.cmd = new eg(this), this.media = t2 == null ? void 0 : t2.media, this.container.name = t2.id + "_container_[Picture]", this.renderContainer.name = t2.id + "_render_container_[Picture]", this.picFill = new lv(this.ctx, t2.picFill, t2.width, t2.height, { useFilter: true, useSlideBackgroundFill: false });
    }
    applyCommand(t2, e2) {
      var i2, n2, r2, o2;
      if (e2 === "call")
        if (/playFrom\(([0-9.]+)\)/.test(t2)) {
          const e3 = t2.match(/playFrom\(([0-9.]+)\)/), r3 = Number(e3[1] || "0");
          (i2 = this.mediaPlayer) === null || i2 === void 0 || i2.controller.playMediaFromCtrl(true), Math.abs(r3) > 0.1 && ((n2 = this.mediaPlayer) === null || n2 === void 0 || n2.controller.jumpToTime(r3));
        } else
          t2 === "custom-pause" ? (r2 = this.mediaPlayer) === null || r2 === void 0 || r2.controller.pauseMediaFromCtrl(true) : t2 === "togglePause" ? this.mediaPlayer && (this.mediaPlayer.isPlaying ? this.mediaPlayer.controller.pauseMediaFromCtrl(true) : this.mediaPlayer.controller.playMediaFromCtrl(true)) : t2 === "stop" && ((o2 = this.mediaPlayer) === null || o2 === void 0 || o2.stop());
    }
    renderPic() {
      var t2, e2, i2, n2, r2, o2;
      return m_(this, void 0, void 0, function* () {
        const { displayObject: s2 } = this.picFill;
        if (s2) {
          s2.name = this.json.id + "_pic_fill_[Picture]";
          const a2 = (t2 = this.backgroundGraphics) === null || t2 === void 0 ? void 0 : t2.getClonedDisplayObject();
          if (((e2 = this.backgroundGraphics) === null || e2 === void 0 ? void 0 : e2.isNeedMask(s2.width, s2.height)) && a2 && (s2.mask = a2, this.effectContainer.addChild(a2)), s2.width = this.designWidth, s2.height = this.designHeight, s2 instanceof im && this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
            var e3;
            this.ctx.slideIndex === t3 && ((e3 = this.effectObject) === null || e3 === void 0 || e3.setFrameCount(s2.totalFrames), s2.play(), s2.onFrameChange = (t4) => {
              if (this.effectObject)
                if (this.effectObject.hasFrame(t4))
                  this.effectObject.updateFrame(t4);
                else {
                  const e4 = this.getEffectTexture();
                  e4 && (this.effectObject.createFrame(t4, e4.texture), this.effectObject.setFrameOffset(e4.offsetX, e4.offsetY));
                }
            });
          }), this.effectContainer.addChild(s2), this.media) {
            let t3 = this.media.src;
            if (this.media.type === "audio" && /mp4$/.test(t3) && (t3 = t3.replace(/mp4$/, "mp3")), this.ctx.urlInterrupter) {
              const e3 = Date.now();
              t3 = yield this.ctx.urlInterrupter(t3), this.ctx.logger.info("redirect media url by interrupter. time: " + (Date.now() - e3), this.ctx.taskId);
            }
            this.ctx.loaderDelegate && (t3 = this.ctx.loaderDelegate.redirectMedia(t3), this.ctx.logger.info(`redirect media url to ${t3} by delegate.`, this.ctx.taskId)), this.media.src = t3;
          }
          if (((i2 = this.media) === null || i2 === void 0 ? void 0 : i2.type) === "video" && this.media.src) {
            if (this.mediaPlayer = new d_({ id: this.json.id + "-video", shapeId: this.json.id, ctx: this.ctx, video: this.media, height: this.designHeight, width: this.designWidth, target: s2, container: this.effectContainer, canvasElement: this.ctx.view }), ((n2 = this.mediaPlayer) === null || n2 === void 0 ? void 0 : n2.sprite) && a2) {
              const t3 = (r2 = this.backgroundGraphics) === null || r2 === void 0 ? void 0 : r2.getClonedDisplayObject();
              t3 && (this.mediaPlayer.sprite.mask = t3, this.container.addChild(t3));
            }
          } else
            ((o2 = this.media) === null || o2 === void 0 ? void 0 : o2.type) === "audio" && this.media.src && (this.mediaPlayer = new f_({ id: this.json.id + "-audio", shapeId: this.json.id, ctx: this.ctx, audio: this.media, height: this.designHeight, width: this.designWidth, target: s2, canvasElement: this.ctx.view, fade: this.media.fade }));
          this.mediaPlayer && (this.isInteractiveOutside = !!this.container.interactive, this.container.interactive = true, r_.isDesktop() ? (this.container.on("mouseover", () => {
            this.mediaPlayer.showController();
          }), this.container.on("mouseout", () => {
            this.mediaPlayer.hideController();
          }, false)) : this.container.on("pointerdown", () => {
            this.mediaPlayer.showController();
          }));
        }
      });
    }
    preRender(t2) {
      super.preRender(t2);
    }
    subClassRender() {
      return m_(this, void 0, void 0, function* () {
        yield this.renderPic();
      });
    }
    clearOnSlideChange() {
      super.clearOnSlideChange(), this.mediaPlayer && (this.container.interactive = false, this.mediaPlayer.stop(), this.mediaPlayer.hideController());
    }
    initOnReuse() {
      super.initOnReuse(), this.mediaPlayer && (this.container.interactive = true);
    }
    destroy() {
      this.mediaPlayer && (this.picFill.displayObject && !this.isInteractiveOutside && (this.container.interactive = false), this.mediaPlayer.destroy(), this.mediaPlayer = void 0), this.picFill.destroy();
    }
  }
  var v_ = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class __ extends hg {
    constructor(t2, e2, i2, n2) {
      super(t2, e2, i2), this.children = [], this.cacheSprite = new ep(), this.cacheContainer = new Oh.b(), this.json = t2, this.json.fillStyle && this.json.fillStyle.fillType === "groupFill" && i2.groupFillStyle && (this.json.fillStyle = i2.groupFillStyle), this.container.name = t2.id + "_container_[Container]", this.cacheContainer.name = t2.id + "_cache_container_[Container]", this.ctx.timingTargets.addTarget(t2.id, this), this.updateTransform(this.json), this.fillObject = new lv(this.ctx, t2.fillStyle, t2.width, t2.height, { useFilter: false, useSlideBackgroundFill: false }), this.createChildren(n2);
    }
    createChildren(t2) {
      var e2, i2, n2, r2;
      const o2 = { x: (i2 = (e2 = this.json.position) === null || e2 === void 0 ? void 0 : e2.x) !== null && i2 !== void 0 ? i2 : 0, y: (r2 = (n2 = this.json.position) === null || n2 === void 0 ? void 0 : n2.y) !== null && r2 !== void 0 ? r2 : 0 };
      for (let e3 = 0, i3 = this.json.children.length; e3 < i3; e3++)
        t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
          let i4 = this.json.children[e3], n3 = null;
          if (!(!this.ctx.featureList || !this.ctx.featureList.smartArt) && ((i4 == null ? void 0 : i4.type) === "Shape" || (i4 == null ? void 0 : i4.type) === "Picture") && this.ctx.smartArtShapeList) {
            const { id: t3 } = i4, e4 = this.ctx.smartArtShapeList.find((e5) => e5.id === t3);
            e4 && (i4 = e4);
          }
          const r3 = { parentGlobalPos: o2, groupFillStyle: this.json.fillStyle, groupSize: { w: this.json.width, h: this.json.height } };
          (i4 == null ? void 0 : i4.type) === "Shape" ? n3 = new Qv(i4, this.ctx, r3) : (i4 == null ? void 0 : i4.type) === "Picture" ? n3 = new g_(i4, this.ctx, r3) : (i4 == null ? void 0 : i4.type) === "Container" && (n3 = new __(i4, this.ctx, r3, t2)), n3 && this.children.push(n3);
        }), "@ContainerImpl[child.init]");
    }
    get interactiveContainer() {
      return this.container;
    }
    get renderContainer() {
      return this.container;
    }
    preRender(t2) {
      for (const e2 of this.children)
        t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
          e2.preRender(t2);
        }), "@ContainerImpl[child.preRender]");
    }
    getBgElement() {
      return null;
    }
    getIterateEntry(t2, e2, i2) {
      return e2 === 0 ? this : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
    }
    getTextElement() {
      return null;
    }
    render(t2) {
      for (const e2 of this.children)
        e2.render(t2), t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
          this.cacheContainer.addChild(e2.renderContainer);
        }), "@ContainerImpl[child.render]");
      t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
        this.container.addChild(this.cacheContainer);
      }), "@ContainerImpl[child.append]");
    }
    clearOnSlideChange() {
      this.children.forEach((t2) => t2.clearOnSlideChange());
    }
    initOnReuse() {
      this.children.forEach((t2) => t2.initOnReuse());
    }
    isChildrenInteractive() {
      for (const t2 of this.json.children)
        if ((t2 == null ? void 0 : t2.type) === "Container" || (t2 == null ? void 0 : t2.type) === "Stage" || (t2 == null ? void 0 : t2.hlinkHover) || (t2 == null ? void 0 : t2.hlinkClick))
          return true;
      return false;
    }
    destroy() {
      this.cacheSprite && this.cacheSprite.destroy({ texture: true }), this.children.forEach((t2) => t2.destroy()), this.container.destroy({ children: true, texture: true, baseTexture: true }), this.cacheContainer.destroy({ children: true, texture: true, baseTexture: true });
    }
  }
  class y_ extends Za.a {
    constructor(t2, e2, i2, n2) {
      super(), this.cond = {}, this.timeoutIds = [], this.condHandle = (t3, e3 = {}) => {
        if (t3)
          if (t3.delay && t3.delay > 0) {
            const i3 = this.ctx.clock.setTimeout(() => {
              t3.event && (this.cond[t3.event] = true, this.detectTrigger(e3));
            }, t3.delay);
            this.timeoutIds.push(i3);
          } else
            this.cond[t3.event] = true, this.detectTrigger(e3);
        else
          this.detectTrigger(e3);
      }, this.id = t2, this.ctx = n2, this.eventHubs = i2, e2.forEach((t3) => {
        this.addCond(t3);
      });
    }
    setTriggerParams(t2) {
      this.triggerParams = t2;
    }
    addCond(t2) {
      const e2 = (...e3) => {
        this.condHandle(t2, e3);
      };
      t2.event && (/^shape/.test(t2.event) || /^time/.test(t2.event) ? (this.cond[t2.event] = false, this.eventHubs.global.addListener(t2.event, e2)) : /^runtime/.test(t2.event) ? (this.cond[t2.event] = false, this.eventHubs.runtime.addListener(t2.event, e2)) : /^self/.test(t2.event) ? t2.delay && t2.delay > 0 && (this.cond[t2.event] = false, this.eventHubs.runtime.addListener(t2.event, e2)) : this.cond[t2.event] = false);
    }
    isTrigger() {
      return Object.keys(this.cond).every((t2) => !!this.cond[t2]);
    }
    isTriggerWithoutParent() {
      return Object.keys(this.cond).filter((t2) => t2 !== "self").every((t2) => !!this.cond[t2]);
    }
    detectTrigger(t2) {
      if (Object.keys(this.cond).every((t3) => !!this.cond[t3])) {
        Object.keys(this.cond).forEach((t3) => {
          this.cond[t3] = false;
        });
        const e2 = this.triggerParams;
        this.triggerParams = void 0, this.emit("active", e2, t2);
      }
    }
    reset() {
      Object.keys(this.cond).forEach((t2) => {
        this.cond[t2] = false;
      }), this.timeoutIds.forEach((t2) => this.ctx.clock.clearTimeout(t2));
    }
  }
  class x_ extends Za.a {
    constructor(t2) {
      super(), this.isTimeNodeEndSync = false, this.interactiveListeners = [], this.runtimeNodeEventHub = new Za.a(), this._currentSeqIndex = 0, this._currentSeqState = "idle", this.isForward = true, this.autoPlay = false, this.handlePrev = (t3 = false) => {
        var e3, i3, n3, r3, o3, s3;
        this.hasPrev() || !this.isMainSeq ? this.currentSeqState === "idle" ? (this.decrSeqIndex(), (e3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || e3 === void 0 || e3.commonTimeNode.seekToStart(), (i3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || i3 === void 0 || i3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.currentSeqState === "running" ? ((n3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || n3 === void 0 || n3.commonTimeNode.seekToStart(), (r3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || r3 === void 0 || r3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.currentSeqState === "end" && (this.currentSeqIndex >= this.commonTimeNode.children.length && (this.currentSeqIndex = this.commonTimeNode.children.length - 1), (o3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || o3 === void 0 || o3.commonTimeNode.seekToStart(), (s3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || s3 === void 0 || s3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.globalEventHub.emit("c:prev slide", t3);
      }, this.handleNext = (t3, e3) => {
        var i3, n3, r3, o3;
        if (this.isTimeNodeEndSync && (this.isTimeNodeEndSync = false, this.currentSeqState = "idle", this.currentSeqIndex = 0), !this.hasNext() && this.isMainSeq && e3)
          this.globalEventHub.emit("c:next slide", t3);
        else {
          if (this.isInteractiveSeq) {
            this.globalEventHub.emit("shape slide onNext" + (this.json.ctn.id || ""));
            const t4 = { result: null };
            this.findChildInfiniteRepeat(this.commonTimeNode, t4), this.commonTimeNode.children.length === 1 && t4.result && (t4.result.json.subTnLst || []).length > 0 && this.currentSeqIndex === 0 && this.currentSeqState === "running" && this.commonTimeNode.allChildrenEndHandle();
          }
          this.currentSeqState === "idle" ? (i3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || i3 === void 0 || i3.commonTimeNode.startTimeNodeForce() : this.currentSeqState === "running" ? ((n3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || n3 === void 0 || n3.commonTimeNode.seekToEnd(false, true), this.currentSeqState = "end", this.incrSeqIndex(), (r3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || r3 === void 0 || r3.commonTimeNode.startTimeNodeForce()) : this.currentSeqState === "end" && (this.incrSeqIndex(), (o3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || o3 === void 0 || o3.commonTimeNode.startTimeNodeForce());
        }
      };
      const { json: e2, iterateType: i2, isIterate: n2, isSub: r2, parent: o2, ctx: s2, eventHub: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2 } = t2;
      this.isMainSeq = e2.ctn.nodeType === "mainSeq", this.isInteractiveSeq = e2.ctn.nodeType === "interactiveSeq", this.id = e2.ctn.id, this.isIterate = n2, this.json = e2, this.ctx = s2, this.globalEventHub = a2, this.commonTimeNode = new Ty({ json: e2.ctn, isSub: r2, eventHubs: { global: a2, runtime: this.runtimeNodeEventHub }, ctx: s2, parent: o2, isIterate: false, iterateType: i2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2 || this.isInteractiveSeq, fromSeqId: this.isInteractiveSeq ? this.json.ctn.id : "" }), this.bindShapeEvent(), this.nextConds = new y_("mainSeq", e2.nextCondLst, { global: a2, runtime: this.runtimeNodeEventHub }, this.ctx), this.prevConds = new y_("mainSeq", e2.preCondLst, { global: a2, runtime: this.runtimeNodeEventHub }, this.ctx), this.commonTimeNode.on("timeNodeRestart", () => {
        this.currentSeqIndex = 0, this.currentSeqState = "idle";
      }), this.commonTimeNode.on("childTimeNodeStart", (t3) => {
        const e3 = this.commonTimeNode.children.findIndex((e4) => e4.commonTimeNode.uuid === t3.id);
        e3 >= 0 && (this.currentSeqIndex = e3), this.currentSeqState = "running", this.isMainSeq && this.ctx.eventHub.emit(zy.mainSeqStepStart, e3);
      }), this.commonTimeNode.on("childTimeNodeEnd", (t3) => {
        const e3 = this.commonTimeNode.children.findIndex((e4) => e4.commonTimeNode.uuid === t3.id);
        e3 >= 0 && (this.currentSeqIndex = e3), this.currentSeqState = "end", this.autoPlay && this.ctx.clock.setTimeout(() => {
          this.handleNext(false, true);
        }), this.isMainSeq && this.ctx.eventHub.emit(zy.mainSeqStepEnd, e3);
      }), this.commonTimeNode.on("timeNodeEndSync", () => {
        this.isTimeNodeEndSync = true, this.commonTimeNode.resetForRepeat();
      }), this.commonTimeNode.on("timeNodeDestroy", () => {
        this.interactiveListeners.forEach(([t3, e3]) => {
          t3 && e3 && t3.interactiveContainer.removeListener("pointerdown", e3);
        }), this.interactiveListeners = [];
      }), this.nextConds.on("active", (t3, e3) => {
        Array.isArray(e3) ? this.handleNext(e3[0], e3[1]) : this.handleNext(e3, true);
      }), this.prevConds.on("active", (t3, e3) => {
        Array.isArray(e3) ? this.handlePrev(e3[0]) : this.handlePrev(e3);
      });
    }
    get currentSeqIndex() {
      return this._currentSeqIndex;
    }
    set currentSeqIndex(t2) {
      this._currentSeqIndex = t2, this.isMainSeq ? this.ctx.eventHub.emit(zy.mainSeqStepChange, t2) : this.isInteractiveSeq && this.ctx.eventHub.emit(zy.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: t2, state: this._currentSeqState } });
    }
    get currentSeqState() {
      return this._currentSeqState;
    }
    set currentSeqState(t2) {
      this._currentSeqState = t2, this.isMainSeq ? this.ctx.eventHub.emit(zy.mainSeqStateChange, t2) : this.isInteractiveSeq && this.ctx.eventHub.emit(zy.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: this._currentSeqIndex, state: t2 } });
    }
    get stepLength() {
      return this.commonTimeNode.children.length;
    }
    get currentStep() {
      return this.currentSeqIndex;
    }
    get currentState() {
      return this.currentSeqState;
    }
    startAutoPlay() {
      this.autoPlay = true, this.commonTimeNode.children[0].commonTimeNode.startTimeNodeForce();
    }
    incrSeqIndex() {
      this.currentSeqIndex + 1 <= this.commonTimeNode.children.length && (this.currentSeqIndex += 1);
    }
    decrSeqIndex() {
      this.currentSeqIndex - 1 >= -1 && (this.currentSeqIndex -= 1);
    }
    hasPrev() {
      return !(this.currentSeqIndex <= 0 && this.currentSeqState === "idle");
    }
    hasNext() {
      return !(this.currentSeqIndex >= this.commonTimeNode.children.length || this.currentSeqIndex === this.commonTimeNode.children.length - 1 && this.currentSeqState === "end");
    }
    findChildInfiniteRepeat(t2, e2) {
      t2.isInfiniteRepeat() ? e2.result = t2 : t2.children.map((t3) => t3.commonTimeNode).forEach((t3) => this.findChildInfiniteRepeat(t3, e2));
    }
    bindShapeEvent() {
      this.json.ctn.nodeType === "interactiveSeq" && this.json.nextCondLst.forEach((t2) => {
        if (/^shape/.test(t2.event)) {
          const e2 = t2.event.split(" ")[1];
          if (e2) {
            const t3 = this.ctx.timingTargets.getTargetById(e2);
            if (t3) {
              t3.interactiveContainer.interactive = true, t3.interactiveContainer.cursor = "pointer";
              const i2 = () => {
                this.ctx.eventHub.emit(zy.userInput);
                const t4 = `shape ${e2} onClick`, { mode: i3 } = this.ctx;
                i3 !== "interactive" && i3 !== "sync" || this.ctx.eventHub.emit(zy.interactiveSeqAction, { action: t4, seqId: this.json.ctn.id }), i3 !== "sync" && i3 !== "local" || this.globalEventHub.emit(t4);
              };
              t3.interactiveContainer.on("pointerdown", i2), this.interactiveListeners.push([t3, i2]);
            }
          }
        }
      });
    }
    setCurrentStep(t2, e2) {
      const { length: i2 } = this.commonTimeNode.children;
      if (t2 > i2)
        return;
      this.isInteractiveSeq && this.commonTimeNode.applyCount === 0 && (this.commonTimeNode.applyCount = 1);
      let n2 = t2;
      if (this.commonTimeNode.seekToStart(), n2 === -1 && (n2 = i2 - 1), n2 !== 0 || e2 !== "start") {
        if (n2 >= 0 && n2 < i2)
          for (let t3 = 0; t3 <= n2; t3++) {
            const i3 = this.commonTimeNode.children[t3];
            t3 !== n2 ? i3.commonTimeNode.seekToEnd(false, true) : e2 === "start" ? i3.commonTimeNode.seekToStart() : e2 === "end" && i3.commonTimeNode.seekToEnd(false, true);
          }
        this.currentSeqIndex = n2, this.currentSeqState = e2 === "start" ? "idle" : "end";
      }
    }
  }
  function b_(t2, e2, i2) {
    const n2 = e2.split(".");
    n2.reduce((r2, o2, s2) => {
      if (r2)
        return s2 !== n2.length - 1 ? r2[o2] : void (r2[o2] = i2);
      console.warn(`${t2} not support ${e2}`);
    }, t2);
  }
  function T_(t2, e2) {
    if (!e2)
      return null;
    return e2.split(".").reduce((i2, n2) => i2 ? i2[n2] : (console.warn(`${t2} not support ${e2}`), null), t2);
  }
  class E_ {
    constructor(t2) {
      this.timingTarget = null, this.runtimeNodeEventHub = new Za.a(), this.basicOnTimeNodeEnd = () => {
        if (this.isConflict) {
          const { target: t3 } = this.json.cBhvr, e3 = this.getTargetId(t3);
          this.ctx.conflictTimeNodeManager.removeRunningTimeNode(e3, this.modifyAttrKey);
        }
      }, this.basicOnTimeLineStart = () => {
        if (this.isConflict) {
          const { target: t3 } = this.json.cBhvr;
          if (this.activeWhenConflict === "next") {
            const e3 = this.getTargetId(t3);
            this.ctx.conflictTimeNodeManager.addRunningTimeNode(e3, this.modifyAttrKey, this.commonTimeNode);
          } else
            this.activeWhenConflict === "prev" && this.commonTimeNode.dispose();
        }
      };
      const { isIterate: e2, isSub: i2, json: n2, ctx: r2, parent: o2, eventHub: s2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
      this.json = n2, this.id = n2.cBhvr.ctn.id, this.ctx = r2, this.globalEventHub = s2, this.commonTimeNode = new Ty({ json: n2.cBhvr.ctn, isSub: i2, eventHubs: { global: s2, runtime: this.runtimeNodeEventHub }, ctx: r2, parent: o2, isIterate: e2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 }), this.timingTarget = this.ctx.timingTargets.getTarget(n2.cBhvr.target, e2, { type: a2, index: l2, id: h2 }), this.commonTimeNode.on("seekToStart", () => this.onSeekToStart()), this.commonTimeNode.on("seekToEnd", () => this.onSeekToEnd()), this.commonTimeNode.on("timelineStart", this.basicOnTimeLineStart), this.commonTimeNode.on("timeNodeEnd", this.basicOnTimeNodeEnd);
    }
    getTargetId(t2) {
      let e2 = t2.id;
      return t2.type === "shape" && t2.txEl && (e2 = `${e2}-txEl-${t2.txEl.range[0]}`), this.commonTimeNode.isIterate && (e2 = `${e2}-iterate-${this.commonTimeNode.iterateIndex}`), e2;
    }
  }
  class S_ extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.updateStartValue = () => {
        this.timingTarget && (this.startVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]));
      }, this.onSeekToStart = () => {
        const t3 = this.json.cBhvr.attrList[0];
        this.startVal !== null && this.timingTarget && b_(this.timingTarget, t3, this.startVal);
      }, this.onSeekToEnd = () => {
        const t3 = this.json.cBhvr.attrList[0], e2 = this.json.cBhvr.to || this.json.to;
        e2 && this.timingTarget && b_(this.timingTarget, t3, e2);
      }, this.commonTimeNode.on("timeNodeStart", this.updateStartValue), this.commonTimeNode.on("timeNodeCreate", this.updateStartValue), this.commonTimeNode.on("timeUpdate", ({ duration: t3, delta: e2 }) => {
        if (e2 / t3 >= 1) {
          const t4 = this.json.cBhvr.attrList[0];
          this.json.cBhvr.attrList.length > 1 && console.warn("this.json.cBhvr.attrList.length > 0");
          const e3 = this.json.cBhvr.to || this.json.to;
          e3 && this.timingTarget && b_(this.timingTarget, t4, e3);
        }
      });
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
  }
  var w_ = function(t2, e2, i2, n2) {
    var r2, o2 = arguments.length, s2 = o2 < 3 ? e2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(e2, i2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      s2 = Reflect.decorate(t2, e2, i2, n2);
    else
      for (var a2 = t2.length - 1; a2 >= 0; a2--)
        (r2 = t2[a2]) && (s2 = (o2 < 3 ? r2(s2) : o2 > 3 ? r2(e2, i2, s2) : r2(e2, i2)) || s2);
    return o2 > 3 && s2 && Object.defineProperty(e2, i2, s2), s2;
  };
  class A_ {
    constructor(t2, e2) {
      this.math = { pi: Math.PI, e: Math.E, abs: Math.abs, acos: Math.acos, asin: Math.asin, atan: Math.atan, ceil: Math.ceil, cos: Math.cos, cosh: Math.cosh, deg: (t3) => t3 / Math.PI * 180, exp: Math.exp, floor: Math.floor, ln: Math.log, max: Math.max, min: Math.min, rad: (t3) => t3 / 180 * Math.PI, rand: Math.random, sin: Math.sin, sinh: Math.sinh, sqrt: Math.sqrt, tan: Math.tan, tanh: Math.tanh }, this.timingTarget = e2, this.val = t2.val.value, this.time = t2.time, t2.fmla && (this.fmla = this.parseFmla(t2.fmla));
    }
    parseFmla(t2) {
      let e2 = t2.replace(/#ppt_h/g, `(${this.timingTarget.design_ppt_h})`);
      return e2 = e2.replace(/#ppt_w/g, `(${this.timingTarget.design_ppt_w})`), e2 = e2.replace(/#ppt_x/g, `(${this.timingTarget.design_ppt_x})`), e2 = e2.replace(/#ppt_y/g, `(${this.timingTarget.design_ppt_y})`), e2 = e2.replace(/ppt_w/g, "vars.ppt_w"), e2 = e2.replace(/ppt_h/g, "vars.ppt_h"), e2 = e2.replace(/ppt_x/g, "vars.ppt_x"), e2 = e2.replace(/ppt_y/g, "vars.ppt_y"), e2 = e2.replace(/#/g, "vars."), ["abs", "acos", "asin", "atan", "ceil", "cos", "cosh", "deg", "exp", "floor", "ln", "max", "min", "rad", "rand", "sin", "sinh", "sqrt", "tan", "tanh", "pi", "e"].forEach((t3) => {
        const i2 = new RegExp(`([^a-z])${t3}([^a-z])`, "g");
        e2 = e2.replace(i2, (e3, i3, n2) => `${i3}math.${t3}${n2}`);
      }), new Function("vars", "math", "$", "return " + e2);
    }
  }
  class M_ extends A_ {
    constructor(t2, e2, i2) {
      super(t2, e2), this.value = t2.val.value, i2 && (this.fmla = this.parseFmla(i2));
    }
    resolveValue() {
      return this.value;
    }
    interpolationFrom(t2, e2, i2) {
      const n2 = t2.resolveValue(i2), r2 = n2 + (this.resolveValue() - n2) * e2;
      return t2.fmla ? t2.fmla(i2, this.math, r2) : r2;
    }
  }
  w_([Em()], M_.prototype, "interpolationFrom", null);
  class R_ extends A_ {
    constructor(t2, e2) {
      var i2;
      super(t2, e2), this.value = (i2 = t2.val) === null || i2 === void 0 ? void 0 : i2.value;
    }
    interpolationFrom(t2, e2, i2) {
      let n2 = t2.resolveValue(i2);
      return e2 > this.time && ["hidden", "visible"].indexOf(n2) < 0 && (n2 = this.resolveValue()), n2;
    }
    resolveValue() {
      return this.value || "";
    }
  }
  w_([Em()], R_.prototype, "interpolationFrom", null);
  class C_ extends A_ {
    constructor(t2, e2) {
      super(t2, e2), this.fn = this.parseFmla(this.val);
    }
    resolveValue(t2) {
      return this.fn(t2, this.math, 1);
    }
    interpolationFrom(t2, e2, i2) {
      const n2 = t2.resolveValue(i2), r2 = n2 + (this.resolveValue(i2) - n2) * e2;
      return t2.fmla ? t2.fmla(i2, this.math, r2) : r2;
    }
  }
  w_([Em()], C_.prototype, "interpolationFrom", null);
  class I_ extends A_ {
    constructor(t2, e2) {
      super(t2, e2), this.value = t2.val.value;
    }
    interpolationFrom(t2, e2) {
      return vg(t2.resolveValue(), this.value, e2);
    }
    resolveValue() {
      return this.value;
    }
  }
  w_([Em()], I_.prototype, "interpolationFrom", null);
  class P_ extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.vars = { ppt_x: 0, ppt_y: 0, ppt_w: 0, ppt_h: 0 }, this.keyFrames = [], this.isColorAnim = false, this.onTimeNodeStart = () => {
        this.timingTarget && (this.startVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]));
      }, this.updateVars = () => {
        var t3, e2, i2, n2;
        ((t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.ppt_h) && (this.vars.ppt_h = this.timingTarget.ppt_h), ((e2 = this.timingTarget) === null || e2 === void 0 ? void 0 : e2.ppt_w) && (this.vars.ppt_w = this.timingTarget.ppt_w), ((i2 = this.timingTarget) === null || i2 === void 0 ? void 0 : i2.ppt_x) && (this.vars.ppt_x = this.timingTarget.ppt_x), ((n2 = this.timingTarget) === null || n2 === void 0 ? void 0 : n2.ppt_y) && (this.vars.ppt_y = this.timingTarget.ppt_y), this.isColorAnim;
      }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
        const i2 = e2 / t3, n2 = this.keyFrames.findIndex((t4) => i2 <= t4[0]), { attrList: r2 } = this.json.cBhvr;
        if (n2 < 0) {
          const t4 = this.keyFrames[this.keyFrames.length - 1];
          return void (this.timingTarget && r2 && r2[0] && b_(this.timingTarget, r2[0], t4[1].resolveValue(this.vars)));
        }
        const o2 = n2 - 1, s2 = this.keyFrames[n2], a2 = this.keyFrames[o2] || s2, l2 = s2[0] - a2[0] == 0 ? 1 : (i2 - a2[0]) / (s2[0] - a2[0]), h2 = s2[1].interpolationFrom(a2[1], l2, this.vars);
        this.timingTarget && r2 && r2[0] && b_(this.timingTarget, r2[0], h2);
      }, this.onSeekToStart = () => {
        this.startVal !== null && this.timingTarget && b_(this.timingTarget, this.json.cBhvr.attrList[0], this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.onDestroy = () => {
        this.createVal !== null && this.timingTarget && b_(this.timingTarget, this.json.cBhvr.attrList[0], this.createVal);
      }, this.initKeyFrames(), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timelineStart", this.updateVars), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy), this.createVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]);
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
    initKeyFrames() {
      var t2;
      const { valueType: e2 } = this.json;
      if (this.json.tavLst.length <= 0) {
        if (this.json.to) {
          if (this.json.from || this.startVal) {
            const t4 = { time: 0, val: { type: "string", value: this.json.from || this.startVal.toString() }, fmla: "" };
            if (e2 === "num" && this.timingTarget) {
              const e3 = new C_(t4, this.timingTarget);
              this.keyFrames.push([t4.time, e3]);
            }
          }
          const t3 = { time: 1, val: { type: "string", value: this.json.to }, fmla: "" };
          if (e2 === "num" && this.timingTarget) {
            const e3 = new C_(t3, this.timingTarget);
            this.keyFrames.push([t3.time, e3]);
          }
        } else if (this.json.by) {
          const i2 = { time: 0, val: { type: "string", value: this.json.cBhvr.attrList[0] }, fmla: "" };
          if (e2 === "num" && this.timingTarget) {
            const t3 = new C_(i2, this.timingTarget);
            this.keyFrames.push([i2.time, t3]);
          }
          const n2 = { time: 1, val: { type: "string", value: (((t2 = i2.val) === null || t2 === void 0 ? void 0 : t2.value) || "") + "+" + this.json.by }, fmla: "" };
          if (e2 === "num" && this.timingTarget) {
            const t3 = new C_(n2, this.timingTarget);
            this.keyFrames.push([n2.time, t3]);
          }
        }
      }
      if (this.json.tavLst.length > 0) {
        for (const t3 of this.json.tavLst)
          if (t3.val && this.timingTarget) {
            let i2 = null;
            t3.val.type === "string" ? e2 === "num" ? i2 = new C_(t3, this.timingTarget) : e2 === "str" && (i2 = new R_(t3, this.timingTarget)) : t3.val.type === "number" ? i2 = new M_(t3, this.timingTarget) : t3.val.type === "color" ? (this.isColorAnim = true, i2 = new I_(t3, this.timingTarget)) : t3.val.type === "boolean" && console.warn("not implements"), i2 && this.keyFrames.push([t3.time, i2]);
          }
      }
    }
  }
  class O_ extends Vh.k {
    constructor(t2, e2, i2) {
      super(t2, e2, i2);
    }
    set percent(t2) {
      this.uniforms.percent = t2;
    }
    set transition(t2) {
      this.uniforms.transition = t2;
    }
  }
  var N_ = i(121), L_ = i.n(N_), D_ = i(122), F_ = i.n(D_);
  var B_ = i(123), U_ = i.n(B_);
  var k_ = i(124), G_ = i.n(k_), H_ = i(9), j_ = i.n(H_);
  var z_ = i(125), V_ = i.n(z_);
  var X_ = i(126), W_ = i.n(X_);
  const Y_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAMAAABHPGVmAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAr5QTFRFAAAATwAAOQAAZgAAKwAAPAAAPQAA7AAA/wAA/QAAugAA5QAAsQAAwQAAsAAAfwAAawAASQAAZAAAOAAAJwAALAAALQAAqQAAiwAAmgAA5AAA7QAAtQAAhQAALwAAfAAAXwAAYQAAigAAuQAAfgAAswAAcgAArQAAqgAAZwAAaQAAMgAAGAAAiAAAjwAA1gAA6QAA+wAA7wAA2AAAbQAA2gAA3QAAuwAA3wAA2QAAxQAA0QAAzwAA0gAAXQAAYAAADAAADwAAGQAALgAAjgAAcAAAzQAAwgAA+gAA3AAAGwAAoAAAowAAcQAAVwAA1QAAIQAAWQAA5wAAsgAAuAAASwAAbwAARwAAMAAAnAAAUQAAaAAA9wAA4gAAPwAAbAAAOwAAlwAA0wAAjQAAvAAAwwAAkwAAQQAAvgAAnwAAvQAA0AAA2wAAwAAAWwAATQAACwAABwAAQgAAtgAAgwAAvwAAgQAAlgAAEAAAxgAAtwAAmAAARgAAjAAAdwAAqwAArwAAywAAYgAACAAAmwAAHwAApQAA8QAAdAAAbgAAFgAAgAAAogAAewAAXgAA6AAA9gAA/AAAzgAA3gAAkgAAngAAdQAARAAAmQAATgAAUgAAJQAAIgAAqAAARQAAPgAAxwAACQAAAgAAMQAAiQAAhwAA4AAAUAAABQAAeQAAygAA9AAAFQAAVQAAyAAANQAA4wAAKAAAWAAAZQAApwAA4QAAyQAAXAAAkQAArAAAdgAApgAAHgAA8gAA/gAA6gAA8wAAFwAAHQAAhgAArgAAnQAANAAASAAA7gAAlQAAJgAA+AAA8AAANwAAJAAAHAAANgAAkAAAKQAAoQAAzAAABgAAFAAATAAAeAAAAQAADgAAggAA6wAAEQAAfQAAVAAA9QAAIAAADQAAEgAAVgAA5gAAQAAABAAA1wAA+QAAUHExBAAAJDlJREFUeJwlevk/lPv7/2XtOrKNsWcbzGCMJSmSpSxJZtQkjPEOg5mxRWns+xpZyr5ECGmcLIOsdVK2oyJbcVI0J8fp/Bff2+d7/+BhPO6Z1+u+ruf1XF4GAEAGZOXkFRQBTiD+dgKVTiqrqKqpq5M0ZMmaWtoAOrp6+qcMDMFIzdiEYmpmbqJBpVlYWtFJitYMG1sbFTskLvvTDmcQHM+ec3ImXp13uYCubvB/l7sHkC9eAk8jcy9Eb5/LvldQzQ+v+jsw1ZAlfwYDAK5dZ98IvIlBwXRNXVYIJ9TpLJUb9j9LvBVOj4jkRVGj/Y1i8AwiH09eEwhjMU4uXtsiAWLlqInMcLh+28okKRnuhNy945lic0+Uqu7NdErDdB/5DBo7MwuE4J+dw8jIzcsvwEIUFFGEisWQm1ACpcZlxF7vl1c8YMCJyqrqGio+fFRbVw8NjU2uec0isNWhVuq2XMPzmjcRBVHhSWCtXaPR2mZoybHzL0TUfmxPabeR6yg/+6QTY83VQNOkSwkbumsgkgzwtKe8tDdHYM7ts3sW1Q/Pn3PEWaGmYjoje+B3ewx9bM4V0LNfDB5XL3/o5v1hSBi5fzvQkQESOkQOwiiwI++5YBdkDjFIrKEx3cZK4Ti8eAlZpjcnYMSHKG0ygKKVeFSLRpOZNL9p19Ku1Q9enKlp45lZiQGr7hlWS17RKWp03mv8481cQnwBUNTAXwIUeAvsJwCCTnV4FyJC9CrKYDnOT91DpRZSG8Bsn7pAw2Ihd7Hn7R0hynXezjQcvQTyMGgUjV12kiW75XaR7Z9OK9kD0/j6ckfyk/fcPHCkvkz48NG/r3p4FeRpoQa9JA74sJAOcLubirEPqXqTpZ1hNzUN5exoNVbk5RmSOQqcJix5yWvvRZZ9nyay+tqAsb6U76oAwo3wgXvJkK6sCpOYQBTIdT6cg92rSxWh16pdV2c8NnDzfQhveqvND4k6aAB0ssWnHuL2yZQ7AHLzJTgUrreyZeWewhawpw1RMDWYHLP1OcNQgKzwlKVP5JV5crB7cZ+NRJ6AB3wx/x3RsEufEkozLu+g7+zkekfLbFQo8byEubp5ld7Ot2CQKxJ7qguZxF4SB3ozQF2pCEIbcaFxg6eAr0/MbeHb1DCK+vQCA3j4YTcwjNiWyEgcq1dRlfnXsq31K3hhhvNX/CYM0JC+asxk91d+7ahTr6AAaTAn3U2lTBfjIc1pr5VEX94yw8uIZhWQVAHQj66iLErxDLqNmN0wuO9hYf6FN+boQb1FjENYJAiWKrru2ejWzoZX6M9A91p2Sw1TTRT/rdDQsyiOT1f6br4fKm6Fpeb9qocNfvYOLPAuczuA5BTbeVT2O/ghlkYEScGHX0Df3StfyMT4iYHCTEQTLj04iWePVx6aomPYGLc08OXB+drJLqoq42/wXqB5eagtaqR+ZAPsymG8utBxt1rO8zFTPHITA50gCMQ4Gw7tQBZFo0DBsWb5ExlyKoBbvRAO7jdv6U8jMYne4Y+iWXmg53gvbNYsGg+gU3elEnaeXB/ufFUKJiyZdNZemo10NviBxr65KE1k/Rijg8KTan5647eoiJQAYPIL+9fuHPb/VSMucg/bcJHzKt557SPRYF8voq1+2SIWmSgQCZo2ZjhlymMigEZdZQ3MzX6wmmMTECwNWieLpWDlKihSZ2sVVwNX9AmecOXtMHP7C/WwPzvKbZqiJIYFZ7PuZngFJmNi9YatOLLQU77vGbS6PzGdsQVn/Ad7nQyALeZVbm01GA72t5bvR/aWTWVIIEVDwDJanzjqAc8QuFl4Yr9/2WTdPVPmHCtY7ZEZ4mJoDqURsbWcaHwtmIqJWrIXshpck5ilsHlYM34YFFXTG3dGzKrDMBxB8gsDn7G3bW/TDpe51ALDmy5KQW8lUgg4guspE7TN7wCTbFWnf7gBB16vuHtYoXsWo14j1cD9/Z+oyj5GF95jqI9KG0s6YtJ0N0jtISrVAZQcIO251QuKrBIaH7k2hLK/Mw8pyNmCnott3tGm6XjT9DsZUps7H8DCHwjc731hFRtTaF2UQ572Ca4Qp/On0RVdmFD0A219YL4DcFBN/lnfBvNr12E0W2MSZatepyNLVIbbFIg7jaYfoR/4W1VUKqL6zsF4NpNiq4orZEhCEjExd7AQ2j+B6GMOPmekeA7+DsM0IAsIqj31xrtAzvWqBsjmIWC6+uBONItM9R+HA8rGHxptX9JAF/G0L6QEiy3McdFEhp4+YNA0FHNwnW0/RFFEtwHRb/hwQsbzX/heYihsB6nNVJssfHnqQe/acYKMv8LqcRe7aEF7Y6ugtWxKLILeNmlzVF277PqxIg8dSxpo5gsaMBFxfgwvdWBhOvzOHHHzx4JUHLNpyc8LUzkLcfiIv3A2jQxpeQ1iL4IKUJ1dTmigtKLpgi6QjX2d8ISbHl1B8bH0UEbnI2DMVm5h4+6Ko+kTd3VVSVPGkpp4/p+BW7/faCjBhlD7MoDqRpcOJxz6lBe8gWYtBP80qaKf86k0FP9L1ziS+Y1m8MPaWpcD8BXkG2flILIvKvoC/hr8upkS1N2pwbQD5NtZmC6iNb2JUVJTRDoZxTXibAjQDp3w/y5Bhld8zynk7OU1S3S3LPnJLvjhzcfUaKeYeJwtkmPDDbYpWt0gTaf8e/gL32vUwV1i7lHVD65CN0n+CySLiHLZfbSx/XYollUUj09xeL/Cjqg2DUp2eM7igsEZPyXlnve63tfjYjZSbBwtUf7mlAhvX0N/CzxFIKE25lol9uEzuf4B95AK6EAVtXBSn3XGA6bVuISAxQuuFKTClSg4xz/VEivy43BYA1UY4x7aSd/i1RMdwdgzi68x0JEYIfLBbEMag6Kcur0R3WGGtXvT2744+WPE4QaWz1rrbq5fEmwQTMwOLPRNs2jAJiPTPpAjXA48lyGNDo/aEnNyEv39YQtTIKcLY2gVw/SWl2eGCgmvgRKcowIU96xWM6PvyJhk/4dRHbP4A2JaG+uq0xb1J15Gaa++VgngHKhh3L3grVzTsa95kyjw3wgZLYViuASK6smRQA8Ds39GAisCnrN+wiGik1BsIZfpFhk9aVvJNr+pUWJbSmxoOAqRzseBsHsCPJ+9EvFA6HLDuymPuB3VbLuUAeRzs5AnmhdV52drj6JdA/9JE6GEWqDZIrYYlrYCDM7hLcefRsAoFiZc4P3tYx5qFsH9ttFzAL0L/lgSwvjbS4Hlik7xGLuSVfejKzFhvtnHF3039B8VGq1UCpg4+cLt0KMDi46N3M5F9YWHiD/InKc21mDdj2pCGZNgqLihu2j14oFnH9dxycOd1FsVBZ+cMEBkuu0U7wwPJEfc9SWATH9MuG0EvfyJPxuf9enmuy3ipIOtB/Tq8fRSfpzQFs03/H+7yBgpxgsOgaPD69B90NfAH5SMhqmB4xns1ARtQlmao4VcBTRTDeuo6wPwzlIp/AQcGagk6KNOsPIQxV8P+wi/EIUDDVLWFGWvjTzIZnkLRH1UoJhWpXMTjPAjt3UAX17p6WGAJwxrWKi26AC0+gNR2jzhlwfEJrgvQCombOyaY8/bLwB9fMvueMLQvWNkBKGC0lq0Ht3KzP5jCcE4StVpESb3tdp2iHeZtLDMQ26rGa6n0GpULC4tIz4jBBxadsL3wHdFQPwahEAq1xR5rwJkcKwXQrx0f6F7awZw4fPbGa1gUiXJVpYOUgng1Il6/kdwHeGfQlS+PdZEZ/WbBBOmQjvC0LG6wpXRfApSSh5UP+GjCtGd2HwGkHtuvHkJDGvpqBlcXLXap5CKR9eJRzlgZ8W4zK891g7/yQl4SpDRz5B6E6FEUxFv8K/4i/p8Hn1DOZxLx2FQHi3X/cwgM0LCK+TZnTMszAMO3JUIXyO6zOQNiThG4OXOrwJNCE8XwV95JJ175KWLydZwJE882VhaOGyWMiSKcP771g4kaYKUFB2Dmz0JUdUk75Pplh8T7VBZwUY90zTpUDwWxIJNQ4p3+oSPgHVcJUQVskdpHklpVCunu2AMvq7HI2HuekbnizilxbZeVzVwQLUBT133fJUvswkKMu+OHgCDmIJX9+b8TDTiXIyTQUrXPXFm5NsIOF7X6snH0GkbLAqxPlJ9ecWoX5Ywy8Vl/GgAlgE21JAfp4T0F8NwItrDq/BXLuXDsET46eLTOOKK5svMyhZ3Ah1ePwHOvYdijiwWbAEJnbIP5V95SOcbXM43qIJm+5G32UABbhvaNNvRffVynh4jmDDQ3V+XtC1dHWnr5PFwd9Ds2UdVaIEHmECBo9V1OAz0w9Q7ZONc7xXtF+8+ETCmmX+G7+2+flmEDTEww2Dr5eQAbJggPltoLQ9vmismCRLQYIvSsXqDWOIS85DgRSlAhWjGdOxACJXNVdyGoSxA1lu2eETiYQrdn23iL9SxSRCa5LgEX0CruBRSxHIQWrdV/mq5qOUyNgs9QUYv+xsmlhwRichkxSqZko2RwH46USV7CUofNLnT23rewuaB+3Y+8g82zzjibgmdChhbQRFk34o/zPECaRHy7wKj5wlFDE8H30Jva81PwVlVT/UNLeH5C/T9cIDrBy3capubs5y2F7ATbAwpRvThn7BsaBvwbu0BBMDxHEtAsSE3DVOdF+kWWcXsfX3AFYeWSbrZP/TS/H80MGryotBYxj1U8rWXomZeevT+aQ0crFNLeulQLpiCr0J3rB5jTS3MR+wbSYRJirC2/5eEGCMHpzOUFWEplMsWaW0SVaCL8y8rZVI4hiy4qyEC7CW0YwNHTGLxvJ2vW6GNMctZQNF8YFxN+y/di6ENOZNtphmlCkIZsU3uvDqzlidm8vQCrkUfzYk6D4AYr6tk+mccy/i8xBKFQzibM/wWTIysZ6cDt/XhySBb1niUMBJRN+ILdWbj7Z6dnUgLZELPYXWeyXNhzV48NvUbAWzWEC0lD8PwVIGTt6rveS3h3gX3XiVRg1O5poRFvgPCL17nEx324dKJT5AC5OU7RFWXuEp0U1v+MRgY7mxikdoB4lle086YyXrr61aA8eVem+VOaY1TKn/sOxOeRhIcR4AZLNrygau7faIG/T/vTPO010Kbci6K9mAYPE3+D/Q/02VDHhOfPxxTud5MF+8KsrdY8Bw4TELjh26cdDiBfCo2ptEyDRsJrRk1KZcvgta3ckuK5CRPn7AxcptUHMpozoAU68b9ElVYL1uhaVz7RTJwRJ15W+0X8HZs7gUMi9wPAEik099Y6ilYhW7j1KNLmlFXlRwAb+NvU+PbN1AfHY1t+/sN4J1JVfn7FDYLloP1Scsg9GA3s2b6XMPgHYNbve6n3ghsmK0WGyzvNrCU7t0veADh7RGOKA7vXwYQc0uuPZMJMUQMLbBdz+2kFzkStJJNFEvH/f/cT1wnXJfsflkfnn+qJe89nGfU5c6Fpsd3vp8y31fD+eHg8uZSYXdwqcoBT9DS0aTRKoaZrdSqk0KtkFZb4+BBqXAnpKdyVLXBuP5clrK5wxSYyIWrghPCaNnLhJkp/A3x8fsMgMczROQeBhpGULvpU+ZNQqKLZQMr2c5uvEvEMHOemnBn5rN1M88Y+/TkhOxUIBP/2P2jr1+oIelfW2KEQFOnrjfGzrGWUsS6YsjIBTxTDwc64bw+fGhfW5AnvnpxLYAJDBm2lJ6rvaNZZMrsfTANYByHtYSbJahyNwhmaepqjdIPb+zS9jVAgfRHPZEjU1Gd3rhA/5cI2/I7HkyV/yE2rhd7VLRC+6h3nRnBwqHqGw2HNB46i9yPFIYrAbBjbP8Xiw3DuyzbyCf9d4TVDRcSKQussrgoejwBiAjYwZi0qcQK8KuYyotDvMBHuWgDgNhVUXyHsaOlkxmK4H0+NoRd5BhMX9v+E0DX3JzZF4fOt9EZhbDdj5dngkuAUBvofWKvSxgvWN/JXhGtuib/SxfY8KRQCXuP9M9m4RKN/YNl9WjkI76xL/vI3tkUW8UwNyBJ97wf3vZkr8zgZWjt09M51pPhhhhIa5n7iOjQUKxcVfAILZl0T4jc7FxaD1109JL9Ca0sSBbrEuNCQcFBiIv+SZSJPYe/1EYItPw54SrCk2fKxMmvjDJ19ORWT937dR9t2yrEWeJCbBTuaVFvARwhlXYkVrmPmMoeHL//5uHAvRj2Y8axOXO33AUsW/qXsBWn9CxkKIYN1C7xCb9tfTfE+3+m+utf4yM6L/i+ic02U8cQ2F98GKWj7KuD2pLDXkPCLCOzaCvJfwOemmSw+9kphfUY4yI+yj5/MmQxX+dJTNMaPNhkZY4Wbc3tEQKBn08wseAkoa6qqIQUIOD3kPmDGdgoM1ToC4KklkiDUBk4Uk/Fidp8zCJcFBMgHj+etTxbRFeHvwhf80CiSt3z3DIFYl6k1lWLVvRBn0lpMVKj6PITC0tar9jbVAPhHP8k4rhblOqCcOdqrAPy67Z1WL4TfMfVx0GLrHQJyH8iQUus8lkFKuv5kcYrNvW13YfKuZ89ORAmC15BmyKxBFilYKq8dxQRWdqGLLb8Rij6WrIs7/mxVyFptbrarK6uDO1v3yxzOWQjtaz2W/01pTvN/Omyfx8D2VGPK80olW8HfnliYW8J7UjIcIlewB+DJW6whrBEqHlPOAQ8W/xs1Hn5GmuasOM+K9M5T9RYI+PMwnvMsCTG6r+dbVXfMESA2YjneGLq0D1CQv4w2JrzNXBsshiH+QHHQa2Mr/AZ4I3FCYwSF30Bqgti3TOnZKmjAfxUANcv/0JqQQ2HHnOhMOwJodHns6/25Jg743Q1lQ+KbmEPuPq51Bt83snYTH17IxKtNv2roT2epeJDTPX4a0X9SZHNHJqSie0RtRDgKb5JGNRAJr4h2aypQVI68DWseD13hXjPfFQtgcpsWw3+bHWbYNMQ5bN4cjo9d8aBirB8/oJdnePZQoxNeCAZZbotwjOCA0wROeUdcuZjnmA4UdjXjcB5b5xb9AZYmwdFSH2DdhvscW5z5QnIMnYTFRngKajbkSdjvvVyWw6LwIJWxlYhshBPGlg4xDUFZOFLf2UlA4MUe8DA8TIea+IX2smNzuP0vmleE8ArQR+UsNqTqekrljgz0+vhX5+FaB5qs3t9J5cPuwScX+MPS/UkluQXNh5WrJFM9p4CGban0P71P43YKxglb2X+cyKQ94h/diX4v9RaCpnBsnLBEiBNo/0idpiYrznuGrJbXrCBGfcS8UOZNOTvW4hnUTwJkuVcBHodNx3R8t5LtTDmf9/EmsNByWOE4XyHplSzut+ilAlOYAW6FAoMlRP17j9CYvp40MImU7d5GfS2Drx+GW3yciuygcSeJPwW0wzd8Jx7iITtZPchNXC6aPAtKQrB2xa8z53r/+NXr2nhyLPFySAhSY0IYOQBgKT6h3kSWUhtwoeuSh11H23xn6OOue1lRwSZFtnWn9cdSaaEGqWp9dYsa7+ChyZcubQzxJjXzXLk9h89vBXfZGDIlvpsP4QIbmPMjqxhqsBfefv19nkI6ATGqFQsHNSKV1bi5RDhNzYOR3Ckunra8gfjADKT/ll0bAtT+Gyj2d7NLfv1oX/s3Dxbwcs6upK916xmn4Cn9qoUPECeybc02KdxfxGRB0zT8l0Zikliu1neuQQ0TmnzytBG1jCdcA7AUAfwLbEnAjIqNRI/tr3AS3HHzaJJ1AVHLTuHM72nkWqYVDDf+j66wmI+h8Lmvxl4OGEXnX3JOrwBz08R7ELtwHigs810rOj0viiWN/+sC7Ni5oBKQ6bZk8eHN3PYLZzQgVjEb5jNex3lMrEC0EzpQ3faNx4xd523exujDDnuf5ZP5S7v7/UuKqkqW2X94NfxXy7549ho3WWi6n1Vt7ABUIeJc5cdqWkRZrf4aNACabeODzxEINKtnW6CGh5734US98i9pjARiQfrdT+ax6iuaQ68hRSbykUQcJUr4DoFBkm4wgd2hq4tBIt5iGqkmIYjIK97X2Ac+y7Al6Eas2r5VF3EkYVixIGsqzlkm0RXA05xqwaznFZjzk8V80Y+iIDhMyNdfSpEMp3IheR2cbKGSnSfWK1HK5rU73te+Y+mp46Jt6oD3xe3/MKUzoD2UBzNmu3iQW2uCJHd2ne9t/x3h7lnn4kBxCEAK//UgVlyjyz9W5JHgDWu3g3OlGHBZO/680MjgZCrLsuOfLU+5jPl2Pxck02uqzyqmPlhPA0isbdnhRis6Qh/S179zV226tq30IMf1KqJ+bHgSCHhjM64dbIL8GGt21vGOEXP+/AJcER6NjIb286TKSzTCCidNp6Zf3rpsWZnG5dNhuEqU94Fd2sYHaDOgM3A3LO9nxQazFRTOJsT7cD4eScDOsG8UfQGqlmCqM7L0/3ZpnWylRSPqBu/B+eHEfYNZO+0QTaWrYVbLURYIK4TWR8iESRGfHHQWgthnGCFSR6XhpDR2Xtq0uhr2QQvOUVv8Giw6ImYIgOdd8OPo1dxm1hQCQV84zTzso6krY75wTfRjcwV5Geb/tJ4owfFd8kC7FDPX9B9mBYVZ0zuK21vYoVpvazdgKlwKfwFKZSgPgFfDQtTRYNOvy6JNZ7OeYCWEFJq/hygT5KPD9mIbenEBsAvHdzCG/K5iPb4S4aP/YhnMDJHIP/icNM6ztIK9gkRRdA71nyoMef+2jb3neklwx0pHH2SIdKb2jwOWG3JCmYK4Iva+7eEG0a3If9Da4KaFAGMYlTTCfFBFSoyK7YMSwyuICgV8M49c7bf4VqtKi5LOaLKCJlVZ5zBpLrIr9LvsMNctO/oiM3ab/MknNJPPbnirNLPbGflQrRr2aJJYXg/QIsh8k1PXzz+z9w5gIxiXea4P0RlO2OUDqhJdvv8EBpRLy6Z9p8GR+FFKgDHcGsMkkbMnJz0q7hAhDVdF3sCfBM6hj2P4SlE5njIsBmSky6FhkNYd2UfgLt37a35+BEvupCA+Jh5kmC5dWaGeQNmz35EEQvhwZG3qxKo/RZr66hM7IJ5Won7gh78anK172Zt3buKAMKyMDjzdR9ufcCZ0zU4DOA5RKIgkAMTbytB3LQFlT5MH/An6qfRJPjj2dg5WFP3mdlZkwFePrA+3eN2Wu0A+WAFKZrztzJRibcqCweEddxU/PSGWxOnjHtOUDzfDk9lEvDDj39cFH1E9dVeQLGVI3Qgeo0M34dZ6K/3cb9BBZcZf8uS+BivagqBuLW31L60FMADuX1jiTur3n1ZrBrIgpkFO//0OmyT9qWthHcnwzLRswTdDbgUflRNCAvfaODDSX8vQLo7QBDltK42Y/OdFbS1zUYFLv6qSiV43zDiUrcAtbEqoMVBPa37+RMTuT1gmrJVH1qqYsi12cyakNWPLrTGqg9NO1KY2vPwISkCnxobu6FodJWlXUwABhb1LwveepTps6Tt0E8j+tabfLiI+MdLLWSxLqA1cJON1hz8aZkisUWXUMhNOQpLrIR062CCV3Bg0ZwlU9OhbKefT1NjDog/g2q+TAW89zQllayE0d/y9qAdSAucb3iKOXZYzSSmdealQNS1IL3qMUpowYU6uuO7LEqyPD05MgXvXy6frzzrkpBXlAx+J30gur7J4OT/ziwA3fvIcKvLAHet4sqms0BCkZk6CKbyRPu8Xqwsv5KGfYcI4thniGI9nFwFwt1bfZm9racBom20+/R8n0upa1EAueM5b9A7lN3BE9empZqOTj5NkKNeCf630MV2jeKeEP8cImJ5W9l3gYGDg1wPxxZcmBvsZ4qZXUMim6a/M2jKAsHtYvPN1A0FsH3AAbpFvCxA200RpdN9ME2nSQL2g5pg9OIw6KkYT3gKe7QmWrItoXK1c/XBbJQ6pVOca2BzfQfoOCTygsFljpEPDG+tBLrte+jUDP2DcYKLisBjhgtTZnAmgmg8/Aus/awVIZGqScBZ1xa/82qG7rzT0BDLldEs0sP5HS8oNhU3lhDue5NS0TUt0T7YTZvSGH0HEYEs97dJ7xpNO1TKokYmLWenco4PvNEsv2hQ85pcgDjlA29jwVT9IoAcXQGCnhPG8fgYyhJ64NNzBiWf5p1XdoBx+xtXoPiVbK44FcHipEqTaar9/ruKsdneZuJmevOHPOjhmtvwVVX8Nmx+/eftj7gZmxlF3ocI/n5T0byPxzPfMi24AxSQeAGjdI3Q4hc5ffAT7v7F89ZNEgj6fheuHl2hjRQlG4EMMwpiAnsm1HT499a+zKPMejH0uAfnT4JyItDTiDQ4l5DoO/sQZ0HkzGpiM8KQNwaHk0Un9WaO+yuA1ZTV9z8Jm13bqwTlfNHncIi8M/kHQMFhMF7Imo2mUw/Sox7Bh3W6UplqvEiy+g2NvVzFPCtGkHSTLuFSL2CtGzpPY+E5O0PK3HSbUnBzNBZodkNnUAlch2Zk9/9F8JuAYBirgoVpE7QyheJ33WDOysDFYMSXBdm20XfXCWcGzsGyvXE8FJN7EadsGjIDzZ+GtIUEBWuQ6o87kaDvo4eplYs4dz6P06lSSCA0yAvpXKD1djjC8dnWdYtWsLpl4Fplhje74Y6i/M7VMSQnRvD54/CC4LPzx4vghhIOzVo6bLzl7QIHPvVyM/drqBBZ3tW1lYqvXfauRfH5WHe+RcHI+xxeqDECqJ9tdXLyy9L7RqxyUaZKwmlAux+zEzdzITSRlr36YuSm0LBhTpkivodWytR6BNULFxftqF42QqKLmoog9WlYNRb4GtNm93bHuxBvV5VcOUeY6N/9xDutwbqYhaN3rIzpg1M6XfrYctTdA5Msr2v4Aydmb+Nl2/Eqw+jSXYvctmuDHYUAei0pUc6E5N1bULPEjHAr+HI3gwDjpDg0nE2fMkXneCumq9ifZR5IKUOqn0aDIfN64olrhaHfV4msozkdG/3j5HHqsf5Els8kwvDrCaK4/BXb+YzYC00mJEOu8njPsKgB9dG+FjqqeToCsJKLTvHS+iQTnqFquCJ+yCckuDaHLnP4GzroGg7BelrYZWStEFay3j+vkEuXHy3B2zG5xBqSx+/pxoEOv+OfiCfq5QMCCNq26xXC+1DZ+eQdH2jJ9FXSh9yrISZTk56jTzMIzG9+Ye+pumQffxmh2lcvPXjmNWL3PoOgRpkx4o/TZzE2y3IMtEZNxpNUlBqFlnBVXuPS0TIBkF+ZfvW3y2bGWD14zb8Cju5+wiSW1pIIRRtD0DeaxOLIvup5BZ2R2QfQVx6ryHH4H/rls/fRJy6KIdsJ/qVsWrBZaKgKOhP0GOUjA16wS+vlpcmot72SIWJWQDwyiD04TLSU6LyObtnOC2W5QA0OCGXHtlTi9Cyh95AIL8UU6AaQOaDSDfuf3DbxO4065WUdqPZ6Zj9S26jGlhDs/3mX1c4h+to5J2UwvgO3dkFtmKMBF3OuQvskMsOO8R5FnXblT4zMUpkjhs3m1ygag6zQWKfFOQCFM8jmAFtaCpCqDX77xqhE3B99uGU3UT+41SufAp9fQENvgk5lwqneywazIE9IpGT8v23sBPibAHG34mLWiivxnjk8p2S5ofshihnLQd4CU5ABpVcMX/5Hg39Jm55k+hgxugBCGIR5KmY+qz6US5/wKYimBbjTOSBlyD9OiYpWxtoLH6PcoaUdK0dW4vKR121dfMwumvgSBf8g0fsVN0w8jbplh7Df1FVC9wZuTbZStSswGJu6IngHRvBgOFag8F3hwPVNuUYjxNngNURuMvnnOvway+3l+1sK7aILbzdSzAxUCtG9/CaaHsBFIVzMWEH7upNL6Hr6P+oI4i+VqT6NyQrYUMkRXYd2P1ZjEMDaJ1rrurxTBgTfMw9cZe8SHIAz0JA7jpgDmr+InVbg0HrkFNZVhQ2uBKn75tLEZwfMp2azBhkglsAXDPx2BccwTDGmnsjRDh2jHh9ynTQY4vLqcuv/NWRlP8sFHWyxSmm38ikF1UoTywoZL0oFE4I4ujqIcvCuo+0ABPohIMdyq8EqgTcogXcYNCGdgvytDCA/fwt2eG78+OAANOgmKkOI8WdjE3FaFdqW6rx/oOBunJoqMLOwnPtv67Cw7PY8c4jFvek2G/hk1Thivu5Pf2iV8YDA8DyziBPz6MKlF9XQlRt7ZRV09nZrygwo00ME7IpFuOiEsUrd14UcCvNC/DPkbFmqB1uQIg477mFiq2niVADUYnvdjiQPNpFfMTo4yg4X+tDW3rmH2WE9E2rY0ES40wM6QRwaQL5/fepJULkj3Zc6L1ItuWmO6zXbvou399GBCPcQwB2+rRpubsw03qWL2iRyHH9Afl/YHuFYa8v7zEXDEigXJo9RAtTM4BTzElQhSgePv55AmHTo4W9v4SmkPDlLIhOpcXBK4GO2AnyzeN0MaKP7umX9bZAfc5LA84bxj3frYCxezbP9KG7QeJzevIhiAU4p/j+y2OyMV2mxNgAAAABJRU5ErkJggg==";
  var q_ = i(127), Z_ = i.n(q_);
  var J_ = i(128), K_ = i.n(J_);
  var Q_ = i(129), $_ = i.n(Q_);
  var ty = i(130), ey = i.n(ty);
  var iy = i(131), ny = i.n(iy);
  var ry = i(132), oy = i.n(ry);
  var sy = i(133), ay = i.n(sy);
  var ly = i(134), hy = i.n(ly);
  var uy = i(135), cy = i.n(uy);
  const dy = { wipe: class extends O_ {
    constructor(t2) {
      super(F_.a, L_.a, { percent: 0, direction: 1, transition: 0 });
      let e2 = 1;
      t2 === "up" ? e2 = 1 : t2 === "down" ? e2 = 2 : t2 === "left" ? e2 = 3 : t2 === "right" && (e2 = 4), this.uniforms.direction = e2;
    }
  }, fade: class extends O_ {
    constructor(t2) {
      super(void 0, U_.a, { percent: 0, transition: 1 });
      let e2 = 1;
      t2 === "out" ? e2 = -1 : t2 === "in" && (e2 = 1), this.uniforms.transition = Math.pow(e2, e2);
    }
  }, blinds: class extends O_ {
    constructor(t2) {
      super(j_.a, G_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "vertical" ? 1 : 0;
    }
  }, checkerboard: class extends O_ {
    constructor(t2) {
      super(j_.a, V_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "down" ? 1 : 0;
    }
  }, dissolve: class extends O_ {
    constructor(t2) {
      super(j_.a, W_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.setTextTure();
    }
    setTextTure() {
      this.uniforms.dissolveSampler = Vh.t.from(Y_);
    }
  }, randombar: class extends O_ {
    constructor(t2) {
      super(j_.a, Z_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "vertical" ? 1 : 0, this.setTextTure();
    }
    setTextTure() {
      this.uniforms.dissolveSampler = Vh.t.from(Y_);
    }
  }, circle: class extends O_ {
    constructor(t2) {
      super(j_.a, K_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "out" ? 1 : 0;
    }
  }, box: class extends O_ {
    constructor(t2) {
      super(j_.a, $_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "out" ? 1 : 0;
    }
  }, diamond: class extends O_ {
    constructor(t2) {
      super(j_.a, ey.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "out" ? 1 : 0;
    }
  }, plus: class extends O_ {
    constructor(t2) {
      super(j_.a, ny.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "out" ? 1 : 0;
    }
  }, barn: class extends O_ {
    constructor(t2) {
      super(j_.a, oy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "inHorizontal" ? 1 : t2 === "outHorizontal" ? 2 : t2 === "outVertical" ? 3 : 0;
    }
  }, strips: class extends O_ {
    constructor(t2) {
      super(j_.a, ay.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = t2 === "upLeft" ? 1 : t2 === "downRight" ? 2 : t2 === "upRight" ? 3 : 0;
    }
  }, wedge: class extends O_ {
    constructor(t2) {
      super(j_.a, hy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) });
    }
  }, wheel: class extends O_ {
    constructor(t2) {
      super(j_.a, cy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = Number(t2) || 1;
    }
  } };
  class py extends E_ {
    constructor(t2) {
      var e2;
      super(t2), this.filterType = "", this.isConflict = false, this.activeWhenConflict = "prev", this.onTimeUpdate = ({ duration: t3, delta: e3 }) => {
        var i3;
        const n3 = e3 / t3;
        if (this.filter) {
          this.filter.percent = this.commonTimeNode.applyTimeFilter(n3);
          const t4 = (i3 = this.timingTarget) === null || i3 === void 0 ? void 0 : i3.container.getBounds();
          t4 && (this.filter.uniforms.uBoundRect = new Float32Array([t4.x, t4.y, t4.width, t4.height]));
        }
        n3 >= 1 && this.timingTarget && this.ctx.clock.setTimeout(() => {
          this.removeFilter();
        }, 34);
      }, this.onSeekToStart = () => {
        this.timingTarget && this.removeFilter();
      }, this.onSeekToEnd = () => {
        this.timingTarget && this.removeFilter();
      }, this.onDestroy = () => {
        this.removeFilter();
      }, this.commonTimeNode.on("timelineStart", () => {
        this.filter && this.timingTarget && (this.timingTarget.container.filters && this.timingTarget.container.filters.length !== 0 ? this.timingTarget.container.filters.push(this.filter) : this.timingTarget.container.filters = [this.filter]);
      }), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
      let i2 = 1;
      t2.json.transition === "out" && (i2 = -1);
      const n2 = (e2 = t2.json.filter) === null || e2 === void 0 ? void 0 : e2.match(/^([a-zA-Z]+)(\((.+)\))?/);
      if (n2) {
        const t3 = n2[1], e3 = n2[3];
        dy[t3] && (this.filter = new dy[t3](e3), this.filterType = `${t3}-${e3}`, this.filter && (this.filter.transition = i2));
      }
    }
    get modifyAttrKey() {
      return this.filterType;
    }
    removeFilter() {
      var t2;
      if (!((t2 = this.timingTarget) === null || t2 === void 0 ? void 0 : t2.container.filters) || !this.filter)
        return;
      const e2 = this.timingTarget.container.filters.findIndex((t3) => t3 === this.filter);
      e2 >= 0 && this.timingTarget.container.filters.splice(e2, 1);
    }
  }
  class fy extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startPos = null, this.onTimeNodeStart = () => {
        var t3, e2;
        this.startPos = { x: ((t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.ppt_x) || 0, y: ((e2 = this.timingTarget) === null || e2 === void 0 ? void 0 : e2.ppt_y) || 0 };
      }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
        var i2;
        const n2 = e2 / t3, r2 = (i2 = this.path) === null || i2 === void 0 ? void 0 : i2.getPoint(n2);
        this.timingTarget && r2 && (this.timingTarget.ppt_x = r2.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r2.y + +this.timingTarget.design_ppt_y);
      }, this.onSeekToStart = () => {
        this.timingTarget && this.startPos && (this.timingTarget.ppt_x = this.startPos.x, this.timingTarget.ppt_y = this.startPos.y);
      }, this.onSeekToEnd = () => {
        var t3, e2, i2;
        const n2 = (e2 = (t3 = this.commonTimeNode.json) === null || t3 === void 0 ? void 0 : t3.spd) !== null && e2 !== void 0 ? e2 : 1, r2 = (i2 = this.path) === null || i2 === void 0 ? void 0 : i2.getPoint(n2 > 0 ? 1 : 0);
        this.timingTarget && r2 && (this.timingTarget.ppt_x = r2.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r2.y + this.timingTarget.design_ppt_y);
      }, this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart), this.createPath();
    }
    get modifyAttrKey() {
      return "motion";
    }
    createPath() {
      var t2;
      const e2 = new zs(), i2 = (t2 = this.json.path) === null || t2 === void 0 ? void 0 : t2.match(/[MLCmlc][^MLCmlc]+/g);
      if (i2)
        for (const t3 of i2) {
          const [i3, ...n2] = t3.trim().replace(/\s+/g, " ").split(" ");
          if (i3 === "M") {
            const [t4, i4] = n2.map((t5) => Number(t5));
            e2.moveTo(t4, i4);
          } else if (i3 === "L") {
            const [t4, i4] = n2.map((t5) => Number(t5));
            e2.lineTo(t4, i4);
          } else if (i3 === "C") {
            const [t4, i4, r2, o2, s2, a2] = n2.map((t5) => Number(t5));
            e2.bezierCurveTo(t4, i4, r2, o2, s2, a2);
          } else if (i3 === "Z")
            e2.closePath();
          else if (i3 === "E")
            console.warn("not implements");
          else if (i3 === "c") {
            const [t4, i4, r2, o2, s2, a2] = n2.map((t5) => Number(t5)), l2 = e2.currentPoint;
            e2.bezierCurveTo(t4 + l2.x, i4 + l2.y, r2 + l2.x, o2 + l2.y, s2 + l2.x, a2 + l2.y);
          } else if (i3 === "l") {
            const t4 = e2.currentPoint, [i4, r2] = n2.map((t5) => Number(t5));
            e2.lineTo(i4 + t4.x, r2 + t4.y);
          } else if (i3 === "m") {
            const t4 = e2.currentPoint, [i4, r2] = n2.map((t5) => Number(t5));
            e2.moveTo(i4 + t4.x, r2 + t4.y);
          }
        }
      this.path = e2;
    }
  }
  class my extends E_ {
    constructor(t2) {
      var e2;
      super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.onTimelineStart = (t3) => {
        t3.isReverse || this.updateCurrentValue();
      }, this.onTimeUpdate = ({ duration: t3, delta: e3 }) => {
        var i2, n2, r2, o2, s2;
        const a2 = e3 / t3, l2 = { x: 1, y: 1 };
        if (this.to) {
          const t4 = (i2 = this.from) !== null && i2 !== void 0 ? i2 : { x: (r2 = (n2 = this.startVal) === null || n2 === void 0 ? void 0 : n2.x) !== null && r2 !== void 0 ? r2 : 1, y: (s2 = (o2 = this.startVal) === null || o2 === void 0 ? void 0 : o2.y) !== null && s2 !== void 0 ? s2 : 1 };
          l2.x = t4.x + (this.to.x - t4.x) * a2, l2.y = t4.y + (this.to.y - t4.y) * a2;
        } else if (this.by) {
          const t4 = { x: this.by.x, y: this.by.y };
          l2.x = 1 + (t4.x - 1) * a2, l2.y = 1 + (t4.y - 1) * a2;
        }
        this.timingTarget && (this.timingTarget.scale = l2);
      }, this.onTimeNodeStart = () => {
        this.timingTarget && (this.startVal = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
      }, this.onSeekToStart = () => {
        this.timingTarget && this.startVal && (this.timingTarget.scale = this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.onDestroy = () => {
        this.createVal !== null && this.timingTarget && (this.timingTarget.scale = this.createVal);
      }, this.from = t2.json.from, this.to = t2.json.to, this.by = t2.json.by, this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart), ((e2 = this.timingTarget) === null || e2 === void 0 ? void 0 : e2.scale.x) && (this.createVal = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
    }
    get modifyAttrKey() {
      return "scale";
    }
    updateCurrentValue() {
      this.timingTarget && (this.current = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
    }
  }
  class gy extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.isTimelineStart = false, this.startColorString = null, this.currentColorString = "#FFFFFFFF", this.onTimelineStart = (t3) => {
        if (this.isTimelineStart)
          return;
        this.isTimelineStart = true, t3.isReverse || this.updateCurrentValue(), this.from.isInit() || this.from.fromHexString(this.currentColorString), this.to.isInit() || this.from.by(this.by, this.to);
        const e2 = this.json.cBhvr.attrList[0], [i2] = e2.split(".");
        b_(this.timingTarget, i2 + ".on", "true");
      }, this.onTimeNodeEnd = () => {
        const t3 = this.json.cBhvr.attrList[0];
        if (this.json.cBhvr.ctn.fill === "remove") {
          const [e2] = t3.split(".");
          b_(this.timingTarget, e2 + ".on", "false");
        }
        this.isTimelineStart = false;
      }, this.onSeekToStart = () => {
        var t3;
        const e2 = this.json.cBhvr.attrList[0];
        if (this.timingTarget) {
          this.onTimeUpdate({ duration: 1, delta: 0 });
          const i2 = e2 === "ppt_c.color" || e2 === "text.color";
          if (((t3 = this.timingTarget.fill) === null || t3 === void 0 ? void 0 : t3.designColor.toUpperCase()) === this.from.toHexString().toUpperCase() || i2) {
            const [t4] = e2.split(".");
            b_(this.timingTarget, t4 + ".on", "false");
          }
        }
      }, this.onTimeNodeStart = () => {
        if (this.timingTarget) {
          const t3 = this.json.cBhvr.attrList[0], e2 = T_(this.timingTarget, t3);
          e2 && (this.startColorString = e2);
        }
      }, this.onTimeUpdate = ({ delta: t3, duration: e2 }) => {
        const i2 = t3 / e2;
        if (this.to.interpolationFrom(this.from, i2, this.target), this.timingTarget) {
          const t4 = this.json.cBhvr.attrList[0];
          b_(this.timingTarget, t4, this.target.toHexString());
        }
      }, this.onSeekToEnd = () => {
        this.isTimelineStart || this.onTimelineStart({ isReverse: false, activeCount: 0, id: "" }), this.onTimeUpdate({ duration: 1, delta: 1 });
      }, this.replaceAttrToRelation(), this.json.clrSpc === "rgb" ? (this.from = new pg(this.json.from), this.to = new pg(this.json.to), this.by = new pg(this.json.by), this.target = new pg()) : (this.from = new dg(this.json.from), this.to = new dg(this.json.to), this.by = new dg(this.json.by), this.target = new dg()), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeEnd", this.onTimeNodeEnd), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart);
    }
    replaceAttrToRelation() {
      const t2 = this.json.cBhvr.attrList[0];
      t2 !== "ppt_c" ? t2 === "style.color" && (this.json.cBhvr.attrList[0] = "text.color") : this.json.cBhvr.attrList[0] = "ppt_c.color";
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
    updateCurrentValue() {
      if (this.timingTarget) {
        const t2 = this.json.cBhvr.attrList[0], e2 = T_(this.timingTarget, t2);
        e2 && (this.currentColorString = e2);
      }
    }
  }
  class vy extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.lastVal = null, this.onTimelineStart = (t3) => {
        this.lastVal = null, t3.isReverse || this.updateCurrentValue();
      }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
        const i2 = e2 / t3;
        let n2 = 0, r2 = 0;
        if (this.from !== void 0 && this.to !== void 0) {
          n2 = this.from, r2 = this.to;
          const t4 = n2 + (r2 - n2) * i2;
          this.timingTarget && (this.timingTarget.r = t4);
        } else if (this.by !== void 0) {
          this.lastVal || (this.lastVal = 0);
          const t4 = this.by * i2 - this.lastVal;
          this.lastVal = this.by * i2, this.timingTarget && (this.timingTarget.r += t4);
        }
      }, this.onTimeNodeCreate = () => {
        var t3;
        Vm()((t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.r) && (this.createVal = this.timingTarget.r);
      }, this.onTimeNodeStart = () => {
        var t3;
        Vm()((t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.r) && (this.startVal = this.timingTarget.r);
      }, this.onSeekToStart = () => {
        this.timingTarget && this.startVal !== null && (this.timingTarget.r = this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.onDestroy = () => {
        this.timingTarget && this.createVal !== null && (this.timingTarget.r = this.createVal), this.startVal = null;
      }, this.from = this.json.from, this.to = this.json.to, this.by = this.json.by, this.by ? this.isConflict = false : this.isConflict = true, this.onTimeNodeCreate(), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy);
    }
    get modifyAttrKey() {
      return "rotate";
    }
    updateCurrentValue() {
      var t2;
      this.currentVal = (t2 = this.timingTarget) === null || t2 === void 0 ? void 0 : t2.r;
    }
  }
  class _y extends E_ {
    constructor(t2) {
      super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.isApplied = false, this.onTimeUpdate = () => {
        var t3, e2;
        const { cmd: i2, cmdType: n2 } = this.json;
        !this.isApplied && i2 && n2 && (this.isApplied = true, (e2 = (t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.cmd) === null || e2 === void 0 || e2.applyCommand(i2, n2));
      }, this.onSeekToStart = () => {
        var t3, e2;
        this.commonTimeNode.isInInteractiveSeq || (e2 = (t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.cmd) === null || e2 === void 0 || e2.applyCommand("custom-pause", "call");
      }, this.onSeekToEnd = () => {
      }, this.commonTimeNode.on("timeNodeStart", () => {
        this.isApplied = false;
      }), this.commonTimeNode.on("timeNodeEnd", () => {
        this.isApplied = false;
      }), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("seekToStart", this.onSeekToStart), this.commonTimeNode.on("seekToEnd", this.onSeekToEnd);
    }
    get modifyAttrKey() {
      var t2, e2, i2, n2;
      return ((e2 = (t2 = this.json) === null || t2 === void 0 ? void 0 : t2.cmd) !== null && e2 !== void 0 ? e2 : "") + ((n2 = (i2 = this.json) === null || i2 === void 0 ? void 0 : i2.cmdType) !== null && n2 !== void 0 ? n2 : "");
    }
  }
  class yy {
    constructor(t2) {
      this.runtimeNodeEventHub = new Za.a(), this.onVolumeUpdate = (t3) => {
        this.audio.volume(t3);
      }, this.stopAudio = () => {
        this.audio.stop();
      }, this.destroy = () => {
        this.stopAudio(), this.audio.destroy(), this.ctx.activeMedia.delete(this.audio), this.ctx.volumeAdjuster.off("update", this.onVolumeUpdate);
      };
      const { json: e2, isIterate: i2, isSub: n2, eventHub: r2, ctx: o2, parent: s2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
      this.json = e2, this.id = e2.cMediaNode.ctn.id, this.commonTimeNode = new Ty({ json: e2.cMediaNode.ctn, isSub: n2, eventHubs: { global: r2, runtime: this.runtimeNodeEventHub }, ctx: o2, parent: s2, isIterate: i2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 });
      let d2 = e2.cMediaNode.tgtEl;
      o2.loaderDelegate && (d2 = o2.loaderDelegate.redirectMedia(d2), o2.logger.info(`redirect media url from ${e2.cMediaNode.tgtEl} to ${d2} by delegate.`, o2.taskId)), this.audio = new u_(d2, o2.runningAudio), o2.activeMedia.add(this.audio), this.commonTimeNode.on("timelineStart", () => {
        this.audio.volume(o2.volumeAdjuster.volume), this.audio.play();
      }), this.commonTimeNode.on("seekToStart", this.stopAudio), this.commonTimeNode.on("seekToEnd", this.stopAudio), this.commonTimeNode.on("timeNodeDestroy", this.destroy), this.ctx = o2, this.ctx.volumeAdjuster.on("update", this.onVolumeUpdate);
    }
  }
  function xy(t2) {
    return function(t3) {
      var e2;
      return !!((e2 = t3) === null || e2 === void 0 ? void 0 : e2.cBhvr);
    }(t2) ? t2.cBhvr.ctn : function(t3) {
      var e2, i2;
      return !!((i2 = (e2 = t3) === null || e2 === void 0 ? void 0 : e2.cMediaNode) === null || i2 === void 0 ? void 0 : i2.ctn);
    }(t2) ? t2.cMediaNode.ctn : t2.ctn;
  }
  var by = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Ty extends Za.a {
    constructor(t2) {
      var e2, i2;
      super(), this.uuid = Mm(), this.isSub = false, this.isShadow = false, this.startCount = 0, this.applyCount = 0, this.isReverse = false, this.isConflictDispose = false, this.isIterateEnd = false, this.parentTimeNode = null, this.isActive = false, this.isDestroy = false, this.shouldSeekOnStart = false, this.repeatTimeoutId = "", this.iterateShadows = [], this.isEndEventsEmitted = false, this.tmFilter = [], this.timeDelta = 0, this.isIterate = false, this.iterateType = "el", this.iterateIndex = 0, this.children = [], this.subList = [], this.duration = 0, this.isNegativeSpeed = false, this.handleEndCond = () => {
        this.isActive && (this.isActive = false, this.isInfiniteRepeat() ? this.repeatTimeNodeEnd() : this.seekToEnd(false, true));
      }, this.handleActive = (t3 = true) => {
        if (this.isActive = true, this.isConflictDispose = false, this.applyCount += 1, this.json.iterate || this.emit("timeNodeStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startCount > 0 && this.json.restart) {
          if (this.json.restart === "never")
            return;
          this.json.restart !== "whenNotActive" && this.json.restart !== "always" || (this.seekToStart(), this.emit("timeNodeRestart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startTimeLine(t3));
        } else
          this.startTimeLine(t3);
      }, this.updateTimeLine = (t3) => {
        const e3 = t3 / (xd.b.TARGET_FPMS || 0.06);
        this.timeDelta += e3, this.duration - this.timeDelta <= e3 && (this.timeDelta = this.duration), this.timeDelta < this.duration ? this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? this.duration - this.timeDelta : this.timeDelta, duration: this.duration, isReverse: this.isReverse }) : (this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? 0 : this.duration, duration: this.duration, isReverse: this.isReverse }), this.onTimeLineEnd());
      }, this.handleEnd = (t3 = false) => {
        (this.isTimeNodeEnd() || t3) && (this.isActive = false, this.isSub && this.destroy(), this.emitEndEvents());
      };
      const { isSub: n2, isIterate: r2, ctx: o2, eventHubs: s2, parent: a2, json: l2, iterateType: h2, iterateId: u2, iterateIndex: c2, isInInteractiveSeq: d2, fromSeqId: p2 } = t2;
      this.isSub = n2, this.fromSeqId = p2, this.isInInteractiveSeq = d2, this.isIterate = r2, this.parentTimeNode = a2, this.json = l2, this.ctx = o2, this.iterateIndex = c2, this.eventHubs = s2, this.iterateType = h2, this.iterateId = u2, this.tmFilter = (i2 = (e2 = l2.tmFilter) === null || e2 === void 0 ? void 0 : e2.split(";").map((t3) => t3.split(",").map((t4) => parseFloat(t4.trim())))) !== null && i2 !== void 0 ? i2 : [];
      const f2 = Number(this.json.dur), m2 = this.json.spd || 1;
      if (this.isNegativeSpeed = m2 < 0, Number.isNaN(f2) || (this.duration = f2 / Math.abs(m2)), this.uuid += "--" + this.json.id, this.setPreStyle(), l2.childTnLst && this.createChildren(l2.childTnLst), this.startConds = new y_(this.json.id || "", l2.stCondLst, s2, this.ctx), this.endConds = new y_(this.json.id || "", l2.endCondLst, s2, this.ctx), l2.endSync && (this.endSync = new y_(this.json.id || "", [l2.endSync], s2, this.ctx), this.endSync.on("active", () => {
        var t3;
        this.json.nodeType === "interactiveSeq" && (this.isActive = false, this.shouldSeekOnStart = true, this.emit("timeNodeEndSync"), (t3 = this.endSync) === null || t3 === void 0 || t3.reset());
      })), this.startConds.on("active", (t3) => {
        this.isActive || (this.shouldSeekOnStart && (this.shouldSeekOnStart = false, this.seekToStart()), this.handleActive(t3));
      }), this.endConds.on("active", () => {
        this.handleEndCond(), this.children.forEach((t3) => t3.commonTimeNode.handleEndCond());
      }), this.parentTimeNode && this.parentTimeNode.on("timeNodeStart", () => {
        this.applyCount = 0;
      }), this.isSub && this.json.masterRel === "nextClick") {
        const t3 = "shape slide onNext" + this.fromSeqId;
        this.startConds.addCond({ event: t3 });
      }
      this.json.iterate && this.isIterate === false && this.createIterateShadow();
    }
    createIterateShadow() {
      const t2 = Mm();
      let e2 = true, i2 = 0;
      const n2 = (i3) => {
        i3 === t2 && (e2 = false, this.ctx.eventHub.removeListener("IterateTimeNodeEnd", n2));
      };
      for (this.ctx.eventHub.on("IterateTimeNodeEnd", n2); e2; ) {
        const e3 = JSON.parse(JSON.stringify(this.json)), n3 = new Ty({ json: e3, isSub: false, eventHubs: this.eventHubs, ctx: this.ctx, parent: null, isIterate: true, iterateType: e3.iterate.type, iterateIndex: i2, iterateId: t2, isInInteractiveSeq: this.isInInteractiveSeq, fromSeqId: this.fromSeqId });
        this.iterateShadows[i2] = n3, i2 += 1;
      }
    }
    isInfiniteRepeat() {
      return this.json.repeatCount > 999999998;
    }
    getReverse() {
      return this.isReverse;
    }
    setReverse(t2) {
      this.isReverse = t2;
    }
    createTimeNode(t2, e2) {
      let i2 = null;
      const n2 = { json: t2, isSub: e2, isIterate: this.isIterate, eventHub: this.eventHubs.global, ctx: this.ctx, parent: this, iterateType: this.iterateType, iterateIndex: this.iterateIndex, iterateId: this.iterateId, isInInteractiveSeq: this.isInInteractiveSeq, fromSeqId: this.fromSeqId };
      return t2.type === "seq" ? i2 = new x_(n2) : t2.type === "par" ? i2 = new Ey(n2) : t2.type === "set" ? i2 = new S_(n2) : t2.type === "anim" ? i2 = new P_(n2) : t2.type === "animEffect" ? i2 = new py(n2) : t2.type === "animMotion" ? i2 = new fy(n2) : t2.type === "animScale" ? i2 = new my(n2) : t2.type === "animClr" ? i2 = new gy(n2) : t2.type === "animRot" ? i2 = new vy(n2) : t2.type === "cmd" ? i2 = new _y(n2) : t2.type === "audio" && (i2 = new yy(n2)), i2;
    }
    createSubList(t2) {
      this.subList && this.subList.forEach((t3) => t3.commonTimeNode.destroy()), this.subList = [], t2.forEach((t3) => {
        const e2 = this.createTimeNode(t3, true);
        e2 && this.subList.push(e2);
      });
    }
    bindCommonTimeNodeEvent(t2) {
      t2.commonTimeNode.on("timeNodeStart", (t3) => {
        this.emit("childTimeNodeStart", t3);
      }), t2.commonTimeNode.on("timeNodeEnd", (t3) => {
        this.emit("childTimeNodeEnd", t3), this.children.every((t4) => t4.commonTimeNode.isTimeNodeEndWhenDetectEndSync()) && (this.json.iterate || this.allChildrenEndHandle());
      });
    }
    createChildren(t2) {
      function e2(t3) {
        return xy(t3).presetOrder;
      }
      function i2(t3) {
        return /^slide/.test(t3) ? "slide" : /^layout/.test(t3) ? "layout" : /^master/.test(t3) ? "master" : "unknow";
      }
      const n2 = ["master", "layout", "slide", "unknow"];
      if (t2 && t2[0] && e2(t2[0])) {
        [...t2].sort((t3, r2) => {
          var o2, s2, a2, l2;
          const h2 = xy(t3).id, u2 = xy(r2).id;
          if (h2 && u2) {
            const a3 = i2(h2), l3 = i2(u2);
            if (a3 === l3)
              return ((o2 = e2(t3)) !== null && o2 !== void 0 ? o2 : 0) - ((s2 = e2(r2)) !== null && s2 !== void 0 ? s2 : 0);
            return n2.indexOf(a3) - n2.indexOf(l3);
          }
          return ((a2 = e2(t3)) !== null && a2 !== void 0 ? a2 : 0) - ((l2 = e2(r2)) !== null && l2 !== void 0 ? l2 : 0);
        }).forEach((t3) => {
          const e3 = this.createTimeNode(t3, false);
          e3 && (this.bindCommonTimeNodeEvent(e3), this.children.push(e3));
        });
      } else
        t2.forEach((t3) => {
          const e3 = this.createTimeNode(t3, false);
          e3 && (this.bindCommonTimeNodeEvent(e3), this.children.push(e3));
        });
    }
    playReverse() {
      this.isReverse = true, this.startReverseTimeLine(), this.children.forEach((t2) => t2.commonTimeNode.playReverse());
    }
    allChildrenEndHandle() {
      if (!this.isDestroy) {
        if (this.json.autoRev && !this.isReverse)
          return this.isReverse = true, void this.playReverse();
        this.isReverse && (this.isReverse = false), this.json.repeatCount && this.json.repeatCount > this.applyCount ? this.repeatTimeoutId = this.ctx.clock.setTimeout(() => {
          this.seekToStart(false), this.resetForRepeat(), this.startTimeNodeRepeat();
        }) : (this.json.iterate && !this.isIterate && (this.isIterateEnd = true), this.eventHubs.runtime.emit("runtime all end"), this.startSubList(), this.handleEnd());
      }
    }
    resetForRepeat() {
      this.isInInteractiveSeq && this.isInfiniteRepeat() && this.repeatTimeNodeEnd(), this.timeDelta = 0, this.children.forEach((t2) => t2.commonTimeNode.resetForRepeat());
    }
    startSubList() {
      this.subList.forEach((t2) => t2.commonTimeNode.startTimeNode());
    }
    startReverseTimeLine() {
      this.isEndEventsEmitted = false, this.timeDelta = 0;
      const t2 = 1e3 / this.ctx.ticker.maxFPS;
      this.duration <= t2 && this.duration > 0 ? (this.emit("timeUpdate", { delta: this.duration, duration: this.duration, isReverse: this.isReverse }), this.ctx.eventHub.emit(zy.animateEnd), this.ctx.ticker.remove(this.updateTimeLine)) : this.duration > t2 && (this.ctx.eventHub.emit(zy.animateStart), this.ctx.ticker.add(this.updateTimeLine));
    }
    startTimeLine(t2 = true) {
      if (t2 && (this.isEndEventsEmitted = false, this.eventHubs.global.emit(`time ${this.json.id} begin`), this.eventHubs.global.emit(`time ${this.json.id} onBegin`), this.eventHubs.runtime.emit(`runtime ${this.json.id} begin`)), this.json.iterate)
        return void this.startIterate();
      this.timeDelta = 0, this.emit("timelineStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
      const e2 = 1e3 / this.ctx.ticker.maxFPS;
      this.duration <= e2 && this.duration > 0 ? (this.timeDelta = this.isReverse ? 0 : this.duration, this.emit("timeUpdate", { delta: this.timeDelta, duration: this.duration, isReverse: this.isReverse }), this.emit("timelineEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.ctx.ticker.addOnce(() => {
        this.onTimeLineEnd();
      })) : this.duration > e2 && (this.ctx.eventHub.emit(zy.animateStart), this.updateTimeLine(0), this.ctx.ticker.add(this.updateTimeLine));
    }
    startIterate() {
      return by(this, void 0, void 0, function* () {
        if (this.json.iterate) {
          this.isIterateEnd = false;
          for (const t2 of this.iterateShadows) {
            if (this.isIterateEnd)
              break;
            t2.children.forEach((t3) => {
              t3.commonTimeNode.startTimeNode();
            }), t2.applyCount += 1, yield this.ctx.clock.delay(this.json.iterate.interval);
          }
          this.onTimeLineEnd();
        }
      });
    }
    applyTimeFilter(t2) {
      if (!this.tmFilter.every((t3) => Vm()(t3[0]) && Vm()(t3[1])))
        return t2;
      for (let e2 = 0; e2 < this.tmFilter.length; e2++) {
        const i2 = this.tmFilter[e2];
        if (t2 < i2[0]) {
          const n2 = this.tmFilter[e2 - 1];
          return (t2 - n2[0]) / (i2[0] - n2[0]) * (i2[1] - n2[1]) + n2[1];
        }
      }
      return this.tmFilter.length > 0 ? this.tmFilter[this.tmFilter.length - 1][1] : t2;
    }
    isNatureTimeEnd() {
      return this.duration >= 0 && this.timeDelta >= this.duration;
    }
    findTargets() {
      const t2 = [], e2 = (i2) => {
        i2.forEach((i3) => {
          var n2, r2, o2;
          i3.cBhvr && i3.cBhvr.target && t2.findIndex((t3) => t3.id === i3.cBhvr.target.id) < 0 && t2.push(i3.cBhvr.target), ((r2 = (n2 = i3 == null ? void 0 : i3.cBhvr) === null || n2 === void 0 ? void 0 : n2.ctn) === null || r2 === void 0 ? void 0 : r2.childTnLst) && i3.cBhvr.ctn.childTnLst.length > 0 && e2(i3.cBhvr.ctn.childTnLst), ((o2 = i3 == null ? void 0 : i3.ctn) === null || o2 === void 0 ? void 0 : o2.childTnLst) && i3.ctn.childTnLst.length > 0 && e2(i3.ctn.childTnLst);
        });
      };
      return e2(this.json.childTnLst || []), t2;
    }
    setPreStyle() {
      this.json.presetClass && this.findTargets().forEach((t2) => {
        if (this.json.iterate) {
          let e2 = 0, i2 = true;
          for (; i2; ) {
            const n2 = this.ctx.timingTargets.getTarget(t2, true, { type: this.json.iterate.type, index: e2, id: "" });
            n2 && (this.setPreStyleForTarget(n2), e2 += 1), i2 = !!n2;
          }
        } else {
          const e2 = this.ctx.timingTargets.getTarget(t2, false);
          e2 && this.setPreStyleForTarget(e2);
        }
      });
    }
    setPreStyleForTarget(t2) {
      var e2, i2;
      if (t2 && this.json.presetSubtype && (t2.presetSubType = this.json.presetSubtype), t2 && !t2.hasPreset)
        if (this.json.presetClass === "entr") {
          const n2 = (i2 = (e2 = this.json) === null || e2 === void 0 ? void 0 : e2.childTnLst) === null || i2 === void 0 ? void 0 : i2.filter((t3) => t3.type === "set" && t3.to === "visible");
          (n2 == null ? void 0 : n2.length) && (t2.hasPreset = true, t2.style.visibility = "hidden");
        } else
          (this.json.presetClass === "exit" || this.json.presetClass === "path" || this.json.presetClass === "emph") && (t2.hasPreset = true, t2.style.visibility = "visible");
    }
    startTimeNodeRepeat() {
      this.timeDelta = 0, this.isActive = true, this.applyCount += 1, this.startTimeLine(false), this.json.iterate || this.emit("timeNodeRepeat", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
    }
    startTimeNodeForce() {
      this.json.subTnLst && this.createSubList(this.json.subTnLst), this.timeDelta = 0, this.isActive = true, this.handleActive(false);
    }
    startTimeNode(t2 = true) {
      if (this.isDestroy)
        return;
      this.collectStartValue(), this.timeDelta = 0, this.isReverse = false, this.json.subTnLst && this.createSubList(this.json.subTnLst), this.startConds.setTriggerParams(t2);
      const e2 = this.json.stCondLst.filter((t3) => /^self/.test(t3.event || ""))[0];
      e2 && this.startConds.condHandle(e2);
      const i2 = this.json.endCondLst.filter((t3) => /^self/.test(t3.event || ""))[0];
      i2 && this.endConds.condHandle(i2), this.startConds.condHandle();
    }
    onTimeLineEnd() {
      this.dispose(), (this.children.length === 0 || this.json.iterate) && this.allChildrenEndHandle();
    }
    clearSubList() {
      this.subList.forEach((t2) => t2.commonTimeNode.destroy());
    }
    seekToStart(t2 = true) {
      if (this.isEndEventsEmitted = false, this.isActive = false, this.dispose(), this.timeDelta = 0, this.emit("seekToStart"), this.json.iterate && !this.isIterate)
        return this.isIterateEnd = true, void this.iterateShadows.forEach((e2) => e2.seekToStart(t2));
      if (t2)
        for (let t3 = this.subList.length - 1; t3 >= 0; t3--) {
          const e2 = this.subList[t3];
          e2 == null || e2.commonTimeNode.seekToStart();
        }
      for (let t3 = this.children.length - 1; t3 >= 0; t3--) {
        const e2 = this.children[t3];
        e2 == null || e2.commonTimeNode.seekToStart();
      }
      if (this.children.length > 1)
        for (let t3 = this.children.length - 1; t3 >= 0; t3--) {
          const e2 = this.children[t3];
          e2 == null || e2.commonTimeNode.seekToStart();
        }
    }
    repeatTimeNodeEnd() {
      this.dispose(), this.children.forEach((t2) => {
        t2.commonTimeNode.isActive = false, t2.commonTimeNode.dispose();
      });
    }
    dispose(t2 = false) {
      this.isConflictDispose = t2, this.ctx.clock.clearTimeout(this.repeatTimeoutId), this.ctx.eventHub.emit(zy.animateEnd);
      try {
        this.ctx.ticker.remove(this.updateTimeLine);
      } catch (t3) {
      }
      this.startConds.reset(), this.endConds.reset();
    }
    seekToEnd(t2, e2 = false) {
      if (this.isInfiniteRepeat())
        return;
      !this.isActive && this.applyCount <= 0 && this.collectStartValue(), this.applyCount = this.json.repeatCount, this.json.autoRev && (this.isReverse = true), this.timeDelta = this.duration, this.isActive = false, this.dispose();
      const i2 = this.json.autoRev || t2;
      if (i2 ? this.emit("seekToStart") : this.emit("seekToEnd"), this.json.iterate && !this.isIterate)
        return this.isIterateEnd = true, void this.iterateShadows.forEach((t3) => t3.seekToEnd(i2, e2));
      this.children.length === 0 && (this.eventHubs.runtime.emit("runtime all end"), this.handleEnd()), this.children.forEach((t3) => t3.commonTimeNode.seekToEnd(i2, e2)), e2 && this.json.subTnLst && (this.subList.length <= 0 && this.createSubList(this.json.subTnLst), this.subList.forEach((t3) => t3.commonTimeNode.seekToEnd(false)), this.clearSubList());
    }
    isTimeNodeEndWhenDetectEndSync() {
      if (this.isInInteractiveSeq && this.isInfiniteRepeat())
        return true;
      let t2 = true;
      return this.children.length > 0 && (t2 = t2 && this.children.every((t3) => t3.commonTimeNode.isTimeNodeEndWhenDetectEndSync())), this.json.repeatCount && (t2 = t2 && this.applyCount >= this.json.repeatCount), this.json.autoRev && (t2 = t2 && !this.isReverse), t2 = t2 && this.isNatureTimeEnd(), !!this.isConflictDispose || (!(!this.isIterateEnd || !this.json.iterate) || t2);
    }
    isTimeNodeEnd() {
      let t2 = true;
      return this.children.length > 0 && (t2 = t2 && this.children.every((t3) => t3.commonTimeNode.isTimeNodeEnd())), this.json.repeatCount && (t2 = t2 && this.applyCount >= this.json.repeatCount), this.json.autoRev && (t2 = t2 && !this.isReverse), t2 = t2 && this.isNatureTimeEnd(), !!this.isConflictDispose || (!(!this.isIterateEnd || !this.json.iterate) || t2);
    }
    emitEndEvents() {
      this.isEndEventsEmitted || (this.isEndEventsEmitted = true, this.eventHubs.global.emit(`time ${this.json.id} end`), this.eventHubs.global.emit(`time ${this.json.id} onEnd`), this.eventHubs.runtime.emit(`runtime ${this.json.id} end`), this.emit("timeNodeEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }));
    }
    collectStartValue() {
      this.emit("timeNodeCreate"), this.children.forEach((t2) => t2.commonTimeNode.collectStartValue());
    }
    destroy() {
      this.emit("timeNodeDestroy"), this.isDestroy = true, this.dispose(), this.startConds.removeAllListeners(), this.endConds.removeAllListeners(), this.children.forEach((t2) => t2.commonTimeNode.destroy()), this.clearSubList();
    }
  }
  class Ey extends Za.a {
    constructor(t2) {
      super(), this.isRunning = false, this.runtimeNodeEventHub = new Za.a();
      const { json: e2, iterateType: i2, isIterate: n2, isSub: r2, parent: o2, ctx: s2, eventHub: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
      this.id = e2.ctn.id, this.json = e2, this.ctx = s2, this.isIterate = n2, this.globalEventHub = a2, this.commonTimeNode = new Ty({ json: e2.ctn, isSub: r2, eventHubs: { global: a2, runtime: this.runtimeNodeEventHub }, ctx: s2, parent: o2, isIterate: false, iterateType: i2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 }), this.commonTimeNode.on("timeNodeStart", () => {
        this.commonTimeNode.children.forEach((t3) => {
          t3.commonTimeNode.setReverse(this.commonTimeNode.getReverse()), t3.commonTimeNode.startTimeNode();
        }), this.isRunning || (this.isRunning = true, this.globalEventHub.emit(`runtime ${this.id} begin`), this.emit("begin"));
      }), this.commonTimeNode.on("timeNodeRepeat", () => {
        this.commonTimeNode.children.forEach((t3) => {
          t3.commonTimeNode.startTimeNode(false);
        });
      }), this.commonTimeNode.on("timeNodeEnd", () => {
        this.commonTimeNode.isTimeNodeEnd() && this.isRunning && (this.isRunning = false, this.globalEventHub.emit(`runtime ${this.id} end`), this.emit("end")), this.commonTimeNode.json.presetClass === "exit" && this.commonTimeNode.children.length >= 1 && this.commonTimeNode.children[this.commonTimeNode.children.length - 1] instanceof S_ && this.commonTimeNode.children.forEach((t3) => {
          t3 instanceof S_ || typeof t3.onSeekToStart != "function" || t3.onSeekToStart();
        });
      });
    }
  }
  var Sy = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class wy {
    constructor(t2, e2, i2) {
      this.json = t2, this.ctx = i2, this.globalEventHub = e2;
      const n2 = t2.timeNodeList.find((t3) => t3.type === "par" && t3.ctn.nodeType === "tmRoot");
      n2 && (this.tmRoot = new Ey({ json: n2, isSub: false, isIterate: false, eventHub: e2, ctx: i2, parent: null, iterateType: "el", iterateIndex: 0, iterateId: "", isInInteractiveSeq: false, fromSeqId: "" }), this.mainSeq = this.tmRoot.commonTimeNode.children.find((t3) => {
        var e3, i3, n3;
        return ((e3 = t3.json) === null || e3 === void 0 ? void 0 : e3.type) === "seq" && ((n3 = (i3 = t3.json) === null || i3 === void 0 ? void 0 : i3.ctn) === null || n3 === void 0 ? void 0 : n3.nodeType) === "mainSeq";
      }));
    }
    findSeq(t2) {
      var e2;
      return (e2 = this.tmRoot) === null || e2 === void 0 ? void 0 : e2.commonTimeNode.children.find((e3) => {
        var i2, n2, r2;
        return ((i2 = e3.json) === null || i2 === void 0 ? void 0 : i2.type) === "seq" && ((r2 = (n2 = e3.json) === null || n2 === void 0 ? void 0 : n2.ctn) === null || r2 === void 0 ? void 0 : r2.id) === t2;
      });
    }
    start() {
      var t2, e2;
      return Sy(this, void 0, void 0, function* () {
        this.json.autoPlayMainSeq ? (yield this.ctx.clock.delay(16), (t2 = this.mainSeq) === null || t2 === void 0 || t2.commonTimeNode.startTimeNode()) : (e2 = this.mainSeq) === null || e2 === void 0 || e2.commonTimeNode.startTimeNode();
      });
    }
    setMainSeqApplied() {
      this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1);
    }
    collectMainSeqStartValue() {
      var t2;
      (t2 = this.mainSeq) === null || t2 === void 0 || t2.commonTimeNode.collectStartValue();
    }
    setMainSeqStep(t2, e2) {
      var i2;
      t2 === -1 && this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1), (i2 = this.mainSeq) === null || i2 === void 0 || i2.setCurrentStep(t2, e2);
    }
    destroy() {
      var t2;
      this.globalEventHub.removeAllListeners(), (t2 = this.tmRoot) === null || t2 === void 0 || t2.commonTimeNode.destroy();
    }
    hasMainSeq() {
      return !!this.mainSeq && this.mainSeq.commonTimeNode.children.length > 0;
    }
    currentMainSeqState() {
      return this.mainSeq ? this.mainSeq.currentState : null;
    }
    currentMainSeqStep() {
      return this.mainSeq ? this.mainSeq.currentStep : 0;
    }
    currentMainSeqLength() {
      return this.mainSeq ? this.mainSeq.stepLength : 0;
    }
    mainSeqHasNextStep() {
      return !!this.mainSeq && this.mainSeq.hasNext();
    }
    mainSeqHasPrevStep() {
      return !!this.mainSeq && this.mainSeq.hasPrev();
    }
    seekInteractiveSeqToEnd(t2) {
      const e2 = this.findSeq(t2);
      e2 && e2.commonTimeNode.seekToEnd(false, true);
    }
    setInteractiveSeqState(t2, e2, i2) {
      const n2 = this.findSeq(t2);
      n2 && n2.setCurrentStep(e2, i2);
    }
    resetAllInteractiveSeq() {
      var t2;
      (((t2 = this.tmRoot) === null || t2 === void 0 ? void 0 : t2.commonTimeNode.children.filter((t3) => {
        var e2, i2, n2;
        return ((e2 = t3.json) === null || e2 === void 0 ? void 0 : e2.type) === "seq" && ((n2 = (i2 = t3.json) === null || i2 === void 0 ? void 0 : i2.ctn) === null || n2 === void 0 ? void 0 : n2.nodeType) === "interactiveSeq";
      })) || []).forEach((t3) => {
        t3.setCurrentStep(0, "start");
      });
    }
    applyInteractiveAction(t2) {
      this.globalEventHub.emit(t2);
    }
  }
  var Ay = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class My extends __ {
    constructor(t2, e2, i2, n2) {
      super({ id: "stage", width: t2.width, height: t2.height, type: "Container", children: t2.children }, e2, { parentGlobalPos: i2 }, n2), this.isRendered = false, this.isTimingStartValueCollected = false, this.json = t2, this.json.smartArtShapeList && (e2.smartArtShapeList = this.json.smartArtShapeList), e2.hasBackgroundFillShape = this.detectUseBackgroundFill(this.json), this.container.visible = false, this.ctx = e2;
      const r2 = new Jd();
      r2.beginFill(16777215), r2.drawRect(0, 0, t2.width, t2.height), r2.endFill(), this.container.addChild(r2);
    }
    detectUseBackgroundFill(t2) {
      return !!t2 && (t2.type === "Picture" || t2.type === "Shape" ? t2.useBgFill : !(!t2.children || !Array.isArray(t2.children)) && t2.children.some((t3) => this.detectUseBackgroundFill(t3)));
    }
    initOnReuse() {
      super.initOnReuse(), this.ctx.timingEventHub.on("c:prev slide", (t2) => {
        this.ctx.eventHub.emit(zy.requestPrevSlide, t2);
      }), this.ctx.timingEventHub.on("c:next slide", (t2, e2) => {
        this.ctx.eventHub.emit(zy.requestNextSlide, t2, e2);
      });
    }
    get interactiveContainer() {
      return this.container;
    }
    render(t2) {
      if (this.isRendered)
        return;
      this.collectAnimatedIds().forEach((t3) => this.ctx.animatedIds.add(t3)), this.isRendered = true, super.render(t2), t2.addSubMTask(() => Ay(this, void 0, void 0, function* () {
        this.ctx.eventHub.emit("StageRenderEnd");
      }), "@StageImpl[emit.StageRenderEnd]");
    }
    isListTimeNode(t2) {
      return ["excel", "seq", "par"].indexOf(t2.type) >= 0;
    }
    isAnimatedTimeNode(t2) {
      return !!t2.cBhvr;
    }
    collectAnimatedIdsForTimeNode(t2, e2) {
      var i2;
      this.isListTimeNode(t2) ? (i2 = t2.ctn.childTnLst) === null || i2 === void 0 || i2.forEach((t3) => {
        this.collectAnimatedIdsForTimeNode(t3, e2);
      }) : this.isAnimatedTimeNode(t2) && e2.push(t2.cBhvr.target.id);
    }
    collectAnimatedIds() {
      const t2 = [];
      return this.json.timing && this.json.timing.timeNodeList.forEach((e2) => {
        this.collectAnimatedIdsForTimeNode(e2, t2);
      }), t2;
    }
    createTiming() {
      this.json.timing && !this.timing && (this.timing = new wy(this.json.timing, this.ctx.timingEventHub, this.ctx));
    }
    startTiming() {
      var t2;
      return ((t2 = this.timing) === null || t2 === void 0 ? void 0 : t2.start()) || Promise.resolve();
    }
    setMainSeqApplied() {
      var t2;
      (t2 = this.timing) === null || t2 === void 0 || t2.setMainSeqApplied();
    }
    setMainSeqStep(t2, e2) {
      var i2;
      (i2 = this.timing) === null || i2 === void 0 || i2.setMainSeqStep(t2, e2);
    }
    collectMainSeqStartValue() {
      var t2;
      this.isTimingStartValueCollected || (this.isTimingStartValueCollected = true, (t2 = this.timing) === null || t2 === void 0 || t2.collectMainSeqStartValue());
    }
    hasTiming() {
      return !!this.timing;
    }
    clearOnSlideChange() {
      this.ctx.eventHub.removeAllListeners(), this.ctx.timingEventHub.removeAllListeners(), super.clearOnSlideChange();
    }
    clearOnTransactionEnd() {
      var t2, e2;
      this.ctx.timingTargets.getTargets().forEach((t3) => {
        t3.hasPreset = false;
      }), (t2 = this.timing) === null || t2 === void 0 || t2.resetAllInteractiveSeq(), (e2 = this.timing) === null || e2 === void 0 || e2.destroy(), this.timing = void 0;
    }
    destroy() {
      var t2, e2;
      this.isTimingStartValueCollected = false, this.isRendered = false, this.ctx.eventHub.removeAllListeners(), this.ctx.graphicsTexture.destroy(), (t2 = this.ctx.bgTexture) === null || t2 === void 0 || t2.destroy(true), this.ctx.spriteTexture.destroy(), this.ctx.timingEventHub.removeAllListeners(), (e2 = this.timing) === null || e2 === void 0 || e2.destroy(), this.timing = void 0, super.destroy();
    }
    mainSeqStep() {
      var t2, e2;
      return (e2 = (t2 = this.timing) === null || t2 === void 0 ? void 0 : t2.currentMainSeqStep()) !== null && e2 !== void 0 ? e2 : 0;
    }
    mainSeqLength() {
      var t2, e2;
      return (e2 = (t2 = this.timing) === null || t2 === void 0 ? void 0 : t2.currentMainSeqLength()) !== null && e2 !== void 0 ? e2 : 0;
    }
    mainSeqHasNextStep() {
      var t2, e2;
      return (e2 = (t2 = this.timing) === null || t2 === void 0 ? void 0 : t2.mainSeqHasNextStep()) !== null && e2 !== void 0 && e2;
    }
    mainSeqHasPrevStep() {
      var t2, e2;
      return (e2 = (t2 = this.timing) === null || t2 === void 0 ? void 0 : t2.mainSeqHasPrevStep()) !== null && e2 !== void 0 && e2;
    }
    mainSeqState() {
      return this.timing ? this.timing.currentMainSeqState() : null;
    }
    nextStep(t2, e2) {
      var i2;
      this.hasTiming() && ((i2 = this.timing) === null || i2 === void 0 ? void 0 : i2.hasMainSeq()) ? (this.ctx.timingEventHub.emit("shape slide onStopAudio"), this.ctx.timingEventHub.emit("shape slide onNext", t2, e2)) : this.ctx.eventHub.emit(zy.requestNextSlide, t2, e2);
    }
    prevStep(t2 = false) {
      var e2;
      this.hasTiming() && ((e2 = this.timing) === null || e2 === void 0 ? void 0 : e2.hasMainSeq()) ? (this.ctx.timingEventHub.emit("shape slide onStopAudio"), this.ctx.timingEventHub.emit("shape slide onPrev", t2)) : this.ctx.eventHub.emit(zy.requestPrevSlide, t2);
    }
    applyInteractiveAction(t2) {
      var e2;
      (e2 = this.timing) === null || e2 === void 0 || e2.applyInteractiveAction(t2);
    }
    seekInteractiveSeqToEnd(t2) {
      var e2;
      (e2 = this.timing) === null || e2 === void 0 || e2.seekInteractiveSeqToEnd(t2);
    }
    setInteractiveSeqState(t2, e2, i2) {
      var n2;
      (n2 = this.timing) === null || n2 === void 0 || n2.setInteractiveSeqState(t2, e2, i2);
    }
    setMediaState(t2, e2, i2) {
      return Ay(this, void 0, void 0, function* () {
        const n2 = this.ctx.medias[t2];
        n2 && (e2 ? i2 ? (yield Pm(() => n2.clippedDuration > 0, 5e3), i2 < n2.clippedDuration && (n2.once("play", () => {
          n2.seek(i2);
        }), yield n2.play())) : yield n2.play() : (i2 && n2.seek(i2), yield n2.pause()));
      });
    }
    setMediaCurrentTime(t2, e2) {
      const i2 = this.ctx.medias[t2];
      i2 && i2.seek(e2);
    }
  }
  class Ry {
    constructor(t2) {
      this.ticker = t2, this.tasks = [], this.couldRunning = false, this.applyNext = () => {
        const t3 = this.tasks[0];
        t3 && t3.applyNext();
      }, t2.add(this.applyNext);
    }
    addTask(t2) {
      this.tasks.push(t2), t2.once("task-finish", () => {
        const e2 = this.tasks.indexOf(t2);
        e2 >= 0 && this.tasks.splice(e2, 1);
      }), t2.once("task-error", () => {
        const e2 = this.tasks.indexOf(t2);
        e2 >= 0 && this.tasks.splice(e2, 1);
      });
    }
    start() {
      this.couldRunning = true;
    }
    stop() {
      this.couldRunning = false;
    }
  }
  var Cy = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  const Iy = (t2) => new Promise((e2) => setTimeout(e2, t2));
  class Py extends Za.a {
    constructor(t2, e2, i2) {
      super(), this.slideIndex = t2, this.taskId = e2, this.logger = i2, this.uuid = Mm(), this.isCancel = false, this.tasks = [];
    }
    addMTask(t2, e2) {
      this.tasks.push({ fn: t2, state: "wait", sub: [], name: e2 });
    }
    addSubMTask(t2, e2) {
      let i2 = this.tasks.findIndex((t3) => t3.state === "running");
      i2 < 0 && (i2 = 0), this.tasks[i2].sub.push({ fn: t2, state: "wait", sub: [], name: e2 });
    }
    cancel() {
      this.tasks = [], this.isCancel = true;
    }
    applyNext() {
      if (this.tasks.some((t3) => t3.state === "running"))
        return;
      if (this.tasks.some((t3) => t3.state === "error"))
        return;
      if (this.tasks.every((t3) => t3.state === "finish"))
        return void (this.isCancel || this.emit("task-finish"));
      const t2 = this.tasks.find((t3) => t3.state === "wait");
      t2 && (t2.state = "running", t2.fn.apply(null).then(() => {
        if (t2.state = "finish", t2.sub.length > 0) {
          const e2 = this.tasks.findIndex((e3) => e3 === t2);
          this.tasks.splice(e2 + 1, 0, ...t2.sub);
        }
      }).catch((e2) => {
        t2.state = "error", this.logger.error(`${e2} ${e2.stack}`, this.taskId), this.emit("task-error", Tm.transform(e2), this.slideIndex);
      }));
    }
    applyAll() {
      return Cy(this, void 0, void 0, function* () {
        for (; !this.tasks.every((t2) => t2.state === "finish"); )
          if (this.tasks.some((t2) => t2.state === "running"))
            yield Iy(16);
          else {
            if (this.tasks.some((t2) => t2.state === "error"))
              return;
            {
              const t2 = this.tasks.find((t3) => t3.state === "wait");
              if (t2) {
                t2.state = "running";
                try {
                  if ((yield Im(() => t2.fn.apply(null), 6e4)) === Rm)
                    throw new Tm(gm.RuntimeError, `subtask ${t2.name} apply timeout`);
                  if (t2.state = "finish", t2.sub.length > 0) {
                    const e2 = this.tasks.findIndex((e3) => e3 === t2);
                    this.tasks.splice(e2 + 1, 0, ...t2.sub);
                  }
                } catch (e2) {
                  let i2;
                  i2 = (e2 == null ? void 0 : e2.errorType) ? e2 : new Tm(gm.RuntimeError, `subtask ${t2.name} error. ${e2}`), t2.state = "error", this.logger.error(`${e2} ${e2.stack}`, this.taskId), this.emit("task-error", Tm.transform(i2), this.slideIndex);
                  break;
                }
              }
            }
          }
        !this.isCancel && this.tasks.every((t2) => t2.state === "finish") && this.emit("task-finish");
      });
    }
  }
  var Oy = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Ny {
    constructor(t2, e2) {
      if (this.renderer = t2, this.localStorage = e2, this.outputData = /* @__PURE__ */ new Map(), this.loadingSdfKeys = /* @__PURE__ */ new Set(), !Ny.worker) {
        const t3 = new Blob(['\nself.onmessage = function(e) {\n    var data = e.data.data;\n    var key = e.data.key;\n    var height = Math.ceil(e.data.height);\n    var width = Math.ceil(e.data.width);\n    if (!data || !key) {\n        return;\n    }\n    var maxDis = 0;\n    var d = [];\n    var p = [];\n    var maxInt = Number.MAX_SAFE_INTEGER || 255 * 255 * 255;\n    var setD = function(x, y, v) { d[y * width + x] = v; };\n    var getD = function(x, y) { return d[y * width + x]; };\n    var setP = function(x, y, v) { p[y * width + x] = v; };\n    var getP = function(x, y) { return p[y * width + x]; };\n    var isContains = function(x, y) { return x >= 0 && x < width && y >= 0 && y < height; };\n    var isInterior = function(x, y) { return data[(y * width + x) * 4 + 3] > 10; };\n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            var c = isInterior(x, y);\n            var t = isContains(x, y - 1) ? isInterior(x, y - 1) : false;\n            var b = isContains(x, y + 1) ? isInterior(x, y + 1) : false;\n            var l = isContains(x - 1, y) ? isInterior(x - 1, y) : false;\n            var r = isContains(x + 1, y) ? isInterior(x + 1, y) : false;\n            if (c !== t || c !== b || c !== l || c !== r) {\n                setD(x, y, 0);\n                setP(x, y, [x, y]);\n            } else {\n                setD(x, y, maxInt);\n                setP(x, y, [-1, -1]);\n            }\n        }\n    }\n    \n    var f = function (x, y, dir) {\n        var d1 = 1;\n        var d2 = Math.sqrt(2);\n        var dx;\n        var dy;\n        var od;\n        switch (dir) {\n            case "TL": dx = -1; dy = -1; od = d2; break;\n            case "T": dx = 0; dy = -1; od = d1; break;\n            case "TR": dx = 1; dy = -1; od = d2; break;\n            case "L": dx = -1; dy = 0; od = d1; break;\n            case "R": dx = 1; dy = 0; od = d1; break;\n            case "BL": dx = -1; dy = 1; od = d2; break;\n            case "B": dx = 0; dy = 1; od = d1; break;\n            case "BR": dx = 1; dy = 1; od = d2; break;\n        }\n        var b = isContains(x + dx, y + dy);\n        var cb = b ? getD(x + dx, y + dy) : maxInt;\n        if (cb + od < getD(x, y)) {\n            var p = b ? getP(x + dx, y + dy) : [-1, -1];\n            var dis = Math.sqrt(Math.pow(x - p[0], 2) + Math.pow(y - p[1], 2));\n            setP(x, y, p);\n            setD(x, y, dis);\n            if (dis > maxDis) {\n                maxDis = dis;\n            }\n        }\n    };\n    \n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            var dirs = ["TL", "T", "TR", "L"];\n            for (var i = 0; i < dirs.length; ++ i) {\n                var dir = dirs[i];\n                f(x, y, dir);\n            }\n        }\n    }\n\n    for (var y = height - 1; y >= 0; -- y) {\n        for (var x = width - 1; x >= 0; -- x) {\n            var dirs = ["R", "BL", "B", "BR"];\n            for (var i = 0; i < dirs.length; ++ i) {\n                var dir = dirs[i];\n                f(x, y, dir);\n            }\n        }\n    }\n\n    var outputData = [];\n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            outputData.push(isInterior(x, y) ? 255: 0);\n            outputData.push(0);\n            outputData.push(0);\n            outputData.push(Math.ceil(getD(x, y) / maxDis * 255));\n        }\n    }\n    self.postMessage({\n        key, outputData, maxDis\n    });\n};\n'], { type: "text/javascript" });
        Ny.worker = new Worker(URL.createObjectURL(t3)), Ny.worker.onmessage = (t4) => {
          this.outputData.set(t4.data.key, { data: t4.data.outputData, maxDis: t4.data.maxDis });
        }, this.outputData.set("111", "222");
      }
    }
    createSdfByWorker(t2, e2, i2, n2, r2, o2, s2, a2) {
      const l2 = document.createElement("canvas");
      l2.width = r2, l2.height = o2;
      const h2 = l2.getContext("2d");
      if (!h2 || !Ny.worker)
        return;
      h2.drawImage(s2, t2, e2, i2, n2);
      const { data: u2 } = h2.getImageData(0, 0, r2, o2);
      Ny.worker.postMessage({ data: u2, key: a2, width: r2, height: o2 });
    }
    createSdf(t2, e2, i2) {
      const n2 = document.createElement("canvas");
      n2.width = t2, n2.height = e2;
      const r2 = n2.getContext("2d");
      if (!r2)
        return { src: "", maxDis: 1 };
      r2.drawImage(i2, 0, 0);
      let o2 = 0;
      const { data: s2 } = r2.getImageData(0, 0, t2, e2), a2 = [], l2 = [], h2 = function(e3, i3, n3) {
        a2[i3 * t2 + e3] = n3;
      }, u2 = function(e3, i3) {
        return a2[i3 * t2 + e3];
      }, c2 = function(e3, i3, n3) {
        l2[i3 * t2 + e3] = n3;
      }, d2 = function(e3, i3) {
        return l2[i3 * t2 + e3];
      }, p2 = function(i3, n3) {
        return i3 >= 0 && i3 < t2 && n3 >= 0 && n3 < e2;
      }, f2 = function(e3, i3) {
        return s2[4 * (i3 * t2 + e3) + 3] > 10;
      };
      for (let i3 = 0; i3 < e2; ++i3)
        for (let e3 = 0; e3 < t2; ++e3) {
          const t3 = f2(e3, i3), n3 = !!p2(e3, i3 - 1) && f2(e3, i3 - 1), r3 = !!p2(e3, i3 + 1) && f2(e3, i3 + 1), o3 = !!p2(e3 - 1, i3) && f2(e3 - 1, i3), s3 = !!p2(e3 + 1, i3) && f2(e3 + 1, i3);
          t3 !== n3 || t3 !== r3 || t3 !== o3 || t3 !== s3 ? (h2(e3, i3, 0), c2(e3, i3, [e3, i3])) : (h2(e3, i3, Number.MAX_SAFE_INTEGER), c2(e3, i3, [-1, -1]));
        }
      const m2 = function(t3, e3, i3) {
        const n3 = Math.sqrt(2);
        let r3, s3, a3;
        switch (i3) {
          case "TL":
            r3 = -1, s3 = -1, a3 = n3;
            break;
          case "T":
            r3 = 0, s3 = -1, a3 = 1;
            break;
          case "TR":
            r3 = 1, s3 = -1, a3 = n3;
            break;
          case "L":
            r3 = -1, s3 = 0, a3 = 1;
            break;
          case "R":
            r3 = 1, s3 = 0, a3 = 1;
            break;
          case "BL":
            r3 = -1, s3 = 1, a3 = n3;
            break;
          case "B":
            r3 = 0, s3 = 1, a3 = 1;
            break;
          case "BR":
            r3 = 1, s3 = 1, a3 = n3;
        }
        const l3 = p2(t3 + r3, e3 + s3);
        if ((l3 ? u2(t3 + r3, e3 + s3) : Number.MAX_SAFE_INTEGER) + a3 < u2(t3, e3)) {
          const i4 = l3 ? d2(t3 + r3, e3 + s3) : [-1, -1], n4 = Math.sqrt(Math.pow(t3 - i4[0], 2) + Math.pow(e3 - i4[1], 2));
          c2(t3, e3, i4), h2(t3, e3, n4), n4 > o2 && (o2 = n4);
        }
      };
      for (let i3 = 0; i3 < e2; ++i3)
        for (let e3 = 0; e3 < t2; ++e3) {
          const t3 = ["TL", "T", "TR", "L"];
          for (const n3 of t3)
            m2(e3, i3, n3);
        }
      for (let i3 = e2 - 1; i3 >= 0; --i3)
        for (let e3 = t2 - 1; e3 >= 0; --e3) {
          const t3 = ["R", "BL", "B", "BR"];
          for (const n3 of t3)
            m2(e3, i3, n3);
        }
      const g2 = [];
      for (let i3 = 0; i3 < e2; ++i3)
        for (let e3 = 0; e3 < t2; ++e3)
          g2.push(0, 0, 0, Math.ceil(u2(e3, i3) / o2 * 255));
      return r2.putImageData(new ImageData(Uint8ClampedArray.from(g2), t2, e2), 0, 0), { src: n2.toDataURL("image/png"), maxDis: o2 };
    }
    getSdf(t2, e2, i2) {
      return Oy(this, void 0, void 0, function* () {
        const n2 = Math.ceil(e2.width), r2 = Math.ceil(e2.height), o2 = Math.ceil(e2.width - t2.width) / 2, s2 = Math.ceil(e2.height - t2.height) / 2;
        let a2 = yield this.localStorage.getItem(`sdf-${i2}-src`), l2 = yield this.localStorage.getItem(`sdf-${i2}-maxDis`);
        if (!(a2 && l2 || this.loadingSdfKeys.has(i2))) {
          this.loadingSdfKeys.add(i2);
          const e3 = this.renderer.plugins.extract.image(t2, "image/png");
          e3.addEventListener("load", () => {
            this.createSdfByWorker(o2, s2, t2.width, t2.height, n2, r2, e3, i2);
          }), e3.addEventListener("error", () => null), yield Pm(() => !!this.outputData.has(i2), 2e3), this.loadingSdfKeys.delete(i2);
          const h2 = this.outputData.get(i2);
          if (h2) {
            this.outputData.delete(i2);
            const t3 = document.createElement("canvas");
            t3.width = n2, t3.height = r2;
            const e4 = t3.getContext("2d");
            if (!e4)
              return null;
            e4.putImageData(new ImageData(Uint8ClampedArray.from(h2.data), n2, r2), 0, 0), a2 = t3.toDataURL("image/png"), l2 = h2.maxDis, this.localStorage.setItem(`sdf-${i2}-src`, a2).catch(() => {
            }), this.localStorage.setItem(`sdf-${i2}-maxDis`, l2).catch(() => {
            });
          }
        }
        if (!a2 || !l2)
          return null;
        return document.createElement("img").src = a2, Vh.t.fromURL(a2).then((t3) => ({ texture: t3, maxDis: l2 })).catch(() => null);
      });
    }
  }
  Ny.worker = null;
  var Ly = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class Dy {
    constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2) {
      this.loader = t2, this.mode = e2, this.renderer = i2, this.ticker = n2, this.view = r2, this.clock = o2, this.objPoolGroup = s2, this.errorChannel = a2, this.localstorage = l2, this.logger = h2, this.loaderDelegate = u2, this.urlInterrupter = c2, this.isPlayerPaused = d2, this.maxResolution = p2, this.volumeAdjuster = f2, this.forceCanvas = m2, this.globalEventHub = g2, this.currentStageIndex = 0, this.cacheCount = r_.isDesktop() ? 2 : 1, this.stageStates = /* @__PURE__ */ Object.create(null), this.stageJsons = /* @__PURE__ */ Object.create(null), this.stageCtxs = /* @__PURE__ */ Object.create(null), this.stageImpls = /* @__PURE__ */ Object.create(null), this.taskId = "", this.url = "", this.runningAudio = /* @__PURE__ */ new Map(), this.activeMedia = /* @__PURE__ */ new Set(), this.microTaskManager = new Ry(n2), this.sdfManager = new Ny(i2, l2);
    }
    setResourceData(t2, e2) {
      this.taskId = t2, this.url = e2;
    }
    createCtx(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => Ly(this, void 0, void 0, function* () {
        const e3 = new Gm(this.loader), i2 = new Za.a(), n2 = { taskId: this.taskId, mode: this.mode, renderer: this.renderer, graphicsTexture: new Km(this.maxResolution), stageWidth: 0, stageHeight: 0, ticker: this.ticker, timingTargets: new $m(i2), eventHub: i2, view: this.view, medias: /* @__PURE__ */ Object.create(null), lastViewedIndex: 0, conflictTimeNodeManager: new Qm(), clock: this.clock, spriteTexture: e3, slideIndex: t2, objectPoolGroup: this.objPoolGroup, hasBackgroundFillShape: false, slideScopeEventHub: new Za.a(), logger: this.logger, sdfManager: this.sdfManager, loaderDelegate: this.loaderDelegate, runningAudio: this.runningAudio, activeMedia: this.activeMedia, isPlayerPaused: this.isPlayerPaused, timingEventHub: new Za.a(), maxResolution: this.maxResolution, animatedIds: /* @__PURE__ */ new Set(), volumeAdjuster: this.volumeAdjuster, forceCanvas: this.forceCanvas, globalEventHub: this.globalEventHub, latestChangeFullscreenTargetId: "", isRendering: false, urlInterrupter: this.urlInterrupter };
        this.stageCtxs[t2] = n2;
      }), "@StagePool[createCtx]");
    }
    loadStageJson(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => Ly(this, void 0, void 0, function* () {
        const e3 = yield this.loader.fetchJson(`${this.url}/${this.taskId}/jsonOutput/slide-${t2}.json`);
        this.stageJsons[t2] = e3, this.stageCtxs[t2].stageWidth = e3.width, this.stageCtxs[t2].stageHeight = e3.height, this.stageCtxs[t2].featureList = e3.featureList;
      }), "@StagePool[loadStageJson]");
    }
    loadSpriteSheets(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => {
        const i2 = this.stageJsons[t2], { spriteTexture: n2, stageWidth: r2, stageHeight: o2 } = this.stageCtxs[t2], { coloredSheets: s2, sheets: a2 } = i2, l2 = s2 || a2;
        return l2 && l2.forEach((t3) => {
          e2.addSubMTask(() => {
            let e3 = 1;
            if (r2 > this.maxResolution.x || o2 > this.maxResolution.y) {
              e3 = this.maxResolution.x / r2;
              const t4 = e3 * o2;
              t4 > this.maxResolution.y && (e3 *= this.maxResolution.y / t4);
            }
            return n2.loadSpriteSheetItem(this.url, this.taskId, t3, e3);
          }, "@StagePool[spriteTexture.loadSpriteSheetItem]");
        }), Promise.resolve();
      }, "@StagePool[loadSpriteSheets]");
    }
    createStage(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => {
        const i2 = this.stageJsons[t2], n2 = this.stageCtxs[t2], r2 = new My(i2, n2, { x: 0, y: 0 }, e2);
        return this.stageImpls[t2] = r2, Promise.resolve();
      }, "@StagePool[createStage]");
    }
    preRenderStage(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => (this.stageImpls[t2].preRender(e2), Promise.resolve()), "@StagePool[preRenderStage]");
    }
    createGraphicsTexture(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => Ly(this, void 0, void 0, function* () {
        const i2 = this.stageCtxs[t2];
        i2.graphicsTexture.pack().forEach((n2, r2) => {
          e2.addSubMTask(() => {
            const { stageWidth: e3, stageHeight: o2 } = this.stageCtxs[t2];
            let s2 = 1;
            if (e3 > this.maxResolution.x || o2 > this.maxResolution.y) {
              s2 = this.maxResolution.x / e3;
              const t3 = s2 * o2;
              t3 > this.maxResolution.y && (s2 *= this.maxResolution.y / t3);
            }
            return i2.graphicsTexture.render(n2, r2, this.objPoolGroup, s2);
          }, "@StagePool[graphicsTexture.render]");
        });
      }), "@StagePool[createGraphicsTexture]");
    }
    renderStage(t2) {
      const { task: e2 } = this.stageStates[t2];
      e2.addMTask(() => Ly(this, void 0, void 0, function* () {
        const i2 = this.stageImpls[t2];
        yield i2.render(e2);
      }), "@StagePool[renderStage]");
    }
    destroyStageByIndex(t2) {
      this.stageStates[t2].state === "load" && this.stageStates[t2].task.cancel(), delete this.stageStates[t2];
      this.stageImpls[t2].destroy(), delete this.stageImpls[t2], delete this.stageCtxs[t2];
    }
    destroyStage() {
      Object.keys(this.stageImpls).forEach((t2) => {
        const e2 = parseInt(t2, 10);
        Math.abs(this.currentStageIndex - e2) > this.cacheCount && this.destroyStageByIndex(e2);
      });
    }
    destroyAllStage() {
      Object.keys(this.stageImpls).forEach((t2) => {
        const e2 = parseInt(t2, 10);
        this.destroyStageByIndex(e2);
      });
    }
    preload(t2, e2 = false) {
      if (this.stageImpls[t2] || this.stageStates[t2])
        return Promise.resolve();
      const i2 = new Py(t2, this.taskId, this.logger);
      return i2.on("task-error", (t3, e3) => {
        delete this.stageStates[e3], delete this.stageImpls[e3], delete this.stageCtxs[e3], this.errorChannel.emit("error", t3, e3);
      }), this.stageStates[t2] = { state: "load", task: i2 }, this.createCtx(t2), this.loadStageJson(t2), this.loadSpriteSheets(t2), this.createStage(t2), this.preRenderStage(t2), this.createGraphicsTexture(t2), this.renderStage(t2), this.microTaskManager.addTask(i2), e2 ? i2.applyAll() : new Promise((e3) => {
        i2.once("task-finish", () => {
          this.stageStates[t2].state = "finish";
          Object.keys(this.stageStates).length > 2 * this.cacheCount + 1 && this.destroyStage(), e3();
        });
      });
    }
    getStageJson(t2) {
      return this.stageJsons[t2] || null;
    }
    getStage(t2) {
      return Ly(this, void 0, void 0, function* () {
        this.currentStageIndex = t2;
        const e2 = this.stageStates[t2];
        return (e2 == null ? void 0 : e2.state) === "finish" && this.stageImpls[t2] ? this.stageImpls[t2] : (e2 == null ? void 0 : e2.state) === "load" ? (yield e2.task.applyAll(), this.stageImpls[t2]) : (yield this.preload(t2, true), this.stageImpls[t2]);
      });
    }
    destroy() {
      this.runningAudio.clear();
    }
  }
  var Fy = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  class By {
    constructor(t2) {
      var e2;
      this.logger = t2, this.taskId = "", this.isIndexDBReady = false, this.memoryCache = /* @__PURE__ */ new Map(), (e2 = By.localCache) === null || e2 === void 0 || e2.ready((t3) => {
        t3 || (this.isIndexDBReady = true);
      }).catch(() => {
        t2.warn("local storage not ready", this.taskId);
      });
    }
    get couldUseIndexDBCache() {
      return this.isIndexDBReady && this.taskId.length > 0;
    }
    attachTaskId(t2) {
      this.taskId = t2;
    }
    getItem(t2) {
      return Fy(this, void 0, void 0, function* () {
        let e2 = null;
        if (this.couldUseIndexDBCache && By.localCache)
          try {
            e2 = yield Im(() => By.localCache.getItem(`${this.taskId}/${t2}`), 500);
          } catch (t3) {
          }
        return e2 = e2 === Rm ? null : e2, e2 || this.memoryCache.get(t2) || null;
      });
    }
    setItem(t2, e2, i2 = false) {
      return Fy(this, void 0, void 0, function* () {
        if (!this.couldUseIndexDBCache)
          return i2 && this.memoryCache.set(t2, e2), Promise.resolve();
        if (By.localCache) {
          let n2 = null;
          try {
            n2 = yield Im(() => By.localCache.setItem(`${this.taskId}/${t2}`, e2).catch(() => {
              i2 && this.memoryCache.set(t2, e2);
            }), 500);
          } catch (t3) {
          }
          n2 !== Rm && n2 !== null || !i2 || this.memoryCache.set(t2, e2);
        }
      });
    }
    dispose() {
      var t2;
      this.memoryCache = /* @__PURE__ */ new Map(), this.couldUseIndexDBCache && ((t2 = By.localCache) === null || t2 === void 0 || t2.keys().then((t3) => {
        t3.filter((t4) => t4.indexOf(this.taskId) >= 0).forEach((t4) => {
          var e2;
          (e2 = By.localCache) === null || e2 === void 0 || e2.removeItem(t4).catch(() => {
          });
        });
      }).catch(() => {
      }));
    }
  }
  By.localCache = null;
  try {
    By.localCache = o.createInstance({ name: "slide_local_cache", driver: o.INDEXEDDB, version: 1 });
  } catch (t2) {
  }
  const Uy = new Lh.j();
  class ky {
    constructor(t2) {
      this.localStorage = t2;
    }
    canvas(t2, e2, i2, n2) {
      let r2, o2, s2, a2 = false, l2 = false;
      t2 && (t2 instanceof Vh.p ? s2 = t2 : (s2 = e2.generateTexture(t2), l2 = true)), s2 ? (r2 = s2.baseTexture.resolution, o2 = s2.frame, a2 = false, e2.renderTexture.bind(s2)) : (r2 = e2.resolution, a2 = true, o2 = Uy, o2.width = e2.width, o2.height = e2.height, e2.renderTexture.bind(null));
      const h2 = Math.floor(o2.width * r2 + 1e-4), u2 = Math.floor(o2.height * r2 + 1e-4);
      let c2 = document.createElement("canvas");
      c2.width = h2, c2.height = u2;
      const d2 = c2.getContext("2d");
      if (!d2)
        throw new Error("ctx");
      if (i2)
        d2.putImageData(i2, 0, 0);
      else {
        const t3 = d2.getImageData(0, 0, h2, u2), i3 = new Uint8Array(4 * h2 * u2), { gl: s3 } = e2;
        s3.readPixels(o2.x * r2, o2.y * r2, h2, u2, s3.RGBA, s3.UNSIGNED_BYTE, i3), ky.arrayPostDivide(i3, t3.data), d2.putImageData(t3, 0, 0), n2 && this.localStorage.setItem(n2, t3).catch(() => {
        });
      }
      if (a2) {
        const t3 = document.createElement("canvas");
        t3.width = h2, t3.height = u2;
        const e3 = t3.getContext("2d");
        e3.scale(1, -1), e3.drawImage(c2, 0, -u2), c2 = t3;
      }
      return l2 && (s2 == null || s2.destroy(true)), c2;
    }
    static arrayPostDivide(t2, e2) {
      for (let i2 = 0; i2 < t2.length; i2 += 4) {
        const n2 = e2[i2 + 3] = t2[i2 + 3];
        n2 !== 0 ? (e2[i2] = Math.round(Math.min(255 * t2[i2] / n2, 255)), e2[i2 + 1] = Math.round(Math.min(255 * t2[i2 + 1] / n2, 255)), e2[i2 + 2] = Math.round(Math.min(255 * t2[i2 + 2] / n2, 255))) : (e2[i2] = t2[i2], e2[i2 + 1] = t2[i2 + 1], e2[i2 + 2] = t2[i2 + 2]);
      }
    }
  }
  class Gy extends Za.a {
    constructor() {
      super(...arguments), this._volume = 0.5;
    }
    get volume() {
      return this._volume;
    }
    set volume(t2) {
      t2 < 0 && (t2 = 0), t2 > 1 && (t2 = 1), this._volume = t2, this.emit("update", this._volume);
    }
  }
  var Hy = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  };
  Ph.skipHello();
  const jy = { randomBar: "RandomLines", circle: "Shape", ripple: "Ripples", wipe: "Erase", dissolve: "Dissolve", morph: "Smooth", fade: "FadeInOut", push: "Push", split: "Separation", reveal: "Display", pull: "Uncover", cover: "Cover", flash: "Flash", checker: "Checkerboard", blinds: "WindowShades", curtains: "Curtain", fallOver: "Fall", drape: "Suspension", wheel: "Clock", comb: "Combing", warp: "Scale", peelOff: "PeelOff", flip: "Flip", gallery: "Gallery", switch: "Switch", prism: "Prism", doors: "Doors" }, zy = { mainSeqStepChange: "mainSeqStepChange", mainSeqStateChange: "mainSeqStateChange", interactiveSeqStateChange: "interactiveSeqStateChange", interactiveSeqAction: "interactiveSeqAction", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", slideChange: "slideChange", renderStart: "renderStart", renderEnd: "renderEnd", hyperlinkTrigger: "hyperlinkTrigger", animateStart: "animateStart", animateEnd: "animateEnd", mediaSeek: "mediaSeek", mediaPlay: "mediaPlay", mediaPause: "mediaPause", mediaStop: "mediaStop", requestNextSlide: "requestNextSlide", requestPrevSlide: "requestPrevSlide", requestGotoSlide: "requestGotoSlide", requestOpenUrl: "requestOpenUrl", userInput: "userInput", fullscreenChange: "fullscreenChange", changeLocalFullscreenState: "changeLocalFullscreenState" };
  class Vy extends Za.a {
    constructor(t2, e2 = {}) {
      super(), this.errorChannel = new Za.a(), this.transactionPlayer = null, this.isForward = true, this.drawCall = 0, this.scale = 1, this._isPaused = false, this.maxResolution = new Lh.g(0, 0), this.isNVIDIA = false, this.fps = new bm(), this.designWidth = 0, this.designHeight = 0, this.currentIndex = 0, this.slideCount = 0, this.runtime = { drawCall: 0, fps: 0 }, this.globalEventHub = new Za.a(), this.globalVideoBackground = new Jd(), this.globalVideoSprite = new ep(), this.onMousemoveTimeout = null, this.cacheFunctionMap = /* @__PURE__ */ new Map(), this.isPlayerPaused = () => this._isPaused, this.onWebGLLost = () => {
        this.errorChannel.emit("error", new Tm(gm.CanvasCrash, "webgl context lost."));
      }, this.fullscreenOnMousemove = ({ index: t3, targetId: e3 }) => {
        this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: true }), this.onMousemoveTimeout && clearTimeout(this.onMousemoveTimeout), this.onMousemoveTimeout = setTimeout(() => {
          this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: false });
        }, a_.hoverHiddeDelay);
      }, this.fullscreenOnMouseleave = ({ index: t3, targetId: e3 }) => {
        this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: false });
      }, this.calculateFullscreenVideoPosition = (t3) => {
        const { width: e3, height: i3 } = t3, { designWidth: n3, designHeight: r2 } = this, o2 = Math.min(n3 / e3, r2 / i3);
        return { x: (n3 - e3 * o2) / 2, y: (r2 - i3 * o2) / 2, width: e3 * o2, height: i3 * o2 };
      }, this.onRequestFullscreenVideo = (t3) => {
        const { texture: e3, index: i3, targetId: n3 } = t3;
        if (i3 !== this.currentIndex)
          return void e3.destroy(false);
        this.onRequestCancelFullscreenVideo(), this.globalVideoBackground.width = this.designWidth, this.globalVideoBackground.height = this.designHeight, this.globalVideoBackground.beginFill(0, 1), this.globalVideoBackground.drawRect(0, 0, this.designWidth, this.designHeight), this.globalVideoBackground.endFill(), this.globalVideoBackground.interactive = true, this.app.stage.addChild(this.globalVideoBackground);
        const { x: r2, y: o2, width: s2, height: a2 } = this.calculateFullscreenVideoPosition(e3);
        this.globalVideoSprite.texture = e3, this.globalVideoSprite.width = s2, this.globalVideoSprite.height = a2, this.globalVideoSprite.position.x = r2, this.globalVideoSprite.position.y = o2, this.globalVideoBackground.addChild(this.globalVideoSprite), this.globalEventHub.emit("onFullscreenChange", { status: true, targetId: n3, slideIndex: this.currentIndex }), this.clearFullscreenEventListenersWithAppView();
        const l2 = { handleEvent: () => {
          var t4;
          (t4 = this.currentStage) === null || t4 === void 0 || t4.ctx.eventHub.emit(zy.userInput);
        } };
        if (this.app.view.addEventListener("pointerdown", l2, false), this.cacheFunctionMap.set("pointerdown", l2), r_.isDesktop()) {
          const t4 = { handleEvent: () => {
            this.fullscreenOnMouseleave({ index: i3, targetId: n3 });
          } };
          this.app.view.addEventListener("mouseout", t4, false);
          const e4 = { handleEvent: () => {
            this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: i3, targetId: n3, status: true });
          } };
          this.app.view.addEventListener("mouseover", e4, false);
          const r3 = { handleEvent: () => {
            this.fullscreenOnMousemove({ index: i3, targetId: n3 });
          } };
          this.app.view.addEventListener("mousemove", r3, false), this.cacheFunctionMap.set("mouseover", e4), this.cacheFunctionMap.set("mousemove", r3), this.cacheFunctionMap.set("mouseout", t4);
        } else {
          const t4 = { handleEvent: () => {
            this.fullscreenOnMousemove({ index: i3, targetId: n3 });
          } };
          this.app.view.addEventListener("touchstart", t4, false), this.cacheFunctionMap.set("touchstart", t4);
        }
      }, this.onRequestCancelFullscreenVideo = (t3 = false) => {
        var e3, i3;
        this.globalVideoSprite.texture.destroy(false), this.globalVideoBackground.removeChild(this.globalVideoSprite), this.app.stage.removeChild(this.globalVideoBackground), this.globalEventHub.emit("onFullscreenChange", { status: false, slideIndex: this.currentIndex, targetId: (e3 = this.currentStage) === null || e3 === void 0 ? void 0 : e3.ctx.latestChangeFullscreenTargetId }), this.clearFullscreenEventListenersWithAppView(), t3 && this.emit(zy.changeLocalFullscreenState, { status: false, slideIndex: this.currentIndex, targetId: (i3 = this.currentStage) === null || i3 === void 0 ? void 0 : i3.ctx.latestChangeFullscreenTargetId });
      }, this.logger = t2.logger, this.tracker = t2.tracker, this.mode = t2.mode, this.volumeAdjuster = t2.volumeAdjuster, this.localStorage = new By(this.logger), this.cachedExtract = new ky(this.localStorage), this.config = { minFPS: $a()(e2.minFPS) ? 30 : e2.minFPS, maxFPS: $a()(e2.maxFPS) ? 40 : e2.maxFPS, resolution: $a()(e2.resolution) ? 1 : e2.resolution, autoFPS: !$a()(e2.autoFPS) && e2.autoFPS, autoResolution: !$a()(e2.autoResolution) && e2.autoResolution, transactionBgColor: $a()(e2.transactionBgColor) ? 0 : e2.transactionBgColor, maxResolutionLevel: this.getMaxResolution(e2.maxResolutionLevel), forceCanvas: !$a()(e2.forceCanvas) && e2.forceCanvas, enableNvidiaDetect: !$a()(e2.enableNvidiaDetect) && e2.enableNvidiaDetect }, this.updateMaxResolutionLevel(this.config.maxResolutionLevel), this.loader = new Lm(this.localStorage, t2.useLocalCache, this.logger, this.tracker, t2.resourceTimeout, t2.loadDelegate, t2.urlInterrupter);
      const i2 = Ph.isWebGLSupported();
      this.app = new Xh({ antialias: true, autoDensity: false, backgroundColor: 16777215, forceCanvas: this.config.forceCanvas || !i2 }), this.tracker({ name: "slidePlayerCreate", result: "", reason: "", payload: { webgl: i2, resolution: this.config.resolution, minFPS: this.config.minFPS, maxFPS: this.config.maxFPS, maxResolutionLevel: this.config.maxResolutionLevel, forceCanvas: this.config.forceCanvas } }), this.updateConfig(this.config), this.app.ticker.maxFPS = 60, this.app.ticker.minFPS = this.config.minFPS, this.app.ticker.maxFPS = this.config.maxFPS, this.app.view.style.zIndex = "1", this.app.stage.sortableChildren = true;
      const n2 = this.app.renderer;
      if (n2.gl) {
        const { drawElements: t3 } = n2.gl, e3 = n2.gl.getExtension("WEBGL_debug_renderer_info"), i3 = n2.gl.getParameter(e3.UNMASKED_RENDERER_WEBGL);
        /nvidia/i.test(i3) && this.config.enableNvidiaDetect && (this.isNVIDIA = true), n2.gl.drawElements = (...e4) => {
          t3.call(n2.gl, ...e4), this.drawCall += 1;
        };
      }
      this.fps.on("update", (t3) => {
        if (t3 < this.config.minFPS) {
          if (this.config.autoResolution) {
            const t4 = 0.7 * this.scale, e3 = this.app.renderer.resolution, i3 = Math.max(t4, e3 - 0.1);
            i3 >= t4 && this.updateResolution(i3);
          }
        } else if (t3 > this.config.maxFPS && this.config.autoResolution) {
          const t4 = this.scale * this.config.resolution, e3 = this.app.renderer.resolution, i3 = Math.min(t4, e3 + 0.1);
          i3 <= this.config.resolution && this.updateResolution(i3);
        }
      }), this.app.ticker.add(() => {
        this.runtime.drawCall = this.drawCall, this.runtime.fps = Math.floor(this.app.ticker.minFPS), this.drawCall = 0;
      }, null, Dh.c.LOW), this.clock = new Fm(this.app.ticker), this.objPoolGroup = Mm(), this.stagePool = new Dy(this.loader, this.mode, this.app.renderer, this.app.ticker, this.app.view, this.clock, this.objPoolGroup, this.errorChannel, this.localStorage, this.logger, t2.loadDelegate, t2.urlInterrupter, this.isPlayerPaused, this.maxResolution, this.volumeAdjuster, this.config.forceCanvas, this.globalEventHub), this.app.view.addEventListener("webglcontextlost", this.onWebGLLost);
      try {
        this.config.forceCanvas || (this.transactionPlayer = new Ih());
      } catch (t3) {
        /Error creating WebGL context/.test(t3.message) ? this.errorChannel.emit("error", new Tm(gm.CanvasCrash, "webgl context lost.")) : this.errorChannel.emit("error", new Tm(gm.RuntimeWarn, t3.message));
      }
      this.globalEventHub.on("requestFullscreen", this.onRequestFullscreenVideo), this.globalEventHub.on("requestCancelFullscreen", this.onRequestCancelFullscreenVideo);
    }
    get view() {
      return this.app.renderer ? this.app.view : null;
    }
    get nextSlideIndex() {
      var t2;
      return ((t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.json.nextIndex) ? this.currentStage.json.nextIndex : this.currentIndex + 1;
    }
    get prevSlideIndex() {
      var t2;
      return ((t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.json.prevIndex) ? this.currentStage.json.prevIndex : this.currentIndex - 1;
    }
    getMaxResolution(t2) {
      return !$a()(t2) && Number.isInteger(t2) ? (t2 < 1 && (t2 = 1), t2 > 4 && (t2 = 4), t2) : Vy.platform.isAndroid() || Vy.platform.isIOS() ? 2 : 4;
    }
    updateMaxResolutionLevel(t2) {
      t2 < 0 && (t2 = 0), t2 > 4 && (t2 = 4);
      const e2 = [640, 960, 1280, 1920, 3200][t2], i2 = [360, 540, 720, 1080, 1800][t2];
      this.maxResolution.set(e2, i2);
    }
    updateConfig(t2) {
      $a()(t2.maxFPS) || $a()(t2.minFPS) || (this.config.maxFPS = t2.maxFPS, this.app.ticker.maxFPS = t2.maxFPS, this.config.minFPS = t2.minFPS, this.app.ticker.minFPS = t2.minFPS), $a()(t2.resolution) || (this.config.resolution = t2.resolution, this.updateResolution(this.scale * this.config.resolution)), $a()(t2.autoFPS) || (this.config.autoFPS = t2.autoFPS), $a()(t2.autoResolution) || (this.config.autoResolution = t2.autoResolution), $a()(t2.transactionBgColor) || (this.config.transactionBgColor = t2.transactionBgColor), this.taskId && this.logger.info("ppt player update config: " + JSON.stringify(this.config), this.taskId), $a()(t2.maxResolutionLevel) || (this.config.maxResolutionLevel = t2.maxResolutionLevel, this.updateMaxResolutionLevel(this.config.maxResolutionLevel));
    }
    preload(t2) {
      return Hy(this, void 0, void 0, function* () {
        t2 < 1 || t2 > this.slideCount || (this.logger.info(`preload slide ${t2} begin`, this.taskId), yield this.stagePool.preload(t2), this.logger.info(`preload slide ${t2} end`, this.taskId));
      });
    }
    setResourceData(t2, e2) {
      this.logger.info("ppt player init config: " + JSON.stringify(this.config), t2), this.logger.info("set resource to " + e2, t2), this.taskId = t2, this.url = e2, this.stagePool.setResourceData(t2, e2), this.localStorage.attachTaskId(t2), this.loader.attachTaskId(t2);
    }
    setInteractive(t2) {
      this.app.stage.interactive = t2, this.app.stage.interactiveChildren = t2;
    }
    translateEvent(t2, e2) {
      e2.forEach((e3) => {
        t2.on(e3, (...t3) => {
          var i2, n2, r2, o2;
          e3 === zy.requestGotoSlide && t3[0] !== this.currentIndex && ((n2 = (i2 = this.currentStage) === null || i2 === void 0 ? void 0 : i2.timing) === null || n2 === void 0 || n2.setMainSeqStep(0, "start"), (o2 = (r2 = this.currentStage) === null || r2 === void 0 ? void 0 : r2.timing) === null || o2 === void 0 || o2.destroy()), this.emit(e3, ...t3);
        });
      });
    }
    renderSlide(t2) {
      var e2, i2, n2;
      return Hy(this, void 0, void 0, function* () {
        if (this._isPaused)
          return void this.logger.info("ppt play prevent render slide with paused state", this.taskId);
        const r2 = this.currentIndex, o2 = Date.now();
        this.logger.info("render slide " + t2, this.taskId), this.emit(zy.renderStart, t2);
        const s2 = yield this.stagePool.getStage(t2), a2 = `snapshot-${t2}-${this.isForward ? "start" : "end"}`, l2 = yield this.localStorage.getItem(a2);
        if (!s2)
          return;
        s2.ctx.isRendering = true, this.translateEvent(s2.ctx.eventHub, [zy.mainSeqStepChange, zy.mainSeqStateChange, zy.hyperlinkTrigger, zy.interactiveSeqAction, zy.mainSeqStepStart, zy.mainSeqStepEnd, zy.animateStart, zy.animateEnd, zy.mediaPlay, zy.mediaPause, zy.mediaSeek, zy.mediaStop, zy.requestGotoSlide, zy.requestOpenUrl, zy.requestNextSlide, zy.requestPrevSlide, zy.interactiveSeqStateChange, zy.userInput, zy.fullscreenChange, zy.changeLocalFullscreenState]), this.currentIndex = Number(t2);
        const { width: h2, height: u2, slideCount: c2 } = s2.json;
        this.slideCount = c2, this.designWidth = h2, this.designHeight = u2, (e2 = this.currentStage) === null || e2 === void 0 || e2.clearOnSlideChange();
        const d2 = this.currentStage;
        this.currentStage = s2, s2.initOnReuse(), s2.createTiming(), s2.container.visible = true, s2.collectMainSeqStartValue(), this.isForward ? s2.setMainSeqStep(0, "start") : s2.setMainSeqStep(-1, "end"), this.onRequestCancelFullscreenVideo(true);
        let p2 = false;
        if (Ph.isWebGLSupported() && !this.config.forceCanvas && s2.json.transition && s2.json.transition.type && this.app.stage.children.length > 0 && this.view && d2) {
          let { transition: t3 } = s2.json;
          !this.isForward && (d2 == null ? void 0 : d2.json.transition) && (t3 = d2.json.transition);
          const e3 = this.getTransactionTexture(d2, this.view, null, null);
          this.initTransactionPlayer(t3), (i2 = this.transactionPlayer) === null || i2 === void 0 || i2.setPrevTexture(e3), p2 = true;
        }
        if (this.app.stage.addChild(s2.container), this.updateResolution(this.config.resolution * this.scale), d2 && (d2.clearOnTransactionEnd(), this.app.stage.removeChild(d2.container)), s2.json.transition && s2.json.transition.type && this.app.stage.children.length > 0 && this.view && this.transactionPlayer && p2) {
          const t3 = yield this.getTransactionTexture(s2, this.view, a2, l2);
          this.transactionPlayer.setNextTexture(t3), yield this.transactionPlayer.play();
          const e3 = this.transactionPlayer.renderer.domElement;
          if (this.view.parentElement && e3)
            try {
              this.view.parentElement.removeChild(e3);
            } catch (t4) {
            }
          (n2 = this.transactionPlayer) === null || n2 === void 0 || n2.dispose();
        }
        this.isForward ? yield s2.startTiming() : s2.setMainSeqApplied(), s2.ctx.slideScopeEventHub.emit("slide-render", s2.ctx.slideIndex), this.emit(zy.renderEnd, t2), this.emit(zy.slideChange, t2), s2.ctx.isRendering = false, this.preload(t2 + 1).catch((e3) => {
          this.errorChannel.emit("error", Tm.transform(e3), t2 + 1);
        }), this.preload(t2 - 1).catch((e3) => {
          this.errorChannel.emit("error", Tm.transform(e3), t2 - 1);
        }), this.logger.info(`render slide ${t2} done, time: ${Date.now() - o2}ms`, this.taskId), this.tracker({ name: "slidePageChange", reason: "", result: "", payload: { duration: Date.now() - o2, from: r2, to: t2 } });
      });
    }
    getTransactionTexture(t2, e2, i2, n2) {
      const r2 = Vh.p.create({ width: t2.json.width, height: t2.json.height, resolution: 1 });
      this.app.renderer.render(t2.container, { renderTexture: r2 });
      const o2 = this.cachedExtract.canvas(r2, this.app.renderer, n2, i2);
      return new b(o2);
    }
    renderToBase64(t2, e2, i2) {
      return Hy(this, void 0, void 0, function* () {
        const n2 = yield this.stagePool.getStage(t2);
        if (n2) {
          const { width: r2, height: o2 } = n2.json;
          this.designWidth = r2, this.designHeight = o2;
          const s2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: e2 });
          n2.container.visible = true, this.app.renderer.render(n2.container, { renderTexture: s2 });
          const a2 = this.app.renderer.plugins.extract.base64(s2, i2);
          return this.stagePool.destroyStageByIndex(t2), a2;
        }
        return "__null__";
      });
    }
    renderMainSeqToBase64(t2, e2, i2) {
      return Hy(this, void 0, void 0, function* () {
        const n2 = [], r2 = yield this.stagePool.getStage(t2);
        if (r2.createTiming(), r2) {
          const { width: t3, height: o2 } = r2.json;
          this.designWidth = t3, this.designHeight = o2;
          const s2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: e2 });
          r2.container.visible = true;
          const a2 = r2.mainSeqLength();
          r2.setMainSeqStep(0, "start"), this.app.renderer.render(r2.container, { renderTexture: s2 });
          const l2 = this.app.renderer.plugins.extract.base64(s2, i2);
          n2.push(l2);
          for (let t4 = 0; t4 < a2; t4 += 1) {
            r2.setMainSeqStep(t4, "end"), this.app.renderer.render(r2.container, { renderTexture: s2 });
            const e3 = this.app.renderer.plugins.extract.base64(s2, i2);
            n2.push(e3);
          }
        }
        return n2;
      });
    }
    snapshotWithTimingEnd(t2) {
      return Hy(this, void 0, void 0, function* () {
        const e2 = yield this.stagePool.getStage(t2);
        if (e2) {
          const { width: i2, height: n2 } = e2.json;
          this.designWidth = i2, this.designHeight = n2;
          const r2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: 1 });
          e2.container.visible = true, e2.initOnReuse(), e2.createTiming(), e2.collectMainSeqStartValue(), e2.setMainSeqStep(-1, "end"), this.app.renderer.render(e2.container, { renderTexture: r2 });
          const o2 = this.app.renderer.plugins.extract.base64(r2, "image/png");
          return t2 !== this.currentIndex && this.stagePool.destroyStageByIndex(t2), o2;
        }
        return null;
      });
    }
    getBase64(t2) {
      if (!t2.container.transform)
        return null;
      const e2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: 1 });
      this.app.renderer.render(t2.container, { renderTexture: e2 });
      const i2 = this.app.renderer.plugins.extract.base64(e2, "image/jpeg");
      return e2.destroy(true), i2;
    }
    initTransactionPlayer(t2) {
      var e2, i2, n2, r2, o2;
      const s2 = (e2 = this.view) === null || e2 === void 0 ? void 0 : e2.parentElement;
      if (this.view && s2 && jy[t2.type] && this.transactionPlayer) {
        const e3 = (i2 = this.transactionPlayer) === null || i2 === void 0 ? void 0 : i2.renderer.domElement;
        this.transactionPlayer.initPlayer({ reverse: !this.isForward, stageWidth: this.view.width, stageHeight: this.view.height, presetType: jy[t2.type], duration: (r2 = (n2 = this.currentStage) === null || n2 === void 0 ? void 0 : n2.json.transition) === null || r2 === void 0 ? void 0 : r2.dur, delay: 0, clearColor: this.config.transactionBgColor, maxFPS: Math.ceil((o2 = this.config.maxFPS) !== null && o2 !== void 0 ? o2 : 60), options: t2.options }), e3 && (e3.style.position = "absolute", e3.style.zIndex = "9", e3.style.left = "0", e3.style.top = "0", e3.style.width = this.view.style.width, e3.style.height = this.view.style.height), s2.appendChild(e3);
      }
    }
    scaleView(t2, e2, i2) {
      var n2;
      this.view && (this.view.style.width = Math.floor(this.designWidth * t2) + "px", this.view.style.height = Math.floor(this.designHeight * t2) + "px");
      const r2 = (n2 = this.transactionPlayer) === null || n2 === void 0 ? void 0 : n2.renderer.domElement;
      if (r2 && this.view && (r2.style.width = this.view.style.width, r2.style.height = this.view.style.height), e2) {
        this.scale = t2;
        const e3 = this.scale * this.config.resolution;
        this.updateResolution(e3, i2);
      }
    }
    updateResolution(t2, e2) {
      this.app.ticker.addOnce(() => {
        let i2 = r_.isDesktop() ? t2 : 1;
        for (; i2 * this.designWidth > this.maxResolution.x || i2 * this.designHeight > this.maxResolution.y; )
          i2 -= 0.1;
        this.app.renderer.resolution = i2, this.app.renderer.plugins.interaction.resolution = this.app.renderer.resolution, this.app.renderer.resize(this.designWidth, this.designHeight), Ka()(e2) && e2();
      });
    }
    nextStep(t2, e2) {
      var i2;
      if (this._isPaused)
        this.logger.info("ppt play prevent next step with paused state", this.taskId);
      else {
        this.logger.info("ppt play trigger next step", this.taskId);
        try {
          this.onRequestCancelFullscreenVideo(true), (i2 = this.currentStage) === null || i2 === void 0 || i2.nextStep(t2, e2);
        } catch (t3) {
          this.errorChannel.emit("error", Tm.transform(t3), this.currentIndex);
        }
      }
    }
    prevStep(t2 = false) {
      var e2;
      if (this._isPaused)
        this.logger.info("ppt play prevent prev step with paused state", this.taskId);
      else {
        this.logger.info("ppt play trigger prev step", this.taskId);
        try {
          this.onRequestCancelFullscreenVideo(true), (e2 = this.currentStage) === null || e2 === void 0 || e2.prevStep(t2);
        } catch (t3) {
          this.errorChannel.emit("error", Tm.transform(t3), this.currentIndex);
        }
      }
    }
    mainSeqLength() {
      var t2, e2;
      return (e2 = (t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.mainSeqLength()) !== null && e2 !== void 0 ? e2 : 0;
    }
    mainSeqStep() {
      var t2, e2;
      return (e2 = (t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.mainSeqStep()) !== null && e2 !== void 0 ? e2 : 0;
    }
    setMainSeqStep(t2, e2) {
      var i2;
      (i2 = this.currentStage) === null || i2 === void 0 || i2.setMainSeqStep(t2, e2);
    }
    mainSeqState() {
      var t2, e2;
      return (e2 = (t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.mainSeqState()) !== null && e2 !== void 0 ? e2 : null;
    }
    mainSeqHasNextStep() {
      var t2, e2;
      return (e2 = (t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.mainSeqHasNextStep()) !== null && e2 !== void 0 && e2;
    }
    mainSeqHasPrevStep() {
      var t2, e2;
      return (e2 = (t2 = this.currentStage) === null || t2 === void 0 ? void 0 : t2.mainSeqHasPrevStep()) !== null && e2 !== void 0 && e2;
    }
    nextTick(t2) {
      this.app.ticker.addOnce(() => {
        t2();
      }, Dh.c.LOW);
    }
    applyInteractiveAction(t2) {
      var e2;
      (e2 = this.currentStage) === null || e2 === void 0 || e2.applyInteractiveAction(t2);
    }
    seekInteractiveSeqToEnd(t2) {
      var e2;
      (e2 = this.currentStage) === null || e2 === void 0 || e2.seekInteractiveSeqToEnd(t2);
    }
    setInteractiveSeqState(t2, e2, i2) {
      var n2;
      (n2 = this.currentStage) === null || n2 === void 0 || n2.setInteractiveSeqState(t2, e2, i2);
    }
    setMediaState(t2, e2, i2) {
      var n2;
      return Hy(this, void 0, void 0, function* () {
        yield (n2 = this.currentStage) === null || n2 === void 0 ? void 0 : n2.setMediaState(t2, e2, i2);
      });
    }
    setMediaCurrentTime(t2, e2) {
      var i2;
      (i2 = this.currentStage) === null || i2 === void 0 || i2.setMediaCurrentTime(t2, e2);
    }
    pause() {
      var t2;
      this.app.ticker.stop(), (t2 = this.currentStage) === null || t2 === void 0 || t2.ctx.activeMedia.forEach((t3) => {
        t3.globalPause();
      }), this._isPaused = true;
    }
    resume() {
      var t2;
      this._isPaused = false, this.app.ticker.start(), (t2 = this.currentStage) === null || t2 === void 0 || t2.ctx.activeMedia.forEach((t3) => {
        t3.globalResume();
      });
    }
    getSnapshot() {
      return this.currentStage && this.getBase64(this.currentStage) || "";
    }
    clearLocalCache() {
      this.localStorage.dispose();
    }
    static clearLocalCache() {
      var t2;
      (t2 = By.localCache) === null || t2 === void 0 || t2.clear().catch(() => {
      });
    }
    clearFullscreenEventListenersWithAppView() {
      ["mousemove", "mouseout", "mouseover", "touchstart", "pointerdown"].forEach((t2) => {
        this.cacheFunctionMap.has(t2) && (this.app.view.removeEventListener(t2, this.cacheFunctionMap.get(t2), false), this.cacheFunctionMap.delete(t2));
      });
    }
    syncFullscreenVideoState(t2) {
      this.globalEventHub.emit("syncFullscreenVideoState", t2);
    }
    destroy() {
      var t2, e2;
      try {
        this.app.view.removeEventListener("webglcontextlost", this.onWebGLLost), this.app.renderer.filter.texturePool.clear(true), qm.collectObjectByGroup(this.objPoolGroup), Zm.collectObjectByGroup(this.objPoolGroup), (t2 = this.transactionPlayer) === null || t2 === void 0 || t2.destroy(), this.loader.destroy(), this.fps.destroy(), this.stagePool.destroyAllStage(), this.stagePool.destroy(), this.app.renderer.gl.getExtension("WEBGL_lose_context").loseContext(), this.app.destroy(true, { children: true, texture: true, baseTexture: true }), (e2 = Ny.worker) === null || e2 === void 0 || e2.terminate(), this.tracker({ name: "slidePlayerDestroy", result: "", reason: "", payload: {} });
      } catch (t3) {
      }
    }
  }
  Vy.platform = r_, Vy.RtcAudioClazz = null;
  var Xy = /* @__PURE__ */ new Map();
  var Wy, Yy = i(136), qy = i.n(Yy), Zy = i(49), Jy = i.n(Zy), Ky = i(50), Qy = i.n(Ky), $y = [], tx = "ResizeObserver loop completed with undelivered notifications.";
  !function(t2) {
    t2.BORDER_BOX = "border-box", t2.CONTENT_BOX = "content-box", t2.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
  }(Wy || (Wy = {}));
  var ex, ix = function(t2) {
    return Object.freeze(t2);
  }, nx = function(t2, e2) {
    this.inlineSize = t2, this.blockSize = e2, ix(this);
  }, rx = function() {
    function t2(t3, e2, i2, n2) {
      return this.x = t3, this.y = e2, this.width = i2, this.height = n2, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ix(this);
    }
    return t2.prototype.toJSON = function() {
      var t3 = this;
      return { x: t3.x, y: t3.y, top: t3.top, right: t3.right, bottom: t3.bottom, left: t3.left, width: t3.width, height: t3.height };
    }, t2.fromRect = function(e2) {
      return new t2(e2.x, e2.y, e2.width, e2.height);
    }, t2;
  }(), ox = function(t2) {
    return t2 instanceof SVGElement && "getBBox" in t2;
  }, sx = function(t2) {
    if (ox(t2)) {
      var e2 = t2.getBBox(), i2 = e2.width, n2 = e2.height;
      return !i2 && !n2;
    }
    var r2 = t2, o2 = r2.offsetWidth, s2 = r2.offsetHeight;
    return !(o2 || s2 || t2.getClientRects().length);
  }, ax = function(t2) {
    var e2;
    if (t2 instanceof Element)
      return true;
    var i2 = (e2 = t2 == null ? void 0 : t2.ownerDocument) === null || e2 === void 0 ? void 0 : e2.defaultView;
    return !!(i2 && t2 instanceof i2.Element);
  }, lx = typeof window != "undefined" ? window : {}, hx = /* @__PURE__ */ new WeakMap(), ux = /auto|scroll/, cx = /^tb|vertical/, dx = /msie|trident/i.test(lx.navigator && lx.navigator.userAgent), px = function(t2) {
    return parseFloat(t2 || "0");
  }, fx = function(t2, e2, i2) {
    return t2 === void 0 && (t2 = 0), e2 === void 0 && (e2 = 0), i2 === void 0 && (i2 = false), new nx((i2 ? e2 : t2) || 0, (i2 ? t2 : e2) || 0);
  }, mx = ix({ devicePixelContentBoxSize: fx(), borderBoxSize: fx(), contentBoxSize: fx(), contentRect: new rx(0, 0, 0, 0) }), gx = function(t2, e2) {
    if (e2 === void 0 && (e2 = false), hx.has(t2) && !e2)
      return hx.get(t2);
    if (sx(t2))
      return hx.set(t2, mx), mx;
    var i2 = getComputedStyle(t2), n2 = ox(t2) && t2.ownerSVGElement && t2.getBBox(), r2 = !dx && i2.boxSizing === "border-box", o2 = cx.test(i2.writingMode || ""), s2 = !n2 && ux.test(i2.overflowY || ""), a2 = !n2 && ux.test(i2.overflowX || ""), l2 = n2 ? 0 : px(i2.paddingTop), h2 = n2 ? 0 : px(i2.paddingRight), u2 = n2 ? 0 : px(i2.paddingBottom), c2 = n2 ? 0 : px(i2.paddingLeft), d2 = n2 ? 0 : px(i2.borderTopWidth), p2 = n2 ? 0 : px(i2.borderRightWidth), f2 = n2 ? 0 : px(i2.borderBottomWidth), m2 = c2 + h2, g2 = l2 + u2, v2 = (n2 ? 0 : px(i2.borderLeftWidth)) + p2, _2 = d2 + f2, y2 = a2 ? t2.offsetHeight - _2 - t2.clientHeight : 0, x2 = s2 ? t2.offsetWidth - v2 - t2.clientWidth : 0, b2 = r2 ? m2 + v2 : 0, T2 = r2 ? g2 + _2 : 0, E2 = n2 ? n2.width : px(i2.width) - b2 - x2, S2 = n2 ? n2.height : px(i2.height) - T2 - y2, w2 = E2 + m2 + x2 + v2, A2 = S2 + g2 + y2 + _2, M2 = ix({ devicePixelContentBoxSize: fx(Math.round(E2 * devicePixelRatio), Math.round(S2 * devicePixelRatio), o2), borderBoxSize: fx(w2, A2, o2), contentBoxSize: fx(E2, S2, o2), contentRect: new rx(c2, l2, E2, S2) });
    return hx.set(t2, M2), M2;
  }, vx = function(t2, e2, i2) {
    var n2 = gx(t2, i2), r2 = n2.borderBoxSize, o2 = n2.contentBoxSize, s2 = n2.devicePixelContentBoxSize;
    switch (e2) {
      case Wy.DEVICE_PIXEL_CONTENT_BOX:
        return s2;
      case Wy.BORDER_BOX:
        return r2;
      default:
        return o2;
    }
  }, _x = function(t2) {
    var e2 = gx(t2);
    this.target = t2, this.contentRect = e2.contentRect, this.borderBoxSize = ix([e2.borderBoxSize]), this.contentBoxSize = ix([e2.contentBoxSize]), this.devicePixelContentBoxSize = ix([e2.devicePixelContentBoxSize]);
  }, yx = function(t2) {
    if (sx(t2))
      return 1 / 0;
    for (var e2 = 0, i2 = t2.parentNode; i2; )
      e2 += 1, i2 = i2.parentNode;
    return e2;
  }, xx = function() {
    var t2 = 1 / 0, e2 = [];
    $y.forEach(function(i3) {
      if (i3.activeTargets.length !== 0) {
        var n3 = [];
        i3.activeTargets.forEach(function(e3) {
          var i4 = new _x(e3.target), r2 = yx(e3.target);
          n3.push(i4), e3.lastReportedSize = vx(e3.target, e3.observedBox), r2 < t2 && (t2 = r2);
        }), e2.push(function() {
          i3.callback.call(i3.observer, n3, i3.observer);
        }), i3.activeTargets.splice(0, i3.activeTargets.length);
      }
    });
    for (var i2 = 0, n2 = e2; i2 < n2.length; i2++) {
      (0, n2[i2])();
    }
    return t2;
  }, bx = function(t2) {
    $y.forEach(function(e2) {
      e2.activeTargets.splice(0, e2.activeTargets.length), e2.skippedTargets.splice(0, e2.skippedTargets.length), e2.observationTargets.forEach(function(i2) {
        i2.isActive() && (yx(i2.target) > t2 ? e2.activeTargets.push(i2) : e2.skippedTargets.push(i2));
      });
    });
  }, Tx = function() {
    var t2, e2 = 0;
    for (bx(e2); $y.some(function(t3) {
      return t3.activeTargets.length > 0;
    }); )
      e2 = xx(), bx(e2);
    return $y.some(function(t3) {
      return t3.skippedTargets.length > 0;
    }) && (typeof ErrorEvent == "function" ? t2 = new ErrorEvent("error", { message: tx }) : ((t2 = document.createEvent("Event")).initEvent("error", false, false), t2.message = tx), window.dispatchEvent(t2)), e2 > 0;
  }, Ex = [], Sx = function(t2) {
    if (!ex) {
      var e2 = 0, i2 = document.createTextNode("");
      new MutationObserver(function() {
        return Ex.splice(0).forEach(function(t3) {
          return t3();
        });
      }).observe(i2, { characterData: true }), ex = function() {
        i2.textContent = "".concat(e2 ? e2-- : e2++);
      };
    }
    Ex.push(t2), ex();
  }, wx = 0, Ax = { attributes: true, characterData: true, childList: true, subtree: true }, Mx = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], Rx = function(t2) {
    return t2 === void 0 && (t2 = 0), Date.now() + t2;
  }, Cx = false, Ix = new (function() {
    function t2() {
      var t3 = this;
      this.stopped = true, this.listener = function() {
        return t3.schedule();
      };
    }
    return t2.prototype.run = function(t3) {
      var e2 = this;
      if (t3 === void 0 && (t3 = 250), !Cx) {
        Cx = true;
        var i2, n2 = Rx(t3);
        i2 = function() {
          var i3 = false;
          try {
            i3 = Tx();
          } finally {
            if (Cx = false, t3 = n2 - Rx(), !wx)
              return;
            i3 ? e2.run(1e3) : t3 > 0 ? e2.run(t3) : e2.start();
          }
        }, Sx(function() {
          requestAnimationFrame(i2);
        });
      }
    }, t2.prototype.schedule = function() {
      this.stop(), this.run();
    }, t2.prototype.observe = function() {
      var t3 = this, e2 = function() {
        return t3.observer && t3.observer.observe(document.body, Ax);
      };
      document.body ? e2() : lx.addEventListener("DOMContentLoaded", e2);
    }, t2.prototype.start = function() {
      var t3 = this;
      this.stopped && (this.stopped = false, this.observer = new MutationObserver(this.listener), this.observe(), Mx.forEach(function(e2) {
        return lx.addEventListener(e2, t3.listener, true);
      }));
    }, t2.prototype.stop = function() {
      var t3 = this;
      this.stopped || (this.observer && this.observer.disconnect(), Mx.forEach(function(e2) {
        return lx.removeEventListener(e2, t3.listener, true);
      }), this.stopped = true);
    }, t2;
  }())(), Px = function(t2) {
    !wx && t2 > 0 && Ix.start(), !(wx += t2) && Ix.stop();
  }, Ox = function() {
    function t2(t3, e2) {
      this.target = t3, this.observedBox = e2 || Wy.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 };
    }
    return t2.prototype.isActive = function() {
      var t3, e2 = vx(this.target, this.observedBox, true);
      return t3 = this.target, ox(t3) || function(t4) {
        switch (t4.tagName) {
          case "INPUT":
            if (t4.type !== "image")
              break;
          case "VIDEO":
          case "AUDIO":
          case "EMBED":
          case "OBJECT":
          case "CANVAS":
          case "IFRAME":
          case "IMG":
            return true;
        }
        return false;
      }(t3) || getComputedStyle(t3).display !== "inline" || (this.lastReportedSize = e2), this.lastReportedSize.inlineSize !== e2.inlineSize || this.lastReportedSize.blockSize !== e2.blockSize;
    }, t2;
  }(), Nx = function(t2, e2) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t2, this.callback = e2;
  }, Lx = /* @__PURE__ */ new WeakMap(), Dx = function(t2, e2) {
    for (var i2 = 0; i2 < t2.length; i2 += 1)
      if (t2[i2].target === e2)
        return i2;
    return -1;
  }, Fx = function() {
    function t2() {
    }
    return t2.connect = function(t3, e2) {
      var i2 = new Nx(t3, e2);
      Lx.set(t3, i2);
    }, t2.observe = function(t3, e2, i2) {
      var n2 = Lx.get(t3), r2 = n2.observationTargets.length === 0;
      Dx(n2.observationTargets, e2) < 0 && (r2 && $y.push(n2), n2.observationTargets.push(new Ox(e2, i2 && i2.box)), Px(1), Ix.schedule());
    }, t2.unobserve = function(t3, e2) {
      var i2 = Lx.get(t3), n2 = Dx(i2.observationTargets, e2), r2 = i2.observationTargets.length === 1;
      n2 >= 0 && (r2 && $y.splice($y.indexOf(i2), 1), i2.observationTargets.splice(n2, 1), Px(-1));
    }, t2.disconnect = function(t3) {
      var e2 = this, i2 = Lx.get(t3);
      i2.observationTargets.slice().forEach(function(i3) {
        return e2.unobserve(t3, i3.target);
      }), i2.activeTargets.splice(0, i2.activeTargets.length);
    }, t2;
  }(), Bx = function() {
    function t2(t3) {
      if (arguments.length === 0)
        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
      if (typeof t3 != "function")
        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
      Fx.connect(this, t3);
    }
    return t2.prototype.observe = function(t3, e2) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!ax(t3))
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
      Fx.observe(this, t3, e2);
    }, t2.prototype.unobserve = function(t3) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!ax(t3))
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
      Fx.unobserve(this, t3);
    }, t2.prototype.disconnect = function() {
      Fx.disconnect(this);
    }, t2.toString = function() {
      return "function ResizeObserver () { [polyfill code] }";
    }, t2;
  }(), Ux = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  }, kx = function(t2, e2) {
    var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
      if (1 & r2[0])
        throw r2[1];
      return r2[1];
    }, trys: [], ops: [] };
    return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function a2(o3) {
      return function(a3) {
        return function(o4) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s2; )
            try {
              if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done)
                return r2;
              switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                case 0:
                case 1:
                  r2 = o4;
                  break;
                case 4:
                  return s2.label++, { value: o4[1], done: false };
                case 5:
                  s2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = s2.ops.pop(), s2.trys.pop();
                  continue;
                default:
                  if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                    s2 = 0;
                    continue;
                  }
                  if (o4[0] === 3 && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                    s2.label = o4[1];
                    break;
                  }
                  if (o4[0] === 6 && s2.label < r2[1]) {
                    s2.label = r2[1], r2 = o4;
                    break;
                  }
                  if (r2 && s2.label < r2[2]) {
                    s2.label = r2[2], s2.ops.push(o4);
                    break;
                  }
                  r2[2] && s2.ops.pop(), s2.trys.pop();
                  continue;
              }
              o4 = e2.call(t2, s2);
            } catch (t3) {
              o4 = [6, t3], n2 = 0;
            } finally {
              i2 = r2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, a3]);
      };
    }
  }, Gx = function() {
    function t2(t3, e2, i2, n2, r2) {
      this.state = "idle", this.index = -1, this.slideIndex = -1, this.fn = i2, this.index = t3, this.slideIndex = e2, this.eventHub = n2, this.id = r2;
    }
    return t2.prototype.apply = function() {
      return Ux(this, void 0, void 0, function() {
        var t3;
        return kx(this, function(e2) {
          switch (e2.label) {
            case 0:
              this.eventHub.emit("task-start", this), e2.label = 1;
            case 1:
              return e2.trys.push([1, 3, , 4]), this.state = "start", [4, this.fn()];
            case 2:
              return e2.sent(), this.state = "end", this.eventHub.emit("task-end", this), [3, 4];
            case 3:
              return t3 = e2.sent(), this.eventHub.emit("task-error", { task: this, error: t3 }), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }, t2;
  }(), Hx = function() {
    function t2() {
      var t3 = this;
      this.eventHub = new Za.a(), this.tasks = [], this.index = 0, this.eventHub.on("task-end", function(e2) {
        var i2, n2 = t3.tasks.findIndex(function(t4) {
          return t4.index === e2.index;
        }), r2 = n2 + 1;
        r2 >= 0 && ((i2 = t3.tasks[r2]) === null || i2 === void 0 || i2.apply()), n2 >= 0 && (t3.tasks.splice(n2, 1), t3.replaceIdleTask()), t3.eventHub.emit("task-end-" + e2.id);
      }), this.eventHub.on("task-error", function(e2) {
        var i2 = e2.task, n2 = t3.tasks.findIndex(function(t4) {
          return t4.index === i2.index;
        });
        n2 >= 0 && (t3.tasks.splice(n2, 1), t3.replaceIdleTask());
      });
    }
    return t2.prototype.replaceIdleTask = function() {
      for (var t3, e2 = this, i2 = /* @__PURE__ */ new Set(), n2 = 0, r2 = this.tasks.length; n2 < r2; n2++)
        this.tasks[n2].state === "idle" && ((t3 = this.tasks[n2 + 1]) === null || t3 === void 0 ? void 0 : t3.state) === "idle" && i2.add(n2);
      Array.from(i2).forEach(function(t4) {
        e2.tasks.splice(t4, 1);
      });
    }, t2.prototype.addTask = function(t3, e2, i2) {
      var n2 = new Gx(this.index++, e2, t3, this.eventHub, i2);
      this.tasks.push(n2), this.tasks.sort(function(t4, e3) {
        return t4.index - e3.index;
      }), this.replaceIdleTask(), this.tasks.length === 1 && n2.apply();
    }, t2.prototype.hasStartTask = function() {
      return this.tasks.some(function(t3) {
        return t3.state === "start";
      });
    }, t2.prototype.destroy = function() {
      this.eventHub.removeAllListeners();
    }, t2;
  }();
  function jx(t2, e2) {
    var i2 = t2.__state.conversionName.toString(), n2 = Math.round(t2.r), r2 = Math.round(t2.g), o2 = Math.round(t2.b), s2 = t2.a, a2 = Math.round(t2.h), l2 = t2.s.toFixed(1), h2 = t2.v.toFixed(1);
    if (e2 || i2 === "THREE_CHAR_HEX" || i2 === "SIX_CHAR_HEX") {
      for (var u2 = t2.hex.toString(16); u2.length < 6; )
        u2 = "0" + u2;
      return "#" + u2;
    }
    return i2 === "CSS_RGB" ? "rgb(" + n2 + "," + r2 + "," + o2 + ")" : i2 === "CSS_RGBA" ? "rgba(" + n2 + "," + r2 + "," + o2 + "," + s2 + ")" : i2 === "HEX" ? "0x" + t2.hex.toString(16) : i2 === "RGB_ARRAY" ? "[" + n2 + "," + r2 + "," + o2 + "]" : i2 === "RGBA_ARRAY" ? "[" + n2 + "," + r2 + "," + o2 + "," + s2 + "]" : i2 === "RGB_OBJ" ? "{r:" + n2 + ",g:" + r2 + ",b:" + o2 + "}" : i2 === "RGBA_OBJ" ? "{r:" + n2 + ",g:" + r2 + ",b:" + o2 + ",a:" + s2 + "}" : i2 === "HSV_OBJ" ? "{h:" + a2 + ",s:" + l2 + ",v:" + h2 + "}" : i2 === "HSVA_OBJ" ? "{h:" + a2 + ",s:" + l2 + ",v:" + h2 + ",a:" + s2 + "}" : "unknown format";
  }
  var zx = Array.prototype.forEach, Vx = Array.prototype.slice, Xx = { BREAK: {}, extend: function(t2) {
    return this.each(Vx.call(arguments, 1), function(e2) {
      (this.isObject(e2) ? Object.keys(e2) : []).forEach(function(i2) {
        this.isUndefined(e2[i2]) || (t2[i2] = e2[i2]);
      }.bind(this));
    }, this), t2;
  }, defaults: function(t2) {
    return this.each(Vx.call(arguments, 1), function(e2) {
      (this.isObject(e2) ? Object.keys(e2) : []).forEach(function(i2) {
        this.isUndefined(t2[i2]) && (t2[i2] = e2[i2]);
      }.bind(this));
    }, this), t2;
  }, compose: function() {
    var t2 = Vx.call(arguments);
    return function() {
      for (var e2 = Vx.call(arguments), i2 = t2.length - 1; i2 >= 0; i2--)
        e2 = [t2[i2].apply(this, e2)];
      return e2[0];
    };
  }, each: function(t2, e2, i2) {
    if (t2) {
      if (zx && t2.forEach && t2.forEach === zx)
        t2.forEach(e2, i2);
      else if (t2.length === t2.length + 0) {
        var n2, r2 = void 0;
        for (r2 = 0, n2 = t2.length; r2 < n2; r2++)
          if (r2 in t2 && e2.call(i2, t2[r2], r2) === this.BREAK)
            return;
      } else
        for (var o2 in t2)
          if (e2.call(i2, t2[o2], o2) === this.BREAK)
            return;
    }
  }, defer: function(t2) {
    setTimeout(t2, 0);
  }, debounce: function(t2, e2, i2) {
    var n2 = void 0;
    return function() {
      var r2 = this, o2 = arguments;
      function s2() {
        n2 = null, i2 || t2.apply(r2, o2);
      }
      var a2 = i2 || !n2;
      clearTimeout(n2), n2 = setTimeout(s2, e2), a2 && t2.apply(r2, o2);
    };
  }, toArray: function(t2) {
    return t2.toArray ? t2.toArray() : Vx.call(t2);
  }, isUndefined: function(t2) {
    return t2 === void 0;
  }, isNull: function(t2) {
    return t2 === null;
  }, isNaN: function(t2) {
    function e2(e3) {
      return t2.apply(this, arguments);
    }
    return e2.toString = function() {
      return t2.toString();
    }, e2;
  }(function(t2) {
    return isNaN(t2);
  }), isArray: Array.isArray || function(t2) {
    return t2.constructor === Array;
  }, isObject: function(t2) {
    return t2 === Object(t2);
  }, isNumber: function(t2) {
    return t2 === t2 + 0;
  }, isString: function(t2) {
    return t2 === t2 + "";
  }, isBoolean: function(t2) {
    return t2 === false || t2 === true;
  }, isFunction: function(t2) {
    return t2 instanceof Function;
  } }, Wx = [{ litmus: Xx.isString, conversions: { THREE_CHAR_HEX: { read: function(t2) {
    var e2 = t2.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
    return e2 !== null && { space: "HEX", hex: parseInt("0x" + e2[1].toString() + e2[1].toString() + e2[2].toString() + e2[2].toString() + e2[3].toString() + e2[3].toString(), 0) };
  }, write: jx }, SIX_CHAR_HEX: { read: function(t2) {
    var e2 = t2.match(/^#([A-F0-9]{6})$/i);
    return e2 !== null && { space: "HEX", hex: parseInt("0x" + e2[1].toString(), 0) };
  }, write: jx }, CSS_RGB: { read: function(t2) {
    var e2 = t2.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
    return e2 !== null && { space: "RGB", r: parseFloat(e2[1]), g: parseFloat(e2[2]), b: parseFloat(e2[3]) };
  }, write: jx }, CSS_RGBA: { read: function(t2) {
    var e2 = t2.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
    return e2 !== null && { space: "RGB", r: parseFloat(e2[1]), g: parseFloat(e2[2]), b: parseFloat(e2[3]), a: parseFloat(e2[4]) };
  }, write: jx } } }, { litmus: Xx.isNumber, conversions: { HEX: { read: function(t2) {
    return { space: "HEX", hex: t2, conversionName: "HEX" };
  }, write: function(t2) {
    return t2.hex;
  } } } }, { litmus: Xx.isArray, conversions: { RGB_ARRAY: { read: function(t2) {
    return t2.length === 3 && { space: "RGB", r: t2[0], g: t2[1], b: t2[2] };
  }, write: function(t2) {
    return [t2.r, t2.g, t2.b];
  } }, RGBA_ARRAY: { read: function(t2) {
    return t2.length === 4 && { space: "RGB", r: t2[0], g: t2[1], b: t2[2], a: t2[3] };
  }, write: function(t2) {
    return [t2.r, t2.g, t2.b, t2.a];
  } } } }, { litmus: Xx.isObject, conversions: { RGBA_OBJ: { read: function(t2) {
    return !!(Xx.isNumber(t2.r) && Xx.isNumber(t2.g) && Xx.isNumber(t2.b) && Xx.isNumber(t2.a)) && { space: "RGB", r: t2.r, g: t2.g, b: t2.b, a: t2.a };
  }, write: function(t2) {
    return { r: t2.r, g: t2.g, b: t2.b, a: t2.a };
  } }, RGB_OBJ: { read: function(t2) {
    return !!(Xx.isNumber(t2.r) && Xx.isNumber(t2.g) && Xx.isNumber(t2.b)) && { space: "RGB", r: t2.r, g: t2.g, b: t2.b };
  }, write: function(t2) {
    return { r: t2.r, g: t2.g, b: t2.b };
  } }, HSVA_OBJ: { read: function(t2) {
    return !!(Xx.isNumber(t2.h) && Xx.isNumber(t2.s) && Xx.isNumber(t2.v) && Xx.isNumber(t2.a)) && { space: "HSV", h: t2.h, s: t2.s, v: t2.v, a: t2.a };
  }, write: function(t2) {
    return { h: t2.h, s: t2.s, v: t2.v, a: t2.a };
  } }, HSV_OBJ: { read: function(t2) {
    return !!(Xx.isNumber(t2.h) && Xx.isNumber(t2.s) && Xx.isNumber(t2.v)) && { space: "HSV", h: t2.h, s: t2.s, v: t2.v };
  }, write: function(t2) {
    return { h: t2.h, s: t2.s, v: t2.v };
  } } } }], Yx = void 0, qx = void 0, Zx = function() {
    qx = false;
    var t2 = arguments.length > 1 ? Xx.toArray(arguments) : arguments[0];
    return Xx.each(Wx, function(e2) {
      if (e2.litmus(t2))
        return Xx.each(e2.conversions, function(e3, i2) {
          if (Yx = e3.read(t2), qx === false && Yx !== false)
            return qx = Yx, Yx.conversionName = i2, Yx.conversion = e3, Xx.BREAK;
        }), Xx.BREAK;
    }), qx;
  }, Jx = void 0, Kx = { hsv_to_rgb: function(t2, e2, i2) {
    var n2 = Math.floor(t2 / 60) % 6, r2 = t2 / 60 - Math.floor(t2 / 60), o2 = i2 * (1 - e2), s2 = i2 * (1 - r2 * e2), a2 = i2 * (1 - (1 - r2) * e2), l2 = [[i2, a2, o2], [s2, i2, o2], [o2, i2, a2], [o2, s2, i2], [a2, o2, i2], [i2, o2, s2]][n2];
    return { r: 255 * l2[0], g: 255 * l2[1], b: 255 * l2[2] };
  }, rgb_to_hsv: function(t2, e2, i2) {
    var n2 = Math.min(t2, e2, i2), r2 = Math.max(t2, e2, i2), o2 = r2 - n2, s2 = void 0;
    return r2 === 0 ? { h: NaN, s: 0, v: 0 } : (s2 = t2 === r2 ? (e2 - i2) / o2 : e2 === r2 ? 2 + (i2 - t2) / o2 : 4 + (t2 - e2) / o2, (s2 /= 6) < 0 && (s2 += 1), { h: 360 * s2, s: o2 / r2, v: r2 / 255 });
  }, rgb_to_hex: function(t2, e2, i2) {
    var n2 = this.hex_with_component(0, 2, t2);
    return n2 = this.hex_with_component(n2, 1, e2), n2 = this.hex_with_component(n2, 0, i2);
  }, component_from_hex: function(t2, e2) {
    return t2 >> 8 * e2 & 255;
  }, hex_with_component: function(t2, e2, i2) {
    return i2 << (Jx = 8 * e2) | t2 & ~(255 << Jx);
  } }, Qx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, $x = function(t2, e2) {
    if (!(t2 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }, tb = function() {
    function t2(t3, e2) {
      for (var i2 = 0; i2 < e2.length; i2++) {
        var n2 = e2[i2];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
      }
    }
    return function(e2, i2, n2) {
      return i2 && t2(e2.prototype, i2), n2 && t2(e2, n2), e2;
    };
  }(), eb = function t2(e2, i2, n2) {
    e2 === null && (e2 = Function.prototype);
    var r2 = Object.getOwnPropertyDescriptor(e2, i2);
    if (r2 === void 0) {
      var o2 = Object.getPrototypeOf(e2);
      return o2 === null ? void 0 : t2(o2, i2, n2);
    }
    if ("value" in r2)
      return r2.value;
    var s2 = r2.get;
    return s2 !== void 0 ? s2.call(n2) : void 0;
  }, ib = function(t2, e2) {
    if (typeof e2 != "function" && e2 !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e2);
    t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, enumerable: false, writable: true, configurable: true } }), e2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t2, e2) : t2.__proto__ = e2);
  }, nb = function(t2, e2) {
    if (!t2)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return !e2 || typeof e2 != "object" && typeof e2 != "function" ? t2 : e2;
  }, rb = function() {
    function t2() {
      if ($x(this, t2), this.__state = Zx.apply(this, arguments), this.__state === false)
        throw new Error("Failed to interpret color arguments");
      this.__state.a = this.__state.a || 1;
    }
    return tb(t2, [{ key: "toString", value: function() {
      return jx(this);
    } }, { key: "toHexString", value: function() {
      return jx(this, true);
    } }, { key: "toOriginal", value: function() {
      return this.__state.conversion.write(this);
    } }]), t2;
  }();
  function ob(t2, e2, i2) {
    Object.defineProperty(t2, e2, { get: function() {
      return this.__state.space === "RGB" || rb.recalculateRGB(this, e2, i2), this.__state[e2];
    }, set: function(t3) {
      this.__state.space !== "RGB" && (rb.recalculateRGB(this, e2, i2), this.__state.space = "RGB"), this.__state[e2] = t3;
    } });
  }
  function sb(t2, e2) {
    Object.defineProperty(t2, e2, { get: function() {
      return this.__state.space === "HSV" || rb.recalculateHSV(this), this.__state[e2];
    }, set: function(t3) {
      this.__state.space !== "HSV" && (rb.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e2] = t3;
    } });
  }
  rb.recalculateRGB = function(t2, e2, i2) {
    if (t2.__state.space === "HEX")
      t2.__state[e2] = Kx.component_from_hex(t2.__state.hex, i2);
    else {
      if (t2.__state.space !== "HSV")
        throw new Error("Corrupted color state");
      Xx.extend(t2.__state, Kx.hsv_to_rgb(t2.__state.h, t2.__state.s, t2.__state.v));
    }
  }, rb.recalculateHSV = function(t2) {
    var e2 = Kx.rgb_to_hsv(t2.r, t2.g, t2.b);
    Xx.extend(t2.__state, { s: e2.s, v: e2.v }), Xx.isNaN(e2.h) ? Xx.isUndefined(t2.__state.h) && (t2.__state.h = 0) : t2.__state.h = e2.h;
  }, rb.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], ob(rb.prototype, "r", 2), ob(rb.prototype, "g", 1), ob(rb.prototype, "b", 0), sb(rb.prototype, "h"), sb(rb.prototype, "s"), sb(rb.prototype, "v"), Object.defineProperty(rb.prototype, "a", { get: function() {
    return this.__state.a;
  }, set: function(t2) {
    this.__state.a = t2;
  } }), Object.defineProperty(rb.prototype, "hex", { get: function() {
    return this.__state.space !== "HEX" && (this.__state.hex = Kx.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
  }, set: function(t2) {
    this.__state.space = "HEX", this.__state.hex = t2;
  } });
  var ab = function() {
    function t2(e2, i2) {
      $x(this, t2), this.initialValue = e2[i2], this.domElement = document.createElement("div"), this.object = e2, this.property = i2, this.__onChange = void 0, this.__onFinishChange = void 0;
    }
    return tb(t2, [{ key: "onChange", value: function(t3) {
      return this.__onChange = t3, this;
    } }, { key: "onFinishChange", value: function(t3) {
      return this.__onFinishChange = t3, this;
    } }, { key: "setValue", value: function(t3) {
      return this.object[this.property] = t3, this.__onChange && this.__onChange.call(this, t3), this.updateDisplay(), this;
    } }, { key: "getValue", value: function() {
      return this.object[this.property];
    } }, { key: "updateDisplay", value: function() {
      return this;
    } }, { key: "isModified", value: function() {
      return this.initialValue !== this.getValue();
    } }]), t2;
  }(), lb = {};
  Xx.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(t2, e2) {
    Xx.each(t2, function(t3) {
      lb[t3] = e2;
    });
  });
  var hb = /(\d+(\.\d+)?)px/;
  function ub(t2) {
    if (t2 === "0" || Xx.isUndefined(t2))
      return 0;
    var e2 = t2.match(hb);
    return Xx.isNull(e2) ? 0 : parseFloat(e2[1]);
  }
  var cb = { makeSelectable: function(t2, e2) {
    t2 !== void 0 && t2.style !== void 0 && (t2.onselectstart = e2 ? function() {
      return false;
    } : function() {
    }, t2.style.MozUserSelect = e2 ? "auto" : "none", t2.style.KhtmlUserSelect = e2 ? "auto" : "none", t2.unselectable = e2 ? "on" : "off");
  }, makeFullscreen: function(t2, e2, i2) {
    var n2 = i2, r2 = e2;
    Xx.isUndefined(r2) && (r2 = true), Xx.isUndefined(n2) && (n2 = true), t2.style.position = "absolute", r2 && (t2.style.left = 0, t2.style.right = 0), n2 && (t2.style.top = 0, t2.style.bottom = 0);
  }, fakeEvent: function(t2, e2, i2, n2) {
    var r2 = i2 || {}, o2 = lb[e2];
    if (!o2)
      throw new Error("Event type " + e2 + " not supported.");
    var s2 = document.createEvent(o2);
    switch (o2) {
      case "MouseEvents":
        var a2 = r2.x || r2.clientX || 0, l2 = r2.y || r2.clientY || 0;
        s2.initMouseEvent(e2, r2.bubbles || false, r2.cancelable || true, window, r2.clickCount || 1, 0, 0, a2, l2, false, false, false, false, 0, null);
        break;
      case "KeyboardEvents":
        var h2 = s2.initKeyboardEvent || s2.initKeyEvent;
        Xx.defaults(r2, { cancelable: true, ctrlKey: false, altKey: false, shiftKey: false, metaKey: false, keyCode: void 0, charCode: void 0 }), h2(e2, r2.bubbles || false, r2.cancelable, window, r2.ctrlKey, r2.altKey, r2.shiftKey, r2.metaKey, r2.keyCode, r2.charCode);
        break;
      default:
        s2.initEvent(e2, r2.bubbles || false, r2.cancelable || true);
    }
    Xx.defaults(s2, n2), t2.dispatchEvent(s2);
  }, bind: function(t2, e2, i2, n2) {
    var r2 = n2 || false;
    return t2.addEventListener ? t2.addEventListener(e2, i2, r2) : t2.attachEvent && t2.attachEvent("on" + e2, i2), cb;
  }, unbind: function(t2, e2, i2, n2) {
    var r2 = n2 || false;
    return t2.removeEventListener ? t2.removeEventListener(e2, i2, r2) : t2.detachEvent && t2.detachEvent("on" + e2, i2), cb;
  }, addClass: function(t2, e2) {
    if (t2.className === void 0)
      t2.className = e2;
    else if (t2.className !== e2) {
      var i2 = t2.className.split(/ +/);
      i2.indexOf(e2) === -1 && (i2.push(e2), t2.className = i2.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
    }
    return cb;
  }, removeClass: function(t2, e2) {
    if (e2)
      if (t2.className === e2)
        t2.removeAttribute("class");
      else {
        var i2 = t2.className.split(/ +/), n2 = i2.indexOf(e2);
        n2 !== -1 && (i2.splice(n2, 1), t2.className = i2.join(" "));
      }
    else
      t2.className = void 0;
    return cb;
  }, hasClass: function(t2, e2) {
    return new RegExp("(?:^|\\s+)" + e2 + "(?:\\s+|$)").test(t2.className) || false;
  }, getWidth: function(t2) {
    var e2 = getComputedStyle(t2);
    return ub(e2["border-left-width"]) + ub(e2["border-right-width"]) + ub(e2["padding-left"]) + ub(e2["padding-right"]) + ub(e2.width);
  }, getHeight: function(t2) {
    var e2 = getComputedStyle(t2);
    return ub(e2["border-top-width"]) + ub(e2["border-bottom-width"]) + ub(e2["padding-top"]) + ub(e2["padding-bottom"]) + ub(e2.height);
  }, getOffset: function(t2) {
    var e2 = t2, i2 = { left: 0, top: 0 };
    if (e2.offsetParent)
      do {
        i2.left += e2.offsetLeft, i2.top += e2.offsetTop, e2 = e2.offsetParent;
      } while (e2);
    return i2;
  }, isActive: function(t2) {
    return t2 === document.activeElement && (t2.type || t2.href);
  } }, db = function(t2) {
    function e2(t3, i2) {
      $x(this, e2);
      var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), r2 = n2;
      return n2.__prev = n2.getValue(), n2.__checkbox = document.createElement("input"), n2.__checkbox.setAttribute("type", "checkbox"), cb.bind(n2.__checkbox, "change", function() {
        r2.setValue(!r2.__prev);
      }, false), n2.domElement.appendChild(n2.__checkbox), n2.updateDisplay(), n2;
    }
    return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
      var i2 = eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, t3);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i2;
    } }, { key: "updateDisplay", value: function() {
      return this.getValue() === true ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = true, this.__prev = true) : (this.__checkbox.checked = false, this.__prev = false), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
    } }]), e2;
  }(ab), pb = function(t2) {
    function e2(t3, i2, n2) {
      $x(this, e2);
      var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = n2, s2 = r2;
      if (r2.__select = document.createElement("select"), Xx.isArray(o2)) {
        var a2 = {};
        Xx.each(o2, function(t4) {
          a2[t4] = t4;
        }), o2 = a2;
      }
      return Xx.each(o2, function(t4, e3) {
        var i3 = document.createElement("option");
        i3.innerHTML = e3, i3.setAttribute("value", t4), s2.__select.appendChild(i3);
      }), r2.updateDisplay(), cb.bind(r2.__select, "change", function() {
        var t4 = this.options[this.selectedIndex].value;
        s2.setValue(t4);
      }), r2.domElement.appendChild(r2.__select), r2;
    }
    return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
      var i2 = eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, t3);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i2;
    } }, { key: "updateDisplay", value: function() {
      return cb.isActive(this.__select) ? this : (this.__select.value = this.getValue(), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this));
    } }]), e2;
  }(ab), fb = function(t2) {
    function e2(t3, i2) {
      $x(this, e2);
      var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), r2 = n2;
      function o2() {
        r2.setValue(r2.__input.value);
      }
      return n2.__input = document.createElement("input"), n2.__input.setAttribute("type", "text"), cb.bind(n2.__input, "keyup", o2), cb.bind(n2.__input, "change", o2), cb.bind(n2.__input, "blur", function() {
        r2.__onFinishChange && r2.__onFinishChange.call(r2, r2.getValue());
      }), cb.bind(n2.__input, "keydown", function(t4) {
        t4.keyCode === 13 && this.blur();
      }), n2.updateDisplay(), n2.domElement.appendChild(n2.__input), n2;
    }
    return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
      return cb.isActive(this.__input) || (this.__input.value = this.getValue()), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
    } }]), e2;
  }(ab);
  function mb(t2) {
    var e2 = t2.toString();
    return e2.indexOf(".") > -1 ? e2.length - e2.indexOf(".") - 1 : 0;
  }
  var gb = function(t2) {
    function e2(t3, i2, n2) {
      $x(this, e2);
      var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = n2 || {};
      return r2.__min = o2.min, r2.__max = o2.max, r2.__step = o2.step, Xx.isUndefined(r2.__step) ? r2.initialValue === 0 ? r2.__impliedStep = 1 : r2.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r2.initialValue)) / Math.LN10)) / 10 : r2.__impliedStep = r2.__step, r2.__precision = mb(r2.__impliedStep), r2;
    }
    return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
      var i2 = t3;
      return this.__min !== void 0 && i2 < this.__min ? i2 = this.__min : this.__max !== void 0 && i2 > this.__max && (i2 = this.__max), this.__step !== void 0 && i2 % this.__step != 0 && (i2 = Math.round(i2 / this.__step) * this.__step), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, i2);
    } }, { key: "min", value: function(t3) {
      return this.__min = t3, this;
    } }, { key: "max", value: function(t3) {
      return this.__max = t3, this;
    } }, { key: "step", value: function(t3) {
      return this.__step = t3, this.__impliedStep = t3, this.__precision = mb(t3), this;
    } }]), e2;
  }(ab);
  var vb = function(t2) {
    function e2(t3, i2, n2) {
      $x(this, e2);
      var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2, n2));
      r2.__truncationSuspended = false;
      var o2 = r2, s2 = void 0;
      function a2() {
        o2.__onFinishChange && o2.__onFinishChange.call(o2, o2.getValue());
      }
      function l2(t4) {
        var e3 = s2 - t4.clientY;
        o2.setValue(o2.getValue() + e3 * o2.__impliedStep), s2 = t4.clientY;
      }
      function h2() {
        cb.unbind(window, "mousemove", l2), cb.unbind(window, "mouseup", h2), a2();
      }
      return r2.__input = document.createElement("input"), r2.__input.setAttribute("type", "text"), cb.bind(r2.__input, "change", function() {
        var t4 = parseFloat(o2.__input.value);
        Xx.isNaN(t4) || o2.setValue(t4);
      }), cb.bind(r2.__input, "blur", function() {
        a2();
      }), cb.bind(r2.__input, "mousedown", function(t4) {
        cb.bind(window, "mousemove", l2), cb.bind(window, "mouseup", h2), s2 = t4.clientY;
      }), cb.bind(r2.__input, "keydown", function(t4) {
        t4.keyCode === 13 && (o2.__truncationSuspended = true, this.blur(), o2.__truncationSuspended = false, a2());
      }), r2.updateDisplay(), r2.domElement.appendChild(r2.__input), r2;
    }
    return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
      var t3, i2, n2;
      return this.__input.value = this.__truncationSuspended ? this.getValue() : (t3 = this.getValue(), i2 = this.__precision, n2 = Math.pow(10, i2), Math.round(t3 * n2) / n2), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
    } }]), e2;
  }(gb);
  function _b(t2, e2, i2, n2, r2) {
    return n2 + (t2 - e2) / (i2 - e2) * (r2 - n2);
  }
  var yb = function(t2) {
    function e2(t3, i2, n2, r2, o2) {
      $x(this, e2);
      var s2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2, { min: n2, max: r2, step: o2 })), a2 = s2;
      function l2(t4) {
        t4.preventDefault();
        var e3 = a2.__background.getBoundingClientRect();
        return a2.setValue(_b(t4.clientX, e3.left, e3.right, a2.__min, a2.__max)), false;
      }
      function h2() {
        cb.unbind(window, "mousemove", l2), cb.unbind(window, "mouseup", h2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
      }
      function u2(t4) {
        var e3 = t4.touches[0].clientX, i3 = a2.__background.getBoundingClientRect();
        a2.setValue(_b(e3, i3.left, i3.right, a2.__min, a2.__max));
      }
      function c2() {
        cb.unbind(window, "touchmove", u2), cb.unbind(window, "touchend", c2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
      }
      return s2.__background = document.createElement("div"), s2.__foreground = document.createElement("div"), cb.bind(s2.__background, "mousedown", function(t4) {
        document.activeElement.blur(), cb.bind(window, "mousemove", l2), cb.bind(window, "mouseup", h2), l2(t4);
      }), cb.bind(s2.__background, "touchstart", function(t4) {
        if (t4.touches.length !== 1)
          return;
        cb.bind(window, "touchmove", u2), cb.bind(window, "touchend", c2), u2(t4);
      }), cb.addClass(s2.__background, "slider"), cb.addClass(s2.__foreground, "slider-fg"), s2.updateDisplay(), s2.__background.appendChild(s2.__foreground), s2.domElement.appendChild(s2.__background), s2;
    }
    return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
      var t3 = (this.getValue() - this.__min) / (this.__max - this.__min);
      return this.__foreground.style.width = 100 * t3 + "%", eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
    } }]), e2;
  }(gb), xb = function(t2) {
    function e2(t3, i2, n2) {
      $x(this, e2);
      var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = r2;
      return r2.__button = document.createElement("div"), r2.__button.innerHTML = n2 === void 0 ? "Fire" : n2, cb.bind(r2.__button, "click", function(t4) {
        return t4.preventDefault(), o2.fire(), false;
      }), cb.addClass(r2.__button, "button"), r2.domElement.appendChild(r2.__button), r2;
    }
    return ib(e2, t2), tb(e2, [{ key: "fire", value: function() {
      this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
    } }]), e2;
  }(ab), bb = function(t2) {
    function e2(t3, i2) {
      $x(this, e2);
      var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2));
      n2.__color = new rb(n2.getValue()), n2.__temp = new rb(0);
      var r2 = n2;
      n2.domElement = document.createElement("div"), cb.makeSelectable(n2.domElement, false), n2.__selector = document.createElement("div"), n2.__selector.className = "selector", n2.__saturation_field = document.createElement("div"), n2.__saturation_field.className = "saturation-field", n2.__field_knob = document.createElement("div"), n2.__field_knob.className = "field-knob", n2.__field_knob_border = "2px solid ", n2.__hue_knob = document.createElement("div"), n2.__hue_knob.className = "hue-knob", n2.__hue_field = document.createElement("div"), n2.__hue_field.className = "hue-field", n2.__input = document.createElement("input"), n2.__input.type = "text", n2.__input_textShadow = "0 1px 1px ", cb.bind(n2.__input, "keydown", function(t4) {
        t4.keyCode === 13 && c2.call(this);
      }), cb.bind(n2.__input, "blur", c2), cb.bind(n2.__selector, "mousedown", function() {
        cb.addClass(this, "drag").bind(window, "mouseup", function() {
          cb.removeClass(r2.__selector, "drag");
        });
      }), cb.bind(n2.__selector, "touchstart", function() {
        cb.addClass(this, "drag").bind(window, "touchend", function() {
          cb.removeClass(r2.__selector, "drag");
        });
      });
      var o2, s2 = document.createElement("div");
      function a2(t4) {
        p2(t4), cb.bind(window, "mousemove", p2), cb.bind(window, "touchmove", p2), cb.bind(window, "mouseup", h2), cb.bind(window, "touchend", h2);
      }
      function l2(t4) {
        f2(t4), cb.bind(window, "mousemove", f2), cb.bind(window, "touchmove", f2), cb.bind(window, "mouseup", u2), cb.bind(window, "touchend", u2);
      }
      function h2() {
        cb.unbind(window, "mousemove", p2), cb.unbind(window, "touchmove", p2), cb.unbind(window, "mouseup", h2), cb.unbind(window, "touchend", h2), d2();
      }
      function u2() {
        cb.unbind(window, "mousemove", f2), cb.unbind(window, "touchmove", f2), cb.unbind(window, "mouseup", u2), cb.unbind(window, "touchend", u2), d2();
      }
      function c2() {
        var t4 = Zx(this.value);
        t4 !== false ? (r2.__color.__state = t4, r2.setValue(r2.__color.toOriginal())) : this.value = r2.__color.toString();
      }
      function d2() {
        r2.__onFinishChange && r2.__onFinishChange.call(r2, r2.__color.toOriginal());
      }
      function p2(t4) {
        t4.type.indexOf("touch") === -1 && t4.preventDefault();
        var e3 = r2.__saturation_field.getBoundingClientRect(), i3 = t4.touches && t4.touches[0] || t4, n3 = i3.clientX, o3 = i3.clientY, s3 = (n3 - e3.left) / (e3.right - e3.left), a3 = 1 - (o3 - e3.top) / (e3.bottom - e3.top);
        return a3 > 1 ? a3 = 1 : a3 < 0 && (a3 = 0), s3 > 1 ? s3 = 1 : s3 < 0 && (s3 = 0), r2.__color.v = a3, r2.__color.s = s3, r2.setValue(r2.__color.toOriginal()), false;
      }
      function f2(t4) {
        t4.type.indexOf("touch") === -1 && t4.preventDefault();
        var e3 = r2.__hue_field.getBoundingClientRect(), i3 = 1 - ((t4.touches && t4.touches[0] || t4).clientY - e3.top) / (e3.bottom - e3.top);
        return i3 > 1 ? i3 = 1 : i3 < 0 && (i3 = 0), r2.__color.h = 360 * i3, r2.setValue(r2.__color.toOriginal()), false;
      }
      return Xx.extend(n2.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), Xx.extend(n2.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: n2.__field_knob_border + (n2.__color.v < 0.5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), Xx.extend(n2.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), Xx.extend(n2.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), Xx.extend(s2.style, { width: "100%", height: "100%", background: "none" }), Eb(s2, "top", "rgba(0,0,0,0)", "#000"), Xx.extend(n2.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (o2 = n2.__hue_field).style.background = "", o2.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o2.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", Xx.extend(n2.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: n2.__input_textShadow + "rgba(0,0,0,0.7)" }), cb.bind(n2.__saturation_field, "mousedown", a2), cb.bind(n2.__saturation_field, "touchstart", a2), cb.bind(n2.__field_knob, "mousedown", a2), cb.bind(n2.__field_knob, "touchstart", a2), cb.bind(n2.__hue_field, "mousedown", l2), cb.bind(n2.__hue_field, "touchstart", l2), n2.__saturation_field.appendChild(s2), n2.__selector.appendChild(n2.__field_knob), n2.__selector.appendChild(n2.__saturation_field), n2.__selector.appendChild(n2.__hue_field), n2.__hue_field.appendChild(n2.__hue_knob), n2.domElement.appendChild(n2.__input), n2.domElement.appendChild(n2.__selector), n2.updateDisplay(), n2;
    }
    return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
      var t3 = Zx(this.getValue());
      if (t3 !== false) {
        var e3 = false;
        Xx.each(rb.COMPONENTS, function(i3) {
          if (!Xx.isUndefined(t3[i3]) && !Xx.isUndefined(this.__color.__state[i3]) && t3[i3] !== this.__color.__state[i3])
            return e3 = true, {};
        }, this), e3 && Xx.extend(this.__color.__state, t3);
      }
      Xx.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
      var i2 = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, n2 = 255 - i2;
      Xx.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i2 + "," + i2 + "," + i2 + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Eb(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), Xx.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i2 + "," + i2 + "," + i2 + ")", textShadow: this.__input_textShadow + "rgba(" + n2 + "," + n2 + "," + n2 + ",.7)" });
    } }]), e2;
  }(ab), Tb = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
  function Eb(t2, e2, i2, n2) {
    t2.style.background = "", Xx.each(Tb, function(r2) {
      t2.style.cssText += "background: " + r2 + "linear-gradient(" + e2 + ", " + i2 + " 0%, " + n2 + " 100%); ";
    });
  }
  var Sb = function(t2, e2) {
    var i2 = e2 || document, n2 = document.createElement("style");
    n2.type = "text/css", n2.innerHTML = t2;
    var r2 = i2.getElementsByTagName("head")[0];
    try {
      r2.appendChild(n2);
    } catch (t3) {
    }
  }, wb = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`, Ab = function(t2, e2) {
    var i2 = t2[e2];
    return Xx.isArray(arguments[2]) || Xx.isObject(arguments[2]) ? new pb(t2, e2, arguments[2]) : Xx.isNumber(i2) ? Xx.isNumber(arguments[2]) && Xx.isNumber(arguments[3]) ? Xx.isNumber(arguments[4]) ? new yb(t2, e2, arguments[2], arguments[3], arguments[4]) : new yb(t2, e2, arguments[2], arguments[3]) : Xx.isNumber(arguments[4]) ? new vb(t2, e2, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new vb(t2, e2, { min: arguments[2], max: arguments[3] }) : Xx.isString(i2) ? new fb(t2, e2) : Xx.isFunction(i2) ? new xb(t2, e2, "") : Xx.isBoolean(i2) ? new db(t2, e2) : null;
  };
  var Mb = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t2) {
    setTimeout(t2, 1e3 / 60);
  }, Rb = function() {
    function t2() {
      $x(this, t2), this.backgroundElement = document.createElement("div"), Xx.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), cb.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), Xx.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
      var e2 = this;
      cb.bind(this.backgroundElement, "click", function() {
        e2.hide();
      });
    }
    return tb(t2, [{ key: "show", value: function() {
      var t3 = this;
      this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), Xx.defer(function() {
        t3.backgroundElement.style.opacity = 1, t3.domElement.style.opacity = 1, t3.domElement.style.webkitTransform = "scale(1)";
      });
    } }, { key: "hide", value: function() {
      var t3 = this, e2 = function e3() {
        t3.domElement.style.display = "none", t3.backgroundElement.style.display = "none", cb.unbind(t3.domElement, "webkitTransitionEnd", e3), cb.unbind(t3.domElement, "transitionend", e3), cb.unbind(t3.domElement, "oTransitionEnd", e3);
      };
      cb.bind(this.domElement, "webkitTransitionEnd", e2), cb.bind(this.domElement, "transitionend", e2), cb.bind(this.domElement, "oTransitionEnd", e2), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    } }, { key: "layout", value: function() {
      this.domElement.style.left = window.innerWidth / 2 - cb.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - cb.getHeight(this.domElement) / 2 + "px";
    } }]), t2;
  }();
  Sb(function(t2) {
    if (t2 && typeof window != "undefined") {
      var e2 = document.createElement("style");
      return e2.setAttribute("type", "text/css"), e2.innerHTML = t2, document.head.appendChild(e2), t2;
    }
  }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
  var Cb = function() {
    try {
      return !!window.localStorage;
    } catch (t2) {
      return false;
    }
  }(), Ib = void 0, Pb = true, Ob = void 0, Nb = false, Lb = [], Db = function t2(e2) {
    var i2 = this, n2 = e2 || {};
    this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), cb.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n2 = Xx.defaults(n2, { closeOnTop: false, autoPlace: true, width: t2.DEFAULT_WIDTH }), n2 = Xx.defaults(n2, { resizable: n2.autoPlace, hideable: n2.autoPlace }), Xx.isUndefined(n2.load) ? n2.load = { preset: "Default" } : n2.preset && (n2.load.preset = n2.preset), Xx.isUndefined(n2.parent) && n2.hideable && Lb.push(this), n2.resizable = Xx.isUndefined(n2.parent) && n2.resizable, n2.autoPlace && Xx.isUndefined(n2.scrollable) && (n2.scrollable = true);
    var r2, o2 = Cb && localStorage.getItem(Hb(this, "isLocal")) === "true", s2 = void 0, a2 = void 0;
    if (Object.defineProperties(this, { parent: { get: function() {
      return n2.parent;
    } }, scrollable: { get: function() {
      return n2.scrollable;
    } }, autoPlace: { get: function() {
      return n2.autoPlace;
    } }, closeOnTop: { get: function() {
      return n2.closeOnTop;
    } }, preset: { get: function() {
      return i2.parent ? i2.getRoot().preset : n2.load.preset;
    }, set: function(t3) {
      i2.parent ? i2.getRoot().preset = t3 : n2.load.preset = t3, function(t4) {
        for (var e3 = 0; e3 < t4.__preset_select.length; e3++)
          t4.__preset_select[e3].value === t4.preset && (t4.__preset_select.selectedIndex = e3);
      }(this), i2.revert();
    } }, width: { get: function() {
      return n2.width;
    }, set: function(t3) {
      n2.width = t3, Wb(i2, t3);
    } }, name: { get: function() {
      return n2.name;
    }, set: function(t3) {
      n2.name = t3, a2 && (a2.innerHTML = n2.name);
    } }, closed: { get: function() {
      return n2.closed;
    }, set: function(e3) {
      n2.closed = e3, n2.closed ? cb.addClass(i2.__ul, t2.CLASS_CLOSED) : cb.removeClass(i2.__ul, t2.CLASS_CLOSED), this.onResize(), i2.__closeButton && (i2.__closeButton.innerHTML = e3 ? t2.TEXT_OPEN : t2.TEXT_CLOSED);
    } }, load: { get: function() {
      return n2.load;
    } }, useLocalStorage: { get: function() {
      return o2;
    }, set: function(t3) {
      Cb && (o2 = t3, t3 ? cb.bind(window, "unload", s2) : cb.unbind(window, "unload", s2), localStorage.setItem(Hb(i2, "isLocal"), t3));
    } } }), Xx.isUndefined(n2.parent)) {
      if (this.closed = n2.closed || false, cb.addClass(this.domElement, t2.CLASS_MAIN), cb.makeSelectable(this.domElement, false), Cb && o2) {
        i2.useLocalStorage = true;
        var l2 = localStorage.getItem(Hb(this, "gui"));
        l2 && (n2.load = JSON.parse(l2));
      }
      this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t2.TEXT_CLOSED, cb.addClass(this.__closeButton, t2.CLASS_CLOSE_BUTTON), n2.closeOnTop ? (cb.addClass(this.__closeButton, t2.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (cb.addClass(this.__closeButton, t2.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), cb.bind(this.__closeButton, "click", function() {
        i2.closed = !i2.closed;
      });
    } else {
      n2.closed === void 0 && (n2.closed = true);
      var h2 = document.createTextNode(n2.name);
      cb.addClass(h2, "controller-name"), a2 = Fb(i2, h2);
      cb.addClass(this.__ul, t2.CLASS_CLOSED), cb.addClass(a2, "title"), cb.bind(a2, "click", function(t3) {
        return t3.preventDefault(), i2.closed = !i2.closed, false;
      }), n2.closed || (this.closed = false);
    }
    n2.autoPlace && (Xx.isUndefined(n2.parent) && (Pb && (Ob = document.createElement("div"), cb.addClass(Ob, "dg"), cb.addClass(Ob, t2.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ob), Pb = false), Ob.appendChild(this.domElement), cb.addClass(this.domElement, t2.CLASS_AUTO_PLACE)), this.parent || Wb(i2, n2.width)), this.__resizeHandler = function() {
      i2.onResizeDebounced();
    }, cb.bind(window, "resize", this.__resizeHandler), cb.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), cb.bind(this.__ul, "transitionend", this.__resizeHandler), cb.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n2.resizable && Xb(this), s2 = function() {
      Cb && localStorage.getItem(Hb(i2, "isLocal")) === "true" && localStorage.setItem(Hb(i2, "gui"), JSON.stringify(i2.getSaveObject()));
    }, this.saveToLocalStorageIfPossible = s2, n2.parent || ((r2 = i2.getRoot()).width += 1, Xx.defer(function() {
      r2.width -= 1;
    }));
  };
  function Fb(t2, e2, i2) {
    var n2 = document.createElement("li");
    return e2 && n2.appendChild(e2), i2 ? t2.__ul.insertBefore(n2, i2) : t2.__ul.appendChild(n2), t2.onResize(), n2;
  }
  function Bb(t2) {
    cb.unbind(window, "resize", t2.__resizeHandler), t2.saveToLocalStorageIfPossible && cb.unbind(window, "unload", t2.saveToLocalStorageIfPossible);
  }
  function Ub(t2, e2) {
    var i2 = t2.__preset_select[t2.__preset_select.selectedIndex];
    i2.innerHTML = e2 ? i2.value + "*" : i2.value;
  }
  function kb(t2, e2) {
    var i2 = t2.getRoot(), n2 = i2.__rememberedObjects.indexOf(e2.object);
    if (n2 !== -1) {
      var r2 = i2.__rememberedObjectIndecesToControllers[n2];
      if (r2 === void 0 && (r2 = {}, i2.__rememberedObjectIndecesToControllers[n2] = r2), r2[e2.property] = e2, i2.load && i2.load.remembered) {
        var o2 = i2.load.remembered, s2 = void 0;
        if (o2[t2.preset])
          s2 = o2[t2.preset];
        else {
          if (!o2.Default)
            return;
          s2 = o2.Default;
        }
        if (s2[n2] && s2[n2][e2.property] !== void 0) {
          var a2 = s2[n2][e2.property];
          e2.initialValue = a2, e2.setValue(a2);
        }
      }
    }
  }
  function Gb(t2, e2, i2, n2) {
    if (e2[i2] === void 0)
      throw new Error('Object "' + e2 + '" has no property "' + i2 + '"');
    var r2 = void 0;
    if (n2.color)
      r2 = new bb(e2, i2);
    else {
      var o2 = [e2, i2].concat(n2.factoryArgs);
      r2 = Ab.apply(t2, o2);
    }
    n2.before instanceof ab && (n2.before = n2.before.__li), kb(t2, r2), cb.addClass(r2.domElement, "c");
    var s2 = document.createElement("span");
    cb.addClass(s2, "property-name"), s2.innerHTML = r2.property;
    var a2 = document.createElement("div");
    a2.appendChild(s2), a2.appendChild(r2.domElement);
    var l2 = Fb(t2, a2, n2.before);
    return cb.addClass(l2, Db.CLASS_CONTROLLER_ROW), r2 instanceof bb ? cb.addClass(l2, "color") : cb.addClass(l2, Qx(r2.getValue())), function(t3, e3, i3) {
      if (i3.__li = e3, i3.__gui = t3, Xx.extend(i3, { options: function(e4) {
        if (arguments.length > 1) {
          var n4 = i3.__li.nextElementSibling;
          return i3.remove(), Gb(t3, i3.object, i3.property, { before: n4, factoryArgs: [Xx.toArray(arguments)] });
        }
        if (Xx.isArray(e4) || Xx.isObject(e4)) {
          var r4 = i3.__li.nextElementSibling;
          return i3.remove(), Gb(t3, i3.object, i3.property, { before: r4, factoryArgs: [e4] });
        }
      }, name: function(t4) {
        return i3.__li.firstElementChild.firstElementChild.innerHTML = t4, i3;
      }, listen: function() {
        return i3.__gui.listen(i3), i3;
      }, remove: function() {
        return i3.__gui.remove(i3), i3;
      } }), i3 instanceof yb) {
        var n3 = new vb(i3.object, i3.property, { min: i3.__min, max: i3.__max, step: i3.__step });
        Xx.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(t4) {
          var e4 = i3[t4], r4 = n3[t4];
          i3[t4] = n3[t4] = function() {
            var t5 = Array.prototype.slice.call(arguments);
            return r4.apply(n3, t5), e4.apply(i3, t5);
          };
        }), cb.addClass(e3, "has-slider"), i3.domElement.insertBefore(n3.domElement, i3.domElement.firstElementChild);
      } else if (i3 instanceof vb) {
        var r3 = function(e4) {
          if (Xx.isNumber(i3.__min) && Xx.isNumber(i3.__max)) {
            var n4 = i3.__li.firstElementChild.firstElementChild.innerHTML, r4 = i3.__gui.__listening.indexOf(i3) > -1;
            i3.remove();
            var o3 = Gb(t3, i3.object, i3.property, { before: i3.__li.nextElementSibling, factoryArgs: [i3.__min, i3.__max, i3.__step] });
            return o3.name(n4), r4 && o3.listen(), o3;
          }
          return e4;
        };
        i3.min = Xx.compose(r3, i3.min), i3.max = Xx.compose(r3, i3.max);
      } else
        i3 instanceof db ? (cb.bind(e3, "click", function() {
          cb.fakeEvent(i3.__checkbox, "click");
        }), cb.bind(i3.__checkbox, "click", function(t4) {
          t4.stopPropagation();
        })) : i3 instanceof xb ? (cb.bind(e3, "click", function() {
          cb.fakeEvent(i3.__button, "click");
        }), cb.bind(e3, "mouseover", function() {
          cb.addClass(i3.__button, "hover");
        }), cb.bind(e3, "mouseout", function() {
          cb.removeClass(i3.__button, "hover");
        })) : i3 instanceof bb && (cb.addClass(e3, "color"), i3.updateDisplay = Xx.compose(function(t4) {
          return e3.style.borderLeftColor = i3.__color.toString(), t4;
        }, i3.updateDisplay), i3.updateDisplay());
      i3.setValue = Xx.compose(function(e4) {
        return t3.getRoot().__preset_select && i3.isModified() && Ub(t3.getRoot(), true), e4;
      }, i3.setValue);
    }(t2, l2, r2), t2.__controllers.push(r2), r2;
  }
  function Hb(t2, e2) {
    return document.location.href + "." + e2;
  }
  function jb(t2, e2, i2) {
    var n2 = document.createElement("option");
    n2.innerHTML = e2, n2.value = e2, t2.__preset_select.appendChild(n2), i2 && (t2.__preset_select.selectedIndex = t2.__preset_select.length - 1);
  }
  function zb(t2, e2) {
    e2.style.display = t2.useLocalStorage ? "block" : "none";
  }
  function Vb(t2) {
    var e2 = t2.__save_row = document.createElement("li");
    cb.addClass(t2.domElement, "has-save"), t2.__ul.insertBefore(e2, t2.__ul.firstChild), cb.addClass(e2, "save-row");
    var i2 = document.createElement("span");
    i2.innerHTML = "&nbsp;", cb.addClass(i2, "button gears");
    var n2 = document.createElement("span");
    n2.innerHTML = "Save", cb.addClass(n2, "button"), cb.addClass(n2, "save");
    var r2 = document.createElement("span");
    r2.innerHTML = "New", cb.addClass(r2, "button"), cb.addClass(r2, "save-as");
    var o2 = document.createElement("span");
    o2.innerHTML = "Revert", cb.addClass(o2, "button"), cb.addClass(o2, "revert");
    var s2 = t2.__preset_select = document.createElement("select");
    if (t2.load && t2.load.remembered ? Xx.each(t2.load.remembered, function(e3, i3) {
      jb(t2, i3, i3 === t2.preset);
    }) : jb(t2, "Default", false), cb.bind(s2, "change", function() {
      for (var e3 = 0; e3 < t2.__preset_select.length; e3++)
        t2.__preset_select[e3].innerHTML = t2.__preset_select[e3].value;
      t2.preset = this.value;
    }), e2.appendChild(s2), e2.appendChild(i2), e2.appendChild(n2), e2.appendChild(r2), e2.appendChild(o2), Cb) {
      var a2 = document.getElementById("dg-local-explain"), l2 = document.getElementById("dg-local-storage");
      document.getElementById("dg-save-locally").style.display = "block", localStorage.getItem(Hb(0, "isLocal")) === "true" && l2.setAttribute("checked", "checked"), zb(t2, a2), cb.bind(l2, "change", function() {
        t2.useLocalStorage = !t2.useLocalStorage, zb(t2, a2);
      });
    }
    var h2 = document.getElementById("dg-new-constructor");
    cb.bind(h2, "keydown", function(t3) {
      !t3.metaKey || t3.which !== 67 && t3.keyCode !== 67 || Ib.hide();
    }), cb.bind(i2, "click", function() {
      h2.innerHTML = JSON.stringify(t2.getSaveObject(), void 0, 2), Ib.show(), h2.focus(), h2.select();
    }), cb.bind(n2, "click", function() {
      t2.save();
    }), cb.bind(r2, "click", function() {
      var e3 = prompt("Enter a new preset name.");
      e3 && t2.saveAs(e3);
    }), cb.bind(o2, "click", function() {
      t2.revert();
    });
  }
  function Xb(t2) {
    var e2 = void 0;
    function i2(i3) {
      return i3.preventDefault(), t2.width += e2 - i3.clientX, t2.onResize(), e2 = i3.clientX, false;
    }
    function n2() {
      cb.removeClass(t2.__closeButton, Db.CLASS_DRAG), cb.unbind(window, "mousemove", i2), cb.unbind(window, "mouseup", n2);
    }
    function r2(r3) {
      return r3.preventDefault(), e2 = r3.clientX, cb.addClass(t2.__closeButton, Db.CLASS_DRAG), cb.bind(window, "mousemove", i2), cb.bind(window, "mouseup", n2), false;
    }
    t2.__resize_handle = document.createElement("div"), Xx.extend(t2.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), cb.bind(t2.__resize_handle, "mousedown", r2), cb.bind(t2.__closeButton, "mousedown", r2), t2.domElement.insertBefore(t2.__resize_handle, t2.domElement.firstElementChild);
  }
  function Wb(t2, e2) {
    t2.domElement.style.width = e2 + "px", t2.__save_row && t2.autoPlace && (t2.__save_row.style.width = e2 + "px"), t2.__closeButton && (t2.__closeButton.style.width = e2 + "px");
  }
  function Yb(t2, e2) {
    var i2 = {};
    return Xx.each(t2.__rememberedObjects, function(n2, r2) {
      var o2 = {}, s2 = t2.__rememberedObjectIndecesToControllers[r2];
      Xx.each(s2, function(t3, i3) {
        o2[i3] = e2 ? t3.initialValue : t3.getValue();
      }), i2[r2] = o2;
    }), i2;
  }
  Db.toggleHide = function() {
    Nb = !Nb, Xx.each(Lb, function(t2) {
      t2.domElement.style.display = Nb ? "none" : "";
    });
  }, Db.CLASS_AUTO_PLACE = "a", Db.CLASS_AUTO_PLACE_CONTAINER = "ac", Db.CLASS_MAIN = "main", Db.CLASS_CONTROLLER_ROW = "cr", Db.CLASS_TOO_TALL = "taller-than-window", Db.CLASS_CLOSED = "closed", Db.CLASS_CLOSE_BUTTON = "close-button", Db.CLASS_CLOSE_TOP = "close-top", Db.CLASS_CLOSE_BOTTOM = "close-bottom", Db.CLASS_DRAG = "drag", Db.DEFAULT_WIDTH = 245, Db.TEXT_CLOSED = "Close Controls", Db.TEXT_OPEN = "Open Controls", Db._keydownHandler = function(t2) {
    document.activeElement.type === "text" || t2.which !== 72 && t2.keyCode !== 72 || Db.toggleHide();
  }, cb.bind(window, "keydown", Db._keydownHandler, false), Xx.extend(Db.prototype, { add: function(t2, e2) {
    return Gb(this, t2, e2, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
  }, addColor: function(t2, e2) {
    return Gb(this, t2, e2, { color: true });
  }, remove: function(t2) {
    this.__ul.removeChild(t2.__li), this.__controllers.splice(this.__controllers.indexOf(t2), 1);
    var e2 = this;
    Xx.defer(function() {
      e2.onResize();
    });
  }, destroy: function() {
    if (this.parent)
      throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
    this.autoPlace && Ob.removeChild(this.domElement);
    var t2 = this;
    Xx.each(this.__folders, function(e2) {
      t2.removeFolder(e2);
    }), cb.unbind(window, "keydown", Db._keydownHandler, false), Bb(this);
  }, addFolder: function(t2) {
    if (this.__folders[t2] !== void 0)
      throw new Error('You already have a folder in this GUI by the name "' + t2 + '"');
    var e2 = { name: t2, parent: this };
    e2.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t2] && (e2.closed = this.load.folders[t2].closed, e2.load = this.load.folders[t2]);
    var i2 = new Db(e2);
    this.__folders[t2] = i2;
    var n2 = Fb(this, i2.domElement);
    return cb.addClass(n2, "folder"), i2;
  }, removeFolder: function(t2) {
    this.__ul.removeChild(t2.domElement.parentElement), delete this.__folders[t2.name], this.load && this.load.folders && this.load.folders[t2.name] && delete this.load.folders[t2.name], Bb(t2);
    var e2 = this;
    Xx.each(t2.__folders, function(e3) {
      t2.removeFolder(e3);
    }), Xx.defer(function() {
      e2.onResize();
    });
  }, open: function() {
    this.closed = false;
  }, close: function() {
    this.closed = true;
  }, hide: function() {
    this.domElement.style.display = "none";
  }, show: function() {
    this.domElement.style.display = "";
  }, onResize: function() {
    var t2 = this.getRoot();
    if (t2.scrollable) {
      var e2 = cb.getOffset(t2.__ul).top, i2 = 0;
      Xx.each(t2.__ul.childNodes, function(e3) {
        t2.autoPlace && e3 === t2.__save_row || (i2 += cb.getHeight(e3));
      }), window.innerHeight - e2 - 20 < i2 ? (cb.addClass(t2.domElement, Db.CLASS_TOO_TALL), t2.__ul.style.height = window.innerHeight - e2 - 20 + "px") : (cb.removeClass(t2.domElement, Db.CLASS_TOO_TALL), t2.__ul.style.height = "auto");
    }
    t2.__resize_handle && Xx.defer(function() {
      t2.__resize_handle.style.height = t2.__ul.offsetHeight + "px";
    }), t2.__closeButton && (t2.__closeButton.style.width = t2.width + "px");
  }, onResizeDebounced: Xx.debounce(function() {
    this.onResize();
  }, 50), remember: function() {
    if (Xx.isUndefined(Ib) && ((Ib = new Rb()).domElement.innerHTML = wb), this.parent)
      throw new Error("You can only call remember on a top level GUI.");
    var t2 = this;
    Xx.each(Array.prototype.slice.call(arguments), function(e2) {
      t2.__rememberedObjects.length === 0 && Vb(t2), t2.__rememberedObjects.indexOf(e2) === -1 && t2.__rememberedObjects.push(e2);
    }), this.autoPlace && Wb(this, this.width);
  }, getRoot: function() {
    for (var t2 = this; t2.parent; )
      t2 = t2.parent;
    return t2;
  }, getSaveObject: function() {
    var t2 = this.load;
    return t2.closed = this.closed, this.__rememberedObjects.length > 0 && (t2.preset = this.preset, t2.remembered || (t2.remembered = {}), t2.remembered[this.preset] = Yb(this)), t2.folders = {}, Xx.each(this.__folders, function(e2, i2) {
      t2.folders[i2] = e2.getSaveObject();
    }), t2;
  }, save: function() {
    this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = Yb(this), Ub(this, false), this.saveToLocalStorageIfPossible();
  }, saveAs: function(t2) {
    this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = Yb(this, true)), this.load.remembered[t2] = Yb(this), this.preset = t2, jb(this, t2, true), this.saveToLocalStorageIfPossible();
  }, revert: function(t2) {
    Xx.each(this.__controllers, function(e2) {
      this.getRoot().load.remembered ? kb(t2 || this.getRoot(), e2) : e2.setValue(e2.initialValue), e2.__onFinishChange && e2.__onFinishChange.call(e2, e2.getValue());
    }, this), Xx.each(this.__folders, function(t3) {
      t3.revert(t3);
    }), t2 || Ub(this.getRoot(), false);
  }, listen: function(t2) {
    var e2 = this.__listening.length === 0;
    this.__listening.push(t2), e2 && function t3(e3) {
      e3.length !== 0 && Mb.call(window, function() {
        t3(e3);
      });
      Xx.each(e3, function(t4) {
        t4.updateDisplay();
      });
    }(this.__listening);
  }, updateDisplay: function() {
    Xx.each(this.__controllers, function(t2) {
      t2.updateDisplay();
    }), Xx.each(this.__folders, function(t2) {
      t2.updateDisplay();
    });
  } });
  var qb = Db, Zb = function() {
    function t2(t3) {
      this.player = t3;
    }
    return Object.defineProperty(t2.prototype, "frameRate", { get: function() {
      return this.player.fps.value;
    }, set: function(t3) {
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "drawFrames", { get: function() {
      return this.player.runtime.fps;
    }, set: function(t3) {
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "drawCall", { get: function() {
      return this.player.runtime.drawCall;
    }, set: function(t3) {
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "resolution", { get: function() {
      return this.player.config.resolution;
    }, set: function(t3) {
      this.player.updateConfig({ resolution: t3 });
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "size", { get: function() {
      var t3, e2;
      return ((t3 = this.player.view) === null || t3 === void 0 ? void 0 : t3.width) + "*" + ((e2 = this.player.view) === null || e2 === void 0 ? void 0 : e2.height);
    }, set: function(t3) {
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "minFPS", { get: function() {
      return this.player.config.minFPS;
    }, set: function(t3) {
      this.player.updateConfig({ minFPS: t3, maxFPS: this.player.config.maxFPS });
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "maxFPS", { get: function() {
      return this.player.config.maxFPS;
    }, set: function(t3) {
      this.player.updateConfig({ maxFPS: t3, minFPS: this.player.config.minFPS });
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "autoResolution", { get: function() {
      return this.player.config.autoResolution;
    }, set: function(t3) {
      this.player.updateConfig({ autoResolution: t3 });
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "autoFPS", { get: function() {
      return this.player.config.autoFPS;
    }, set: function(t3) {
      this.player.updateConfig({ autoFPS: t3 });
    }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "backgroundColor", { get: function() {
      return this.player.config.transactionBgColor;
    }, set: function(t3) {
      this.player.updateConfig({ transactionBgColor: t3 });
    }, enumerable: false, configurable: true }), t2;
  }(), Jb = function() {
    function t2(t3, e2) {
      var i2;
      this.config = new Zb(t3), this.anchor = e2, i2 = this.createControllerGUI(), this.gui = i2[0], this.controller = i2[1], this.createStats();
    }
    return t2.prototype.createStats = function() {
      var t3 = this;
      this.stateId = setInterval(function() {
        t3.controller.frameRate.updateDisplay(), t3.controller.size.updateDisplay(), t3.controller.minFPS.updateDisplay(), t3.controller.drawFrames.updateDisplay(), t3.controller.maxFPS.updateDisplay(), t3.controller.resolution.updateDisplay(), t3.controller.autoFps.updateDisplay(), t3.controller.autoResolution.updateDisplay(), t3.controller.drawCall.updateDisplay();
      }, 16);
    }, t2.prototype.createControllerGUI = function() {
      var t3 = new qb({ autoPlace: true, closed: true });
      t3.domElement.style.opacity = ".6", t3.domElement.style.transformOrigin = "100% 0", t3.domElement.style.transform = "scale(1)", this.anchor.appendChild(t3.domElement), t3.domElement.style.position = "absolute", t3.domElement.style.right = "0", t3.domElement.style.top = "0", t3.domElement.style.zIndex = "2";
      var e2 = { frameRate: t3.add(this.config, "frameRate"), drawFrames: t3.add(this.config, "drawFrames"), drawCall: t3.add(this.config, "drawCall"), size: t3.add(this.config, "size"), minFPS: t3.add(this.config, "minFPS", 0, 60), maxFPS: t3.add(this.config, "maxFPS", 0, 60), resolution: t3.add(this.config, "resolution", 0.5, 8, 0.5), autoResolution: t3.add(this.config, "autoResolution"), autoFps: t3.add(this.config, "autoFPS"), transactionBgColor: t3.addColor(this.config, "backgroundColor") };
      return [t3, e2];
    }, t2.prototype.destroy = function() {
      try {
        window.clearInterval(this.stateId), this.anchor.removeChild(this.gui.domElement), this.gui.destroy();
      } catch (t3) {
      }
    }, t2;
  }(), Kb = function() {
    function t2(t3) {
      var e2 = this;
      this.tasks = [], this.isDestroy = false, this.isScheduling = false, this.schedule = function() {
        e2.isScheduling = true;
        var t4 = e2.tasks.shift();
        t4 && !e2.isDestroy && e2.fn(t4).then(function() {
          e2.tasks.length > 0 ? window.requestAnimationFrame(e2.schedule) : e2.isScheduling = false;
        });
      }, this.fn = t3;
    }
    return t2.prototype.destroy = function() {
      this.isDestroy = true;
    }, t2.prototype.addTask = function(t3) {
      this.tasks.push(t3), this.isScheduling || this.schedule();
    }, t2;
  }(), Qb = function() {
    function t2(t3) {
      this.autoUnlock = /* @__PURE__ */ Object.create(null), this.locks = /* @__PURE__ */ Object.create(null), this.available = false, this.available = t3;
    }
    return t2.prototype.addLock = function(t3, e2) {
      var i2 = this;
      this.available && (this.locks[t3] = e2, this.autoUnlock[t3] = window.setTimeout(function() {
        delete i2.locks[t3];
      }, 3e3));
    }, t2.prototype.unlock = function(t3, e2) {
      this.available && e2 && this.locks[t3] && this.locks[t3] === e2 && (window.clearTimeout(this.autoUnlock[t3]), delete this.locks[t3]);
    }, t2.prototype.isLocked = function(t3) {
      return !!this.available && !!this.locks[t3];
    }, t2;
  }(), $b = function() {
    function t2() {
      var t3 = this;
      this.tasks = [], this.isDestroy = false, this.isScheduling = false, this.schedule = function() {
        t3.isScheduling = true;
        var e2 = t3.tasks.shift();
        e2 && !t3.isDestroy && (e2.status = "running", e2.fn.apply(null).then(function() {
          t3.tasks.length > 0 ? window.requestAnimationFrame(t3.schedule) : t3.isScheduling = false;
        }).catch(function() {
          t3.tasks.length > 0 ? window.requestAnimationFrame(t3.schedule) : t3.isScheduling = false;
        }));
      };
    }
    return t2.prototype.getRunningTask = function() {
      return this.tasks[0] && this.tasks[0].status === "running" ? this.tasks[0] : null;
    }, t2.prototype.addTask = function(t3, e2) {
      var i2 = { type: t3, status: "wait", fn: e2 }, n2 = this.getRunningTask();
      n2 && t3 === n2.type || (this.tasks = this.tasks.filter(function(e3) {
        return e3.type !== t3;
      }), this.tasks.push(i2), this.isScheduling || this.schedule());
    }, t2.prototype.destroy = function() {
      this.isDestroy = true;
    }, t2;
  }(), tT = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  }, eT = function(t2, e2) {
    var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
      if (1 & r2[0])
        throw r2[1];
      return r2[1];
    }, trys: [], ops: [] };
    return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function a2(o3) {
      return function(a3) {
        return function(o4) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s2; )
            try {
              if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done)
                return r2;
              switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                case 0:
                case 1:
                  r2 = o4;
                  break;
                case 4:
                  return s2.label++, { value: o4[1], done: false };
                case 5:
                  s2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = s2.ops.pop(), s2.trys.pop();
                  continue;
                default:
                  if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                    s2 = 0;
                    continue;
                  }
                  if (o4[0] === 3 && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                    s2.label = o4[1];
                    break;
                  }
                  if (o4[0] === 6 && s2.label < r2[1]) {
                    s2.label = r2[1], r2 = o4;
                    break;
                  }
                  if (r2 && s2.label < r2[2]) {
                    s2.label = r2[2], s2.ops.push(o4);
                    break;
                  }
                  r2[2] && s2.ops.pop(), s2.trys.pop();
                  continue;
              }
              o4 = e2.call(t2, s2);
            } catch (t3) {
              o4 = [6, t3], n2 = 0;
            } finally {
              i2 = r2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, a3]);
      };
    }
  }, iT = function() {
    function t2() {
      var t3 = this;
      this.logList = [], this.checkTimer = null, this.retryTimes = 0, this.enable = false, this.uploadLoggerGlobalEvent = function(e2) {
        e2.data.type === "@slide/_upload_log_" && t3.start();
      }, this.config = { checkTime: 3e3, buffer: 300 }, window.addEventListener("message", this.uploadLoggerGlobalEvent), this.start();
    }
    return t2.prototype.start = function() {
      return tT(this, void 0, void 0, function() {
        var t3 = this;
        return eT(this, function(e2) {
          return clearInterval(this.checkTimer), this.checkTimer = setInterval(function() {
            return tT(t3, void 0, void 0, function() {
              return eT(this, function(t4) {
                switch (t4.label) {
                  case 0:
                    return [4, this.uploadLog()];
                  case 1:
                    return t4.sent(), [2];
                }
              });
            });
          }, this.config.checkTime), [2];
        });
      });
    }, t2.prototype.pause = function() {
      clearInterval(this.checkTimer);
    }, t2.prototype.addLog = function(t3, e2, i2, n2) {
      this.logList.push({ level: e2, taskId: i2, message: t3, randomId: n2 });
    }, t2.prototype.destroy = function() {
      clearInterval(this.checkTimer), window.removeEventListener("message", this.uploadLoggerGlobalEvent);
    }, t2.prototype.uploadLog = function(t3) {
      return t3 === void 0 && (t3 = false), tT(this, void 0, void 0, function() {
        var e2, i2, n2, r2 = this;
        return eT(this, function(o2) {
          switch (o2.label) {
            case 0:
              if (!(this.logList.length >= this.config.buffer || t3))
                return [2];
              e2 = this.logList.splice(0), i2 = function() {
                r2.logList = e2.concat(r2.logList), r2.retryTimes > 3 && r2.pause(), r2.retryTimes += 1;
              }, o2.label = 1;
            case 1:
              return o2.trys.push([1, 3, , 4]), [4, fetch("https://netless-ppt-plugin-dev.cn-hangzhou.log.aliyuncs.com/logstores/netless-ppt-plugin-dev/track", { method: "POST", headers: { "x-log-apiversion": "0.6.0", "Content-Type": "application/json", Accept: "*/*" }, body: JSON.stringify({ __topic__: "netless-ppt-plugin-dev", __source__: "netless-ppt-plugin-dev", __logs__: e2 }) })];
            case 2:
              return o2.sent().ok ? this.retryTimes = 0 : i2(), [3, 4];
            case 3:
              return n2 = o2.sent(), console.warn(n2), i2(), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }, t2.prototype.setEnable = function(t3) {
      this.enable !== t3 && (t3 ? this.start() : this.pause());
    }, t2;
  }(), nT = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  }, rT = function(t2, e2) {
    var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
      if (1 & r2[0])
        throw r2[1];
      return r2[1];
    }, trys: [], ops: [] };
    return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function a2(o3) {
      return function(a3) {
        return function(o4) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s2; )
            try {
              if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done)
                return r2;
              switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                case 0:
                case 1:
                  r2 = o4;
                  break;
                case 4:
                  return s2.label++, { value: o4[1], done: false };
                case 5:
                  s2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = s2.ops.pop(), s2.trys.pop();
                  continue;
                default:
                  if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                    s2 = 0;
                    continue;
                  }
                  if (o4[0] === 3 && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                    s2.label = o4[1];
                    break;
                  }
                  if (o4[0] === 6 && s2.label < r2[1]) {
                    s2.label = r2[1], r2 = o4;
                    break;
                  }
                  if (r2 && s2.label < r2[2]) {
                    s2.label = r2[2], s2.ops.push(o4);
                    break;
                  }
                  r2[2] && s2.ops.pop(), s2.trys.pop();
                  continue;
              }
              o4 = e2.call(t2, s2);
            } catch (t3) {
              o4 = [6, t3], n2 = 0;
            } finally {
              i2 = r2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, a3]);
      };
    }
  };
  function oT(t2, e2, i2) {
    return nT(this, void 0, void 0, function() {
      var n2, r2, o2, s2;
      return rT(this, function(a2) {
        switch (a2.label) {
          case 0:
            return n2 = document.createElement("div"), (r2 = new _T({ anchor: n2, renderOptions: { minFPS: 1, maxFPS: 1, resolution: 1 }, mode: "local", interactive: false, useLocalCache: true })).setResource(t2, e2), [4, r2.getSlideCountAsync()];
          case 1:
            o2 = a2.sent(), s2 = 1, a2.label = 2;
          case 2:
            return s2 <= o2 ? [4, r2.player.stagePool.preload(s2, true)] : [3, 5];
          case 3:
            a2.sent(), i2(Math.round(s2 / o2 * 100) / 100), a2.label = 4;
          case 4:
            return s2++, [3, 2];
          case 5:
            return r2.destroy(), [2];
        }
      });
    });
  }
  var sT = function() {
    var t2 = function(e2, i2) {
      return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
        t3.__proto__ = e3;
      } || function(t3, e3) {
        for (var i3 in e3)
          Object.prototype.hasOwnProperty.call(e3, i3) && (t3[i3] = e3[i3]);
      })(e2, i2);
    };
    return function(e2, i2) {
      if (typeof i2 != "function" && i2 !== null)
        throw new TypeError("Class extends value " + String(i2) + " is not a constructor or null");
      function n2() {
        this.constructor = e2;
      }
      t2(e2, i2), e2.prototype = i2 === null ? Object.create(i2) : (n2.prototype = i2.prototype, new n2());
    };
  }(), aT = function() {
    return (aT = Object.assign || function(t2) {
      for (var e2, i2 = 1, n2 = arguments.length; i2 < n2; i2++)
        for (var r2 in e2 = arguments[i2])
          Object.prototype.hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
      return t2;
    }).apply(this, arguments);
  }, lT = function(t2, e2, i2, n2) {
    var r2, o2 = arguments.length, s2 = o2 < 3 ? e2 : n2 === null ? n2 = Object.getOwnPropertyDescriptor(e2, i2) : n2;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      s2 = Reflect.decorate(t2, e2, i2, n2);
    else
      for (var a2 = t2.length - 1; a2 >= 0; a2--)
        (r2 = t2[a2]) && (s2 = (o2 < 3 ? r2(s2) : o2 > 3 ? r2(e2, i2, s2) : r2(e2, i2)) || s2);
    return o2 > 3 && s2 && Object.defineProperty(e2, i2, s2), s2;
  }, hT = function(t2, e2, i2, n2) {
    return new (i2 || (i2 = Promise))(function(r2, o2) {
      function s2(t3) {
        try {
          l2(n2.next(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function a2(t3) {
        try {
          l2(n2.throw(t3));
        } catch (t4) {
          o2(t4);
        }
      }
      function l2(t3) {
        var e3;
        t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(s2, a2);
      }
      l2((n2 = n2.apply(t2, e2 || [])).next());
    });
  }, uT = function(t2, e2) {
    var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
      if (1 & r2[0])
        throw r2[1];
      return r2[1];
    }, trys: [], ops: [] };
    return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function a2(o3) {
      return function(a3) {
        return function(o4) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s2; )
            try {
              if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done)
                return r2;
              switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                case 0:
                case 1:
                  r2 = o4;
                  break;
                case 4:
                  return s2.label++, { value: o4[1], done: false };
                case 5:
                  s2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = s2.ops.pop(), s2.trys.pop();
                  continue;
                default:
                  if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                    s2 = 0;
                    continue;
                  }
                  if (o4[0] === 3 && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                    s2.label = o4[1];
                    break;
                  }
                  if (o4[0] === 6 && s2.label < r2[1]) {
                    s2.label = r2[1], r2 = o4;
                    break;
                  }
                  if (r2 && s2.label < r2[2]) {
                    s2.label = r2[2], s2.ops.push(o4);
                    break;
                  }
                  r2[2] && s2.ops.pop(), s2.trys.pop();
                  continue;
              }
              o4 = e2.call(t2, s2);
            } catch (t3) {
              o4 = [6, t3], n2 = 0;
            } finally {
              i2 = r2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, a3]);
      };
    }
  }, cT = window.ResizeObserver || Bx, dT = function(t2) {
    return new Promise(function(e2) {
      return setTimeout(e2, t2);
    });
  };
  function pT(t2, e2) {
    return hT(this, void 0, void 0, function() {
      var i2;
      return uT(this, function(n2) {
        switch (n2.label) {
          case 0:
            i2 = Date.now(), n2.label = 1;
          case 1:
            return !t2() && Date.now() - i2 < e2 ? [4, dT(50)] : [3, 3];
          case 2:
            return n2.sent(), i2 = Date.now(), [3, 1];
          case 3:
            return [2];
        }
      });
    });
  }
  var fT = { syncDispatch: "syncDispatch", syncReceive: "syncReceive", syncEventLag: "syncEventLag", renderStart: "renderStart", renderEnd: "renderEnd", renderError: "renderError", slideChange: "slideChange", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", animateStart: "animateStart", animateEnd: "animateEnd", stateChange: "stateChange", slideStepEnd: "slideEnd", slideStepStart: "slideStart" }, mT = { taskId: "", url: "", currentSlideIndex: -1, mainSeqStep: -1, mainSeqState: null, mediaState: /* @__PURE__ */ Object.create(null), interactiveSeqState: /* @__PURE__ */ Object.create(null) }, gT = "";
  try {
    gT = "1.2.1";
  } catch (t2) {
    gT = "dev -";
  }
  var vT = null;
  try {
    (vT = o.createInstance({ name: "__slide_local_log__", driver: o.INDEXEDDB, version: 1 })).ready(function(t2) {
    }).catch(function(t2) {
    });
  } catch (t2) {
  }
  var _T = function(t2) {
    function e2(i3) {
      var n3 = t2.call(this) || this;
      return n3.iosResetCache = [], n3.needClearCacheImage = false, n3.version = gT, n3.__slideState = Qy()(mT), n3.userInputTime = 0, n3.isSyncingSlideState = false, n3.frozenTaskManager = new $b(), n3.randomId = r(), n3.resize = false, n3.isAnimating = false, n3.renderingTaskManager = new Hx(), n3.isLoading = false, n3.interactive = true, n3.renderingIndex = 0, n3.frameWidth = 1, n3.frameHeight = 1, n3.frame = document.createElement("div"), n3.canvasContainer = document.createElement("div"), n3.medianController = document.createElement("div"), n3.frameResizeObserver = new cT(function() {
        return n3.frameResizeHandler();
      }), n3.timestamp = function() {
        return Date.now();
      }, n3.mode = "local", n3.enableGlobalClick = false, n3.lastEmitedState = null, n3.playerController = null, n3.isInitResized = false, n3.cacheImage = document.createElement("img"), n3.isTouchStart = false, n3.touchStartId = void 0, n3.taskId = "", n3.volumeAdjuster = new Gy(), n3.designWidth = 0, n3.designHeight = 0, n3._slideCount = 0, n3._dispatchIncrId = 0, n3._receiveIncrId = 0, n3._updateVolumeByStaticAdjuster = function(t3) {
        n3.volumeAdjuster.volume = t3;
      }, n3.recoverHandler = function(t3) {
        if (t3.data.type === "@slide/_recover_" && t3.data.slideId === n3.randomId) {
          var e3 = t3.data, i4 = e3.recoverBy, r2 = e3.payload;
          if (!r2)
            return;
          i4 === "renderOtherPage" && r2.slideIndex ? n3.doRenderSlide(r2.slideIndex).catch(function(t4) {
            n3.logger.error(t4, n3.taskId);
          }) : i4 === "reloadCurrentPage" && n3.doRenderSlide(n3.renderingIndex).catch(function(t4) {
            n3.logger.error(t4, n3.taskId);
          });
        }
      }, n3.userInputHandle = function() {
        n3.userInputTime = Date.now();
      }, n3.handleViewClick = function() {
        setTimeout(function() {
          var t3 = Date.now();
          Math.abs(t3 - n3.userInputTime) > 500 && n3.enableGlobalClick && n3.nextStep();
        });
      }, n3.handleViewTouchStart = function() {
        window.clearTimeout(n3.touchStartId), n3.isTouchStart = true, n3.touchStartId = setTimeout(function() {
          n3.isTouchStart = false;
        }, 350);
      }, n3.handleViewTouchEnd = function() {
        n3.isTouchStart && (n3.isTouchStart = false, n3.handleViewClick());
      }, n3.handleSlideRef = function() {
        console.log(n3), window.__slide = n3;
      }, n3.receiveSyncHandler = function(t3) {
        return hT(n3, void 0, void 0, function() {
          var e3, i4, n4, r2, o2, s2 = this;
          return uT(this, function(a2) {
            switch (a2.label) {
              case 0:
                return Vm()(t3.incrId) && (t3.incrId && t3.incrId - this._receiveIncrId != 1 && this.emit(fT.syncEventLag), this._receiveIncrId = t3.incrId || 0), this.logger.info("sync receive " + JSON.stringify(t3), this.taskId), t3.type !== "nextStep" ? [3, 1] : (this.mainSeqStep !== t3.next - 1 && this.mainSeqStep + 1 !== this.mainSeqLength && this.player ? (this.setMainSeqStep(t3.next, "start"), this.player.nextTick(function() {
                  s2.doNextStep(true, t3.clientId || "");
                })) : this.doNextStep(true, t3.clientId || ""), [3, 6]);
              case 1:
                return t3.type !== "prevStep" ? [3, 2] : (this.mainSeqStep === 0 && this.mainSeqState === "idle" || this.mainSeqStep === t3.next + 1 || this.mainSeqStep + 1 === this.mainSeqLength ? this.doPrevStep(true) : (this.setMainSeqStep(t3.next + 1, "start"), (e3 = this.player) === null || e3 === void 0 || e3.nextTick(function() {
                  s2.doPrevStep(true);
                })), [3, 6]);
              case 2:
                return t3.type !== "interactiveAnim" ? [3, 3] : (this.player ? this.player.applyInteractiveAction(t3.action) : this.__slideState.interactiveSeqState[t3.seqId] ? this.__slideState.interactiveSeqState[t3.seqId].step += 1 : this.__slideState.interactiveSeqState[t3.seqId] = { step: 0, state: "end" }, [3, 6]);
              case 3:
                return t3.type !== "renderSlide" ? [3, 5] : [4, this.doRenderSlide(t3.index, t3.isForward)];
              case 4:
                return a2.sent(), [3, 6];
              case 5:
                t3.type === "mediaPlay" ? ((i4 = this.player) === null || i4 === void 0 || i4.setMediaState(t3.id, true), this.__slideState.mediaState[t3.id] = t3.state) : t3.type === "mediaPause" ? ((n4 = this.player) === null || n4 === void 0 || n4.setMediaState(t3.id, false), this.__slideState.mediaState[t3.id] = t3.state) : t3.type === "mediaSeek" ? ((r2 = this.player) === null || r2 === void 0 || r2.setMediaCurrentTime(t3.id, t3.time), this.__slideState.mediaState[t3.id] = t3.state) : t3.type === "mediaFullscreen" && (t3.targetId && this.__slideState.mediaState[t3.targetId] ? this.__slideState.mediaState[t3.targetId].fullscreen = t3.state : this.__slideState.mediaState[t3.targetId] = { fullscreen: t3.state, type: "pause", time: 0 }, (o2 = this.player) === null || o2 === void 0 || o2.syncFullscreenVideoState({ targetId: t3.targetId, state: t3.state, slideIndex: t3.slideIndex })), a2.label = 6;
              case 6:
                return [2];
            }
          });
        });
      }, n3.handlePrevSlide = function(t3) {
        return t3 === void 0 && (t3 = false), hT(n3, void 0, void 0, function() {
          var e3, i4;
          return uT(this, function(n4) {
            return this.player ? ((e3 = this.player.prevSlideIndex) >= 1 && (((i4 = this.config.navigatorDelegate) === null || i4 === void 0 ? void 0 : i4.gotoPage) ? this.config.navigatorDelegate.gotoPage(e3) : t3 ? this.doRenderSlide(e3, false) : this.renderSlide(e3, false)), [2]) : [2];
          });
        });
      }, n3.handleNextSlide = function(t3) {
        return t3 === void 0 && (t3 = false), hT(n3, void 0, void 0, function() {
          var e3, i4;
          return uT(this, function(n4) {
            return this.player ? ((e3 = this.player.nextSlideIndex) <= this.slideCount && (((i4 = this.config.navigatorDelegate) === null || i4 === void 0 ? void 0 : i4.gotoPage) ? this.config.navigatorDelegate.gotoPage(e3) : t3 ? this.doRenderSlide(e3, true) : this.renderSlide(e3, true)), [2]) : [2];
          });
        });
      }, n3.handleGotoSlide = function(t3) {
        if (t3 <= n3.slideCount && t3 >= 1) {
          var e3 = n3.slideState.currentSlideIndex <= t3;
          n3.renderSlide(t3, e3);
        } else
          t3 === -1 && n3.renderSlide(n3.slideCount, true);
      }, e2.instances.push(n3), n3.config = n3.initSlideConfig(i3), n3.tracker = function(t3) {
        i3.whiteTracker && i3.whiteTracker.commit({ name: t3.name, reason: t3.reason, result: t3.result, payload: aT(aT({}, t3.payload), { slideId: n3.randomId, taskId: n3.taskId }) }, { slideVersion: n3.version || "" });
      }, e2.trackLogger.setEnable(!!n3.config.enableTracking), n3.logger = { info: function(t3, i4) {
        var r2;
        e2.appendLogString("INFO - " + new Date().toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "info", i4, n3.randomId);
        var o2 = (r2 = n3.config.logger) === null || r2 === void 0 ? void 0 : r2.info;
        o2 && o2("[" + i4 + "] " + t3);
      }, warn: function(t3, i4) {
        var r2;
        e2.appendLogString("WARN - " + new Date().toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "warn", i4, n3.randomId);
        var o2 = (r2 = n3.config.logger) === null || r2 === void 0 ? void 0 : r2.warn;
        o2 && o2("[" + i4 + "] " + t3);
      }, error: function(t3, i4) {
        var r2;
        e2.appendLogString("ERROR - " + new Date().toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "error", i4, n3.randomId);
        var o2 = (r2 = n3.config.logger) === null || r2 === void 0 ? void 0 : r2.error;
        o2 && o2("[" + i4 + "] " + t3);
      } }, n3.logger.info("new slide with clientId: " + n3.config.clientId + ", version: " + n3.version, n3.taskId), n3.tracker({ name: "initSlide", result: "", reason: "", payload: { taskId: n3.taskId } }), n3.anchor = n3.config.anchor, n3.syncQueue = new Kb(n3.receiveSyncHandler), n3.lock = new Qb(n3.mode === "interactive"), n3.cacheImage.style.position = "absolute", n3.cacheImage.style.zIndex = "100", n3.setMedianControllerAttribute(), n3.canvasContainer.style.position = "relative", n3.canvasContainer.style.fontSize = "0", n3.canvasContainer.appendChild(n3.medianController), n3.frame.appendChild(n3.canvasContainer), n3.frameResizeObserver.observe(n3.frame), n3.on(fT.syncReceive, function(t3) {
        n3.lock.unlock(t3.type, t3.uuid), n3.syncQueue.addTask(t3);
      }), n3.renderingTaskManager.eventHub.on("task-error", function(t3) {
        var e3 = t3.error, i4 = t3.task, r2 = Tm.transform(e3);
        r2.errorType === gm.RuntimeWarn ? n3.logger.warn(r2.message, n3.taskId) : n3.logger.error(r2.message, n3.taskId), n3.isLoading = false, n3.reportError(r2, i4.slideIndex);
      }), window.addEventListener("__slide_ref__", n3.handleSlideRef), n3.resizeView = Jy()(n3.resizeView.bind(n3), 50), n3.player = n3.initPlayer(n3.config), n3.config.controller && n3.createController(), n3.player.view && n3.canvasContainer.appendChild(n3.player.view), n3.handleViewClick = Jy()(n3.handleViewClick, 300), n3.player.errorChannel.on("error", function(t3, e3) {
        var i4 = Tm.transform(t3);
        i4.errorType === gm.RuntimeWarn ? n3.logger.warn(i4.message, n3.taskId) : n3.logger.error(i4.message, n3.taskId), n3.isLoading = false, n3.reportError(t3, e3), n3.tracker({ name: "slideError", reason: i4.errorMsg, result: "", payload: { code: i4.errorType } });
      }), window.addEventListener("message", n3.recoverHandler), e2.volumeAdjuster.on("update", n3._updateVolumeByStaticAdjuster), n3.volumeAdjuster.volume = e2.volumeAdjuster.volume, n3;
    }
    var i2, n2;
    return sT(e2, t2), e2.flushLog = function(t3) {
      return t3 === void 0 && (t3 = false), hT(this, void 0, void 0, function() {
        return uT(this, function(i3) {
          switch (i3.label) {
            case 0:
              if (!(e2._tempLog.length > 131072 || t3 && e2._tempLog.length > 0))
                return [3, 5];
              i3.label = 1;
            case 1:
              return i3.trys.push([1, 3, , 4]), [4, vT == null ? void 0 : vT.setItem("run_time_log_" + e2._tempLogIndex, e2._tempLog)];
            case 2:
              return i3.sent(), [3, 4];
            case 3:
              return i3.sent(), [3, 4];
            case 4:
              e2._tempLog = "", e2._tempLogIndex += 1, i3.label = 5;
            case 5:
              return [2];
          }
        });
      });
    }, e2.stopRemoteLog = function() {
      e2.remoteLogAddress = null;
    }, e2.startRemoteLog = function(t3) {
      return hT(this, void 0, void 0, function() {
        var i3, n3, r2, o2, s2;
        return uT(this, function(a2) {
          switch (a2.label) {
            case 0:
              return e2.remoteLogAddress = t3, [4, e2.flushLog(true)];
            case 1:
              if (a2.sent(), !vT)
                return [3, 13];
              i3 = [], a2.label = 2;
            case 2:
              return a2.trys.push([2, 4, , 5]), [4, vT.keys()];
            case 3:
              return i3 = (a2.sent() || []).sort(function(t4, e3) {
                return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
              }), [3, 5];
            case 4:
              return a2.sent(), [3, 5];
            case 5:
              n3 = 0, r2 = i3, a2.label = 6;
            case 6:
              if (!(n3 < r2.length))
                return [3, 13];
              o2 = r2[n3], o2.replace("run_time_log_", ""), s2 = "", a2.label = 7;
            case 7:
              return a2.trys.push([7, 9, , 10]), [4, vT.getItem(o2)];
            case 8:
              return s2 = a2.sent() || "", [3, 10];
            case 9:
              return a2.sent(), [3, 10];
            case 10:
              return [4, fetch(e2.remoteLogAddress + "/logs", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ log: s2 }) })];
            case 11:
              a2.sent(), a2.label = 12;
            case 12:
              return n3++, [3, 6];
            case 13:
              return [2];
          }
        });
      });
    }, e2.appendLogString = function(t3) {
      e2._tempLog += t3, e2.remoteLogAddress && fetch(e2.remoteLogAddress + "/logs", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ log: t3 }) }).catch(function() {
      });
    }, Object.defineProperty(e2.prototype, "dispatchIncrId", { get: function() {
      return this._dispatchIncrId++;
    }, enumerable: false, configurable: true }), e2.prototype.reportError = function(t3, i3) {
      this.emit(fT.renderError, { error: t3, index: i3 }), window.postMessage({ type: "@slide/_error_", errorType: t3.errorType, errorMsg: t3.errorMsg, slideId: this.randomId, slideIndex: i3, customMessage: "@slide/_error_" }, "*"), e2.trackLogger.uploadLog(true);
    }, e2.prototype.initSlideConfig = function(t3) {
      return t3.timestamp && (this.timestamp = t3.timestamp), t3.rtcAudio && (Vy.RtcAudioClazz = t3.rtcAudio), this.mode = t3.mode, this.anchor = t3.anchor, this.anchor.appendChild(this.frame), this.enableGlobalClick = !$a()(t3.enableGlobalClick) && t3.enableGlobalClick, this.resize = t3.resize || false, this.interactive = t3.interactive, this.frame.style.cssText = t3.fixedFrameSize ? "width:" + t3.fixedFrameSize.width + "px;height:" + t3.fixedFrameSize.height + "px;" : "width:100%;height:100%", this.frame.style.cssText += "display:flex;justify-content:center;align-items:center;visibility:hidden;position:relative;z-index:1;", t3.fixedFrameSize && (this.frameWidth = t3.fixedFrameSize.width, this.frameHeight = t3.fixedFrameSize.height), t3;
    }, e2.prototype.initPlayer = function(t3) {
      var e3, i3, n3, r2 = this, o2 = new Vy({ mode: this.mode, useLocalCache: !!$a()(this.config.useLocalCache) || this.config.useLocalCache, logger: this.logger, resourceTimeout: $a()(this.config.resourceTimeout) ? 15e3 : this.config.resourceTimeout, loadDelegate: this.config.loaderDelegate, volumeAdjuster: this.volumeAdjuster, urlInterrupter: this.config.urlInterrupter, tracker: this.tracker }, t3.renderOptions);
      return o2.setInteractive(this.interactive), o2.updateConfig(t3.renderOptions || {}), o2.on(zy.renderStart, function(t4) {
        r2.isLoading = true, r2.emit(fT.renderStart, t4), window.postMessage({ type: "@slide/_render_start_", taskId: r2.taskId, index: t4 }, "*");
      }), o2.on(zy.renderEnd, function(t4) {
        r2.isLoading = false, r2.player && (r2.designHeight = r2.player.designHeight, r2.designWidth = r2.player.designWidth, r2.cacheImage.style.width = r2.player.designWidth + "px", r2.cacheImage.style.height = r2.player.designHeight + "px", r2._slideCount = r2.player.slideCount), r2.emit(fT.renderEnd, t4), window.postMessage({ type: "@slide/_render_end_", taskId: r2.taskId, index: t4 }, "*");
      }), o2.on(zy.slideChange, function(t4) {
        r2.__slideState.currentSlideIndex = t4, r2.emitStateChange(), r2.emit(fT.slideChange, t4);
      }), o2.on(zy.mainSeqStateChange, function(t4) {
        r2.__slideState.mainSeqState = t4, r2.emitStateChange();
      }), o2.on(zy.mainSeqStepChange, function(t4) {
        r2.__slideState.mainSeqStep = t4, r2.emitStateChange();
      }), o2.on(zy.interactiveSeqStateChange, function(t4) {
        var e4 = t4.id, i4 = t4.state;
        r2.__slideState.interactiveSeqState[e4] = i4, r2.emitStateChange();
      }), o2.on(zy.animateStart, function() {
        r2.isAnimating !== true && (r2.isAnimating = true, r2.emit(fT.animateStart));
      }), o2.on(zy.animateEnd, function() {
        r2.isAnimating !== false && (r2.isAnimating = false, r2.emit(fT.animateEnd));
      }), o2.on(zy.interactiveSeqAction, function(t4) {
        var e4 = t4.action, i4 = t4.seqId;
        r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "interactiveAnim", action: e4, seqId: i4 }), r2.emitStateChange();
      }), o2.on(zy.mainSeqStepStart, function(t4) {
        r2.emit(fT.mainSeqStepStart, t4);
      }), o2.on(zy.mainSeqStepEnd, function(t4) {
        r2.emit(fT.mainSeqStepEnd, t4);
      }), o2.on(zy.mediaPlay, function(t4) {
        var e4, i4 = (e4 = r2.__slideState.mediaState[t4.id]) !== null && e4 !== void 0 ? e4 : {};
        i4.type = "play", i4.time = r2.timestamp() - 1e3 * t4.time, r2.__slideState.mediaState[t4.id] = i4, t4._stateOnly ? r2.config.mode === "interactive" && r2.receiveSyncHandler({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPlay", id: t4.id, state: i4 }).catch(function(t5) {
          r2.logger.error(t5 == null ? void 0 : t5.message, r2.taskId);
        }) : r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPlay", id: t4.id, state: i4 }), r2.emitStateChange();
      }), o2.on(zy.mediaStop, function(t4) {
        delete r2.__slideState.mediaState[t4.id], r2.emitStateChange();
      }), o2.on(zy.mediaPause, function(t4) {
        var e4, i4 = (e4 = r2.__slideState.mediaState[t4.id]) !== null && e4 !== void 0 ? e4 : {};
        i4.type = "pause", i4.time = t4.time, r2.__slideState.mediaState[t4.id] = i4, t4._stateOnly ? r2.config.mode === "interactive" && r2.receiveSyncHandler({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPause", id: t4.id, state: i4 }).catch(function(t5) {
          r2.logger.error(t5 == null ? void 0 : t5.message, r2.taskId);
        }) : r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPause", id: t4.id, state: i4 }), r2.emitStateChange();
      }), o2.on(zy.mediaSeek, function(t4) {
        var e4, i4 = (e4 = r2.__slideState.mediaState[t4.id]) !== null && e4 !== void 0 ? e4 : {};
        t4.isPlaying ? (i4.type = "play", i4.time = r2.timestamp() - 1e3 * t4.time) : (i4.type = "pause", i4.time = t4.time), r2.__slideState.mediaState[t4.id] = i4, r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaSeek", id: t4.id, time: t4.time, state: i4 }), r2.emitStateChange();
      }), o2.on(zy.requestPrevSlide, function(t4) {
        r2.handlePrevSlide(t4);
      }), o2.on(zy.requestNextSlide, function(t4) {
        r2.handleNextSlide(t4);
      }), o2.on(zy.requestGotoSlide, function(t4) {
        var e4;
        ((e4 = r2.config.navigatorDelegate) === null || e4 === void 0 ? void 0 : e4.gotoPage) ? r2.config.navigatorDelegate.gotoPage(t4) : r2.handleGotoSlide(t4);
      }), o2.on(zy.requestOpenUrl, function(t4) {
        var e4;
        console.log(r2.config.navigatorDelegate), ((e4 = r2.config.navigatorDelegate) === null || e4 === void 0 ? void 0 : e4.openUrl) && r2.config.navigatorDelegate.openUrl(t4);
      }), o2.on(zy.fullscreenChange, function(t4) {
        var e4, i4 = t4.targetId, n4 = t4.state;
        r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaFullscreen", targetId: i4, state: n4 });
        var o3 = (e4 = r2.__slideState.mediaState[i4]) !== null && e4 !== void 0 ? e4 : {};
        o3.fullscreen = n4, r2.__slideState.mediaState[i4] = o3, r2.emitStateChange();
      }), o2.on(zy.changeLocalFullscreenState, function(t4) {
        t4.slideIndex === r2.__slideState.currentSlideIndex ? (t4.targetId && r2.__slideState.mediaState[t4.targetId] && (r2.__slideState.mediaState[t4.targetId].fullscreen = t4.status), r2.emitStateChange()) : r2.logger.info("event slideIndex: " + t4.slideIndex + ", current slideIndex: " + r2.__slideState.currentSlideIndex, r2.taskId);
      }), (e3 = o2.view) === null || e3 === void 0 || e3.addEventListener("touchend", this.handleViewTouchEnd), (i3 = o2.view) === null || i3 === void 0 || i3.addEventListener("touchstart", this.handleViewTouchStart), (n3 = o2.view) === null || n3 === void 0 || n3.addEventListener("click", this.handleViewClick), o2.on(zy.userInput, this.userInputHandle), o2;
    }, e2.prototype.createController = function() {
      this.player && (this.playerController = new Jb(this.player, this.frame));
    }, e2.prototype.setMedianControllerAttribute = function() {
      this.medianController.className = "median-container", this.medianController.style.position = "absolute", this.medianController.style.left = "0", this.medianController.style.top = "0", this.medianController.style.zIndex = "2", this.medianController.style.fontSize = "16px";
    }, e2.prototype.frameResizeHandler = function() {
      if (!this.config.fixedFrameSize) {
        var t3 = this.frame.getBoundingClientRect(), e3 = t3.width, i3 = t3.height;
        this.frameWidth = e3, this.frameHeight = i3, this.resizeView();
      }
    }, e2.prototype.updateFixedFrameSize = function(t3, e3, i3) {
      this.config.fixedFrameSize && (this.frameWidth = t3, this.frameHeight = e3, this.frame.style.width = t3 + "px", this.frame.style.height = e3 + "px", this.resizeView(i3));
    }, e2.prototype.resizeView = function(t3) {
      var e3, i3, n3 = this, r2 = this.width, o2 = this.height;
      if (r2 > 0 && o2 > 0) {
        var s2 = this.frameWidth / r2, a2 = s2 * o2;
        a2 > this.frameHeight && (s2 *= this.frameHeight / a2), (e3 = this.player) === null || e3 === void 0 || e3.scaleView(s2, this.resize, t3), this.cacheImage.style.transform = "scale(" + s2 + ")", this.medianController.style.transform = "scale(" + s2 + ")", this.medianController.setAttribute("data-scale", s2.toString()), this.isInitResized || (this.isInitResized = true, (i3 = this.player) === null || i3 === void 0 || i3.clock.setTimeout(function() {
          n3.frame.style.visibility = "visible";
        }, 32));
      }
    }, e2.prototype.setSlideState = function(t3) {
      var e3, i3, n3;
      return hT(this, void 0, void 0, function() {
        var r2, o2 = this;
        return uT(this, function(s2) {
          switch (s2.label) {
            case 0:
              return this.isSyncingSlideState = true, this.logger.info("stateChange receive " + JSON.stringify(t3), this.taskId), t3.taskId && t3.taskId !== this.__slideState.taskId && (this.__slideState.taskId = t3.taskId, (e3 = this.player) === null || e3 === void 0 || e3.setResourceData(t3.taskId, this.__slideState.url)), t3.url && t3.url !== this.__slideState.url && (this.__slideState.url = t3.url, (i3 = this.player) === null || i3 === void 0 || i3.setResourceData(this.__slideState.taskId, t3.url)), Number.isInteger(t3.currentSlideIndex) && t3.currentSlideIndex !== this.__slideState.currentSlideIndex ? (this.__slideState.currentSlideIndex = t3.currentSlideIndex, [4, this.doRenderSlide(t3.currentSlideIndex)]) : [3, 2];
            case 1:
              s2.sent(), s2.label = 2;
            case 2:
              return [4, (n3 = this.player) === null || n3 === void 0 ? void 0 : n3.clock.waitUntil(function() {
                var e4, i4;
                return ((e4 = o2.player) === null || e4 === void 0 ? void 0 : e4.currentIndex) === t3.currentSlideIndex && ((i4 = o2.player) === null || i4 === void 0 ? void 0 : i4.currentStage);
              }, 3e3)];
            case 3:
              return s2.sent(), r2 = false, Number.isInteger(t3.mainSeqStep) && t3.mainSeqStep !== this.__slideState.mainSeqStep && (r2 = true, this.__slideState.mainSeqStep = t3.mainSeqStep), t3.mainSeqState && t3.mainSeqState !== this.__slideState.mainSeqState && (r2 = true, this.__slideState.mainSeqState = t3.mainSeqState), r2 && this.setMainSeqStep(this.__slideState.mainSeqStep, this.__slideState.mainSeqState === "idle" ? "start" : "end"), t3.interactiveSeqState && (this.initInteractiveSeq(t3), this.__slideState.interactiveSeqState = t3.interactiveSeqState), [4, dT(1500)];
            case 4:
              return s2.sent(), t3.mediaState && (this.initMedia(t3), this.__slideState.mediaState = t3.mediaState), this.isSyncingSlideState = false, [2];
          }
        });
      });
    }, e2.prototype.initInteractiveSeq = function(t3) {
      var e3;
      for (var i3 in t3.interactiveSeqState) {
        var n3 = t3.interactiveSeqState[i3];
        (e3 = this.player) === null || e3 === void 0 || e3.setInteractiveSeqState(i3, n3.step, n3.state === "idle" ? "start" : "end");
      }
    }, e2.prototype.initMedia = function(t3) {
      var e3, i3, n3;
      for (var r2 in t3.mediaState) {
        var o2 = t3.mediaState[r2], s2 = this.__slideState.mediaState[r2];
        if ((e3 = this.player) === null || e3 === void 0 || e3.syncFullscreenVideoState({ targetId: r2, state: !!o2.fullscreen, slideIndex: this.slideState.currentSlideIndex }), !s2 || o2.type !== s2.type || o2.time !== s2.time)
          if (o2.type === "play") {
            var a2 = (this.timestamp() - o2.time) / 1e3;
            (i3 = this.player) === null || i3 === void 0 || i3.setMediaState(r2, true, a2);
          } else
            (n3 = this.player) === null || n3 === void 0 || n3.setMediaState(r2, false, o2.time);
      }
    }, Object.defineProperty(e2.prototype, "slideCount", { get: function() {
      return this._slideCount;
    }, enumerable: false, configurable: true }), e2.prototype.getSizeAsync = function() {
      return hT(this, void 0, void 0, function() {
        var t3;
        return uT(this, function(e3) {
          switch (e3.label) {
            case 0:
              if (this.width > 0 && this.height > 0)
                return [2, [this.width, this.height]];
              e3.label = 1;
            case 1:
              return e3.trys.push([1, 4, , 5]), [4, fetch(this.__slideState.url + "/" + this.__slideState.taskId + "/jsonOutput/slide-1.json")];
            case 2:
              return [4, e3.sent().json()];
            case 3:
              return [2, [(t3 = e3.sent()).width, t3.height]];
            case 4:
              return e3.sent(), [2, [0, 0]];
            case 5:
              return [2];
          }
        });
      });
    }, e2.prototype.getSlideCountAsync = function() {
      return hT(this, void 0, void 0, function() {
        return uT(this, function(t3) {
          switch (t3.label) {
            case 0:
              if (this._slideCount > 0)
                return [2, this._slideCount];
              t3.label = 1;
            case 1:
              return t3.trys.push([1, 4, , 5]), [4, fetch(this.__slideState.url + "/" + this.__slideState.taskId + "/jsonOutput/slide-1.json")];
            case 2:
              return [4, t3.sent().json()];
            case 3:
              return [2, t3.sent().slideCount];
            case 4:
              return t3.sent(), [2, 0];
            case 5:
              return [2];
          }
        });
      });
    }, Object.defineProperty(e2.prototype, "slideState", { get: function() {
      return this.__slideState.mainSeqState = this.mainSeqState, this.__slideState.mainSeqStep = this.mainSeqStep, JSON.parse(JSON.stringify(this.__slideState));
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqLength", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.mainSeqLength()) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqStep", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.mainSeqStep()) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqState", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.mainSeqState()) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "renderOptions", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.config) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "drawCall", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.runtime.drawCall) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "renderFps", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.runtime.fps) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "runtimeFps", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.fps.value) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "view", { get: function() {
      var t3;
      return ((t3 = this.player) === null || t3 === void 0 ? void 0 : t3.view) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
      return this.designWidth;
    }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
      return this.designHeight;
    }, enumerable: false, configurable: true }), e2.prototype.updateRenderOption = function(t3) {
      this.player && (this.player.updateConfig(t3), this.renderOptions && (this.config.renderOptions = this.renderOptions));
    }, e2.prototype.setResource = function(t3, e3) {
      var i3;
      this.taskId = t3, (i3 = this.player) === null || i3 === void 0 || i3.setResourceData(t3, e3), this.__slideState.taskId = t3, this.__slideState.url = e3, this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "setResource", taskId: t3, url: e3 });
    }, e2.prototype._renderSlide = function(t3) {
      var e3;
      return hT(this, void 0, void 0, function() {
        var i3 = this;
        return uT(this, function(n3) {
          switch (n3.label) {
            case 0:
              return this.renderingIndex = t3, this.player && t3 === this.player.currentIndex ? [2] : ((Vy.platform.isIOS() || Vy.platform.isAndroid()) && this.iosResetCache.indexOf(t3) < 0 && this.iosResetCache.push(t3), [4, (e3 = this.player) === null || e3 === void 0 ? void 0 : e3.renderSlide(t3)]);
            case 1:
              return n3.sent(), this.__slideState.currentSlideIndex = t3, this.resizeView(), this.__slideState.interactiveSeqState = {}, this.__slideState.mediaState = {}, this.emitStateChange(), setTimeout(function() {
                var t4, e4;
                if (((e4 = (t4 = i3.player) === null || t4 === void 0 ? void 0 : t4.view) === null || e4 === void 0 ? void 0 : e4.style.visibility) === "hidden" && (i3.player.view.style.visibility = "visible"), i3.frame.style.visibility === "hidden" && (i3.frame.style.visibility = "visible"), i3.needClearCacheImage)
                  try {
                    i3.frame.removeChild(i3.cacheImage);
                  } catch (t5) {
                  }
              }, 100), [2];
          }
        });
      });
    }, e2.prototype.renderSlide = function(t3, e3) {
      if (e3 === void 0 && (e3 = true), this.player) {
        var i3 = Number(t3);
        (i3 !== this.player.currentIndex || this.renderingTaskManager.hasStartTask()) && (i3 > this.slideCount && this.slideCount > 0 || this.poseRenderSlide(i3, e3));
      }
    }, e2.prototype.needCreateNewPlayer = function() {
      var t3 = Vy.platform.isLowGpuMemory() ? 15 : 30;
      return (Vy.platform.isIOS() || Vy.platform.isAndroid()) && this.iosResetCache.length > t3;
    }, e2.prototype.poseRenderSlide = function(t3, e3) {
      this.mode === "interactive" ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t3, isForward: e3 }) : this.mode === "sync" ? (this.doRenderSlide(t3, e3), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t3, isForward: e3 })) : this.doRenderSlide(t3, e3);
    }, e2.prototype.doRenderSlide = function(t3, e3) {
      var i3, n3, r2, o2 = this;
      if (e3 === void 0 && (e3 = true), !this.player)
        return Promise.resolve();
      if (this.needCreateNewPlayer() && (this.iosResetCache = [], this.iosNewPlayer = this.initPlayer(this.config), this.iosNewPlayer.setResourceData(this.__slideState.taskId, this.__slideState.url)), this.iosNewPlayer) {
        var s2 = this.player.getSnapshot();
        this.cacheImage.src = s2, this.frame.appendChild(this.cacheImage), this.player.destroy(), (i3 = this.playerController) === null || i3 === void 0 || i3.destroy(), this.player = this.iosNewPlayer, this.iosNewPlayer = void 0, ((n3 = this.config) === null || n3 === void 0 ? void 0 : n3.controller) && this.createController(), this.needClearCacheImage = true, ((r2 = this == null ? void 0 : this.player) === null || r2 === void 0 ? void 0 : r2.view) && (this.player.view.style.visibility = "hidden", this.canvasContainer.appendChild(this.player.view));
      }
      var a2 = Math.random().toString(32).substr(2);
      return this.player.isForward = e3, this.renderingTaskManager.addTask(function() {
        return o2._renderSlide(t3);
      }, t3, a2), new Promise(function(t4) {
        o2.renderingTaskManager.eventHub.once("task-end-" + a2, t4);
      });
    }, e2.prototype.getSnapshot = function() {
      var t3, e3;
      return (e3 = (t3 = this.player) === null || t3 === void 0 ? void 0 : t3.getSnapshot()) !== null && e3 !== void 0 ? e3 : null;
    }, e2.prototype.nextStep = function() {
      !this.isLoading && this.player && this.interactive ? (this.hasNextStep() || this.emit(fT.slideStepEnd), this.player.mainSeqHasNextStep() ? this.mode === "interactive" ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() + 1 }) : this.mode === "sync" ? (this.doNextStep(false, ""), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() })) : this.doNextStep(false, "") : this.handleNextSlide()) : this.logger.info("prevent nextStep. isLoading: " + this.isLoading + ", player: " + !!this.player + ", interactive: " + this.interactive, this.taskId);
    }, e2.prototype.doNextStep = function(t3, e3) {
      if (this.player) {
        var i3 = !this.config.clientId || e3 === this.config.clientId;
        this.player.nextStep(t3, i3);
        var n3 = this.player.mainSeqStep();
        this.__slideState.mainSeqStep = n3, this.emitStateChange();
      }
    }, e2.prototype.prevStep = function() {
      !this.isLoading && this.player && this.interactive ? (this.hasPrevStep() || this.emit(fT.slideStepStart), this.player.mainSeqHasPrevStep() ? this.mode === "interactive" ? this.emitSyncDispatch({ type: "prevStep", slideIndex: this.__slideState.currentSlideIndex, next: this.player.mainSeqStep() - 1 }) : this.mode === "sync" ? (this.doPrevStep(), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "prevStep", next: this.player.mainSeqStep() })) : this.doPrevStep() : this.handlePrevSlide()) : this.logger.info("prevent nextStep. isLoading: " + this.isLoading + ", player: " + this.player + ", interactive: " + this.interactive, this.taskId);
    }, e2.prototype.doPrevStep = function(t3) {
      if (t3 === void 0 && (t3 = false), this.player) {
        this.player.prevStep(t3);
        var e3 = this.player.mainSeqStep();
        this.__slideState.mainSeqStep = e3, this.emitStateChange();
      }
    }, e2.prototype.isSlideStateReady = function(t3) {
      return t3.taskId.length > 0 && t3.url.length > 0 && t3.currentSlideIndex > 0;
    }, e2.prototype.emitStateChange = function() {
      if (this.mode !== "local" && !this.isSyncingSlideState) {
        var t3 = this.slideState;
        !qy()(this.lastEmitedState, t3) && this.isSlideStateReady(t3) && (this.lastEmitedState = t3, this.emit(fT.stateChange, t3), this.logger.info("stateChange dispatch " + JSON.stringify(this.slideState), this.taskId));
      }
    }, e2.prototype.emitSyncDispatch = function(t3) {
      if (!this.lock.isLocked(t3.type)) {
        var e3 = Math.random().toString(32).substr(2);
        this.lock.addLock(t3.type, e3);
        var i3 = aT(aT({}, t3), { uuid: e3, clientId: this.config.clientId });
        this.config.mode === "sync" && (i3.incrId = this.dispatchIncrId), this.emit(fT.syncDispatch, i3), this.logger.info("sync dispatch " + JSON.stringify(i3), this.taskId);
      }
    }, e2.prototype.setMainSeqStep = function(t3, e3) {
      var i3;
      (i3 = this.player) === null || i3 === void 0 || i3.setMainSeqStep(t3, e3);
    }, e2.prototype.setInteractive = function(t3) {
      var e3;
      this.interactive = t3, (e3 = this.player) === null || e3 === void 0 || e3.setInteractive(t3);
    }, e2.prototype.pause = function() {
      var t3;
      (t3 = this.player) === null || t3 === void 0 || t3.pause();
    }, e2.prototype.resume = function() {
      var t3;
      (t3 = this.player) === null || t3 === void 0 || t3.resume();
    }, e2.prototype._doFrozen = function() {
      var t3;
      return hT(this, void 0, void 0, function() {
        var e3, i3, n3, r2 = this;
        return uT(this, function(o2) {
          switch (o2.label) {
            case 0:
              return this.logger.info("frozen with player[" + !!this.player + "]", this.taskId), this.tracker({ name: "frozenSlide", reason: "", result: "", payload: { taskId: this.taskId } }), this.view && this.player ? [4, this.player.clock.waitUntil(function() {
                return !r2.isLoading;
              }, 6e4)] : [3, 2];
            case 1:
              for (i3 in o2.sent(), e3 = this.player.getSnapshot() || "", this.cacheImage.src = e3, this.frame.appendChild(this.cacheImage), this.player.destroy(), (t3 = this.playerController) === null || t3 === void 0 || t3.destroy(), this.player = void 0, this.__slideState.mediaState)
                n3 = this.__slideState.mediaState[i3], this.__slideState.mediaState[i3] = aT(aT({}, n3), { frozenTime: this.timestamp() });
              o2.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e2.prototype.frozen = function() {
      var t3 = this;
      this.frozenTaskManager.addTask("frozen", function() {
        return t3._doFrozen();
      });
    }, e2.prototype._doRelease = function() {
      var t3, e3;
      return hT(this, void 0, void 0, function() {
        var i3, n3, r2, o2;
        return uT(this, function(s2) {
          switch (s2.label) {
            case 0:
              if (this.logger.info("do release slide", this.taskId), this.tracker({ name: "releaseSlide", reason: "", result: "", payload: { taskId: this.taskId } }), this.player)
                return [2];
              for (n3 in this.player = this.initPlayer(this.config), ((t3 = this.config) === null || t3 === void 0 ? void 0 : t3.controller) && this.createController(), this.player.view && (this.canvasContainer.appendChild(this.player.view), this.player.view.style.visibility = "hidden"), i3 = this.__slideState, this.__slideState = Qy()(mT), i3.mediaState)
                (r2 = i3.mediaState[n3]).type === "play" && (o2 = Math.max((e3 = r2.frozenTime) !== null && e3 !== void 0 ? e3 : 0, r2.time), r2.time = this.timestamp() - (o2 - r2.time), r2.frozenTime = void 0);
              return [4, this.setSlideState(i3)];
            case 1:
              return s2.sent(), [4, this.player.clock.delay(333)];
            case 2:
              s2.sent(), this.player.view && (this.player.view.style.visibility = "visible");
              try {
                this.frame.removeChild(this.cacheImage);
              } catch (t4) {
              }
              return [2];
          }
        });
      });
    }, e2.prototype.release = function() {
      var t3 = this;
      this.frozenTaskManager.addTask("release", function() {
        return t3._doRelease();
      });
    }, e2.prototype._doDestroy = function() {
      var t3, i3, n3, r2, o2 = this;
      this.logger.info("do destroy slide", this.taskId), this.tracker({ name: "destroySlide", reason: "", result: "", payload: { taskId: this.taskId } });
      var s2 = e2.instances.findIndex(function(t4) {
        return t4.randomId === o2.randomId;
      });
      s2 >= 0 && e2.instances.splice(s2, 1), this.playerController && this.playerController.destroy(), this.frameResizeObserver.disconnect(), (t3 = this.player) === null || t3 === void 0 || t3.removeAllListeners(), (i3 = this.player) === null || i3 === void 0 || i3.destroy(), (n3 = this.player) === null || n3 === void 0 || n3.removeAllListeners(), this.logger = { warn: function() {
        return {};
      }, info: function() {
        return {};
      }, error: function() {
        return {};
      } }, this.syncQueue.destroy(), this.renderingTaskManager.destroy(), this.frozenTaskManager.destroy(), window.removeEventListener("__slide_ref__", this.handleSlideRef), window.removeEventListener("message", this.recoverHandler), this.removeAllListeners();
      try {
        ((r2 = this.player) === null || r2 === void 0 ? void 0 : r2.view) && this.anchor.removeChild(this.player.view), this.anchor.removeChild(this.frame);
      } catch (t4) {
      }
      e2.volumeAdjuster.off("update", this._updateVolumeByStaticAdjuster);
    }, e2.prototype.waitLoadEnd = function() {
      return hT(this, void 0, void 0, function() {
        var t3;
        return uT(this, function(e3) {
          switch (e3.label) {
            case 0:
              t3 = 0, e3.label = 1;
            case 1:
              return this.isLoading && t3 < 10 ? [4, dT(100)] : [3, 3];
            case 2:
              return e3.sent(), t3 += 1, [3, 1];
            case 3:
              return [2];
          }
        });
      });
    }, e2.prototype.preload = function(t3) {
      return this.player ? this.player.preload(t3) : Promise.resolve();
    }, e2.prototype.destroy = function() {
      var t3 = this;
      this.logger.info("pre destroy slide", ""), this.isLoading ? this.waitLoadEnd().then(function() {
        t3._doDestroy();
      }) : this._doDestroy();
    }, e2.prototype.clearSlideCache = function() {
      var t3;
      (t3 = this.player) === null || t3 === void 0 || t3.clearLocalCache();
    }, e2.prototype.hasNextStep = function() {
      if (!this.player)
        return false;
      var t3 = this.player.currentIndex === this.slideCount, e3 = this.mainSeqLength === 0 || this.mainSeqStep >= this.mainSeqLength - 1, i3 = this.mainSeqState === "end" || this.mainSeqState === "running" || this.mainSeqState == null;
      return !(t3 && e3 && i3);
    }, e2.prototype.hasPrevStep = function() {
      if (!this.player)
        return false;
      var t3 = this.player.currentIndex === 1, e3 = this.mainSeqLength === 0 || this.mainSeqStep === 0, i3 = this.mainSeqState === "idle" || this.mainSeqState === null;
      return !(t3 && e3 && i3);
    }, e2.prototype.snapshot = function() {
      return hT(this, void 0, void 0, function() {
        return uT(this, function(t3) {
          return this.player ? [2, this.player.getSnapshot()] : [2, null];
        });
      });
    }, e2.prototype.snapshotWithTimingEnd = function(t3) {
      return hT(this, void 0, void 0, function() {
        return uT(this, function(e3) {
          return this.player ? [2, this.player.snapshotWithTimingEnd(t3)] : [2, null];
        });
      });
    }, e2.prototype.updateGlobalVolume = function(t3) {
      this.volumeAdjuster.volume = t3;
    }, e2.prototype.getGlobalVolume = function() {
      return this.volumeAdjuster.volume;
    }, e2.clearLocalCache = function() {
      Vy.clearLocalCache();
    }, e2.disposeLocalCache = function() {
    }, i2 = e2, e2.preloadResource = oT, e2.instances = [], e2._tempFrozenIds = [], e2._tempLog = "", e2._tempLogIndex = 1, e2.remoteLogAddress = null, e2.usePlugin = function(t3) {
      t3.context({ logger: { info: function(t4) {
        e2.appendLogString("INFO - " + new Date().toISOString() + " - " + t4 + "\n");
      }, warn: function(t4) {
        e2.appendLogString("WARN - " + new Date().toISOString() + " - " + t4 + "\n");
      }, error: function(t4) {
        e2.appendLogString("ERROR - " + new Date().toISOString() + " - " + t4 + "\n");
      } } }), function(t4) {
        var e3 = Xy.get(t4.hookPoint) || [];
        e3.push(t4), Xy.set(t4.hookPoint, e3);
      }(t3);
    }, e2.volumeAdjuster = new Gy(), e2.trackLogger = new iT(), e2.handleFrozenAllSlide = function() {
      e2.instances.forEach(function(t3) {
        t3.player && (e2._tempFrozenIds.push(t3.randomId), t3.frozen());
      });
    }, e2.handleReleaseAllSlide = function() {
      e2._tempFrozenIds.forEach(function(t3) {
        var i3 = e2.instances.find(function(e3) {
          return e3.randomId === t3;
        });
        i3 && i3.release();
      }), e2._tempFrozenIds = [];
    }, e2.handleLogReport = function(t3) {
      return hT(void 0, void 0, void 0, function() {
        var n3, r2, o2, s2, a2, l2;
        return uT(i2, function(i3) {
          switch (i3.label) {
            case 0:
              return [4, e2.flushLog(true)];
            case 1:
              if (i3.sent(), !vT)
                return [3, 12];
              n3 = [], i3.label = 2;
            case 2:
              return i3.trys.push([2, 4, , 5]), [4, vT.keys()];
            case 3:
              return n3 = (i3.sent() || []).sort(function(t4, e3) {
                return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
              }), [3, 5];
            case 4:
              return i3.sent(), [3, 5];
            case 5:
              if (n3.length === 0)
                return window.postMessage({ type: "@slide/_report_log_", log: "", index: 1, total: 1, customMessage: "@slide/_report_log_", sessionId: t3 }, "*"), [2];
              r2 = 0, o2 = n3, i3.label = 6;
            case 6:
              if (!(r2 < o2.length))
                return [3, 12];
              s2 = o2[r2], a2 = s2.replace("run_time_log_", ""), l2 = "", i3.label = 7;
            case 7:
              return i3.trys.push([7, 9, , 10]), [4, vT.getItem(s2)];
            case 8:
              return l2 = i3.sent() || "", [3, 10];
            case 9:
              return i3.sent(), [3, 10];
            case 10:
              window.postMessage({ type: "@slide/_report_log_", log: l2, index: parseInt(a2, 10), total: n3.length, customMessage: "@slide/_report_log_", sessionId: t3 }, "*"), i3.label = 11;
            case 11:
              return r2++, [3, 6];
            case 12:
              return [2];
          }
        });
      });
    }, e2.handleLogDownload = function() {
      return hT(void 0, void 0, void 0, function() {
        var t3, n3, r2, o2, s2, a2, l2;
        return uT(i2, function(i3) {
          switch (i3.label) {
            case 0:
              return i3.trys.push([0, 7, , 8]), [4, e2.flushLog(true)];
            case 1:
              return i3.sent(), t3 = "", vT ? [4, vT.keys()] : [3, 6];
            case 2:
              n3 = (i3.sent() || []).sort(function(t4, e3) {
                return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
              }), r2 = 0, o2 = n3, i3.label = 3;
            case 3:
              return r2 < o2.length ? (s2 = o2[r2], a2 = t3, [4, vT.getItem(s2)]) : [3, 6];
            case 4:
              t3 = a2 + (i3.sent() || ""), i3.label = 5;
            case 5:
              return r2++, [3, 3];
            case 6:
              return (l2 = document.createElement("a")).setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(t3)), l2.setAttribute("download", "slide_log"), l2.style.display = "none", document.body.appendChild(l2), l2.click(), document.body.removeChild(l2), [3, 8];
            case 7:
              return i3.sent(), [3, 8];
            case 8:
              return [2];
          }
        });
      });
    }, lT([(n2 = "Slide.initConfig", function(t3, e3, i3) {
      var r2 = i3.value;
      i3.value = function() {
        for (var t4 = [], e4 = 0; e4 < arguments.length; e4++)
          t4[e4] = arguments[e4];
        for (var i4 = Xy.get(n2) || [], o2 = t4, s2 = 0, a2 = i4; s2 < a2.length; s2++) {
          var l2 = a2[s2];
          try {
            o2 = l2.before(o2);
          } catch (t5) {
          }
          if (!Array.isArray(o2) || o2.length !== t4.length)
            throw new Error("plugin before hook return invalid args");
        }
        for (var h2 = r2.bind(this).apply(void 0, o2), u2 = 0, c2 = i4.reverse(); u2 < c2.length; u2++) {
          l2 = c2[u2];
          try {
            h2 = l2.after(h2);
          } catch (t5) {
          }
          if (!h2)
            throw new Error("plugin after hook return undefined result");
        }
        return h2;
      };
    })], e2.prototype, "initSlideConfig", null), e2;
  }(Za.a);
  vT == null || vT.clear().catch(function() {
  }), window.addEventListener("__slide_log__", _T.handleLogDownload), window.addEventListener("message", function(t2) {
    if (t2.data.type === "@slide/_request_log_")
      _T.handleLogReport(t2.data.sessionId).catch(function() {
      });
    else if (t2.data.type === "@slide/_request_frozen_")
      _T.handleFrozenAllSlide();
    else if (t2.data.type === "@slide/_request_release_")
      _T.handleReleaseAllSlide();
    else if (t2.data.type === "@slide/_update_volume_") {
      var e2 = 0.5;
      try {
        e2 = parseFloat(t2.data.volume.toString());
      } catch (t3) {
      }
      _T.volumeAdjuster.volume = e2;
    } else
      t2.data.type === "@slide/_get_volume_" ? window.postMessage({ type: "@slide/_report_volume_", volume: _T.volumeAdjuster.volume, customMessage: "@slide/_report_volume_" }, "*") : t2.data.type === "@slide/_preload_slide_" && _T.preloadResource(t2.data.taskId, t2.data.prefix, function(e3) {
        window.postMessage({ type: "@slide/_preload_slide_progress_", taskId: t2.data.taskId, progress: e3 }, "*");
      }).catch(function(e3) {
        window.postMessage({ type: "@slide/_preload_slide_error_", taskId: t2.data.taskId, error: e3 }, "*");
      });
  }), window.setInterval(function() {
    _T.flushLog().catch(function() {
    });
  }, 2e3);
}]);
const SOUP = "!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
const SOUP_LEN = 87;
const ID_LEN = 20;
const reusedIdCarrier = [];
const genUID = () => {
  for (let i = 0; i < ID_LEN; i++) {
    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);
  }
  return reusedIdCarrier.join("");
};
function invoke(fn) {
  try {
    return fn();
  } catch (e) {
    console.error(e);
  }
}
class SideEffectManager {
  constructor() {
    this.push = this.addDisposer;
    this.disposers = /* @__PURE__ */ new Map();
  }
  addDisposer(disposer, disposerID = this.genUID()) {
    this.flush(disposerID);
    this.disposers.set(disposerID, Array.isArray(disposer) ? joinDisposers(disposer) : disposer);
    return disposerID;
  }
  add(executor, disposerID = this.genUID()) {
    const disposers = executor();
    return disposers ? this.addDisposer(disposers, disposerID) : disposerID;
  }
  addEventListener(el, type, listener, options, disposerID = this.genUID()) {
    el.addEventListener(type, listener, options);
    this.addDisposer(() => el.removeEventListener(type, listener, options), disposerID);
    return disposerID;
  }
  setTimeout(handler, timeout, disposerID = this.genUID()) {
    const ticket = window.setTimeout(() => {
      this.remove(disposerID);
      handler();
    }, timeout);
    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);
  }
  setInterval(handler, timeout, disposerID = this.genUID()) {
    const ticket = window.setInterval(handler, timeout);
    return this.addDisposer(() => window.clearInterval(ticket), disposerID);
  }
  remove(disposerID) {
    const disposer = this.disposers.get(disposerID);
    this.disposers.delete(disposerID);
    return disposer;
  }
  flush(disposerID) {
    const disposer = this.remove(disposerID);
    if (disposer) {
      disposer();
    }
  }
  flushAll() {
    this.disposers.forEach(invoke);
    this.disposers.clear();
  }
  genUID() {
    let uid;
    do {
      uid = genUID();
    } while (this.disposers.has(uid));
    return uid;
  }
}
function joinDisposers(disposers) {
  return () => disposers.forEach(invoke);
}
function clamp$1(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function isObj(obj) {
  return typeof obj === "object" && obj !== null;
}
function isEditable(el) {
  if (!el)
    return false;
  const tagName = el.tagName;
  return tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT";
}
var colorString = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish2 = isArrayish$1;
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
  var results = [];
  for (var i = 0, len = args.length; i < len; i++) {
    var arg = args[i];
    if (isArrayish2(arg)) {
      results = concat.call(results, slice.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn) {
  return function() {
    return fn(swizzle$1(arguments));
  };
};
var colorNames = colorName;
var swizzle2 = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = /* @__PURE__ */ Object.create(null);
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb = [0, 0, 0, 1];
  var match;
  var i;
  var hexAlpha;
  if (match = string.match(hex)) {
    hexAlpha = match[2];
    match = match[1];
    for (i = 0; i < 3; i++) {
      var i2 = i * 2;
      rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i = 0; i < 3; i++) {
      rgb[i] = parseInt(match[i] + match[i], 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = parseInt(match[i + 1], 0);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(per)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match[1])) {
      return null;
    }
    rgb = colorNames[match[1]];
    rgb[3] = 1;
    return rgb;
  } else {
    return null;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] = clamp(rgb[i], 0, 255);
  }
  rgb[3] = clamp(rgb[3], 0, 1);
  return rgb;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hsl);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var s = clamp(parseFloat(match[2]), 0, 100);
    var l = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s, l, a];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hwb);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var w = clamp(parseFloat(match[2]), 0, 100);
    var b = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w, b, a];
  }
  return null;
};
cs.to.hex = function() {
  var rgba = swizzle2(arguments);
  return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba = swizzle2(arguments);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba = swizzle2(arguments);
  var r = Math.round(rgba[0] / 255 * 100);
  var g = Math.round(rgba[1] / 255 * 100);
  var b = Math.round(rgba[2] / 255 * 100);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function() {
  var hsla = swizzle2(arguments);
  return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle2(arguments);
  var a = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(rgb) {
  return reverseNames[rgb.slice(0, 3)];
};
function clamp(num, min, max) {
  return Math.min(Math.max(min, num), max);
}
function hexDouble(num) {
  var str = Math.round(num).toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
}
var ColorString = colorString.exports;
class Logger {
  constructor(enable) {
    this.enable = enable;
    this.apps = {};
    this.level = "debug";
    this.roomLogger = null;
    this._onMessage = (ev) => {
      let data;
      if (ev instanceof CustomEvent) {
        data = ev.detail;
      } else if (isObj(ev.data)) {
        data = ev.data;
      }
      if (data) {
        if (typeof data.slide === "boolean") {
          this.enable = data.slide;
        } else if (data.slide === "__instance") {
          console.log(this);
        } else if (data.slide === "__debug") {
          Object.values(this.apps).forEach((app) => {
            var _a, _b;
            (_b = (_a = app.controller) == null ? void 0 : _a.slide) == null ? void 0 : _b.createController();
          });
        }
      }
    };
    this.initialize();
  }
  setAppContext(appId, context) {
    var _a;
    ((_a = this.apps)[appId] || (_a[appId] = {})).context = context;
    this.log(`[Slide] new ${appId}`);
  }
  setAppController(appId, controller) {
    var _a;
    ((_a = this.apps)[appId] || (_a[appId] = {})).controller = controller;
  }
  deleteApp(appId) {
    delete this.apps[appId];
    this.log(`[Slide] delete ${appId}`);
  }
  initialize() {
    window.addEventListener("message", this._onMessage);
  }
  dispose() {
    window.removeEventListener("message", this._onMessage);
  }
  log(...args) {
    if (this.roomLogger) {
      this.roomLogger.info(...args);
    } else if (this.enable) {
      console.log(...args);
    }
  }
  verbose(...args) {
    if (this.roomLogger) {
      this.roomLogger.debug(...args);
    } else if (this.enable && this.level === "verbose") {
      console.log(...args);
    }
  }
  warn(...args) {
    if (this.roomLogger) {
      this.roomLogger.warn(...args);
    } else {
      console.warn(...args);
    }
  }
}
const logger = /* @__PURE__ */ new Logger(false);
const log = /* @__PURE__ */ logger.log.bind(logger);
const verbose = /* @__PURE__ */ logger.verbose.bind(logger);
const setRoomLogger = (displayer) => {
  logger.roomLogger = displayer.logger;
};
function guessBgColor(el) {
  try {
    const bg = window.getComputedStyle(el).backgroundColor;
    if (bg !== "rgba(0, 0, 0, 0)" && bg !== "transparent") {
      return bg;
    }
    if (el.parentElement) {
      return guessBgColor(el.parentElement);
    }
  } catch {
  }
  return "#ffffff";
}
function toHex(color) {
  const result = ColorString.get(color);
  if (result && result.model === "rgb") {
    const args = result.value;
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16);
    return "#" + "000000".substring(string.length) + string;
  } else {
    return color;
  }
}
let cachedBgColor = "";
function cachedGetBgColor(el) {
  if (!cachedBgColor) {
    cachedBgColor = toHex(guessBgColor(el));
    log("[Slide] guess bg color", cachedBgColor);
  }
  return cachedBgColor;
}
const getRoomTracker = (displayer) => {
  return displayer.tracker;
};
function createDocsViewerPages(slide) {
  const { width, height, slideCount, slideState } = slide;
  const { taskId, url } = slideState;
  const pages = [];
  for (let i = 1; i <= slideCount; ++i) {
    pages.push({ width, height, thumbnail: `${url}/${taskId}/preview/${i}.png`, src: "ppt" });
  }
  return pages;
}
function syncSceneWithSlide(room, context, slide, baseScenePath) {
  var _a;
  const page = slide.slideState.currentSlideIndex;
  if (!(page > 0) || !context.getIsWritable())
    return;
  const scenePath = [baseScenePath, page].join("/");
  if (room.scenePathType(scenePath) !== "page") {
    room.removeScenes(baseScenePath);
    const count = slide.slideCount;
    const scenes = [];
    for (let i = 1; i <= count; ++i)
      scenes.push({ name: `${i}` });
    room.putScenes(baseScenePath, scenes);
  }
  let currentScenePath;
  if (context.getBox().focus) {
    currentScenePath = room.state.sceneState.scenePath;
  } else {
    currentScenePath = ((_a = context.getView()) == null ? void 0 : _a.focusScenePath) || "";
  }
  if (currentScenePath !== scenePath) {
    context.setScenePath(scenePath);
  }
}
const DefaultUrl = "https://convertcdn.netless.link/dynamicConvert";
const MaxPollCount = 40;
const EmptyAttributes = {
  taskId: "",
  url: "",
  state: null
};
class SlideController {
  constructor({
    context,
    anchor,
    onRenderStart,
    onPageChanged,
    onTransitionStart,
    onTransitionEnd,
    onError,
    onRenderError,
    showRenderError
  }) {
    this.sideEffect = new SideEffectManager();
    this.ready = false;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = () => {
        if (this.ready) {
          log("[Slide] render end");
        } else {
          setTimeout(() => {
            this.ready = true;
            resolve();
          }, 1e3);
        }
      };
    });
    this.onSyncDispatch = (event) => {
      if (this.context.getIsWritable() && this.room) {
        const payload = {
          type: Slide.SLIDE_EVENTS.syncDispatch,
          payload: event
        };
        verbose("[Slide] dispatch", JSON.stringify(event));
        this.context.dispatchMagixEvent(Slide.SLIDE_EVENTS.syncDispatch, payload);
      }
    };
    this.magixEventListener = (ev) => {
      const { type, payload } = ev.payload;
      if (type === Slide.SLIDE_EVENTS.syncDispatch) {
        this.syncStateOnce();
        verbose("[Slide] receive", JSON.stringify(payload));
        this.slide.emit(Slide.SLIDE_EVENTS.syncReceive, payload);
      }
    };
    this.onStateChange = (state) => {
      if (this.context.getIsWritable()) {
        verbose("[Slide] state change", JSON.stringify(state, null, 2));
        this.context.storage.setState({ state });
      }
    };
    this.pollCount = 0;
    this.pollReadyState = () => {
      if (this.ready) {
        if (this._toFreeze === 1) {
          this.freeze();
        } else if (this._toFreeze === -1) {
          this.unfreeze();
        }
      } else if (this.pollCount < MaxPollCount) {
        this.pollCount++;
        setTimeout(this.pollReadyState, 500);
      } else {
        this.pollCount = 0;
        log("[Slide] renderSlide 1 (retry after timeout)");
        this.slide.renderSlide(1);
      }
    };
    this._pageCount = 0;
    this.destroyed = false;
    this.timestamp = () => {
      if (this.room && this.room.calibrationTimestamp) {
        return this.room.calibrationTimestamp;
      } else if (this.player) {
        return this.player.beginTimestamp + this.player.progressTime;
      } else {
        return Date.now();
      }
    };
    this.isFrozen = false;
    this._toFreeze = 0;
    this.freeze = () => {
      this.isFrozen = true;
      if (this.ready) {
        log("[Slide] freeze", this.context.appId);
        this.slide.frozen();
      } else {
        this._toFreeze = 1;
      }
    };
    this.unfreeze = async () => {
      if (!this.visible)
        return;
      this.isFrozen = false;
      if (this.ready) {
        log("[Slide] unfreeze", this.context.appId);
        this.slide.release();
      } else {
        this._toFreeze = -1;
      }
    };
    this.onVisibilityChange = async () => {
      if (!(this.visible = document.visibilityState === "visible")) {
        this.savedIsFrozen = this.isFrozen;
        log("[Slide] freeze because tab becomes invisible");
        this.freeze();
      } else {
        log("[Slide] unfreeze because tab becomes visible", { savedIsFrozen: this.savedIsFrozen });
        if (!this.savedIsFrozen) {
          this.unfreeze();
        }
      }
    };
    this.onRenderStart = onRenderStart;
    this.onPageChanged = onPageChanged;
    this.onTransitionStart = onTransitionStart;
    this.onTransitionEnd = onTransitionEnd;
    this.onError = onError;
    this.onRenderError = onRenderError;
    this.showRenderError = showRenderError != null ? showRenderError : true;
    this.context = context;
    this.room = context.getRoom();
    this.player = this.room ? void 0 : context.getDisplayer();
    setRoomLogger(this.room || this.player);
    this.slide = this.createSlide(anchor, {
      whiteTracker: getRoomTracker(context.getDisplayer())
    });
    this.syncStateOnceFlag = !this.context.isAddApp;
    this.visible = document.visibilityState === "visible";
    this.savedIsFrozen = false;
    this.initialize();
  }
  jumpToPage(page) {
    if (this.ready) {
      page = clamp$1(page, 1, this.pageCount);
      this.slide.renderSlide(page);
    }
  }
  initialize() {
    this.registerEventListeners();
    this.kickStart();
  }
  kickStart() {
    const { context, slide } = this;
    if (context.getIsWritable()) {
      context.storage.ensureState(EmptyAttributes);
    }
    const { taskId, url, state } = context.storage.state;
    slide.setResource(taskId, url || DefaultUrl);
    if (state) {
      log("[Slide] init with state", JSON.stringify(state));
      this.syncStateOnceFlag = false;
      slide.setSlideState(state);
    } else if (context.isAddApp) {
      log("[Slide] init by renderSlide", 1);
      slide.renderSlide(1);
    }
    this.pollReadyState();
  }
  registerEventListeners() {
    const { context, slide } = this;
    const disposerId = this.sideEffect.addDisposer(context.storage.addStateChangedListener(() => {
      if (context.storage.state.state) {
        this.syncStateOnce();
        this.sideEffect.flush(disposerId);
      }
    }));
    this.sideEffect.add(() => context.addMagixEventListener(Slide.SLIDE_EVENTS.syncDispatch, this.magixEventListener, {
      fireSelfEventAfterCommit: true
    }));
    slide.on(Slide.SLIDE_EVENTS.renderStart, this.onRenderStart);
    slide.on(Slide.SLIDE_EVENTS.slideChange, this.onPageChanged);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.renderError, this.onError);
    slide.on(Slide.SLIDE_EVENTS.stateChange, this.onStateChange);
    slide.on(Slide.SLIDE_EVENTS.syncDispatch, this.onSyncDispatch);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.resolveReady);
    this.sideEffect.add(() => {
      document.addEventListener("visibilitychange", this.onVisibilityChange);
      return () => document.removeEventListener("visibilitychange", this.onVisibilityChange);
    });
  }
  syncStateOnce() {
    if (this.syncStateOnceFlag) {
      if (this.context.getIsWritable()) {
        this.context.storage.ensureState(EmptyAttributes);
      }
      const { state } = this.context.storage.state;
      if (state) {
        log("[Slide] sync with state (once)", JSON.stringify(state));
        this.slide.setSlideState(state);
        this.syncStateOnceFlag = false;
      }
    }
  }
  get pageCount() {
    if (this._pageCount > 0)
      return this._pageCount;
    this._pageCount = this.slide.slideCount;
    return this._pageCount;
  }
  get page() {
    return this.slide.slideState.currentSlideIndex;
  }
  createSlide(anchor, defaults = {}) {
    var _a, _b, _c;
    const options = this.context.getAppOptions() || {};
    const slide = new Slide.Slide({
      anchor,
      interactive: true,
      mode: "interactive",
      controller: logger.enable,
      enableGlobalClick: (_a = options.enableGlobalClick) != null ? _a : true,
      renderOptions: {
        minFPS: options.minFPS || 25,
        maxFPS: options.maxFPS || 30,
        autoFPS: (_b = options.autoFPS) != null ? _b : true,
        autoResolution: (_c = options.autoResolution) != null ? _c : true,
        resolution: options.resolution,
        transactionBgColor: options.bgColor || cachedGetBgColor(anchor),
        maxResolutionLevel: options.maxResolutionLevel,
        forceCanvas: options.forceCanvas,
        enableNvidiaDetect: options.enableNvidiaDetect
      },
      fixedFrameSize: options.fixedFrameSize,
      loaderDelegate: options.loaderDelegate,
      navigatorDelegate: options.navigatorDelegate,
      urlInterrupter: options.urlInterrupter,
      resourceTimeout: options.resourceTimeout,
      rtcAudio: options.rtcAudio,
      useLocalCache: options.useLocalCache,
      logger: options.logger,
      whiteTracker: defaults.whiteTracker,
      timestamp: this.timestamp
    });
    return slide;
  }
  destroy() {
    this.sideEffect.flushAll();
    if (!this.destroyed) {
      log("[Slide] destroy slide (once)");
      this.slide.destroy();
      this.destroyed = true;
    }
  }
}
function sidebarSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-sidebar`);
  $svg.setAttribute("viewBox", "0 0 64 64");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M50 8H14c-3.309 0-6 2.691-6 6v36c0 3.309 2.691 6 6 6h36c3.309 0 6-2.691 6-6V14c0-3.309-2.691-6-6-6zM12 50V14c0-1.103.897-2 2-2h8v40h-8c-1.103 0-2-.897-2-2zm40 0c0 1.103-.897 2-2 2H26V12h24c1.103 0 2 .897 2 2z");
  $svg.appendChild($path);
  return $svg;
}
function arrowLeftSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-left`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M177.81 249.959L337.473 90.295c2.722-2.865 2.651-7.378-.143-10.1-2.793-2.65-7.163-2.65-9.956 0l-164.75 164.75c-2.793 2.793-2.793 7.306 0 10.1l164.75 164.75c2.865 2.722 7.378 2.65 10.099-.143 2.651-2.794 2.651-7.163 0-9.957L177.809 249.959z");
  $svg.appendChild($path);
  return $svg;
}
function arrowRightSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-right`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M322.19 250.041L162.527 409.705c-2.722 2.865-2.651 7.378.143 10.1 2.793 2.65 7.163 2.65 9.956 0l164.75-164.75c2.793-2.793 2.793-7.306 0-10.1l-164.75-164.75c-2.865-2.722-7.378-2.65-10.099.143-2.651 2.794-2.651 7.163 0 9.957l159.664 159.736z");
  $svg.appendChild($path);
  return $svg;
}
function playSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-play`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M418.158 257.419L174.663 413.33c-6.017 3.919-15.708 3.772-21.291-.29-2.791-2.018-4.295-4.483-4.295-7.084V94.109c0-5.65 6.883-10.289 15.271-10.289 4.298 0 8.391 1.307 11.181 3.332l242.629 155.484c6.016 3.917 6.451 10.292.649 14.491-.216.154-.432.154-.649.292zM170.621 391.288l223.116-141.301L170.71 107.753l-.089 283.535z");
  $svg.appendChild($path);
  return $svg;
}
function pauseSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-pause`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M312.491 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261zM165.257 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261z");
  $svg.appendChild($path);
  return $svg;
}
const runningOnBrowser = typeof window !== "undefined";
const isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
const supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
const supportsClassList = runningOnBrowser && "classList" in document.createElement("p");
const isHiDpi = runningOnBrowser && window.devicePixelRatio > 1;
const defaultSettings = {
  elements_selector: ".lazy",
  container: isBot || runningOnBrowser ? document : null,
  threshold: 300,
  thresholds: null,
  data_src: "src",
  data_srcset: "srcset",
  data_sizes: "sizes",
  data_bg: "bg",
  data_bg_hidpi: "bg-hidpi",
  data_bg_multi: "bg-multi",
  data_bg_multi_hidpi: "bg-multi-hidpi",
  data_bg_set: "bg-set",
  data_poster: "poster",
  class_applied: "applied",
  class_loading: "loading",
  class_loaded: "loaded",
  class_error: "error",
  class_entered: "entered",
  class_exited: "exited",
  unobserve_completed: true,
  unobserve_entered: false,
  cancel_on_exit: true,
  callback_enter: null,
  callback_exit: null,
  callback_applied: null,
  callback_loading: null,
  callback_loaded: null,
  callback_error: null,
  callback_finish: null,
  callback_cancel: null,
  use_native: false,
  restore_on_error: false
};
const getExtendedSettings = (customSettings) => {
  return Object.assign({}, defaultSettings, customSettings);
};
const createInstance = function(classObj, options) {
  let event;
  const eventString = "LazyLoad::Initialized";
  const instance = new classObj(options);
  try {
    event = new CustomEvent(eventString, { detail: { instance } });
  } catch (err) {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventString, false, false, { instance });
  }
  window.dispatchEvent(event);
};
const autoInitialize = (classObj, options) => {
  if (!options) {
    return;
  }
  if (!options.length) {
    createInstance(classObj, options);
  } else {
    for (let i = 0, optionsItem; optionsItem = options[i]; i += 1) {
      createInstance(classObj, optionsItem);
    }
  }
};
const SRC = "src";
const SRCSET = "srcset";
const SIZES = "sizes";
const POSTER = "poster";
const ORIGINALS = "llOriginalAttrs";
const DATA = "data";
const statusLoading = "loading";
const statusLoaded = "loaded";
const statusApplied = "applied";
const statusEntered = "entered";
const statusError = "error";
const statusNative = "native";
const dataPrefix = "data-";
const statusDataName = "ll-status";
const getData = (element, attribute) => {
  return element.getAttribute(dataPrefix + attribute);
};
const setData = (element, attribute, value) => {
  var attrName = dataPrefix + attribute;
  if (value === null) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const getStatus = (element) => getData(element, statusDataName);
const setStatus = (element, status) => setData(element, statusDataName, status);
const resetStatus = (element) => setStatus(element, null);
const hasEmptyStatus = (element) => getStatus(element) === null;
const hasStatusLoading = (element) => getStatus(element) === statusLoading;
const hasStatusError = (element) => getStatus(element) === statusError;
const hasStatusNative = (element) => getStatus(element) === statusNative;
const statusesAfterLoading = [statusLoading, statusLoaded, statusApplied, statusError];
const hadStartedLoading = (element) => statusesAfterLoading.indexOf(getStatus(element)) >= 0;
const safeCallback = (callback, arg1, arg2, arg3) => {
  if (!callback) {
    return;
  }
  if (arg3 !== void 0) {
    callback(arg1, arg2, arg3);
    return;
  }
  if (arg2 !== void 0) {
    callback(arg1, arg2);
    return;
  }
  callback(arg1);
};
const addClass = (element, className) => {
  if (supportsClassList) {
    element.classList.add(className);
    return;
  }
  element.className += (element.className ? " " : "") + className;
};
const removeClass = (element, className) => {
  if (supportsClassList) {
    element.classList.remove(className);
    return;
  }
  element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
};
const addTempImage = (element) => {
  element.llTempImage = document.createElement("IMG");
};
const deleteTempImage = (element) => {
  delete element.llTempImage;
};
const getTempImage = (element) => element.llTempImage;
const unobserve = (element, instance) => {
  if (!instance)
    return;
  const observer = instance._observer;
  if (!observer)
    return;
  observer.unobserve(element);
};
const resetObserver = (observer) => {
  observer.disconnect();
};
const unobserveEntered = (element, settings, instance) => {
  if (settings.unobserve_entered)
    unobserve(element, instance);
};
const updateLoadingCount = (instance, delta) => {
  if (!instance)
    return;
  instance.loadingCount += delta;
};
const decreaseToLoadCount = (instance) => {
  if (!instance)
    return;
  instance.toLoadCount -= 1;
};
const setToLoadCount = (instance, value) => {
  if (!instance)
    return;
  instance.toLoadCount = value;
};
const isSomethingLoading = (instance) => instance.loadingCount > 0;
const haveElementsToLoad = (instance) => instance.toLoadCount > 0;
const getSourceTags = (parentTag) => {
  let sourceTags = [];
  for (let i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
    if (childTag.tagName === "SOURCE") {
      sourceTags.push(childTag);
    }
  }
  return sourceTags;
};
const forEachPictureSource = (element, fn) => {
  const parent = element.parentNode;
  if (!parent || parent.tagName !== "PICTURE") {
    return;
  }
  let sourceTags = getSourceTags(parent);
  sourceTags.forEach(fn);
};
const forEachVideoSource = (element, fn) => {
  let sourceTags = getSourceTags(element);
  sourceTags.forEach(fn);
};
const attrsSrc = [SRC];
const attrsSrcPoster = [SRC, POSTER];
const attrsSrcSrcsetSizes = [SRC, SRCSET, SIZES];
const attrsData = [DATA];
const hasOriginalAttrs = (element) => !!element[ORIGINALS];
const getOriginalAttrs = (element) => element[ORIGINALS];
const deleteOriginalAttrs = (element) => delete element[ORIGINALS];
const setOriginalsObject = (element, attributes) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  const originals = {};
  attributes.forEach((attribute) => {
    originals[attribute] = element.getAttribute(attribute);
  });
  element[ORIGINALS] = originals;
};
const saveOriginalBackgroundStyle = (element) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  element[ORIGINALS] = { backgroundImage: element.style.backgroundImage };
};
const setOrResetAttribute = (element, attrName, value) => {
  if (!value) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const restoreOriginalAttrs = (element, attributes) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  attributes.forEach((attribute) => {
    setOrResetAttribute(element, attribute, originals[attribute]);
  });
};
const restoreOriginalBgImage = (element) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  element.style.backgroundImage = originals.backgroundImage;
};
const manageApplied = (element, settings, instance) => {
  addClass(element, settings.class_applied);
  setStatus(element, statusApplied);
  if (!instance)
    return;
  if (settings.unobserve_completed) {
    unobserve(element, settings);
  }
  safeCallback(settings.callback_applied, element, instance);
};
const manageLoading = (element, settings, instance) => {
  addClass(element, settings.class_loading);
  setStatus(element, statusLoading);
  if (!instance)
    return;
  updateLoadingCount(instance, 1);
  safeCallback(settings.callback_loading, element, instance);
};
const setAttributeIfValue = (element, attrName, value) => {
  if (!value) {
    return;
  }
  element.setAttribute(attrName, value);
};
const setImageAttributes = (element, settings) => {
  setAttributeIfValue(element, SIZES, getData(element, settings.data_sizes));
  setAttributeIfValue(element, SRCSET, getData(element, settings.data_srcset));
  setAttributeIfValue(element, SRC, getData(element, settings.data_src));
};
const setSourcesImg = (imgEl, settings) => {
  forEachPictureSource(imgEl, (sourceTag) => {
    setOriginalsObject(sourceTag, attrsSrcSrcsetSizes);
    setImageAttributes(sourceTag, settings);
  });
  setOriginalsObject(imgEl, attrsSrcSrcsetSizes);
  setImageAttributes(imgEl, settings);
};
const setSourcesIframe = (iframe, settings) => {
  setOriginalsObject(iframe, attrsSrc);
  setAttributeIfValue(iframe, SRC, getData(iframe, settings.data_src));
};
const setSourcesVideo = (videoEl, settings) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    setOriginalsObject(sourceEl, attrsSrc);
    setAttributeIfValue(sourceEl, SRC, getData(sourceEl, settings.data_src));
  });
  setOriginalsObject(videoEl, attrsSrcPoster);
  setAttributeIfValue(videoEl, POSTER, getData(videoEl, settings.data_poster));
  setAttributeIfValue(videoEl, SRC, getData(videoEl, settings.data_src));
  videoEl.load();
};
const setSourcesObject = (object, settings) => {
  setOriginalsObject(object, attrsData);
  setAttributeIfValue(object, DATA, getData(object, settings.data_src));
};
const setBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg);
  const bgHiDpiValue = getData(element, settings.data_bg_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue)
    return;
  element.style.backgroundImage = `url("${bgDataValue}")`;
  getTempImage(element).setAttribute(SRC, bgDataValue);
  manageLoading(element, settings, instance);
};
const setMultiBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg_multi);
  const bgHiDpiValue = getData(element, settings.data_bg_multi_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue) {
    return;
  }
  element.style.backgroundImage = bgDataValue;
  manageApplied(element, settings, instance);
};
const setImgsetBackground = (element, settings, instance) => {
  const bgImgSetDataValue = getData(element, settings.data_bg_set);
  if (!bgImgSetDataValue) {
    return;
  }
  const imgSetValues = bgImgSetDataValue.split("|");
  let bgImageValues = imgSetValues.map((value) => `image-set(${value})`);
  element.style.backgroundImage = bgImageValues.join();
  if (element.style.backgroundImage === "") {
    bgImageValues = imgSetValues.map((value) => `-webkit-image-set(${value})`);
    element.style.backgroundImage = bgImageValues.join();
  }
  manageApplied(element, settings, instance);
};
const setSourcesFunctions = {
  IMG: setSourcesImg,
  IFRAME: setSourcesIframe,
  VIDEO: setSourcesVideo,
  OBJECT: setSourcesObject
};
const setSourcesNative = (element, settings) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
};
const setSources = (element, settings, instance) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
  manageLoading(element, settings, instance);
};
const elementsWithLoadEvent = ["IMG", "IFRAME", "VIDEO", "OBJECT"];
const hasLoadEvent = (element) => elementsWithLoadEvent.indexOf(element.tagName) > -1;
const checkFinish = (settings, instance) => {
  if (instance && !isSomethingLoading(instance) && !haveElementsToLoad(instance)) {
    safeCallback(settings.callback_finish, instance);
  }
};
const addEventListener = (element, eventName, handler) => {
  element.addEventListener(eventName, handler);
  element.llEvLisnrs[eventName] = handler;
};
const removeEventListener = (element, eventName, handler) => {
  element.removeEventListener(eventName, handler);
};
const hasEventListeners = (element) => {
  return !!element.llEvLisnrs;
};
const addEventListeners = (element, loadHandler2, errorHandler2) => {
  if (!hasEventListeners(element))
    element.llEvLisnrs = {};
  const loadEventName = element.tagName === "VIDEO" ? "loadeddata" : "load";
  addEventListener(element, loadEventName, loadHandler2);
  addEventListener(element, "error", errorHandler2);
};
const removeEventListeners = (element) => {
  if (!hasEventListeners(element)) {
    return;
  }
  const eventListeners = element.llEvLisnrs;
  for (let eventName in eventListeners) {
    const handler = eventListeners[eventName];
    removeEventListener(element, eventName, handler);
  }
  delete element.llEvLisnrs;
};
const doneHandler = (element, settings, instance) => {
  deleteTempImage(element);
  updateLoadingCount(instance, -1);
  decreaseToLoadCount(instance);
  removeClass(element, settings.class_loading);
  if (settings.unobserve_completed) {
    unobserve(element, instance);
  }
};
const loadHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_loaded);
  setStatus(element, statusLoaded);
  safeCallback(settings.callback_loaded, element, instance);
  if (!goingNative)
    checkFinish(settings, instance);
};
const errorHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_error);
  setStatus(element, statusError);
  safeCallback(settings.callback_error, element, instance);
  if (settings.restore_on_error)
    restoreOriginalAttrs(element, attrsSrcSrcsetSizes);
  if (!goingNative)
    checkFinish(settings, instance);
};
const addOneShotEventListeners = (element, settings, instance) => {
  const elementToListenTo = getTempImage(element) || element;
  if (hasEventListeners(elementToListenTo)) {
    return;
  }
  const _loadHandler = (event) => {
    loadHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  const _errorHandler = (event) => {
    errorHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  addEventListeners(elementToListenTo, _loadHandler, _errorHandler);
};
const loadBackground = (element, settings, instance) => {
  addTempImage(element);
  addOneShotEventListeners(element, settings, instance);
  saveOriginalBackgroundStyle(element);
  setBackground(element, settings, instance);
  setMultiBackground(element, settings, instance);
  setImgsetBackground(element, settings, instance);
};
const loadRegular = (element, settings, instance) => {
  addOneShotEventListeners(element, settings, instance);
  setSources(element, settings, instance);
};
const load = (element, settings, instance) => {
  if (hasLoadEvent(element)) {
    loadRegular(element, settings, instance);
  } else {
    loadBackground(element, settings, instance);
  }
};
const loadNative = (element, settings, instance) => {
  element.setAttribute("loading", "lazy");
  addOneShotEventListeners(element, settings, instance);
  setSourcesNative(element, settings);
  setStatus(element, statusNative);
};
const removeImageAttributes = (element) => {
  element.removeAttribute(SRC);
  element.removeAttribute(SRCSET);
  element.removeAttribute(SIZES);
};
const resetSourcesImg = (element) => {
  forEachPictureSource(element, (sourceTag) => {
    removeImageAttributes(sourceTag);
  });
  removeImageAttributes(element);
};
const restoreImg = (imgEl) => {
  forEachPictureSource(imgEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrcSrcsetSizes);
  });
  restoreOriginalAttrs(imgEl, attrsSrcSrcsetSizes);
};
const restoreVideo = (videoEl) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrc);
  });
  restoreOriginalAttrs(videoEl, attrsSrcPoster);
  videoEl.load();
};
const restoreIframe = (iframeEl) => {
  restoreOriginalAttrs(iframeEl, attrsSrc);
};
const restoreObject = (objectEl) => {
  restoreOriginalAttrs(objectEl, attrsData);
};
const restoreFunctions = {
  IMG: restoreImg,
  IFRAME: restoreIframe,
  VIDEO: restoreVideo,
  OBJECT: restoreObject
};
const restoreAttributes = (element) => {
  const restoreFunction = restoreFunctions[element.tagName];
  if (!restoreFunction) {
    restoreOriginalBgImage(element);
    return;
  }
  restoreFunction(element);
};
const resetClasses = (element, settings) => {
  if (hasEmptyStatus(element) || hasStatusNative(element)) {
    return;
  }
  removeClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  removeClass(element, settings.class_applied);
  removeClass(element, settings.class_loading);
  removeClass(element, settings.class_loaded);
  removeClass(element, settings.class_error);
};
const restore = (element, settings) => {
  restoreAttributes(element);
  resetClasses(element, settings);
  resetStatus(element);
  deleteOriginalAttrs(element);
};
const cancelLoading = (element, entry, settings, instance) => {
  if (!settings.cancel_on_exit)
    return;
  if (!hasStatusLoading(element))
    return;
  if (element.tagName !== "IMG")
    return;
  removeEventListeners(element);
  resetSourcesImg(element);
  restoreImg(element);
  removeClass(element, settings.class_loading);
  updateLoadingCount(instance, -1);
  resetStatus(element);
  safeCallback(settings.callback_cancel, element, entry, instance);
};
const onEnter = (element, entry, settings, instance) => {
  const dontLoad = hadStartedLoading(element);
  setStatus(element, statusEntered);
  addClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  unobserveEntered(element, settings, instance);
  safeCallback(settings.callback_enter, element, entry, instance);
  if (dontLoad)
    return;
  load(element, settings, instance);
};
const onExit = (element, entry, settings, instance) => {
  if (hasEmptyStatus(element))
    return;
  addClass(element, settings.class_exited);
  cancelLoading(element, entry, settings, instance);
  safeCallback(settings.callback_exit, element, entry, instance);
};
const tagsWithNativeLazy = ["IMG", "IFRAME", "VIDEO"];
const shouldUseNative = (settings) => settings.use_native && "loading" in HTMLImageElement.prototype;
const loadAllNative = (elements, settings, instance) => {
  elements.forEach((element) => {
    if (tagsWithNativeLazy.indexOf(element.tagName) === -1) {
      return;
    }
    loadNative(element, settings, instance);
  });
  setToLoadCount(instance, 0);
};
const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;
const getObserverSettings = (settings) => ({
  root: settings.container === document ? null : settings.container,
  rootMargin: settings.thresholds || settings.threshold + "px"
});
const intersectionHandler = (entries, settings, instance) => {
  entries.forEach((entry) => isIntersecting(entry) ? onEnter(entry.target, entry, settings, instance) : onExit(entry.target, entry, settings, instance));
};
const observeElements = (observer, elements) => {
  elements.forEach((element) => {
    observer.observe(element);
  });
};
const updateObserver = (observer, elementsToObserve) => {
  resetObserver(observer);
  observeElements(observer, elementsToObserve);
};
const setObserver = (settings, instance) => {
  if (!supportsIntersectionObserver || shouldUseNative(settings)) {
    return;
  }
  instance._observer = new IntersectionObserver((entries) => {
    intersectionHandler(entries, settings, instance);
  }, getObserverSettings(settings));
};
const toArray = (nodeSet) => Array.prototype.slice.call(nodeSet);
const queryElements = (settings) => settings.container.querySelectorAll(settings.elements_selector);
const excludeManagedElements = (elements) => toArray(elements).filter(hasEmptyStatus);
const hasError = (element) => hasStatusError(element);
const filterErrorElements = (elements) => toArray(elements).filter(hasError);
const getElementsToLoad = (elements, settings) => excludeManagedElements(elements || queryElements(settings));
const retryLazyLoad = (settings, instance) => {
  const errorElements = filterErrorElements(queryElements(settings));
  errorElements.forEach((element) => {
    removeClass(element, settings.class_error);
    resetStatus(element);
  });
  instance.update();
};
const setOnlineCheck = (settings, instance) => {
  if (!runningOnBrowser) {
    return;
  }
  instance._onlineHandler = () => {
    retryLazyLoad(settings, instance);
  };
  window.addEventListener("online", instance._onlineHandler);
};
const resetOnlineCheck = (instance) => {
  if (!runningOnBrowser) {
    return;
  }
  window.removeEventListener("online", instance._onlineHandler);
};
const LazyLoad = function(customSettings, elements) {
  const settings = getExtendedSettings(customSettings);
  this._settings = settings;
  this.loadingCount = 0;
  setObserver(settings, this);
  setOnlineCheck(settings, this);
  this.update(elements);
};
LazyLoad.prototype = {
  update: function(givenNodeset) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(givenNodeset, settings);
    setToLoadCount(this, elementsToLoad.length);
    if (isBot || !supportsIntersectionObserver) {
      this.loadAll(elementsToLoad);
      return;
    }
    if (shouldUseNative(settings)) {
      loadAllNative(elementsToLoad, settings, this);
      return;
    }
    updateObserver(this._observer, elementsToLoad);
  },
  destroy: function() {
    if (this._observer) {
      this._observer.disconnect();
    }
    resetOnlineCheck(this);
    queryElements(this._settings).forEach((element) => {
      deleteOriginalAttrs(element);
    });
    delete this._observer;
    delete this._settings;
    delete this._onlineHandler;
    delete this.loadingCount;
    delete this.toLoadCount;
  },
  loadAll: function(elements) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(elements, settings);
    elementsToLoad.forEach((element) => {
      unobserve(element, this);
      load(element, settings, this);
    });
  },
  restoreAll: function() {
    const settings = this._settings;
    queryElements(settings).forEach((element) => {
      restore(element, settings);
    });
  }
};
LazyLoad.load = (element, customSettings) => {
  const settings = getExtendedSettings(customSettings);
  load(element, settings);
};
LazyLoad.resetStatus = (element) => {
  resetStatus(element);
};
if (runningOnBrowser) {
  autoInitialize(LazyLoad, window.lazyLoadOptions);
}
class DocsViewer {
  constructor({ readonly, onNewPageIndex, onPlay, onPagesReady, urlInterrupter }) {
    this._pages = [];
    this.pageIndex = 0;
    this.setPaused = () => {
      this.$btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), false);
    };
    this.setPlaying = () => {
      this.$btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), true);
    };
    this.namespace = "netless-app-slide";
    this.isShowPreview = false;
    this.isSmallBox = false;
    this.sideEffect = new SideEffectManager();
    this.readonly = readonly;
    this.onNewPageIndex = onNewPageIndex;
    this.onPlay = onPlay;
    this.onPagesReady = onPagesReady;
    this.urlInterrupter = urlInterrupter || ((url) => url);
    this.render();
  }
  set pages(value) {
    this._pages = value;
    this.refreshPreview().then(this.refreshBtnSidebar.bind(this));
    this.refreshTotalPage();
    if (this.onPagesReady) {
      this.onPagesReady(value);
    }
  }
  get pages() {
    return this._pages;
  }
  unmount() {
    this.$content.remove();
    this.$footer.remove();
  }
  setReadonly(readonly) {
    this.readonly = readonly;
    this.$content.classList.toggle(this.wrapClassName("readonly"), readonly);
    this.$footer.classList.toggle(this.wrapClassName("readonly"), readonly);
    this.$pageNumberInput.disabled = readonly;
  }
  destroy() {
    var _a;
    (_a = this.previewLazyLoad) == null ? void 0 : _a.destroy();
    this.sideEffect.flushAll();
    this.unmount();
  }
  setPageIndex(pageIndex) {
    if (!Number.isNaN(pageIndex)) {
      this.pageIndex = pageIndex;
      this.$pageNumberInput.value = String(pageIndex + 1);
    }
  }
  refreshTotalPage() {
    if (this.pages.length) {
      this.$totalPage.textContent = " / " + this.pages.length;
    } else {
      this.$totalPage.textContent = "";
    }
  }
  setSmallBox(isSmallBox) {
    if (this.isSmallBox !== isSmallBox) {
      this.isSmallBox = isSmallBox;
      this.$footer.classList.toggle(this.wrapClassName("float-footer"), isSmallBox);
    }
  }
  render() {
    this.renderContent();
    this.renderFooter();
    return this.$content;
  }
  renderContent() {
    if (!this.$content) {
      const $content = document.createElement("div");
      $content.className = this.wrapClassName("content");
      this.$content = $content;
      if (this.readonly) {
        $content.classList.add(this.wrapClassName("readonly"));
      }
      $content.appendChild(this.renderPreviewMask());
      $content.appendChild(this.renderPreview());
    }
    return this.$content;
  }
  renderPreview() {
    if (!this.$preview) {
      const $preview = document.createElement("div");
      $preview.className = this.wrapClassName("preview") + " tele-fancy-scrollbar";
      this.$preview = $preview;
      this.refreshPreview();
      this.sideEffect.addEventListener($preview, "click", (ev) => {
        var _a;
        if (this.readonly) {
          return;
        }
        const pageIndex = (_a = ev.target.dataset) == null ? void 0 : _a.pageIndex;
        if (pageIndex) {
          ev.preventDefault();
          ev.stopPropagation();
          ev.stopImmediatePropagation();
          this.onNewPageIndex(Number(pageIndex));
          this.togglePreview(false);
        }
      });
    }
    return this.$preview;
  }
  async refreshPreview() {
    var _a, _b;
    const { $preview } = this;
    const pageClassName = this.wrapClassName("preview-page");
    const pageNameClassName = this.wrapClassName("preview-page-name");
    while ($preview.firstChild) {
      $preview.firstChild.remove();
    }
    const previewSRCs = [];
    for (let i = 0, len = this.pages.length; i < len; i++) {
      const page = this.pages[i];
      const src = (_a = page.thumbnail) != null ? _a : page.src.startsWith("ppt") ? void 0 : page.src;
      if (src) {
        previewSRCs[i] = this.urlInterrupter(src);
      }
    }
    for (let i = 0, len = this.pages.length; i < len; i++) {
      previewSRCs[i] = await previewSRCs[i];
    }
    this.pages.forEach((page, i) => {
      const previewSRC = previewSRCs[i];
      if (!previewSRC) {
        return;
      }
      const pageIndex = String(i);
      const $page = document.createElement("a");
      $page.className = pageClassName + " " + this.wrapClassName(`preview-page-${i}`);
      $page.setAttribute("href", "#");
      $page.dataset.pageIndex = pageIndex;
      const $name = document.createElement("span");
      $name.className = pageNameClassName;
      $name.textContent = String(i + 1);
      $name.dataset.pageIndex = pageIndex;
      const $img = document.createElement("img");
      $img.width = page.width;
      $img.height = page.height;
      $img.dataset.src = previewSRC;
      $img.dataset.pageIndex = pageIndex;
      $page.appendChild($img);
      $page.appendChild($name);
      $preview.appendChild($page);
    });
    (_b = this.previewLazyLoad) == null ? void 0 : _b.update();
  }
  renderPreviewMask() {
    if (!this.$previewMask) {
      this.$previewMask = document.createElement("div");
      this.$previewMask.className = this.wrapClassName("preview-mask");
      this.sideEffect.addEventListener(this.$previewMask, "click", (ev) => {
        if (this.readonly) {
          return;
        }
        if (ev.target === this.$previewMask) {
          this.togglePreview(false);
        }
      });
    }
    return this.$previewMask;
  }
  refreshBtnSidebar() {
    this.$btnSidebar.style.display = this.pages.length > 0 ? "" : "none";
  }
  renderFooter() {
    if (!this.$footer) {
      const $footer = document.createElement("div");
      $footer.className = this.wrapClassName("footer");
      this.$footer = $footer;
      if (this.readonly) {
        $footer.classList.add(this.wrapClassName("readonly"));
      }
      if (this.isSmallBox) {
        $footer.classList.add(this.wrapClassName("float-footer"));
      }
      const $btnSidebar = this.renderFooterBtn("btn-sidebar", sidebarSVG(this.namespace));
      this.sideEffect.addEventListener($btnSidebar, "click", () => {
        if (this.readonly) {
          return;
        }
        this.togglePreview();
      });
      this.$btnSidebar = $btnSidebar;
      this.$btnSidebar.style.display = "none";
      this.$footer.appendChild($btnSidebar);
      const $pageJumps = document.createElement("div");
      $pageJumps.className = this.wrapClassName("page-jumps");
      const $btnPageBack = this.renderFooterBtn("btn-page-back", arrowLeftSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageBack, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex - 1);
      });
      $pageJumps.appendChild($btnPageBack);
      if (this.onPlay) {
        const $btnPlay = this.renderFooterBtn("btn-page-play", playSVG(this.namespace), pauseSVG(this.namespace));
        this.$btnPlay = $btnPlay;
        this.sideEffect.addEventListener($btnPlay, "click", () => {
          if (this.readonly) {
            return;
          }
          this.setPlaying();
          if (this.onPlay) {
            this.onPlay();
          }
        });
        $pageJumps.appendChild($btnPlay);
      }
      const $btnPageNext = this.renderFooterBtn("btn-page-next", arrowRightSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageNext, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex + 1);
      });
      $pageJumps.appendChild($btnPageNext);
      const $pageNumber = document.createElement("div");
      $pageNumber.className = this.wrapClassName("page-number");
      const $pageNumberInput = document.createElement("input");
      $pageNumberInput.className = this.wrapClassName("page-number-input");
      $pageNumberInput.value = String(this.pageIndex + 1);
      if (this.readonly) {
        $pageNumberInput.disabled = true;
      }
      this.$pageNumberInput = $pageNumberInput;
      this.sideEffect.addEventListener($pageNumberInput, "focus", () => {
        $pageNumberInput.select();
      });
      this.sideEffect.addEventListener($pageNumberInput, "change", () => {
        if (this.readonly) {
          return;
        }
        if ($pageNumberInput.value) {
          this.onNewPageIndex(Number($pageNumberInput.value) - 1);
        }
      });
      const $totalPage = document.createElement("span");
      this.$totalPage = $totalPage;
      $pageNumber.appendChild($pageNumberInput);
      $pageNumber.appendChild($totalPage);
      this.$footer.appendChild($pageJumps);
      this.$footer.appendChild($pageNumber);
    }
    return this.$footer;
  }
  renderFooterBtn(className, $icon, $iconActive) {
    const $btn = document.createElement("button");
    $btn.className = this.wrapClassName("footer-btn") + " " + this.wrapClassName(className);
    $btn.appendChild($icon);
    if ($iconActive) {
      $btn.appendChild($iconActive);
    }
    return $btn;
  }
  togglePreview(isShowPreview) {
    this.isShowPreview = isShowPreview != null ? isShowPreview : !this.isShowPreview;
    this.$content.classList.toggle(this.wrapClassName("preview-active"), this.isShowPreview);
    if (this.isShowPreview) {
      const $previewPage = this.$preview.querySelector("." + this.wrapClassName(`preview-page-${this.pageIndex}`));
      if ($previewPage) {
        this.previewLazyLoad || (this.previewLazyLoad = new LazyLoad({
          container: this.$preview,
          elements_selector: `.${this.wrapClassName("preview-page>img")}`
        }));
        this.$preview.scrollTo({
          top: $previewPage.offsetTop - 16
        });
      }
    }
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
const ClickThroughAppliances = /* @__PURE__ */ new Set(["clicker"]);
class SlideDocsViewer {
  constructor({
    box,
    view,
    mountSlideController,
    mountWhiteboard,
    baseScenePath,
    appId,
    urlInterrupter,
    onPagesReady
  }) {
    this.slideController = null;
    this.isViewMounted = false;
    this.onError = ({ error, index }) => {
      var _a, _b;
      this.viewer.setPaused();
      if ((_a = this.slideController) == null ? void 0 : _a.showRenderError) {
        this.$overlay.textContent = `Error on slide[page=${this.slideController.page}]: ${error.message}`;
        this.$overlay.style.opacity = "1";
      }
      if ((_b = this.slideController) == null ? void 0 : _b.onRenderError) {
        this.slideController.onRenderError(error, index);
      }
      logger.warn("[Slide] render error", error);
    };
    this.onRenderStart = () => {
      this.$whiteboardView.classList.add(this.wrapClassName("wb-view-hidden"));
      this.viewer.setPlaying();
    };
    this.onRenderEnd = () => {
    };
    this.onPageChanged = () => {
      clearTimeout(this._onPageChangedTimer);
      this._onPageChangedTimer = setTimeout(this._onPageChanged, 200);
    };
    this._onPageChangedTimer = 0;
    this._onPageChanged = () => {
      this.$overlay.style.opacity = "";
      this.$whiteboardView.classList.remove(this.wrapClassName("wb-view-hidden"));
    };
    this.refreshPages = () => {
      if (this.slideController) {
        this.viewer.pages = createDocsViewerPages(this.slideController.slide);
        this.viewer.setPageIndex(this.getPageIndex(this.slideController.page));
        this.scaleDocsToFit();
      }
    };
    this.scaleDocsToFit = () => {
      if (this.slideController) {
        const { width, height } = this.slideController.slide;
        if (width && height) {
          this.whiteboardView.moveCameraToContain({
            originX: -width / 2,
            originY: -height / 2,
            width,
            height,
            animationMode: "immediately"
          });
          this.whiteboardView.setCameraBound({
            damping: 1,
            maxContentMode: () => this.whiteboardView.camera.scale,
            minContentMode: () => this.whiteboardView.camera.scale,
            centerX: 0,
            centerY: 0,
            width,
            height
          });
          if (!this.isViewMounted) {
            this.isViewMounted = true;
            console.log("[Slide] mount whiteboard view");
            this.mountWhiteboard(this.$whiteboardView);
          }
        }
      }
    };
    this.onPlay = () => {
      if (this.slideController) {
        this.slideController.slide.nextStep();
      }
    };
    this.onNewPageIndex = (index) => {
      if (this.slideController) {
        this.slideController.jumpToPage(index + 1);
      }
    };
    this.sideEffect = new SideEffectManager();
    this.namespace = "netless-app-slide";
    this.toPdf = async () => {
      if (!this.slideController) {
        this.reportProgress(100, null);
        return;
      }
      const { slide } = this.slideController;
      const MAX = 1920;
      const resizeCanvas = document.createElement("canvas");
      const resizeCtx = resizeCanvas.getContext("2d");
      const { slideCount, width, height } = slide;
      let pdfWidth = Math.floor(width);
      let pdfHeight = Math.floor(height);
      if (pdfWidth > MAX) {
        pdfWidth = MAX;
        pdfHeight = Math.floor(height * pdfWidth / width);
      }
      if (pdfHeight > MAX) {
        pdfHeight = MAX;
        pdfWidth = Math.floor(width * pdfHeight / height);
      }
      resizeCanvas.width = pdfWidth;
      resizeCanvas.height = pdfHeight;
      const whiteSnapshotCanvas = document.createElement("canvas");
      whiteSnapshotCanvas.width = pdfWidth;
      whiteSnapshotCanvas.height = pdfHeight;
      const whiteCtx = whiteSnapshotCanvas.getContext("2d");
      if (!whiteCtx || !this.getWhiteSnapshot || !resizeCtx) {
        this.reportProgress(100, null);
        return null;
      }
      const orientation = pdfWidth > pdfHeight ? "l" : "p";
      const { jsPDF } = await import("jspdf");
      const pdf = new jsPDF({
        format: [pdfWidth, pdfHeight],
        orientation,
        compress: true
      });
      for (let i = 1; i <= slideCount; i++) {
        let slideSnapshot = null;
        try {
          slideSnapshot = await this.slideController.slide.snapshotWithTimingEnd(i);
        } catch {
        }
        if (slideSnapshot) {
          const img = document.createElement("img");
          img.src = slideSnapshot;
          await new Promise((resolve) => img.onload = resolve);
          resizeCtx.drawImage(img, 0, 0, pdfWidth, pdfHeight);
        }
        whiteCtx.clearRect(0, 0, pdfWidth, pdfHeight);
        this.getWhiteSnapshot(i, whiteSnapshotCanvas, whiteCtx, width, height);
        try {
          const whiteSnapshot = whiteSnapshotCanvas.toDataURL("image/png");
          const whiteImg = document.createElement("img");
          whiteImg.src = whiteSnapshot;
          await new Promise((resolve) => whiteImg.onload = resolve);
          resizeCtx.drawImage(whiteImg, 0, 0, pdfWidth, pdfHeight);
        } catch (e) {
        }
        const outputDataUrl = resizeCanvas.toDataURL("image/jpeg", 0.6);
        if (i > 1) {
          pdf.addPage();
        }
        pdf.addImage(outputDataUrl, "JPEG", 0, 0, pdfWidth, pdfHeight, "", "FAST");
        resizeCtx.clearRect(0, 0, pdfWidth, pdfHeight);
        const progress = Math.ceil(i / slideCount * 100);
        if (progress < 100) {
          this.reportProgress(Math.ceil(i / slideCount * 100), null);
        }
      }
      const dataUrl = pdf.output("arraybuffer");
      const title = this.box.title;
      this.reportProgress(100, { pdf: dataUrl, title });
    };
    this.box = box;
    this.whiteboardView = view;
    this.mountSlideController = mountSlideController;
    this.mountWhiteboard = mountWhiteboard;
    this.baseScenePath = baseScenePath;
    this.appId = appId;
    this.viewer = new DocsViewer({
      readonly: box.readonly,
      onNewPageIndex: this.onNewPageIndex,
      onPlay: this.onPlay,
      urlInterrupter,
      onPagesReady
    });
    this.sideEffect.add(() => {
      const handler = (readonly) => {
        this.setReadonly(readonly);
      };
      box.events.on("readonly", handler);
      return () => box.events.off("readonly", handler);
    });
    this.sideEffect.add(() => {
      const handleDownloadPdf = (evt) => {
        if (evt.data.type === "@netless/_request_save_pdf_" && evt.data.appId === this.appId) {
          this.toPdf().catch(() => this.reportProgress(100, null));
        }
      };
      window.addEventListener("message", handleDownloadPdf);
      return () => {
        window.removeEventListener("message", handleDownloadPdf);
      };
    });
    this.render();
  }
  render() {
    this.viewer.$content.appendChild(this.renderSlideContainer());
    this.viewer.$content.appendChild(this.renderWhiteboardView());
    this.viewer.$content.appendChild(this.renderOverlay());
    this.sideEffect.addEventListener(window, "keydown", (ev) => {
      if (this.box.focus && this.slideController && !isEditable(ev.target)) {
        switch (ev.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            this.slideController.slide.prevStep();
            break;
          }
          case "ArrowRight":
          case "ArrowDown": {
            this.slideController.slide.nextStep();
            break;
          }
        }
      }
    });
  }
  renderOverlay() {
    if (!this.$overlay) {
      const $overlay = document.createElement("div");
      $overlay.className = this.wrapClassName("overlay");
      this.$overlay = $overlay;
    }
    return this.$overlay;
  }
  renderSlideContainer() {
    if (!this.$slide) {
      const $slide = document.createElement("div");
      $slide.className = this.wrapClassName("slide");
      $slide.dataset.appKind = "Slide";
      this.$slide = $slide;
    }
    return this.$slide;
  }
  renderWhiteboardView() {
    if (!this.$whiteboardView) {
      this.$whiteboardView = document.createElement("div");
      this.$whiteboardView.className = this.wrapClassName("wb-view");
    }
    return this.$whiteboardView;
  }
  mount() {
    this.box.mountContent(this.viewer.$content);
    this.box.mountFooter(this.viewer.$footer);
    this.slideController = this.mountSlideController({
      anchor: this.$slide,
      onRenderStart: this.onRenderStart,
      onRenderEnd: this.onRenderEnd,
      onTransitionStart: this.viewer.setPlaying,
      onTransitionEnd: this.viewer.setPaused,
      onReady: this.refreshPages,
      onError: this.onError
    });
    this.scaleDocsToFit();
    this.sideEffect.add(() => {
      this.whiteboardView.callbacks.on("onSizeUpdated", this.scaleDocsToFit);
      return () => this.whiteboardView.callbacks.off("onSizeUpdated", this.scaleDocsToFit);
    });
    return this;
  }
  getPageIndex(page) {
    return (page > 0 ? page : 1) - 1;
  }
  unmount() {
    if (this.slideController) {
      this.slideController.destroy();
      this.slideController = null;
    }
    this.viewer.unmount();
    return this;
  }
  setReadonly(readonly) {
    this.viewer.setReadonly(readonly);
  }
  destroy() {
    this.sideEffect.flushAll();
    this.unmount();
    this.viewer.destroy();
  }
  toggleClickThrough(tool) {
    this.$whiteboardView.style.pointerEvents = !tool || ClickThroughAppliances.has(tool) ? "none" : "auto";
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
  getWhiteSnapshot(pageIndex, canvas, ctx, slideWidth, slideHeight) {
    this.whiteboardView.screenshotToCanvas(ctx, `${this.baseScenePath}/${pageIndex}`, canvas.width, canvas.height, {
      centerX: 0,
      centerY: 0,
      scale: Math.min(canvas.width / slideWidth, canvas.height / slideHeight)
    });
  }
  reportProgress(progress, result) {
    window.postMessage({
      type: "@netless/_result_save_pdf_",
      appId: this.appId,
      progress,
      result
    });
  }
}
let useFreezer = false;
let FreezerLength = 2;
function getFreezerLength() {
  return FreezerLength;
}
function setFreezerLength(length) {
  FreezerLength = length < 1 ? Infinity : length;
}
const inspect = (arr) => {
  return "[" + arr + "]";
};
const apps = {
  map: /* @__PURE__ */ new Map(),
  boxes: /* @__PURE__ */ new Map(),
  queue: [],
  validateQueue() {
    this.queue.sort((a, b) => {
      var _a, _b, _c, _d;
      const za = (_b = (_a = this.boxes.get(a)) == null ? void 0 : _a.zIndex) != null ? _b : 0;
      const zb = (_d = (_c = this.boxes.get(b)) == null ? void 0 : _c.zIndex) != null ? _d : 0;
      return -(za - zb);
    });
    log("[Slide] freezer: validate", inspect(this.queue));
    while (this.queue.length > FreezerLength) {
      const appId = this.queue.pop();
      const slide = this.map.get(appId);
      if (slide) {
        log("[Slide] freezer: validate-freeze", appId, inspect(this.queue));
        slide.freeze();
      }
    }
  },
  set(appId, slide, box) {
    log("[Slide] freezer: add", appId, inspect(this.queue));
    this.map.set(appId, slide);
    this.boxes.set(appId, box);
    if (!this.queue.includes(appId)) {
      this.queue.unshift(appId);
    }
    this.validateQueue();
  },
  delete(appId) {
    this.map.delete(appId);
    this.boxes.delete(appId);
    this.queue = this.queue.filter((id) => id !== appId);
    log("[Slide] freezer: delete", appId, inspect(this.queue));
  },
  focus(appId) {
    const slide = this.map.get(appId);
    const index = this.queue.indexOf(appId);
    if (index > -1) {
      this.queue.splice(index, 1);
    }
    this.queue.unshift(appId);
    this.validateQueue();
    log("[Slide] freezer: focus", appId, inspect(this.queue));
    if (slide) {
      slide.unfreeze();
    }
  }
};
const on_created_callbacks = /* @__PURE__ */ new Set();
function onCreated(callback) {
  on_created_callbacks.add(callback);
  return () => on_created_callbacks.delete(callback);
}
const on_destroyed_callbacks = /* @__PURE__ */ new Set();
function onDestroyed(callback) {
  on_destroyed_callbacks.add(callback);
  return () => on_destroyed_callbacks.delete(callback);
}
const addHooks = (emitter) => {
  useFreezer = true;
  emitter.on("focus", ({ appId }) => {
    apps.focus(appId);
  });
  emitter.on("created", ({ appId }) => {
    on_created_callbacks.forEach((callback) => callback(appId));
  });
  emitter.on("destroy", ({ appId }) => {
    on_destroyed_callbacks.forEach((callback) => callback(appId));
  });
};
var styles = /* @__PURE__ */ (() => ".netless-app-slide-content{position:relative;height:100%;overflow:hidden}.netless-app-slide-preview-mask{display:none;position:absolute;z-index:200;top:0;left:0;width:100%;height:100%}.netless-app-slide-preview{display:flex;flex-direction:column;align-items:center;position:absolute;z-index:300;top:0;left:0;width:33%;max-width:200px;height:100%;padding-top:10px;transform:translate(-100%);background:rgba(237,237,240,.9);box-shadow:inset -1px 0 #0000001c;transition:transform .4s}.netless-app-slide-preview-active .netless-app-slide-preview-mask{display:block}.netless-app-slide-preview-active .netless-app-slide-preview{transform:translate(0)}.netless-app-slide-preview-page{position:relative;display:block;width:55%;margin-bottom:10px;font-size:0;color:transparent;outline:none;border:7px solid transparent;border-radius:4px;transition:border-color .3s;user-select:none}.netless-app-slide-preview-page:hover,.netless-app-slide-preview-page.netless-app-slide-preview-page-active{border-color:#444e601a}.netless-app-slide-preview-page>img{width:100%;height:auto;box-sizing:border-box;border:1px solid rgba(0,0,0,.5);border-radius:1px;background-color:#fff;box-shadow:0 2px 8px #0000004d}.netless-app-slide-preview-page-name{position:absolute;top:1px;left:-10px;transform:translate(-100%);text-align:right;font-size:12px;color:#5f5f5f;user-select:none}.netless-app-slide-footer{box-sizing:border-box;height:26px;display:flex;align-items:center;padding:0 16px;border-top:1px solid #eeeef7;color:#191919}.netless-app-slide-float-footer{width:100%;min-height:26px;position:absolute;left:0;bottom:0;z-index:2000;background:rgba(249,249,252,.9);transition:opacity .4s}.netless-app-slide-footer-btn{box-sizing:border-box;width:26px;height:26px;font-size:0;margin:0;padding:3px;border:none;border-radius:1px;outline:none;color:currentColor;background:transparent;transition:background .4s;cursor:pointer;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-slide-footer-btn:hover{background:rgba(237,237,240,.9)}@media (hover: none){.netless-app-slide-footer-btn:hover{background:transparent!important}}.netless-app-slide-footer-btn>svg{width:100%;height:100%}.netless-app-slide-footer-btn>svg:nth-of-type(2){display:none}.netless-app-slide-footer-btn.netless-app-slide-footer-btn-playing>svg:nth-of-type(1){display:none}.netless-app-slide-footer-btn.netless-app-slide-footer-btn-playing>svg:nth-of-type(2){display:initial}.netless-app-slide-footer-btn~.netless-app-slide-footer-btn{margin-left:15px}.netless-app-slide-page-jumps{flex:1;display:flex;justify-content:center;align-items:center}.netless-app-slide-page-number{margin-left:auto;font-size:13px;user-select:none;white-space:nowrap;word-break:keep-all}.netless-app-slide-page-number-input{border:none;outline:none;width:3em;margin:0;padding:0 2px;text-align:right;font-size:13px;line-height:1;font-weight:400;font-family:inherit;border-radius:2px;color:currentColor;background:transparent;transition:background .4s;user-select:text;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-slide-page-number-input:hover,.netless-app-slide-page-number-input:focus,.netless-app-slide-page-number-input:active{background:#fff;box-shadow:#63636333 0 2px 8px}.netless-app-slide-readonly.netless-app-slide-footer{display:none}.telebox-color-scheme-dark .netless-app-slide-page-number-input{color:#a6a6a8}.telebox-color-scheme-dark .netless-app-slide-page-number-input:active,.telebox-color-scheme-dark .netless-app-slide-page-number-input:focus,.telebox-color-scheme-dark .netless-app-slide-page-number-input:hover{color:#222}.telebox-color-scheme-dark .netless-app-slide-footer{color:#a6a6a8;background:#2d2d33;border-top:none}.telebox-color-scheme-dark .netless-app-slide-footer-btn:hover{background:#212126}.telebox-color-scheme-dark .netless-app-slide-preview{background:rgba(50,50,50,.9)}.netless-app-slide-wb-view{position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;overflow:hidden;transition:opacity .2s}.netless-app-slide-wb-view-hidden{opacity:0}.netless-app-slide-overlay{display:flex;align-items:center;justify-content:center;position:absolute;z-index:200;top:0;left:0;width:100%;height:100%;padding:8px;background:rgba(255,0,0,.25);transition:opacity .3s;opacity:0;pointer-events:none}.netless-app-slide-slide{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.netless-app-slide-slide canvas{transform:scale(var(--netless-app-slide-scale, 1))}\n")();
function previewSlide({
  container,
  taskId,
  url = DefaultUrl,
  debug = false
}) {
  if (!taskId) {
    throw new Error("[Slide] taskId is required");
  }
  container.style.cssText += `display:flex;flex-direction:column`;
  const previewer = new SlidePreviewer({ target: container });
  previewer.debug = !!debug;
  previewer.mount(taskId, url);
  return previewer;
}
class SlidePreviewer {
  constructor(config) {
    this.slide = null;
    this.debug = false;
    this.sideEffect = new SideEffectManager();
    this.ready = false;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = () => {
        this.ready = true;
        resolve();
      };
    });
    this.hotkeyListener = (ev) => {
      if (this.slide) {
        switch (ev.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            this.slide.prevStep();
            break;
          }
          case "ArrowRight":
          case "ArrowDown": {
            this.slide.nextStep();
            break;
          }
        }
      }
    };
    this.onPageChanged = (page) => {
      this.viewer.setPageIndex(page - 1);
    };
    this.onTransitionStart = () => {
      this.viewer.setPlaying();
    };
    this.onTransitionEnd = () => {
      this.viewer.setPaused();
    };
    this.onError = ({ error }) => {
      this.viewer.setPaused();
      console.warn("[Slide] render error", error);
    };
    this.destroyed = false;
    this.refreshPages = () => {
      if (this.slide) {
        this.viewer.pages = createDocsViewerPages(this.slide);
        this.viewer.setPageIndex(this.getPageIndex(this.slide.slideState.currentSlideIndex));
      }
    };
    this.onPlay = () => {
      if (this.slide) {
        this.slide.nextStep();
      }
    };
    this.onNewPageIndex = (index) => {
      if (this.slide && this.slide.slideCount > 0) {
        this.slide.renderSlide(clamp$1(index + 1, 1, this.slide.slideCount));
      }
    };
    this.namespace = "netless-app-slide";
    this.target = config.target;
    this.bgColor = cachedGetBgColor(this.target);
    this.viewer = new DocsViewer({
      readonly: false,
      onNewPageIndex: this.onNewPageIndex,
      onPlay: this.onPlay
    });
    this.render();
  }
  render() {
    this.viewer.$content.appendChild(this.renderSlideContainer());
    this.registerHotKeys(window);
  }
  registerHotKeys(windowLike) {
    this.sideEffect.addEventListener(windowLike, "keydown", this.hotkeyListener, void 0, "hotkey");
  }
  mount(taskId, url) {
    this.target.appendChild(this.renderStyle());
    this.target.appendChild(this.viewer.$content);
    this.target.appendChild(this.viewer.$footer);
    this.slide = new Slide.Slide({
      anchor: this.$slide,
      interactive: true,
      mode: "local",
      controller: this.debug,
      enableGlobalClick: true,
      renderOptions: {
        minFPS: 25,
        maxFPS: 30,
        autoFPS: true,
        autoResolution: true,
        transactionBgColor: this.bgColor
      }
    });
    this.registerEventListeners();
    this.slide.setResource(taskId, url);
    this.slide.renderSlide(1);
  }
  renderStyle() {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(styles));
    return element;
  }
  registerEventListeners() {
    if (!this.slide)
      return;
    const { slide } = this;
    slide.on(Slide.SLIDE_EVENTS.slideChange, this.onPageChanged);
    slide.on(Slide.SLIDE_EVENTS.renderStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.renderError, this.onError);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.resolveReady);
    this.readyPromise.then(this.refreshPages);
  }
  destroy() {
    this.sideEffect.flushAll();
    if (this.slide && !this.destroyed) {
      this.slide.destroy();
      this.destroyed = true;
    }
    this.viewer.destroy();
  }
  getPageIndex(page) {
    return (page > 0 ? page : 1) - 1;
  }
  renderSlideContainer() {
    if (!this.$slide) {
      const $slide = document.createElement("div");
      $slide.className = this.wrapClassName("slide");
      $slide.dataset.appKind = "Slide";
      this.$slide = $slide;
    }
    return this.$slide;
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
const usePlugin = /* @__PURE__ */ Slide.Slide.usePlugin.bind(Slide.Slide);
const version = "0.2.51";
const SlideApp = {
  kind: "Slide",
  setup(context) {
    var _a;
    console.log("[Slide] setup @ " + version);
    if (context.getIsWritable()) {
      context.storage.ensureState(EmptyAttributes);
    }
    if (!context.storage.state.taskId) {
      throw new Error("[Slide] no taskId");
    }
    const view = context.getView();
    if (!view) {
      throw new Error("[Slide] no view, please set scenePath on addApp()");
    }
    view.disableCameraTransform = true;
    const box = context.getBox();
    box.mountStyles(styles);
    try {
      box.$content.dataset.appSlideVersion = version;
    } catch {
    }
    const baseScenePath = context.getInitScenePath();
    let docsViewer = null;
    const onPageChanged = (page) => {
      const room2 = context.getRoom();
      if (docsViewer && docsViewer.slideController) {
        let synced = false;
        if (room2 && context.getIsWritable()) {
          syncSceneWithSlide(room2, context, docsViewer.slideController.slide, baseScenePath);
          synced = true;
        }
        log("[Slide] page to", page, synced ? "(synced)" : "");
        docsViewer.viewer.setPageIndex(page - 1);
        docsViewer.viewer.setPaused();
        docsViewer.onPageChanged();
        const length = docsViewer.viewer.pages.length;
        if (length > 0) {
          context.dispatchAppEvent("pageStateChange", { index: page - 1, length });
        }
      }
    };
    const mountSlideController = (options) => {
      const appOptions = context.getAppOptions() || {};
      const slideController = new SlideController(__spreadProps(__spreadValues({
        context
      }, options), {
        onPageChanged,
        onRenderError: appOptions.onRenderError,
        showRenderError: appOptions.showRenderError
      }));
      if (useFreezer)
        apps.set(context.appId, slideController, box);
      logger.setAppController(context.appId, slideController);
      slideController.readyPromise.then(options.onReady).then(() => {
        const room2 = context.getRoom();
        let synced = false;
        if (room2 && context.getIsWritable()) {
          syncSceneWithSlide(room2, context, slideController.slide, baseScenePath);
          synced = true;
        }
        const page = slideController.slide.slideState.currentSlideIndex;
        log("[Slide] page to", page, synced ? "(synced)" : "", "(on ready)");
        slideController.slide.on("renderEnd", options.onRenderEnd);
      });
      return slideController;
    };
    docsViewer = new SlideDocsViewer({
      box,
      view,
      mountSlideController,
      mountWhiteboard: context.mountView.bind(context),
      baseScenePath,
      appId: context.appId,
      urlInterrupter: (_a = context.getAppOptions()) == null ? void 0 : _a.urlInterrupter,
      onPagesReady: ({ length }) => {
        const index = (docsViewer == null ? void 0 : docsViewer.viewer.pageIndex) || 0;
        context.dispatchAppEvent("pageStateChange", { index, length });
      }
    });
    const room = context.getRoom();
    const sideEffect = new SideEffectManager();
    sideEffect.add(() => {
      var _a2;
      logger.setAppContext(context.appId, context);
      logger.enable = ((_a2 = context.getAppOptions()) == null ? void 0 : _a2.debug) || false;
      logger.level = "debug";
      return () => logger.deleteApp(context.appId);
    });
    if (room) {
      docsViewer.toggleClickThrough(room.state.memberState.currentApplianceName);
      sideEffect.add(() => {
        const onRoomStateChanged = (e) => {
          if (e.memberState && docsViewer) {
            docsViewer.toggleClickThrough(e.memberState.currentApplianceName);
          }
        };
        room.callbacks.on("onRoomStateChanged", onRoomStateChanged);
        return () => room.callbacks.off("onRoomStateChanged", onRoomStateChanged);
      });
    }
    context.emitter.on("destroy", () => {
      log("[Slide] destroy", context.appId);
      if (useFreezer)
        apps.delete(context.appId);
      sideEffect.flushAll();
      if (docsViewer) {
        docsViewer.destroy();
        docsViewer = null;
      }
    });
    docsViewer.mount();
    return {
      viewer: () => {
        return docsViewer;
      },
      controller: () => {
        return docsViewer == null ? void 0 : docsViewer.slideController;
      },
      slide: () => {
        var _a2;
        return (_a2 = docsViewer == null ? void 0 : docsViewer.slideController) == null ? void 0 : _a2.slide;
      },
      nextStep: () => {
        var _a2;
        if (docsViewer && docsViewer.slideController) {
          (_a2 = docsViewer == null ? void 0 : docsViewer.slideController) == null ? void 0 : _a2.slide.nextStep();
          return true;
        }
        return false;
      },
      prevStep: () => {
        var _a2;
        if (docsViewer && docsViewer.slideController) {
          (_a2 = docsViewer == null ? void 0 : docsViewer.slideController) == null ? void 0 : _a2.slide.prevStep();
          return true;
        }
        return false;
      },
      position: () => {
        const controller = docsViewer == null ? void 0 : docsViewer.slideController;
        if (controller) {
          return [controller.page, controller.pageCount];
        }
      },
      nextPage: () => {
        const controller = docsViewer == null ? void 0 : docsViewer.slideController;
        if (controller) {
          const { page, pageCount } = controller;
          if (pageCount > 0 && page < pageCount) {
            controller.jumpToPage(page + 1);
            return true;
          }
        }
        return false;
      },
      prevPage: () => {
        const controller = docsViewer == null ? void 0 : docsViewer.slideController;
        if (controller) {
          const { page, pageCount } = controller;
          if (pageCount > 0 && page > 1) {
            controller.jumpToPage(page - 1);
            return true;
          }
        }
        return false;
      },
      jumpToPage: (newPage) => {
        const controller = docsViewer == null ? void 0 : docsViewer.slideController;
        if (controller) {
          const { page, pageCount } = controller;
          if (pageCount > 0 && page > 0 && page <= pageCount) {
            controller.jumpToPage(newPage);
            return true;
          }
        }
        return false;
      }
    };
  }
};
var Slide$1 = Slide.Slide;
export { DefaultUrl, FreezerLength, Slide$1 as Slide, SlidePreviewer, addHooks, apps, SlideApp as default, getFreezerLength, onCreated, onDestroyed, previewSlide, setFreezerLength, usePlugin, version };
//# sourceMappingURL=main.es.js.map
